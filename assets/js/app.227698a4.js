(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var o,i,s=e[0],l=e[1],c=e[2],d=0,p=[];d<s.length;d++)i=s[d],Object.prototype.hasOwnProperty.call(r,i)&&r[i]&&p.push(r[i][0]),r[i]=0;for(o in l)Object.prototype.hasOwnProperty.call(l,o)&&(n[o]=l[o]);for(u&&u(e);p.length;)p.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],o=!0,s=1;s<t.length;s++){var l=t[s];0!==r[l]&&(o=!1)}o&&(a.splice(e--,1),n=i(i.s=t[0]))}return n}var o={},r={1:0},a=[];function i(e){if(o[e])return o[e].exports;var t=o[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var o=new Promise((function(e,o){t=r[n]=[e,o]}));e.push(t[2]=o);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"326d7be9",3:"099c9c22",4:"a0146097",5:"baca3e62",6:"197fa299",7:"f9fd7841",8:"f164e50c",9:"a37f00c1",10:"13d1d530",11:"a901da6f",12:"a75bf772",13:"afe1ee82",14:"a4db097c",15:"d3cc8762",16:"fc036fdf",17:"483f7b22",18:"ac4c1791",19:"97ce8b7d",20:"14c8cc28",21:"450d47de",22:"a8fbadf5",23:"d1c8642e",24:"3bccc5b5",25:"cbe288ad",26:"6a77ab0d",27:"cb980704",28:"3f52da80",29:"7e90b036",30:"d9a78b86",31:"016999b2",32:"b01ce507",33:"23915f7b",34:"a4c69afc",35:"14654322",36:"49d02365",37:"00950315",38:"13ecba12",39:"0e6d46c3",40:"9b4030d9",41:"8f66bd68",42:"3b168600",43:"7c222fa2",44:"f8f67500",45:"e0bd8f77",46:"57763417",47:"a22975fc",48:"fbeaf250",49:"5276f96c",50:"6b2df3a4",51:"8264fdb4",52:"d61255d0",53:"7cdc2a52",54:"090a6883",55:"2f4da549",56:"54e5ca96",57:"11784996",58:"6b775c5a",59:"9d78f347",60:"445873b2",61:"6f499abf",62:"41ea6451",63:"bc5fa5df",64:"e99cf1ac",65:"e60324ce",66:"79a72b55",67:"13e66a0b",68:"d89b6c90",69:"99172080",70:"779b8056",71:"7444e034",72:"5702a263",73:"4eab3b04",74:"6bd9417d",75:"d0f32e36",76:"3e04af34",77:"b8e909d7",78:"1b597517",79:"46cd4e72",80:"f9f0a2c8",81:"5a17c55d",82:"12cb0f75",83:"043456fc",84:"68b0334c",85:"f8e4feae",86:"5b5bfdc8",87:"e3507f1f",88:"4a343088",89:"3b7d86bc",90:"f722c98f",91:"46854866",92:"67a3d5d5",93:"db069917",94:"fd4e2517",95:"c38339d4",96:"5b24e2a6",97:"de058bbb",98:"6bc1d80c",99:"914c6b0c",100:"9d60cfbe",101:"4ed28680",102:"748fdcc5",103:"1c3273c8",104:"b58dc8e8",105:"f41acee5",106:"6ebcdb4f",107:"6d63f9d5",108:"4d3fafcc",109:"5b1531f0",110:"5b6aadbc",111:"38477a3b",112:"a404ccda",113:"93f03071",114:"06c51475",115:"5777180e",116:"7e8f0d9e",117:"445ba9a8",118:"67f6c034",119:"d5e4452a",120:"ec9e1c6a",121:"cf1a6c95",122:"57903e7f",123:"54d2abeb",124:"52ce9053",125:"b5b496ee"}[n]+".js"}(n);var l=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var o=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+o+": "+a+")",l.name="ChunkLoadError",l.type=o,l.request=a,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=o,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)i.d(t,o,function(e){return n[e]}.bind(null,o));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="https://zfh-oss.oss-cn-shanghai.aliyuncs.com/docs-assets/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var u=l;a.push([347,0]),t()}([function(n,e,t){"use strict";t.d(e,"d",(function(){return w})),t.d(e,"c",(function(){return A})),t.d(e,"b",(function(){return k})),t.d(e,"e",(function(){return j})),t.d(e,"a",(function(){return B})),t.d(e,"f",(function(){return S})),t.d(e,"g",(function(){return C})),t.d(e,"h",(function(){return T}));var o=t(8),r=t(112),a=t(57),i=t(91),s=(t(97),t(20),t(45),t(40),t(330),t(331),t(7),t(27),t(21),t(76),t(63),t(31),t(19),t(5)),l={NotFound:function(){return t.e(8).then(t.bind(null,623))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,621))}},c={"v-7dd30b36":function(){return t.e(9).then(t.bind(null,627))},"v-6c71d7d8":function(){return t.e(10).then(t.bind(null,628))},"v-35a28194":function(){return t.e(11).then(t.bind(null,629))},"v-288dfe3c":function(){return t.e(12).then(t.bind(null,630))},"v-57a6865a":function(){return t.e(13).then(t.bind(null,631))},"v-39e06f8c":function(){return t.e(14).then(t.bind(null,632))},"v-4c4aff17":function(){return t.e(15).then(t.bind(null,633))},"v-73b464c0":function(){return t.e(16).then(t.bind(null,634))},"v-2433b719":function(){return t.e(17).then(t.bind(null,635))},"v-c9df4500":function(){return t.e(18).then(t.bind(null,636))},"v-0934a038":function(){return t.e(19).then(t.bind(null,637))},"v-6400ccc0":function(){return t.e(20).then(t.bind(null,638))},"v-619cc960":function(){return t.e(21).then(t.bind(null,639))},"v-cbef54ee":function(){return t.e(22).then(t.bind(null,640))},"v-7bee9c99":function(){return t.e(23).then(t.bind(null,641))},"v-54a8f500":function(){return t.e(24).then(t.bind(null,642))},"v-b6571256":function(){return t.e(25).then(t.bind(null,643))},"v-1af69640":function(){return t.e(26).then(t.bind(null,644))},"v-e7f7dee2":function(){return t.e(27).then(t.bind(null,645))},"v-7381bf8a":function(){return t.e(28).then(t.bind(null,646))},"v-3a0007c8":function(){return t.e(29).then(t.bind(null,647))},"v-1a83c4d8":function(){return t.e(31).then(t.bind(null,648))},"v-01a65d50":function(){return t.e(30).then(t.bind(null,649))},"v-0c0f2fc9":function(){return t.e(32).then(t.bind(null,650))},"v-30659e0a":function(){return t.e(33).then(t.bind(null,651))},"v-76290fb8":function(){return t.e(34).then(t.bind(null,652))},"v-542bb398":function(){return t.e(35).then(t.bind(null,653))},"v-1cd5d196":function(){return t.e(36).then(t.bind(null,654))},"v-0905848e":function(){return t.e(37).then(t.bind(null,655))},"v-861bc42a":function(){return t.e(38).then(t.bind(null,656))},"v-3b874c4a":function(){return t.e(39).then(t.bind(null,657))},"v-773a8648":function(){return t.e(40).then(t.bind(null,658))},"v-4fa67b80":function(){return t.e(42).then(t.bind(null,659))},"v-94f2abb4":function(){return t.e(41).then(t.bind(null,660))},"v-0267583d":function(){return t.e(43).then(t.bind(null,661))},"v-58f9bc27":function(){return t.e(44).then(t.bind(null,662))},"v-00baf344":function(){return t.e(45).then(t.bind(null,663))},"v-b93431e0":function(){return t.e(46).then(t.bind(null,664))},"v-dd911646":function(){return t.e(48).then(t.bind(null,665))},"v-132c28d6":function(){return t.e(49).then(t.bind(null,666))},"v-f89e44c8":function(){return t.e(47).then(t.bind(null,667))},"v-6eeb162e":function(){return t.e(50).then(t.bind(null,668))},"v-18f59fc6":function(){return t.e(51).then(t.bind(null,669))},"v-0b0e011c":function(){return t.e(52).then(t.bind(null,670))},"v-1d8ccd1e":function(){return t.e(53).then(t.bind(null,671))},"v-78a84160":function(){return t.e(54).then(t.bind(null,672))},"v-159e0fe2":function(){return t.e(55).then(t.bind(null,673))},"v-998970b8":function(){return t.e(56).then(t.bind(null,674))},"v-f594f93a":function(){return t.e(57).then(t.bind(null,675))},"v-2fd9779b":function(){return t.e(58).then(t.bind(null,676))},"v-0cd5d1ed":function(){return t.e(59).then(t.bind(null,677))},"v-f421c146":function(){return t.e(60).then(t.bind(null,678))},"v-3694fad4":function(){return t.e(61).then(t.bind(null,679))},"v-fe61dbea":function(){return t.e(62).then(t.bind(null,680))},"v-078bbb46":function(){return t.e(63).then(t.bind(null,681))},"v-bef5cc7e":function(){return t.e(64).then(t.bind(null,682))},"v-c3b1654e":function(){return t.e(65).then(t.bind(null,683))},"v-3092cb6e":function(){return t.e(67).then(t.bind(null,684))},"v-187547cf":function(){return t.e(66).then(t.bind(null,685))},"v-1fdb8159":function(){return t.e(68).then(t.bind(null,686))},"v-15a2f62d":function(){return t.e(69).then(t.bind(null,687))},"v-2ede98c9":function(){return t.e(71).then(t.bind(null,688))},"v-1180216e":function(){return t.e(70).then(t.bind(null,689))},"v-3eb9b545":function(){return t.e(72).then(t.bind(null,690))},"v-469764e9":function(){return t.e(73).then(t.bind(null,691))},"v-69ca47ce":function(){return t.e(74).then(t.bind(null,692))},"v-30c5f9aa":function(){return t.e(75).then(t.bind(null,693))},"v-85f3b0ec":function(){return t.e(76).then(t.bind(null,694))},"v-a312ef94":function(){return t.e(77).then(t.bind(null,695))},"v-61e67f96":function(){return t.e(78).then(t.bind(null,696))},"v-3408f9af":function(){return t.e(79).then(t.bind(null,697))},"v-8097d612":function(){return t.e(80).then(t.bind(null,698))},"v-7863fde9":function(){return t.e(81).then(t.bind(null,699))},"v-6fb355dc":function(){return t.e(82).then(t.bind(null,700))},"v-185bbf26":function(){return t.e(83).then(t.bind(null,701))},"v-3cae5cfe":function(){return t.e(84).then(t.bind(null,702))},"v-83959742":function(){return t.e(85).then(t.bind(null,703))},"v-66d6172e":function(){return t.e(86).then(t.bind(null,704))},"v-5cace148":function(){return t.e(87).then(t.bind(null,705))},"v-82023764":function(){return t.e(88).then(t.bind(null,706))},"v-40014b6e":function(){return t.e(89).then(t.bind(null,707))},"v-d895e9e4":function(){return t.e(90).then(t.bind(null,708))},"v-7201f9e4":function(){return t.e(91).then(t.bind(null,709))},"v-5c684536":function(){return t.e(92).then(t.bind(null,710))},"v-cfd1bbbe":function(){return t.e(93).then(t.bind(null,711))},"v-1d9f91d2":function(){return t.e(94).then(t.bind(null,712))},"v-03875860":function(){return t.e(95).then(t.bind(null,713))},"v-43456df0":function(){return t.e(97).then(t.bind(null,714))},"v-27816f24":function(){return t.e(96).then(t.bind(null,715))},"v-e25d7d4c":function(){return t.e(98).then(t.bind(null,716))},"v-d81aa7ca":function(){return t.e(99).then(t.bind(null,717))},"v-3fe0e2ee":function(){return t.e(100).then(t.bind(null,718))},"v-29760d32":function(){return t.e(101).then(t.bind(null,719))},"v-4a906e56":function(){return t.e(102).then(t.bind(null,720))},"v-2eca1248":function(){return t.e(103).then(t.bind(null,721))},"v-820a830c":function(){return t.e(104).then(t.bind(null,722))},"v-7933b2a2":function(){return t.e(105).then(t.bind(null,723))},"v-8bf3fad8":function(){return t.e(106).then(t.bind(null,724))},"v-4ce5dc34":function(){return t.e(107).then(t.bind(null,725))},"v-1c966386":function(){return t.e(108).then(t.bind(null,726))},"v-379c6be0":function(){return t.e(109).then(t.bind(null,727))},"v-92a93060":function(){return t.e(110).then(t.bind(null,728))},"v-ef44e3ec":function(){return t.e(112).then(t.bind(null,729))},"v-efde0330":function(){return t.e(111).then(t.bind(null,730))},"v-180fb8c6":function(){return t.e(113).then(t.bind(null,731))},"v-275267e8":function(){return t.e(114).then(t.bind(null,732))},"v-7230c420":function(){return t.e(116).then(t.bind(null,733))},"v-3e3f78e7":function(){return t.e(115).then(t.bind(null,734))},"v-d0433916":function(){return t.e(119).then(t.bind(null,735))},"v-2c160162":function(){return t.e(117).then(t.bind(null,736))},"v-7fa1a73e":function(){return t.e(121).then(t.bind(null,737))},"v-7306dc59":function(){return t.e(122).then(t.bind(null,738))},"v-f174bee6":function(){return t.e(123).then(t.bind(null,739))},"v-d326b974":function(){return t.e(124).then(t.bind(null,740))},"v-565c38b5":function(){return t.e(118).then(t.bind(null,741))},"v-3f1e209c":function(){return t.e(120).then(t.bind(null,742))}};function u(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var d=/-(\w)/g,p=u((function(n){return n.replace(d,(function(n,e){return e?e.toUpperCase():""}))})),m=/\B([A-Z])/g,h=u((function(n){return n.replace(m,"-$1").toLowerCase()})),f=u((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function v(n,e){if(e)return n(e)?n(e):e.includes("-")?n(f(p(e))):n(f(e))||n(h(e))}var g=Object.assign({},l,c),b=function(n){return g[n]},x=function(n){return c[n]},E=function(n){return l[n]},y=function(n){return s.a.component(n)};function w(n){return v(x,n)}function A(n){return v(E,n)}function k(n){return v(b,n)}function j(n){return v(y,n)}function B(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(i.a)(Object(a.a)().mark((function n(e){var t;return Object(a.a)().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(j(e)||!k(e)){n.next=5;break}return n.next=3,k(e)();case 3:t=n.sent,s.a.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function S(n,e,t){var o;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(o=n[e]).push.apply(o,Object(r.a)(t));break;default:throw new Error("Unknown option name.")}}function C(n,e){var t=n.$localePath;return"object"===Object(o.a)(e)&&e[t]?e[t]:e}function T(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var o=t(1),r=t(67).f,a=t(38),i=t(22),s=t(179),l=t(181),c=t(135);n.exports=function(n,e){var t,u,d,p,m,h=n.target,f=n.global,v=n.stat;if(t=f?o:v?o[h]||s(h,{}):(o[h]||{}).prototype)for(u in e){if(p=e[u],d=n.noTargetGet?(m=r(t,u))&&m.value:t[u],!c(f?u:h+(v?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;l(p,d)}(n.sham||d&&d.sham)&&a(p,"sham",!0),i(t,u,p,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var o=t(103),r=Function.prototype,a=r.bind,i=r.call,s=o&&a.bind(i,i);n.exports=o?function(n){return n&&s(n)}:function(n){return n&&function(){return i.apply(n,arguments)}}},function(n,e,t){"use strict";var o=t(8),r=(t(195),t(7),t(40),t(338),t(95),t(19),t(41),t(47),t(125),t(97),t(20),t(212),t(114),t(155),t(45),t(215),t(216),t(93),t(64),t(118),t(119),t(120),t(46),t(213),t(49),t(62),t(200),t(412),t(413),t(27),t(21),t(61),t(116),t(76),t(217),t(230),t(58),t(420),t(421),t(340),t(117),t(115),t(292),t(77),t(424),t(428),t(59),t(90),t(189),t(190),t(191),t(201),t(214),t(219),t(63),Object.freeze({}));function a(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"===Object(o.a)(n)||"boolean"==typeof n}function c(n){return null!==n&&"object"===Object(o.a)(n)}var u=Object.prototype.toString;function d(n){return"[object Object]"===u.call(n)}function p(n){return"[object RegExp]"===u.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function g(n,e){for(var t=Object.create(null),o=n.split(","),r=0;r<o.length;r++)t[o[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}g("slot,component",!0);var b=g("key,ref,slot,slot-scope,is");function x(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var E=Object.prototype.hasOwnProperty;function y(n,e){return E.call(n,e)}function w(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var A=/-(\w)/g,k=w((function(n){return n.replace(A,(function(n,e){return e?e.toUpperCase():""}))})),j=w((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),B=/\B([A-Z])/g,S=w((function(n){return n.replace(B,"-$1").toLowerCase()}));var C=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var o=arguments.length;return o?o>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function T(n,e){e=e||0;for(var t=n.length-e,o=new Array(t);t--;)o[t]=n[t+e];return o}function I(n,e){for(var t in e)n[t]=e[t];return n}function z(n){for(var e={},t=0;t<n.length;t++)n[t]&&I(e,n[t]);return e}function F(n,e,t){}var D=function(n,e,t){return!1},P=function(n){return n};function O(n,e){if(n===e)return!0;var t=c(n),o=c(e);if(!t||!o)return!t&&!o&&String(n)===String(e);try{var r=Array.isArray(n),a=Array.isArray(e);if(r&&a)return n.length===e.length&&n.every((function(n,t){return O(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||a)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return O(n[t],e[t])}))}catch(n){return!1}}function R(n,e){for(var t=0;t<n.length;t++)if(O(n[t],e))return t;return-1}function _(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var M=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],L={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:D,isReservedAttr:D,isUnknownElement:D,getTagNamespace:F,parsePlatformTagName:P,mustUseProp:D,async:!0,_lifecycleHooks:N},q=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function J(n,e,t,o){Object.defineProperty(n,e,{value:t,enumerable:!!o,writable:!0,configurable:!0})}var $=new RegExp("[^"+q.source+".$_\\d]");var V,U="__proto__"in{},H="undefined"!=typeof window,W="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,G=W&&WXEnvironment.platform.toLowerCase(),X=H&&window.navigator.userAgent.toLowerCase(),Y=X&&/msie|trident/.test(X),Z=X&&X.indexOf("msie 9.0")>0,K=X&&X.indexOf("edge/")>0,Q=(X&&X.indexOf("android"),X&&/iphone|ipad|ipod|ios/.test(X)||"ios"===G),nn=(X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X),X&&X.match(/firefox\/(\d+)/)),en={}.watch,tn=!1;if(H)try{var on={};Object.defineProperty(on,"passive",{get:function(){tn=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var rn=function(){return void 0===V&&(V=!H&&!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),V},an=H&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function sn(n){return"function"==typeof n&&/native code/.test(n.toString())}var ln,cn="undefined"!=typeof Symbol&&sn(Symbol)&&"undefined"!=typeof Reflect&&sn(Reflect.ownKeys);ln="undefined"!=typeof Set&&sn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=F,dn=0,pn=function(){this.id=dn++,this.subs=[]};pn.prototype.addSub=function(n){this.subs.push(n)},pn.prototype.removeSub=function(n){x(this.subs,n)},pn.prototype.depend=function(){pn.target&&pn.target.addDep(this)},pn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},pn.target=null;var mn=[];function hn(n){mn.push(n),pn.target=n}function fn(){mn.pop(),pn.target=mn[mn.length-1]}var vn=function(n,e,t,o,r,a,i,s){this.tag=n,this.data=e,this.children=t,this.text=o,this.elm=r,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},gn={child:{configurable:!0}};gn.child.get=function(){return this.componentInstance},Object.defineProperties(vn.prototype,gn);var bn=function(n){void 0===n&&(n="");var e=new vn;return e.text=n,e.isComment=!0,e};function xn(n){return new vn(void 0,void 0,void 0,String(n))}function En(n){var e=new vn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var yn=Array.prototype,wn=Object.create(yn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=yn[n];J(wn,n,(function(){for(var t=[],o=arguments.length;o--;)t[o]=arguments[o];var r,a=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&i.observeArray(r),i.dep.notify(),a}))}));var An=Object.getOwnPropertyNames(wn),kn=!0;function jn(n){kn=n}var Bn=function(n){this.value=n,this.dep=new pn,this.vmCount=0,J(n,"__ob__",this),Array.isArray(n)?(U?function(n,e){n.__proto__=e}(n,wn):function(n,e,t){for(var o=0,r=t.length;o<r;o++){var a=t[o];J(n,a,e[a])}}(n,wn,An),this.observeArray(n)):this.walk(n)};function Sn(n,e){var t;if(c(n)&&!(n instanceof vn))return y(n,"__ob__")&&n.__ob__ instanceof Bn?t=n.__ob__:kn&&!rn()&&(Array.isArray(n)||d(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new Bn(n)),e&&t&&t.vmCount++,t}function Cn(n,e,t,o,r){var a=new pn,i=Object.getOwnPropertyDescriptor(n,e);if(!i||!1!==i.configurable){var s=i&&i.get,l=i&&i.set;s&&!l||2!==arguments.length||(t=n[e]);var c=!r&&Sn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(n):t;return pn.target&&(a.depend(),c&&(c.dep.depend(),Array.isArray(e)&&zn(e))),e},set:function(e){var o=s?s.call(n):t;e===o||e!=e&&o!=o||s&&!l||(l?l.call(n,e):t=e,c=!r&&Sn(e),a.notify())}})}}function Tn(n,e,t){if(Array.isArray(n)&&m(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var o=n.__ob__;return n._isVue||o&&o.vmCount?t:o?(Cn(o.value,e,t),o.dep.notify(),t):(n[e]=t,t)}function In(n,e){if(Array.isArray(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||y(n,e)&&(delete n[e],t&&t.dep.notify())}}function zn(n){for(var e=void 0,t=0,o=n.length;t<o;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&zn(e)}Bn.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)Cn(n,e[t])},Bn.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Sn(n[e])};var Fn=L.optionMergeStrategies;function Dn(n,e){if(!e)return n;for(var t,o,r,a=cn?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++)"__ob__"!==(t=a[i])&&(o=n[t],r=e[t],y(n,t)?o!==r&&d(o)&&d(r)&&Dn(o,r):Tn(n,t,r));return n}function Pn(n,e,t){return t?function(){var o="function"==typeof e?e.call(t,t):e,r="function"==typeof n?n.call(t,t):n;return o?Dn(o,r):r}:e?n?function(){return Dn("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function On(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Rn(n,e,t,o){var r=Object.create(n||null);return e?I(r,e):r}Fn.data=function(n,e,t){return t?Pn(n,e,t):e&&"function"!=typeof e?n:Pn(n,e)},N.forEach((function(n){Fn[n]=On})),M.forEach((function(n){Fn[n+"s"]=Rn})),Fn.watch=function(n,e,t,o){if(n===en&&(n=void 0),e===en&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var r={};for(var a in I(r,n),e){var i=r[a],s=e[a];i&&!Array.isArray(i)&&(i=[i]),r[a]=i?i.concat(s):Array.isArray(s)?s:[s]}return r},Fn.props=Fn.methods=Fn.inject=Fn.computed=function(n,e,t,o){if(!n)return e;var r=Object.create(null);return I(r,n),e&&I(r,e),r},Fn.provide=Pn;var _n=function(n,e){return void 0===e?n:e};function Mn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var o,r,a={};if(Array.isArray(t))for(o=t.length;o--;)"string"==typeof(r=t[o])&&(a[k(r)]={type:null});else if(d(t))for(var i in t)r=t[i],a[k(i)]=d(r)?r:{type:r};else 0;n.props=a}}(e),function(n,e){var t=n.inject;if(t){var o=n.inject={};if(Array.isArray(t))for(var r=0;r<t.length;r++)o[t[r]]={from:t[r]};else if(d(t))for(var a in t){var i=t[a];o[a]=d(i)?I({from:a},i):{from:i}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var o=e[t];"function"==typeof o&&(e[t]={bind:o,update:o})}}(e),!e._base&&(e.extends&&(n=Mn(n,e.extends,t)),e.mixins))for(var o=0,r=e.mixins.length;o<r;o++)n=Mn(n,e.mixins[o],t);var a,i={};for(a in n)s(a);for(a in e)y(n,a)||s(a);function s(o){var r=Fn[o]||_n;i[o]=r(n[o],e[o],t,o)}return i}function Nn(n,e,t,o){if("string"==typeof t){var r=n[e];if(y(r,t))return r[t];var a=k(t);if(y(r,a))return r[a];var i=j(a);return y(r,i)?r[i]:r[t]||r[a]||r[i]}}function Ln(n,e,t,o){var r=e[n],a=!y(t,n),i=t[n],s=Vn(Boolean,r.type);if(s>-1)if(a&&!y(r,"default"))i=!1;else if(""===i||i===S(n)){var l=Vn(String,r.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!y(e,"default"))return;var o=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof o&&"Function"!==Jn(e.type)?o.call(n):o}(o,r,n);var c=kn;jn(!0),Sn(i),jn(c)}return i}var qn=/^\s*function (\w+)/;function Jn(n){var e=n&&n.toString().match(qn);return e?e[1]:""}function $n(n,e){return Jn(n)===Jn(e)}function Vn(n,e){if(!Array.isArray(e))return $n(e,n)?0:-1;for(var t=0,o=e.length;t<o;t++)if($n(e[t],n))return t;return-1}function Un(n,e,t){hn();try{if(e)for(var o=e;o=o.$parent;){var r=o.$options.errorCaptured;if(r)for(var a=0;a<r.length;a++)try{if(!1===r[a].call(o,n,e,t))return}catch(n){Wn(n,o,"errorCaptured hook")}}Wn(n,e,t)}finally{fn()}}function Hn(n,e,t,o,r){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&h(a)&&!a._handled&&(a.catch((function(n){return Un(n,o,r+" (Promise/async)")})),a._handled=!0)}catch(n){Un(n,o,r)}return a}function Wn(n,e,t){if(L.errorHandler)try{return L.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Gn(e,null,"config.errorHandler")}Gn(n,e,t)}function Gn(n,e,t){if(!H&&!W||"undefined"==typeof console)throw n;console.error(n)}var Xn,Yn=!1,Zn=[],Kn=!1;function Qn(){Kn=!1;var n=Zn.slice(0);Zn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&sn(Promise)){var ne=Promise.resolve();Xn=function(){ne.then(Qn),Q&&setTimeout(F)},Yn=!0}else if(Y||"undefined"==typeof MutationObserver||!sn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Xn="undefined"!=typeof setImmediate&&sn(setImmediate)?function(){setImmediate(Qn)}:function(){setTimeout(Qn,0)};else{var ee=1,te=new MutationObserver(Qn),oe=document.createTextNode(String(ee));te.observe(oe,{characterData:!0}),Xn=function(){ee=(ee+1)%2,oe.data=String(ee)},Yn=!0}function re(n,e){var t;if(Zn.push((function(){if(n)try{n.call(e)}catch(n){Un(n,e,"nextTick")}else t&&t(e)})),Kn||(Kn=!0,Xn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var ae=new ln;function ie(n){!function n(e,t){var o,r,a=Array.isArray(e);if(!a&&!c(e)||Object.isFrozen(e)||e instanceof vn)return;if(e.__ob__){var i=e.__ob__.dep.id;if(t.has(i))return;t.add(i)}if(a)for(o=e.length;o--;)n(e[o],t);else for(r=Object.keys(e),o=r.length;o--;)n(e[r[o]],t)}(n,ae),ae.clear()}var se=w((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),o="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=o?n.slice(1):n,once:t,capture:o,passive:e}}));function le(n,e){function t(){var n=arguments,o=t.fns;if(!Array.isArray(o))return Hn(o,null,arguments,e,"v-on handler");for(var r=o.slice(),a=0;a<r.length;a++)Hn(r[a],null,n,e,"v-on handler")}return t.fns=n,t}function ce(n,e,t,o,r,i){var l,c,u,d;for(l in n)c=n[l],u=e[l],d=se(l),a(c)||(a(u)?(a(c.fns)&&(c=n[l]=le(c,i)),s(d.once)&&(c=n[l]=r(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)a(n[l])&&o((d=se(l)).name,e[l],d.capture)}function ue(n,e,t){var o;n instanceof vn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),x(o.fns,l)}a(r)?o=le([l]):i(r.fns)&&s(r.merged)?(o=r).fns.push(l):o=le([r,l]),o.merged=!0,n[e]=o}function de(n,e,t,o,r){if(i(e)){if(y(e,t))return n[t]=e[t],r||delete e[t],!0;if(y(e,o))return n[t]=e[o],r||delete e[o],!0}return!1}function pe(n){return l(n)?[xn(n)]:Array.isArray(n)?function n(e,t){var o,r,c,u,d=[];for(o=0;o<e.length;o++)a(r=e[o])||"boolean"==typeof r||(c=d.length-1,u=d[c],Array.isArray(r)?r.length>0&&(me((r=n(r,(t||"")+"_"+o))[0])&&me(u)&&(d[c]=xn(u.text+r[0].text),r.shift()),d.push.apply(d,r)):l(r)?me(u)?d[c]=xn(u.text+r):""!==r&&d.push(xn(r)):me(r)&&me(u)?d[c]=xn(u.text+r.text):(s(e._isVList)&&i(r.tag)&&a(r.key)&&i(t)&&(r.key="__vlist"+t+"_"+o+"__"),d.push(r)));return d}(n):void 0}function me(n){return i(n)&&i(n.text)&&!1===n.isComment}function he(n,e){if(n){for(var t=Object.create(null),o=cn?Reflect.ownKeys(n):Object.keys(n),r=0;r<o.length;r++){var a=o[r];if("__ob__"!==a){for(var i=n[a].from,s=e;s;){if(s._provided&&y(s._provided,i)){t[a]=s._provided[i];break}s=s.$parent}if(!s)if("default"in n[a]){var l=n[a].default;t[a]="function"==typeof l?l.call(e):l}else 0}}return t}}function fe(n,e){if(!n||!n.length)return{};for(var t={},o=0,r=n.length;o<r;o++){var a=n[o],i=a.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,a.context!==e&&a.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(a);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(ve)&&delete t[c];return t}function ve(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ge(n){return n.isComment&&n.asyncFactory}function be(n,e,t){var o,a=Object.keys(e).length>0,i=n?!!n.$stable:!a,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(i&&t&&t!==r&&s===t.$key&&!a&&!t.$hasNormal)return t;for(var l in o={},n)n[l]&&"$"!==l[0]&&(o[l]=xe(e,l,n[l]))}else o={};for(var c in e)c in o||(o[c]=Ee(e,c));return n&&Object.isExtensible(n)&&(n._normalized=o),J(o,"$stable",i),J(o,"$key",s),J(o,"$hasNormal",a),o}function xe(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"===Object(o.a)(n)&&!Array.isArray(n)?[n]:pe(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!ge(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function Ee(n,e){return function(){return n[e]}}function ye(n,e){var t,o,r,a,s;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),o=0,r=n.length;o<r;o++)t[o]=e(n[o],o);else if("number"==typeof n)for(t=new Array(n),o=0;o<n;o++)t[o]=e(o+1,o);else if(c(n))if(cn&&n[Symbol.iterator]){t=[];for(var l=n[Symbol.iterator](),u=l.next();!u.done;)t.push(e(u.value,t.length)),u=l.next()}else for(a=Object.keys(n),t=new Array(a.length),o=0,r=a.length;o<r;o++)s=a[o],t[o]=e(n[s],s,o);return i(t)||(t=[]),t._isVList=!0,t}function we(n,e,t,o){var r,a=this.$scopedSlots[n];a?(t=t||{},o&&(t=I(I({},o),t)),r=a(t)||("function"==typeof e?e():e)):r=this.$slots[n]||("function"==typeof e?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},r):r}function Ae(n){return Nn(this.$options,"filters",n)||P}function ke(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function je(n,e,t,o,r){var a=L.keyCodes[e]||t;return r&&o&&!L.keyCodes[e]?ke(r,o):a?ke(a,n):o?S(o)!==e:void 0===n}function Be(n,e,t,o,r){if(t)if(c(t)){var a;Array.isArray(t)&&(t=z(t));var i=function(i){if("class"===i||"style"===i||b(i))a=n;else{var s=n.attrs&&n.attrs.type;a=o||L.mustUseProp(e,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=k(i),c=S(i);l in a||c in a||(a[i]=t[i],r&&((n.on||(n.on={}))["update:"+i]=function(n){t[i]=n}))};for(var s in t)i(s)}else;return n}function Se(n,e){var t=this._staticTrees||(this._staticTrees=[]),o=t[n];return o&&!e||Te(o=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),o}function Ce(n,e,t){return Te(n,"__once__"+e+(t?"_"+t:""),!0),n}function Te(n,e,t){if(Array.isArray(n))for(var o=0;o<n.length;o++)n[o]&&"string"!=typeof n[o]&&Ie(n[o],e+"_"+o,t);else Ie(n,e,t)}function Ie(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function ze(n,e){if(e)if(d(e)){var t=n.on=n.on?I({},n.on):{};for(var o in e){var r=t[o],a=e[o];t[o]=r?[].concat(r,a):a}}else;return n}function Fe(n,e,t,o){e=e||{$stable:!t};for(var r=0;r<n.length;r++){var a=n[r];Array.isArray(a)?Fe(a,e,t):a&&(a.proxy&&(a.fn.proxy=!0),e[a.key]=a.fn)}return o&&(e.$key=o),e}function De(n,e){for(var t=0;t<e.length;t+=2){var o=e[t];"string"==typeof o&&o&&(n[e[t]]=e[t+1])}return n}function Pe(n,e){return"string"==typeof n?e+n:n}function Oe(n){n._o=Ce,n._n=v,n._s=f,n._l=ye,n._t=we,n._q=O,n._i=R,n._m=Se,n._f=Ae,n._k=je,n._b=Be,n._v=xn,n._e=bn,n._u=Fe,n._g=ze,n._d=De,n._p=Pe}function Re(n,e,t,o,a){var i,l=this,c=a.options;y(o,"_uid")?(i=Object.create(o))._original=o:(i=o,o=o._original);var u=s(c._compiled),d=!u;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||r,this.injections=he(c.inject,o),this.slots=function(){return l.$slots||be(n.scopedSlots,l.$slots=fe(t,o)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return be(n.scopedSlots,this.slots())}}),u&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=be(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,r){var a=$e(i,n,e,t,r,d);return a&&!Array.isArray(a)&&(a.fnScopeId=c._scopeId,a.fnContext=o),a}:this._c=function(n,e,t,o){return $e(i,n,e,t,o,d)}}function _e(n,e,t,o,r){var a=En(n);return a.fnContext=t,a.fnOptions=o,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function Me(n,e){for(var t in e)n[k(t)]=e[t]}Oe(Re.prototype);var Ne={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Ne.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},o=n.data.inlineTemplate;i(o)&&(t.render=o.render,t.staticRenderFns=o.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,o,a){0;var i=o.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==r&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||l);n.$options._parentVnode=o,n.$vnode=o,n._vnode&&(n._vnode.parent=o);if(n.$options._renderChildren=a,n.$attrs=o.data.attrs||r,n.$listeners=t||r,e&&n.$options.props){jn(!1);for(var u=n._props,d=n.$options._propKeys||[],p=0;p<d.length;p++){var m=d[p],h=n.$options.props;u[m]=Ln(m,h,e,n)}jn(!0),n.$options.propsData=e}t=t||r;var f=n.$options._parentListeners;n.$options._parentListeners=t,Ze(n,t,f),c&&(n.$slots=fe(a,o.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,o=n.componentInstance;o._isMounted||(o._isMounted=!0,tt(o,"mounted")),n.data.keepAlive&&(t._isMounted?((e=o)._inactive=!1,rt.push(e)):et(o,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,nt(e)))return;if(!e._inactive){e._inactive=!0;for(var o=0;o<e.$children.length;o++)n(e.$children[o]);tt(e,"deactivated")}}(e,!0):e.$destroy())}},Le=Object.keys(Ne);function qe(n,e,t,o,l){if(!a(n)){var u=t.$options._base;if(c(n)&&(n=u.extend(n)),"function"==typeof n){var d;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=Ue;t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var o=n.owners=[t],r=!0,l=null,u=null;t.$on("hook:destroyed",(function(){return x(o,t)}));var d=function(n){for(var e=0,t=o.length;e<t;e++)o[e].$forceUpdate();n&&(o.length=0,null!==l&&(clearTimeout(l),l=null),null!==u&&(clearTimeout(u),u=null))},p=_((function(t){n.resolved=He(t,e),r?o.length=0:d(!0)})),m=_((function(e){i(n.errorComp)&&(n.error=!0,d(!0))})),f=n(p,m);return c(f)&&(h(f)?a(n.resolved)&&f.then(p,m):h(f.component)&&(f.component.then(p,m),i(f.error)&&(n.errorComp=He(f.error,e)),i(f.loading)&&(n.loadingComp=He(f.loading,e),0===f.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,d(!1))}),f.delay||200)),i(f.timeout)&&(u=setTimeout((function(){u=null,a(n.resolved)&&m(null)}),f.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(d=n,u)))return function(n,e,t,o,r){var a=bn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:o,tag:r},a}(d,e,t,o,l);e=e||{},kt(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",o=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var r=e.on||(e.on={}),a=r[o],s=e.model.callback;i(a)?(Array.isArray(a)?-1===a.indexOf(s):a!==s)&&(r[o]=[s].concat(a)):r[o]=s}(n.options,e);var p=function(n,e,t){var o=e.options.props;if(!a(o)){var r={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in o){var u=S(c);de(r,l,c,u,!0)||de(r,s,c,u,!1)}return r}}(e,n);if(s(n.options.functional))return function(n,e,t,o,a){var s=n.options,l={},c=s.props;if(i(c))for(var u in c)l[u]=Ln(u,c,e||r);else i(t.attrs)&&Me(l,t.attrs),i(t.props)&&Me(l,t.props);var d=new Re(t,l,a,o,n),p=s.render.call(null,d._c,d);if(p instanceof vn)return _e(p,t,d.parent,s,d);if(Array.isArray(p)){for(var m=pe(p)||[],h=new Array(m.length),f=0;f<m.length;f++)h[f]=_e(m[f],t,d.parent,s,d);return h}}(n,p,e,t,o);var m=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Le.length;t++){var o=Le[t],r=e[o],a=Ne[o];r===a||r&&r._merged||(e[o]=r?Je(a,r):a)}}(e);var v=n.options.name||l;return new vn("vue-component-"+n.cid+(v?"-"+v:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:m,tag:l,children:o},d)}}}function Je(n,e){var t=function(t,o){n(t,o),e(t,o)};return t._merged=!0,t}function $e(n,e,t,o,r,u){return(Array.isArray(t)||l(t))&&(r=o,o=t,t=void 0),s(u)&&(r=2),function(n,e,t,o,r){if(i(t)&&i(t.__ob__))return bn();i(t)&&i(t.is)&&(e=t.is);if(!e)return bn();0;Array.isArray(o)&&"function"==typeof o[0]&&((t=t||{}).scopedSlots={default:o[0]},o.length=0);2===r?o=pe(o):1===r&&(o=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(o));var l,u;if("string"==typeof e){var d;u=n.$vnode&&n.$vnode.ns||L.getTagNamespace(e),l=L.isReservedTag(e)?new vn(L.parsePlatformTagName(e),t,o,void 0,void 0,n):t&&t.pre||!i(d=Nn(n.$options,"components",e))?new vn(e,t,o,void 0,void 0,n):qe(d,t,n,o,e)}else l=qe(e,t,n,o);return Array.isArray(l)?l:i(l)?(i(u)&&function n(e,t,o){e.ns=t,"foreignObject"===e.tag&&(t=void 0,o=!0);if(i(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];i(c.tag)&&(a(c.ns)||s(o)&&"svg"!==c.tag)&&n(c,t,o)}}(l,u),i(t)&&function(n){c(n.style)&&ie(n.style);c(n.class)&&ie(n.class)}(t),l):bn()}(n,e,t,o,r)}var Ve,Ue=null;function He(n,e){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function We(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||ge(t)))return t}}function Ge(n,e){Ve.$on(n,e)}function Xe(n,e){Ve.$off(n,e)}function Ye(n,e){var t=Ve;return function o(){var r=e.apply(null,arguments);null!==r&&t.$off(n,o)}}function Ze(n,e,t){Ve=n,ce(e,t||{},Ge,Xe,Ye,n),Ve=void 0}var Ke=null;function Qe(n){var e=Ke;return Ke=n,function(){Ke=e}}function nt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function et(n,e){if(e){if(n._directInactive=!1,nt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)et(n.$children[t]);tt(n,"activated")}}function tt(n,e){hn();var t=n.$options[e],o=e+" hook";if(t)for(var r=0,a=t.length;r<a;r++)Hn(t[r],n,null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),fn()}var ot=[],rt=[],at={},it=!1,st=!1,lt=0;var ct=0,ut=Date.now;if(H&&!Y){var dt=window.performance;dt&&"function"==typeof dt.now&&ut()>document.createEvent("Event").timeStamp&&(ut=function(){return dt.now()})}function pt(){var n,e;for(ct=ut(),st=!0,ot.sort((function(n,e){return n.id-e.id})),lt=0;lt<ot.length;lt++)(n=ot[lt]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=rt.slice(),o=ot.slice();lt=ot.length=rt.length=0,at={},it=st=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,et(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],o=t.vm;o._watcher===t&&o._isMounted&&!o._isDestroyed&&tt(o,"updated")}}(o),an&&L.devtools&&an.emit("flush")}var mt=0,ht=function(n,e,t,o,r){this.vm=n,r&&(n._watcher=this),n._watchers.push(this),o?(this.deep=!!o.deep,this.user=!!o.user,this.lazy=!!o.lazy,this.sync=!!o.sync,this.before=o.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++mt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ln,this.newDepIds=new ln,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!$.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=F)),this.value=this.lazy?void 0:this.get()};ht.prototype.get=function(){var n;hn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Un(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&ie(n),fn(),this.cleanupDeps()}return n},ht.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},ht.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},ht.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==at[e]){if(at[e]=!0,st){for(var t=ot.length-1;t>lt&&ot[t].id>n.id;)t--;ot.splice(t+1,0,n)}else ot.push(n);it||(it=!0,re(pt))}}(this)},ht.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Hn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},ht.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},ht.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},ht.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||x(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ft={enumerable:!0,configurable:!0,get:F,set:F};function vt(n,e,t){ft.get=function(){return this[e][t]},ft.set=function(n){this[e][t]=n},Object.defineProperty(n,t,ft)}function gt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},o=n._props={},r=n.$options._propKeys=[];n.$parent&&jn(!1);var a=function(a){r.push(a);var i=Ln(a,e,t,n);Cn(o,a,i),a in n||vt(n,"_props",a)};for(var i in e)a(i);jn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?F:C(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;d(e=n._data="function"==typeof e?function(n,e){hn();try{return n.call(e,e)}catch(n){return Un(n,e,"data()"),{}}finally{fn()}}(e,n):e||{})||(e={});var t=Object.keys(e),o=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var a=t[r];0,o&&y(o,a)||(i=void 0,36!==(i=(a+"").charCodeAt(0))&&95!==i&&vt(n,"_data",a))}var i;Sn(e,!0)}(n):Sn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),o=rn();for(var r in e){var a=e[r],i="function"==typeof a?a:a.get;0,o||(t[r]=new ht(n,i||F,F,bt)),r in n||xt(n,r,a)}}(n,e.computed),e.watch&&e.watch!==en&&function(n,e){for(var t in e){var o=e[t];if(Array.isArray(o))for(var r=0;r<o.length;r++)wt(n,t,o[r]);else wt(n,t,o)}}(n,e.watch)}var bt={lazy:!0};function xt(n,e,t){var o=!rn();"function"==typeof t?(ft.get=o?Et(e):yt(t),ft.set=F):(ft.get=t.get?o&&!1!==t.cache?Et(e):yt(t.get):F,ft.set=t.set||F),Object.defineProperty(n,e,ft)}function Et(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),pn.target&&e.depend(),e.value}}function yt(n){return function(){return n.call(this,this)}}function wt(n,e,t,o){return d(t)&&(o=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,o)}var At=0;function kt(n){var e=n.options;if(n.super){var t=kt(n.super);if(t!==n.superOptions){n.superOptions=t;var o=function(n){var e,t=n.options,o=n.sealedOptions;for(var r in t)t[r]!==o[r]&&(e||(e={}),e[r]=t[r]);return e}(n);o&&I(n.extendOptions,o),(e=n.options=Mn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function jt(n){this._init(n)}function Bt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,o=t.cid,r=n._Ctor||(n._Ctor={});if(r[o])return r[o];var a=n.name||t.options.name;var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=Mn(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)vt(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)xt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,M.forEach((function(n){i[n]=t[n]})),a&&(i.options.components[a]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=I({},i.options),r[o]=i,i}}function St(n){return n&&(n.Ctor.options.name||n.tag)}function Ct(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function Tt(n,e){var t=n.cache,o=n.keys,r=n._vnode;for(var a in t){var i=t[a];if(i){var s=i.name;s&&!e(s)&&It(t,a,o,r)}}}function It(n,e,t,o){var r=n[e];!r||o&&r.tag===o.tag||r.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=At++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),o=e._parentVnode;t.parent=e.parent,t._parentVnode=o;var r=o.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Mn(kt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ze(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,o=t&&t.context;n.$slots=fe(e._renderChildren,o),n.$scopedSlots=r,n._c=function(e,t,o,r){return $e(n,e,t,o,r,!1)},n.$createElement=function(e,t,o,r){return $e(n,e,t,o,r,!0)};var a=t&&t.data;Cn(n,"$attrs",a&&a.attrs||r,null,!0),Cn(n,"$listeners",e._parentListeners||r,null,!0)}(e),tt(e,"beforeCreate"),function(n){var e=he(n.$options.inject,n);e&&(jn(!1),Object.keys(e).forEach((function(t){Cn(n,t,e[t])})),jn(!0))}(e),gt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),tt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(jt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Tn,n.prototype.$delete=In,n.prototype.$watch=function(n,e,t){if(d(e))return wt(this,n,e,t);(t=t||{}).user=!0;var o=new ht(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'+o.expression+'"';hn(),Hn(e,this,[o.value],this,r),fn()}return function(){o.teardown()}}}(jt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var o=this;if(Array.isArray(n))for(var r=0,a=n.length;r<a;r++)o.$on(n[r],t);else(o._events[n]||(o._events[n]=[])).push(t),e.test(n)&&(o._hasHookEvent=!0);return o},n.prototype.$once=function(n,e){var t=this;function o(){t.$off(n,o),e.apply(t,arguments)}return o.fn=e,t.$on(n,o),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var o=0,r=n.length;o<r;o++)t.$off(n[o],e);return t}var a,i=t._events[n];if(!i)return t;if(!e)return t._events[n]=null,t;for(var s=i.length;s--;)if((a=i[s])===e||a.fn===e){i.splice(s,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?T(t):t;for(var o=T(arguments,1),r='event handler for "'+n+'"',a=0,i=t.length;a<i;a++)Hn(t[a],e,o,e,r)}return e}}(jt),function(n){n.prototype._update=function(n,e){var t=this,o=t.$el,r=t._vnode,a=Qe(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),a(),o&&(o.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){tt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),tt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(jt),function(n){Oe(n.prototype),n.prototype.$nextTick=function(n){return re(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,o=t.render,r=t._parentVnode;r&&(e.$scopedSlots=be(r.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=r;try{Ue=e,n=o.call(e._renderProxy,e.$createElement)}catch(t){Un(t,e,"render"),n=e._vnode}finally{Ue=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof vn||(n=bn()),n.parent=r,n}}(jt);var zt=[String,RegExp,Array],Ft={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:zt,exclude:zt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,o=this.keyToCache;if(t){var r=t.tag,a=t.componentInstance,i=t.componentOptions;n[o]={name:St(i),tag:r,componentInstance:a},e.push(o),this.max&&e.length>parseInt(this.max)&&It(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)It(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Tt(n,(function(n){return Ct(e,n)}))})),this.$watch("exclude",(function(e){Tt(n,(function(n){return!Ct(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=We(n),t=e&&e.componentOptions;if(t){var o=St(t),r=this.include,a=this.exclude;if(r&&(!o||!Ct(r,o))||a&&o&&Ct(a,o))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,x(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return L}};Object.defineProperty(n,"config",e),n.util={warn:un,extend:I,mergeOptions:Mn,defineReactive:Cn},n.set=Tn,n.delete=In,n.nextTick=re,n.observable=function(n){return Sn(n),n},n.options=Object.create(null),M.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,I(n.options.components,Ft),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=T(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Mn(this.options,n),this}}(n),Bt(n),function(n){M.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(jt),Object.defineProperty(jt.prototype,"$isServer",{get:rn}),Object.defineProperty(jt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(jt,"FunctionalRenderContext",{value:Re}),jt.version="2.6.14";var Dt=g("style,class"),Pt=g("input,textarea,option,select,progress"),Ot=g("contenteditable,draggable,spellcheck"),Rt=g("events,caret,typing,plaintext-only"),_t=g("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Mt="http://www.w3.org/1999/xlink",Nt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Lt=function(n){return Nt(n)?n.slice(6,n.length):""},qt=function(n){return null==n||!1===n};function Jt(n){for(var e=n.data,t=n,o=n;i(o.componentInstance);)(o=o.componentInstance._vnode)&&o.data&&(e=$t(o.data,e));for(;i(t=t.parent);)t&&t.data&&(e=$t(e,t.data));return function(n,e){if(i(n)||i(e))return Vt(n,Ut(e));return""}(e.staticClass,e.class)}function $t(n,e){return{staticClass:Vt(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function Vt(n,e){return n?e?n+" "+e:n:e||""}function Ut(n){return Array.isArray(n)?function(n){for(var e,t="",o=0,r=n.length;o<r;o++)i(e=Ut(n[o]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Ht={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Wt=g("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Gt=g("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Xt=function(n){return Wt(n)||Gt(n)};var Yt=Object.create(null);var Zt=g("text,number,password,search,email,tel,url");var Kt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Ht[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Qt={create:function(n,e){no(e)},update:function(n,e){n.data.ref!==e.data.ref&&(no(n,!0),no(e))},destroy:function(n){no(n,!0)}};function no(n,e){var t=n.data.ref;if(i(t)){var o=n.context,r=n.componentInstance||n.elm,a=o.$refs;e?Array.isArray(a[t])?x(a[t],r):a[t]===r&&(a[t]=void 0):n.data.refInFor?Array.isArray(a[t])?a[t].indexOf(r)<0&&a[t].push(r):a[t]=[r]:a[t]=r}}var eo=new vn("",{},[]),to=["create","activate","update","remove","destroy"];function oo(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,o=i(t=n.data)&&i(t=t.attrs)&&t.type,r=i(t=e.data)&&i(t=t.attrs)&&t.type;return o===r||Zt(o)&&Zt(r)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function ro(n,e,t){var o,r,a={};for(o=e;o<=t;++o)i(r=n[o].key)&&(a[r]=o);return a}var ao={create:io,update:io,destroy:function(n){io(n,eo)}};function io(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,o,r,a=n===eo,i=e===eo,s=lo(n.data.directives,n.context),l=lo(e.data.directives,e.context),c=[],u=[];for(t in l)o=s[t],r=l[t],o?(r.oldValue=o.value,r.oldArg=o.arg,uo(r,"update",e,n),r.def&&r.def.componentUpdated&&u.push(r)):(uo(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var d=function(){for(var t=0;t<c.length;t++)uo(c[t],"inserted",e,n)};a?ue(e,"insert",d):d()}u.length&&ue(e,"postpatch",(function(){for(var t=0;t<u.length;t++)uo(u[t],"componentUpdated",e,n)}));if(!a)for(t in s)l[t]||uo(s[t],"unbind",n,n,i)}(n,e)}var so=Object.create(null);function lo(n,e){var t,o,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++)(o=n[t]).modifiers||(o.modifiers=so),r[co(o)]=o,o.def=Nn(e.$options,"directives",o.name);return r}function co(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function uo(n,e,t,o,r){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,o,r)}catch(o){Un(o,t.context,"directive "+n.name+" "+e+" hook")}}var po=[Qt,ao];function mo(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var o,r,s=e.elm,l=n.data.attrs||{},c=e.data.attrs||{};for(o in i(c.__ob__)&&(c=e.data.attrs=I({},c)),c)r=c[o],l[o]!==r&&ho(s,o,r,e.data.pre);for(o in(Y||K)&&c.value!==l.value&&ho(s,"value",c.value),l)a(c[o])&&(Nt(o)?s.removeAttributeNS(Mt,Lt(o)):Ot(o)||s.removeAttribute(o))}}function ho(n,e,t,o){o||n.tagName.indexOf("-")>-1?fo(n,e,t):_t(e)?qt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Ot(e)?n.setAttribute(e,function(n,e){return qt(e)||"false"===e?"false":"contenteditable"===n&&Rt(e)?e:"true"}(e,t)):Nt(e)?qt(t)?n.removeAttributeNS(Mt,Lt(e)):n.setAttributeNS(Mt,e,t):fo(n,e,t)}function fo(n,e,t){if(qt(t))n.removeAttribute(e);else{if(Y&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){n.addEventListener("input",(function e(t){t.stopImmediatePropagation(),n.removeEventListener("input",e)})),n.__ieph=!0}n.setAttribute(e,t)}}var vo={create:mo,update:mo};function go(n,e){var t=e.elm,o=e.data,r=n.data;if(!(a(o.staticClass)&&a(o.class)&&(a(r)||a(r.staticClass)&&a(r.class)))){var s=Jt(e),l=t._transitionClasses;i(l)&&(s=Vt(s,Ut(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var bo,xo={create:go,update:go};function Eo(n,e,t){var o=bo;return function r(){var a=e.apply(null,arguments);null!==a&&Ao(n,r,t,o)}}var yo=Yn&&!(nn&&Number(nn[1])<=53);function wo(n,e,t,o){if(yo){var r=ct,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}bo.addEventListener(n,e,tn?{capture:t,passive:o}:t)}function Ao(n,e,t,o){(o||bo).removeEventListener(n,e._wrapper||e,t)}function ko(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},o=n.data.on||{};bo=e.elm,function(n){if(i(n.__r)){var e=Y?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),ce(t,o,wo,Ao,Eo,e.context),bo=void 0}}var jo,Bo={create:ko,update:ko};function So(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,o,r=e.elm,s=n.data.domProps||{},l=e.data.domProps||{};for(t in i(l.__ob__)&&(l=e.data.domProps=I({},l)),s)t in l||(r[t]="");for(t in l){if(o=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),o===s[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=o;var c=a(o)?"":String(o);Co(r,c)&&(r.value=c)}else if("innerHTML"===t&&Gt(r.tagName)&&a(r.innerHTML)){(jo=jo||document.createElement("div")).innerHTML="<svg>"+o+"</svg>";for(var u=jo.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;u.firstChild;)r.appendChild(u.firstChild)}else if(o!==s[t])try{r[t]=o}catch(n){}}}}function Co(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,o=n._vModifiers;if(i(o)){if(o.number)return v(t)!==v(e);if(o.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var To={create:So,update:So},Io=w((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var o=n.split(t);o.length>1&&(e[o[0].trim()]=o[1].trim())}})),e}));function zo(n){var e=Fo(n.style);return n.staticStyle?I(n.staticStyle,e):e}function Fo(n){return Array.isArray(n)?z(n):"string"==typeof n?Io(n):n}var Do,Po=/^--/,Oo=/\s*!important$/,Ro=function(n,e,t){if(Po.test(e))n.style.setProperty(e,t);else if(Oo.test(t))n.style.setProperty(S(e),t.replace(Oo,""),"important");else{var o=Mo(e);if(Array.isArray(t))for(var r=0,a=t.length;r<a;r++)n.style[o]=t[r];else n.style[o]=t}},_o=["Webkit","Moz","ms"],Mo=w((function(n){if(Do=Do||document.createElement("div").style,"filter"!==(n=k(n))&&n in Do)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<_o.length;t++){var o=_o[t]+e;if(o in Do)return o}}));function No(n,e){var t=e.data,o=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(o.staticStyle)&&a(o.style))){var r,s,l=e.elm,c=o.staticStyle,u=o.normalizedStyle||o.style||{},d=c||u,p=Fo(e.data.style)||{};e.data.normalizedStyle=i(p.__ob__)?I({},p):p;var m=function(n,e){var t,o={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=zo(r.data))&&I(o,t);(t=zo(n.data))&&I(o,t);for(var a=n;a=a.parent;)a.data&&(t=zo(a.data))&&I(o,t);return o}(e,!0);for(s in d)a(m[s])&&Ro(l,s,"");for(s in m)(r=m[s])!==d[s]&&Ro(l,s,null==r?"":r)}}var Lo={create:No,update:No},qo=/\s+/;function Jo(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(qo).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function $o(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(qo).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",o=" "+e+" ";t.indexOf(o)>=0;)t=t.replace(o," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Vo(n){if(n){if("object"===Object(o.a)(n)){var e={};return!1!==n.css&&I(e,Uo(n.name||"v")),I(e,n),e}return"string"==typeof n?Uo(n):void 0}}var Uo=w((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Ho=H&&!Z,Wo="transition",Go="transitionend",Xo="animation",Yo="animationend";Ho&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Wo="WebkitTransition",Go="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Xo="WebkitAnimation",Yo="webkitAnimationEnd"));var Zo=H?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Ko(n){Zo((function(){Zo(n)}))}function Qo(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Jo(n,e))}function nr(n,e){n._transitionClasses&&x(n._transitionClasses,e),$o(n,e)}function er(n,e,t){var o=or(n,e),r=o.type,a=o.timeout,i=o.propCount;if(!r)return t();var s="transition"===r?Go:Yo,l=0,c=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),a+1),n.addEventListener(s,u)}var tr=/\b(transform|all)(,|$)/;function or(n,e){var t,o=window.getComputedStyle(n),r=(o[Wo+"Delay"]||"").split(", "),a=(o[Wo+"Duration"]||"").split(", "),i=rr(r,a),s=(o[Xo+"Delay"]||"").split(", "),l=(o[Xo+"Duration"]||"").split(", "),c=rr(s,l),u=0,d=0;return"transition"===e?i>0&&(t="transition",u=i,d=a.length):"animation"===e?c>0&&(t="animation",u=c,d=l.length):d=(t=(u=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&tr.test(o[Wo+"Property"])}}function rr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ar(e)+ar(n[t])})))}function ar(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ir(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var o=Vo(n.data.transition);if(!a(o)&&!i(t._enterCb)&&1===t.nodeType){for(var r=o.css,s=o.type,l=o.enterClass,u=o.enterToClass,d=o.enterActiveClass,p=o.appearClass,m=o.appearToClass,h=o.appearActiveClass,f=o.beforeEnter,g=o.enter,b=o.afterEnter,x=o.enterCancelled,E=o.beforeAppear,y=o.appear,w=o.afterAppear,A=o.appearCancelled,k=o.duration,j=Ke,B=Ke.$vnode;B&&B.parent;)j=B.context,B=B.parent;var S=!j._isMounted||!n.isRootInsert;if(!S||y||""===y){var C=S&&p?p:l,T=S&&h?h:d,I=S&&m?m:u,z=S&&E||f,F=S&&"function"==typeof y?y:g,D=S&&w||b,P=S&&A||x,O=v(c(k)?k.enter:k);0;var R=!1!==r&&!Z,M=cr(F),N=t._enterCb=_((function(){R&&(nr(t,I),nr(t,T)),N.cancelled?(R&&nr(t,C),P&&P(t)):D&&D(t),t._enterCb=null}));n.data.show||ue(n,"insert",(function(){var e=t.parentNode,o=e&&e._pending&&e._pending[n.key];o&&o.tag===n.tag&&o.elm._leaveCb&&o.elm._leaveCb(),F&&F(t,N)})),z&&z(t),R&&(Qo(t,C),Qo(t,T),Ko((function(){nr(t,C),N.cancelled||(Qo(t,I),M||(lr(O)?setTimeout(N,O):er(t,s,N)))}))),n.data.show&&(e&&e(),F&&F(t,N)),R||M||N()}}}function sr(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var o=Vo(n.data.transition);if(a(o)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var r=o.css,s=o.type,l=o.leaveClass,u=o.leaveToClass,d=o.leaveActiveClass,p=o.beforeLeave,m=o.leave,h=o.afterLeave,f=o.leaveCancelled,g=o.delayLeave,b=o.duration,x=!1!==r&&!Z,E=cr(m),y=v(c(b)?b.leave:b);0;var w=t._leaveCb=_((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),x&&(nr(t,u),nr(t,d)),w.cancelled?(x&&nr(t,l),f&&f(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(A):A()}function A(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),x&&(Qo(t,l),Qo(t,d),Ko((function(){nr(t,l),w.cancelled||(Qo(t,u),E||(lr(y)?setTimeout(w,y):er(t,s,w)))}))),m&&m(t,w),x||E||w())}}function lr(n){return"number"==typeof n&&!isNaN(n)}function cr(n){if(a(n))return!1;var e=n.fns;return i(e)?cr(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function ur(n,e){!0!==e.data.show&&ir(e)}var dr=function(n){var e,t,o={},r=n.modules,c=n.nodeOps;for(e=0;e<to.length;++e)for(o[to[e]]=[],t=0;t<r.length;++t)i(r[t][to[e]])&&o[to[e]].push(r[t][to[e]]);function u(n){var e=c.parentNode(n);i(e)&&c.removeChild(e,n)}function d(n,e,t,r,a,l,u){if(i(n.elm)&&i(l)&&(n=l[u]=En(n)),n.isRootInsert=!a,!function(n,e,t,r){var a=n.data;if(i(a)){var l=i(n.componentInstance)&&a.keepAlive;if(i(a=a.hook)&&i(a=a.init)&&a(n,!1),i(n.componentInstance))return p(n,e),m(t,n.elm,r),s(l)&&function(n,e,t,r){var a,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(a=s.data)&&i(a=a.transition)){for(a=0;a<o.activate.length;++a)o.activate[a](eo,s);e.push(s);break}m(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var d=n.data,f=n.children,g=n.tag;i(g)?(n.elm=n.ns?c.createElementNS(n.ns,g):c.createElement(g,n),b(n),h(n,f,e),i(d)&&v(n,e),m(t,n.elm,r)):s(n.isComment)?(n.elm=c.createComment(n.text),m(t,n.elm,r)):(n.elm=c.createTextNode(n.text),m(t,n.elm,r))}}function p(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(v(n,e),b(n)):(no(n),e.push(n))}function m(n,e,t){i(n)&&(i(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function h(n,e,t){if(Array.isArray(e)){0;for(var o=0;o<e.length;++o)d(e[o],t,n.elm,null,!0,e,o)}else l(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function v(n,t){for(var r=0;r<o.create.length;++r)o.create[r](eo,n);i(e=n.data.hook)&&(i(e.create)&&e.create(eo,n),i(e.insert)&&t.push(n))}function b(n){var e;if(i(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;i(e=Ke)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function x(n,e,t,o,r,a){for(;o<=r;++o)d(t[o],a,n,e,!1,t,o)}function E(n){var e,t,r=n.data;if(i(r))for(i(e=r.hook)&&i(e=e.destroy)&&e(n),e=0;e<o.destroy.length;++e)o.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)E(n.children[t])}function y(n,e,t){for(;e<=t;++e){var o=n[e];i(o)&&(i(o.tag)?(w(o),E(o)):u(o.elm))}}function w(n,e){if(i(e)||i(n.data)){var t,r=o.remove.length+1;for(i(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,r),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&w(t,e),t=0;t<o.remove.length;++t)o.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else u(n.elm)}function A(n,e,t,o){for(var r=t;r<o;r++){var a=e[r];if(i(a)&&oo(n,a))return r}}function k(n,e,t,r,l,u){if(n!==e){i(e.elm)&&i(r)&&(e=r[l]=En(e));var p=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?S(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;i(h)&&i(m=h.hook)&&i(m=m.prepatch)&&m(n,e);var v=n.children,g=e.children;if(i(h)&&f(e)){for(m=0;m<o.update.length;++m)o.update[m](n,e);i(m=h.hook)&&i(m=m.update)&&m(n,e)}a(e.text)?i(v)&&i(g)?v!==g&&function(n,e,t,o,r){var s,l,u,p=0,m=0,h=e.length-1,f=e[0],v=e[h],g=t.length-1,b=t[0],E=t[g],w=!r;for(0;p<=h&&m<=g;)a(f)?f=e[++p]:a(v)?v=e[--h]:oo(f,b)?(k(f,b,o,t,m),f=e[++p],b=t[++m]):oo(v,E)?(k(v,E,o,t,g),v=e[--h],E=t[--g]):oo(f,E)?(k(f,E,o,t,g),w&&c.insertBefore(n,f.elm,c.nextSibling(v.elm)),f=e[++p],E=t[--g]):oo(v,b)?(k(v,b,o,t,m),w&&c.insertBefore(n,v.elm,f.elm),v=e[--h],b=t[++m]):(a(s)&&(s=ro(e,p,h)),a(l=i(b.key)?s[b.key]:A(b,e,p,h))?d(b,o,n,f.elm,!1,t,m):oo(u=e[l],b)?(k(u,b,o,t,m),e[l]=void 0,w&&c.insertBefore(n,u.elm,f.elm)):d(b,o,n,f.elm,!1,t,m),b=t[++m]);p>h?x(n,a(t[g+1])?null:t[g+1].elm,t,m,g,o):m>g&&y(e,p,h)}(p,v,g,t,u):i(g)?(i(n.text)&&c.setTextContent(p,""),x(p,null,g,0,g.length-1,t)):i(v)?y(v,0,v.length-1):i(n.text)&&c.setTextContent(p,""):n.text!==e.text&&c.setTextContent(p,e.text),i(h)&&i(m=h.hook)&&i(m=m.postpatch)&&m(n,e)}}}function j(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var o=0;o<e.length;++o)e[o].data.hook.insert(e[o])}var B=g("attrs,class,staticClass,staticStyle,key");function S(n,e,t,o){var r,a=e.tag,l=e.data,c=e.children;if(o=o||l&&l.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(r=l.hook)&&i(r=r.init)&&r(e,!0),i(r=e.componentInstance)))return p(e,t),!0;if(i(a)){if(i(c))if(n.hasChildNodes())if(i(r=l)&&i(r=r.domProps)&&i(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,m=0;m<c.length;m++){if(!d||!S(d,c[m],t,o)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else h(e,c,t);if(i(l)){var f=!1;for(var g in l)if(!B(g)){f=!0,v(e,t);break}!f&&l.class&&ie(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!a(e)){var l,u=!1,p=[];if(a(n))u=!0,d(e,p);else{var m=i(n.nodeType);if(!m&&oo(n,e))k(n,e,p,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&S(n,e,p))return j(e,p,!0),n;l=n,n=new vn(c.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,v=c.parentNode(h);if(d(e,p,h._leaveCb?null:v,c.nextSibling(h)),i(e.parent))for(var g=e.parent,b=f(e);g;){for(var x=0;x<o.destroy.length;++x)o.destroy[x](g);if(g.elm=e.elm,b){for(var w=0;w<o.create.length;++w)o.create[w](eo,g);var A=g.data.hook.insert;if(A.merged)for(var B=1;B<A.fns.length;B++)A.fns[B]()}else no(g);g=g.parent}i(v)?y([n],0,0):i(n.tag)&&E(n)}}return j(e,p,u),e.elm}i(n)&&E(n)}}({nodeOps:Kt,modules:[vo,xo,Bo,To,Lo,H?{create:ur,activate:ur,remove:function(n,e){!0!==n.data.show?sr(n,e):e()}}:{}].concat(po)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&xr(n,"input")}));var pr={inserted:function(n,e,t,o){"select"===t.tag?(o.elm&&!o.elm._vOptions?ue(t,"postpatch",(function(){pr.componentUpdated(n,e,t)})):mr(n,e,t.context),n._vOptions=[].map.call(n.options,vr)):("textarea"===t.tag||Zt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",gr),n.addEventListener("compositionend",br),n.addEventListener("change",br),Z&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){mr(n,e,t.context);var o=n._vOptions,r=n._vOptions=[].map.call(n.options,vr);if(r.some((function(n,e){return!O(n,o[e])})))(n.multiple?e.value.some((function(n){return fr(n,r)})):e.value!==e.oldValue&&fr(e.value,r))&&xr(n,"change")}}};function mr(n,e,t){hr(n,e,t),(Y||K)&&setTimeout((function(){hr(n,e,t)}),0)}function hr(n,e,t){var o=e.value,r=n.multiple;if(!r||Array.isArray(o)){for(var a,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],r)a=R(o,vr(i))>-1,i.selected!==a&&(i.selected=a);else if(O(vr(i),o))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function fr(n,e){return e.every((function(e){return!O(e,n)}))}function vr(n){return"_value"in n?n._value:n.value}function gr(n){n.target.composing=!0}function br(n){n.target.composing&&(n.target.composing=!1,xr(n.target,"input"))}function xr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Er(n){return!n.componentInstance||n.data&&n.data.transition?n:Er(n.componentInstance._vnode)}var yr={model:pr,show:{bind:function(n,e,t){var o=e.value,r=(t=Er(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;o&&r?(t.data.show=!0,ir(t,(function(){n.style.display=a}))):n.style.display=o?a:"none"},update:function(n,e,t){var o=e.value;!o!=!e.oldValue&&((t=Er(t)).data&&t.data.transition?(t.data.show=!0,o?ir(t,(function(){n.style.display=n.__vOriginalDisplay})):sr(t,(function(){n.style.display="none"}))):n.style.display=o?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,o,r){r||(n.style.display=n.__vOriginalDisplay)}}},wr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ar(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ar(We(e.children)):n}function kr(n){var e={},t=n.$options;for(var o in t.propsData)e[o]=n[o];var r=t._parentListeners;for(var a in r)e[k(a)]=r[a];return e}function jr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Br=function(n){return n.tag||ge(n)},Sr=function(n){return"show"===n.name},Cr={name:"transition",props:wr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Br)).length){0;var o=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var a=Ar(r);if(!a)return r;if(this._leaving)return jr(n,r);var i="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?i+"comment":i+a.tag:l(a.key)?0===String(a.key).indexOf(i)?a.key:i+a.key:a.key;var s=(a.data||(a.data={})).transition=kr(this),c=this._vnode,u=Ar(c);if(a.data.directives&&a.data.directives.some(Sr)&&(a.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,u)&&!ge(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=I({},s);if("out-in"===o)return this._leaving=!0,ue(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),jr(n,r);if("in-out"===o){if(ge(a))return c;var p,m=function(){p()};ue(s,"afterEnter",m),ue(s,"enterCancelled",m),ue(d,"delayLeave",(function(n){p=n}))}}return r}}},Tr=I({tag:String,moveClass:String},wr);function Ir(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function zr(n){n.data.newPos=n.elm.getBoundingClientRect()}function Fr(n){var e=n.data.pos,t=n.data.newPos,o=e.left-t.left,r=e.top-t.top;if(o||r){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate("+o+"px,"+r+"px)",a.transitionDuration="0s"}}delete Tr.mode;var Dr={Transition:Cr,TransitionGroup:{props:Tr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,o){var r=Qe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,o)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),o=this.prevChildren=this.children,r=this.$slots.default||[],a=this.children=[],i=kr(this),s=0;s<r.length;s++){var l=r[s];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))a.push(l),t[l.key]=l,(l.data||(l.data={})).transition=i;else;}if(o){for(var c=[],u=[],d=0;d<o.length;d++){var p=o[d];p.data.transition=i,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?c.push(p):u.push(p)}this.kept=n(e,null,c),this.removed=u}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ir),n.forEach(zr),n.forEach(Fr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,o=t.style;Qo(t,e),o.transform=o.WebkitTransform=o.transitionDuration="",t.addEventListener(Go,t._moveCb=function n(o){o&&o.target!==t||o&&!/transform$/.test(o.propertyName)||(t.removeEventListener(Go,n),t._moveCb=null,nr(t,e))})}})))},methods:{hasMove:function(n,e){if(!Ho)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){$o(t,n)})),Jo(t,e),t.style.display="none",this.$el.appendChild(t);var o=or(t);return this.$el.removeChild(t),this._hasMove=o.hasTransform}}}};jt.config.mustUseProp=function(n,e,t){return"value"===t&&Pt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},jt.config.isReservedTag=Xt,jt.config.isReservedAttr=Dt,jt.config.getTagNamespace=function(n){return Gt(n)?"svg":"math"===n?"math":void 0},jt.config.isUnknownElement=function(n){if(!H)return!0;if(Xt(n))return!1;if(n=n.toLowerCase(),null!=Yt[n])return Yt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Yt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Yt[n]=/HTMLUnknownElement/.test(e.toString())},I(jt.options.directives,yr),I(jt.options.components,Dr),jt.prototype.__patch__=H?dr:F,jt.prototype.$mount=function(n,e){return function(n,e,t){var o;return n.$el=e,n.$options.render||(n.$options.render=bn),tt(n,"beforeMount"),o=function(){n._update(n._render(),t)},new ht(n,o,F,{before:function(){n._isMounted&&!n._isDestroyed&&tt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,tt(n,"mounted")),n}(this,n=n&&H?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},H&&setTimeout((function(){L.devtools&&an&&an.emit("init",jt)}),0),e.a=jt},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var o=t(185),r=t(22),a=t(402);o||r(Object.prototype,"toString",a,{unsafe:!0})},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(49),t(62),t(7),t(90),t(27),t(21);function o(n){return(o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}},function(n,e,t){var o=t(3);n.exports=!o((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var o=t(1),r=t(86),a=t(13),i=t(132),s=t(85),l=t(264),c=r("wks"),u=o.Symbol,d=u&&u.for,p=l?u:u&&u.withoutSetter||i;n.exports=function(n){if(!a(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&a(u,n)?c[n]=u[n]:c[n]=l&&d?d(e):p(e)}return c[n]}},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var o=t(1),r=t(123),a=o.String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var o=t(4),r=t(26),a=o({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(r(n),e)}},function(n,e,t){var o=t(1),r=t(16),a=o.String,i=o.TypeError;n.exports=function(n){if(r(n))return n;throw i(a(n)+" is not an object")}},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var o=t(11);n.exports=function(n){return"object"==typeof n?null!==n:o(n)}},function(n,e,t){var o=t(103),r=Function.prototype.call;n.exports=o?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e,t){var o=t(1),r=t(9),a=t(265),i=t(266),s=t(14),l=t(131),c=o.TypeError,u=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=r?i?function(n,e,t){if(s(n),e=l(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var o=d(n,e);o&&o.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:o.configurable,enumerable:"enumerable"in t?t.enumerable:o.enumerable,writable:!1})}return u(n,e,t)}:u:function(n,e,t){if(s(n),e=l(e),s(t),a)try{return u(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var o=t(22),r=t(409),a=Error.prototype;a.toString!==r&&o(a,"toString",r)},function(n,e,t){"use strict";var o=t(2),r=t(141);o({target:"RegExp",proto:!0,forced:/./.exec!==r},{exec:r})},function(n,e,t){var o=t(1),r=t(274),a=t(275),i=t(333),s=t(38),l=t(10),c=l("iterator"),u=l("toStringTag"),d=i.values,p=function(n,e){if(n){if(n[c]!==d)try{s(n,c,d)}catch(e){n[c]=d}if(n[u]||s(n,u,e),r[e])for(var t in i)if(n[t]!==i[t])try{s(n,t,i[t])}catch(e){n[t]=i[t]}}};for(var m in r)p(o[m]&&o[m].prototype,m);p(a,"DOMTokenList")},function(n,e,t){var o=t(1),r=t(11),a=t(38),i=t(267),s=t(179);n.exports=function(n,e,t,l){var c=!!l&&!!l.unsafe,u=!!l&&!!l.enumerable,d=!!l&&!!l.noTargetGet,p=l&&void 0!==l.name?l.name:e;return r(t)&&i(t,p,l),n===o?(u?n[e]=t:s(e,t),n):(c?!d&&n[e]&&(u=!0):delete n[e],u?n[e]=t:a(n,e,t),n)}},function(n,e,t){function o(e){return n.exports=o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},n.exports.__esModule=!0,n.exports.default=n.exports,o(e)}t(49),t(62),t(7),t(90),t(27),t(21),n.exports=o,n.exports.__esModule=!0,n.exports.default=n.exports},function(n,e,t){var o=t(126),r=Function.prototype,a=r.bind,i=r.call,s=o&&a.bind(i,i);n.exports=o?function(n){return n&&s(n)}:function(n){return n&&function(){return i.apply(n,arguments)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var o=t(1),r=t(30),a=o.Object;n.exports=function(n){return a(r(n))}},function(n,e,t){"use strict";var o=t(222).charAt,r=t(12),a=t(42),i=t(188),s=a.set,l=a.getterFor("String Iterator");i(String,"String",(function(n){s(this,{type:"String Iterator",string:r(n),index:0})}),(function(){var n,e=l(this),t=e.string,r=e.index;return r>=t.length?{value:void 0,done:!0}:(n=o(t,r),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var o=t(6),r=t(235),a=t(43),i=t(236),s=t(237),l=t(239),c=r("wks"),u=o.Symbol,d=u&&u.for,p=l?u:u&&u.withoutSetter||i;n.exports=function(n){if(!a(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&a(u,n)?c[n]=u[n]:c[n]=l&&d?d(e):p(e)}return c[n]}},function(n,e,t){"use strict";function o(n,e,t,o,r,a,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),o&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):r&&(l=s?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return o}))},function(n,e,t){var o=t(1).TypeError;n.exports=function(n){if(null==n)throw o("Can't call method on "+n);return n}},function(n,e,t){var o=t(2),r=t(1),a=t(69),i=t(405),s=r.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=i(n,e,l),o({global:!0,constructor:!0,arity:1,forced:l},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,l),o({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var o=t(126),r=Function.prototype.call;n.exports=o?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e,t){var o=t(1),r=t(11),a=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(o[n]):o[n]&&o[n][e]}},function(n,e,t){var o=t(60);n.exports=function(n){return o(n.length)}},function(n,e,t){var o=t(122),r=t(30);n.exports=function(n){return o(r(n))}},function(n,e,t){var o=t(25);n.exports=!o((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var o=t(4),r=o({}.toString),a=o("".slice);n.exports=function(n){return a(r(n),8,-1)}},function(n,e,t){var o=t(9),r=t(18),a=t(78);n.exports=o?function(n,e,t){return r.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e){var t=Math.ceil,o=Math.floor;n.exports=function(n){var e=+n;return e!=e||0===e?0:(e>0?o:t)(e)}},function(n,e,t){"use strict";var o=t(2),r=t(1),a=t(81),i=t(137),s=t(16),l=t(88),c=t(34),u=t(35),d=t(89),p=t(10),m=t(110),h=t(107),f=m("slice"),v=p("species"),g=r.Array,b=Math.max;o({target:"Array",proto:!0,forced:!f},{slice:function(n,e){var t,o,r,p=u(this),m=c(p),f=l(n,m),x=l(void 0===e?m:e,m);if(a(p)&&(t=p.constructor,(i(t)&&(t===g||a(t.prototype))||s(t)&&null===(t=t[v]))&&(t=void 0),t===g||void 0===t))return h(p,f,x);for(o=new(void 0===t?g:t)(b(x-f,0)),r=0;f<x;f++,r++)f in p&&d(o,r,p[f]);return o.length=r,o}})},function(n,e,t){var o=t(4),r=t(22),a=Date.prototype,i=o(a.toString),s=o(a.getTime);"Invalid Date"!=String(new Date(NaN))&&r(a,"toString",(function(){var n=s(this);return n==n?i(this):"Invalid Date"}))},function(n,e,t){var o,r,a,i=t(395),s=t(1),l=t(4),c=t(16),u=t(38),d=t(13),p=t(178),m=t(134),h=t(106),f=s.TypeError,v=s.WeakMap;if(i||p.state){var g=p.state||(p.state=new v),b=l(g.get),x=l(g.has),E=l(g.set);o=function(n,e){if(x(g,n))throw new f("Object already initialized");return e.facade=n,E(g,n,e),e},r=function(n){return b(g,n)||{}},a=function(n){return x(g,n)}}else{var y=m("state");h[y]=!0,o=function(n,e){if(d(n,y))throw new f("Object already initialized");return e.facade=n,u(n,y,e),e},r=function(n){return d(n,y)?n[y]:{}},a=function(n){return d(n,y)}}n.exports={set:o,get:r,has:a,enforce:function(n){return a(n)?r(n):o(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=r(e)).type!==n)throw f("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var o=t(24),r=t(163),a=o({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(r(n),e)}},function(n,e,t){var o=t(6),r=t(70),a=o.String,i=o.TypeError;n.exports=function(n){if(r(n))return n;throw i(a(n)+" is not an object")}},function(n,e,t){"use strict";var o=t(69),r=t(17),a=t(4),i=t(143),s=t(3),l=t(14),c=t(11),u=t(39),d=t(60),p=t(12),m=t(30),h=t(198),f=t(73),v=t(411),g=t(144),b=t(10)("replace"),x=Math.max,E=Math.min,y=a([].concat),w=a([].push),A=a("".indexOf),k=a("".slice),j="$0"==="a".replace(/./,"$0"),B=!!/./[b]&&""===/./[b]("a","$0");i("replace",(function(n,e,t){var a=B?"$":"$0";return[function(n,t){var o=m(this),a=null==n?void 0:f(n,b);return a?r(a,n,o,t):r(e,p(o),n,t)},function(n,r){var i=l(this),s=p(n);if("string"==typeof r&&-1===A(r,a)&&-1===A(r,"$<")){var m=t(e,i,s,r);if(m.done)return m.value}var f=c(r);f||(r=p(r));var b=i.global;if(b){var j=i.unicode;i.lastIndex=0}for(var B=[];;){var S=g(i,s);if(null===S)break;if(w(B,S),!b)break;""===p(S[0])&&(i.lastIndex=h(s,d(i.lastIndex),j))}for(var C,T="",I=0,z=0;z<B.length;z++){for(var F=p((S=B[z])[0]),D=x(E(u(S.index),s.length),0),P=[],O=1;O<S.length;O++)w(P,void 0===(C=S[O])?C:String(C));var R=S.groups;if(f){var _=y([F],P,D,s);void 0!==R&&w(_,R);var M=p(o(r,void 0,_))}else M=v(F,s,D,P,R,r);D>=I&&(T+=k(s,I,D)+M,I=D+F.length)}return T+k(s,I)}]}),!!s((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!j||B)},function(n,e,t){"use strict";t(20);var o,r,a=t(2),i=t(1),s=t(17),l=t(4),c=t(11),u=t(16),d=(o=!1,(r=/[ac]/).exec=function(){return o=!0,/./.exec.apply(this,arguments)},!0===r.test("abc")&&o),p=i.Error,m=l(/./.test);a({target:"RegExp",proto:!0,forced:!d},{test:function(n){var e=this.exec;if(!c(e))return m(this,n);var t=s(e,this,n);if(null!==t&&!u(t))throw new p("RegExp exec method returned something other than an Object or null");return!!t}})},function(n,e,t){"use strict";var o=t(87).PROPER,r=t(22),a=t(14),i=t(12),s=t(3),l=t(282),c=RegExp.prototype.toString,u=s((function(){return"/a/b"!=c.call({source:"a",flags:"b"})})),d=o&&"toString"!=c.name;(u||d)&&r(RegExp.prototype,"toString",(function(){var n=a(this);return"/"+i(n.source)+"/"+i(l(n))}),{unsafe:!0})},function(n,e,t){var o=t(18).f,r=t(13),a=t(10)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!r(n,a)&&o(n,a,{configurable:!0,value:e})}},function(n,e,t){t(393),t(399),t(400),t(125),t(401)},function(n,e,t){var o,r=t(14),a=t(186),i=t(184),s=t(106),l=t(269),c=t(133),u=t(134),d=u("IE_PROTO"),p=function(){},m=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e},f=function(){try{o=new ActiveXObject("htmlfile")}catch(n){}var n,e;f="undefined"!=typeof document?document.domain&&o?h(o):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F):h(o);for(var t=i.length;t--;)delete f.prototype[i[t]];return f()};s[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=r(n),t=new p,p.prototype=null,t[d]=n):t=f(),void 0===e?t:a.f(t,e)}},function(n,e,t){t(95);var o=Array.isArray;n.exports=o},function(n,e){n.exports=!1},function(n,e,t){var o=t(6),r=t(15),a=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(o[n]):o[n]&&o[n][e]}},function(n,e,t){var o=t(6),r=t(173).f,a=t(130),i=t(83),s=t(162),l=t(359),c=t(252);n.exports=function(n,e){var t,u,d,p,m,h=n.target,f=n.global,v=n.stat;if(t=f?o:v?o[h]||s(h,{}):(o[h]||{}).prototype)for(u in e){if(p=e[u],d=n.noTargetGet?(m=r(t,u))&&m.value:t[u],!c(f?u:h+(v?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;l(p,d)}(n.sham||d&&d.sham)&&a(p,"sham",!0),i(t,u,p,n)}}},function(n,e,t){var o=t(4);n.exports=o({}.isPrototypeOf)},function(n,e,t){var o=t(23).default,r=t(298),a="object"==("undefined"==typeof self?"undefined":o(self))&&self&&self.Object===Object&&self,i=r||a||Function("return this")();n.exports=i},function(n,e,t){"use strict";t.d(e,"a",(function(){return r}));t(49),t(62),t(7),t(90),t(27),t(21),t(404),t(189),t(190),t(191),t(64),t(97),t(31),t(19),t(192),t(58),t(59),t(61),t(193),t(223),t(40);var o=t(8);function r(){
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
r=function(){return n};var n={},e=Object.prototype,t=e.hasOwnProperty,a="function"==typeof Symbol?Symbol:{},i=a.iterator||"@@iterator",s=a.asyncIterator||"@@asyncIterator",l=a.toStringTag||"@@toStringTag";function c(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{c({},"")}catch(n){c=function(n,e,t){return n[e]=t}}function u(n,e,t,o){var r=e&&e.prototype instanceof m?e:m,a=Object.create(r.prototype),i=new j(o||[]);return a._invoke=function(n,e,t){var o="suspendedStart";return function(r,a){if("executing"===o)throw new Error("Generator is already running");if("completed"===o){if("throw"===r)throw a;return S()}for(t.method=r,t.arg=a;;){var i=t.delegate;if(i){var s=w(i,t);if(s){if(s===p)continue;return s}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===o)throw o="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);o="executing";var l=d(n,e,t);if("normal"===l.type){if(o=t.done?"completed":"suspendedYield",l.arg===p)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(o="completed",t.method="throw",t.arg=l.arg)}}}(n,t,i),a}function d(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=u;var p={};function m(){}function h(){}function f(){}var v={};c(v,i,(function(){return this}));var g=Object.getPrototypeOf,b=g&&g(g(B([])));b&&b!==e&&t.call(b,i)&&(v=b);var x=f.prototype=m.prototype=Object.create(v);function E(n){["next","throw","return"].forEach((function(e){c(n,e,(function(n){return this._invoke(e,n)}))}))}function y(n,e){var r;this._invoke=function(a,i){function s(){return new e((function(r,s){!function r(a,i,s,l){var c=d(n[a],n,i);if("throw"!==c.type){var u=c.arg,p=u.value;return p&&"object"==Object(o.a)(p)&&t.call(p,"__await")?e.resolve(p.__await).then((function(n){r("next",n,s,l)}),(function(n){r("throw",n,s,l)})):e.resolve(p).then((function(n){u.value=n,s(u)}),(function(n){return r("throw",n,s,l)}))}l(c.arg)}(a,i,r,s)}))}return r=r?r.then(s,s):s()}}function w(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,w(n,e),"throw"===e.method))return p;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return p}var o=d(t,n.iterator,e.arg);if("throw"===o.type)return e.method="throw",e.arg=o.arg,e.delegate=null,p;var r=o.arg;return r?r.done?(e[n.resultName]=r.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,p):r:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,p)}function A(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function k(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function j(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(A,this),this.reset(!0)}function B(n){if(n){var e=n[i];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var o=-1,r=function e(){for(;++o<n.length;)if(t.call(n,o))return e.value=n[o],e.done=!1,e;return e.value=void 0,e.done=!0,e};return r.next=r}}return{next:S}}function S(){return{value:void 0,done:!0}}return h.prototype=f,c(x,"constructor",f),c(f,"constructor",h),h.displayName=c(f,l,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===h||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,f):(n.__proto__=f,c(n,l,"GeneratorFunction")),n.prototype=Object.create(x),n},n.awrap=function(n){return{__await:n}},E(y.prototype),c(y.prototype,s,(function(){return this})),n.AsyncIterator=y,n.async=function(e,t,o,r,a){void 0===a&&(a=Promise);var i=new y(u(e,t,o,r),a);return n.isGeneratorFunction(t)?i:i.next().then((function(n){return n.done?n.value:i.next()}))},E(x),c(x,l,"Generator"),c(x,i,(function(){return this})),c(x,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var o=e.pop();if(o in n)return t.value=o,t.done=!1,t}return t.done=!0,t}},n.values=B,j.prototype={constructor:j,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(k),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function o(t,o){return i.type="throw",i.arg=n,e.next=t,o&&(e.method="next",e.arg=void 0),!!o}for(var r=this.tryEntries.length-1;r>=0;--r){var a=this.tryEntries[r],i=a.completion;if("root"===a.tryLoc)return o("end");if(a.tryLoc<=this.prev){var s=t.call(a,"catchLoc"),l=t.call(a,"finallyLoc");if(s&&l){if(this.prev<a.catchLoc)return o(a.catchLoc,!0);if(this.prev<a.finallyLoc)return o(a.finallyLoc)}else if(s){if(this.prev<a.catchLoc)return o(a.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return o(a.finallyLoc)}}}},abrupt:function(n,e){for(var o=this.tryEntries.length-1;o>=0;--o){var r=this.tryEntries[o];if(r.tryLoc<=this.prev&&t.call(r,"finallyLoc")&&this.prev<r.finallyLoc){var a=r;break}}a&&("break"===n||"continue"===n)&&a.tryLoc<=e&&e<=a.finallyLoc&&(a=null);var i=a?a.completion:{};return i.type=n,i.arg=e,a?(this.method="next",this.next=a.finallyLoc,p):this.complete(i)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),p},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),k(t),p}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var o=t.completion;if("throw"===o.type){var r=o.arg;k(t)}return r}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:B(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),p}},n}},function(n,e,t){"use strict";var o=t(2),r=t(278);o({target:"Array",proto:!0,forced:[].forEach!=r},{forEach:r})},function(n,e,t){var o=t(1),r=t(274),a=t(275),i=t(278),s=t(38),l=function(n){if(n&&n.forEach!==i)try{s(n,"forEach",i)}catch(e){n.forEach=i}};for(var c in r)r[c]&&l(o[c]&&o[c].prototype);l(a)},function(n,e,t){var o=t(39),r=Math.min;n.exports=function(n){return n>0?r(o(n),9007199254740991):0}},function(n,e,t){var o=t(9),r=t(87).EXISTS,a=t(4),i=t(18).f,s=Function.prototype,l=a(s.toString),c=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,u=a(c.exec);o&&!r&&i(s,"name",{configurable:!0,get:function(){try{return u(c,l(this))[1]}catch(n){return""}}})},function(n,e,t){"use strict";var o=t(2),r=t(9),a=t(1),i=t(4),s=t(13),l=t(11),c=t(55),u=t(12),d=t(18).f,p=t(181),m=a.Symbol,h=m&&m.prototype;if(r&&l(m)&&(!("description"in h)||void 0!==m().description)){var f={},v=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:u(arguments[0]),e=c(h,this)?new m(n):void 0===n?m():m(n);return""===n&&(f[e]=!0),e};p(v,m),v.prototype=h,h.constructor=v;var g="Symbol(test)"==String(m("test")),b=i(h.toString),x=i(h.valueOf),E=/^Symbol\((.*)\)[^)]+$/,y=i("".replace),w=i("".slice);d(h,"description",{configurable:!0,get:function(){var n=x(this),e=b(n);if(s(f,n))return"";var t=g?w(e,7,-1):y(e,E,"$1");return""===t?void 0:t}}),o({global:!0,constructor:!0,forced:!0},{Symbol:v})}},function(n,e,t){"use strict";var o=t(2),r=t(68).filter;o({target:"Array",proto:!0,forced:!t(110)("filter")},{filter:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var o=t(2),r=t(9),a=t(18).f;o({target:"Object",stat:!0,forced:Object.defineProperty!==a,sham:!r},{defineProperty:a})},function(n,e){n.exports=!1},function(n,e,t){"use strict";var o=t(3);n.exports=function(n,e){var t=[][n];return!!t&&o((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var o=t(9),r=t(17),a=t(220),i=t(78),s=t(35),l=t(131),c=t(13),u=t(265),d=Object.getOwnPropertyDescriptor;e.f=o?d:function(n,e){if(n=s(n),e=l(e),u)try{return d(n,e)}catch(n){}if(c(n,e))return i(!r(a.f,n,e),n[e])}},function(n,e,t){var o=t(94),r=t(4),a=t(122),i=t(26),s=t(34),l=t(154),c=r([].push),u=function(n){var e=1==n,t=2==n,r=3==n,u=4==n,d=6==n,p=7==n,m=5==n||d;return function(h,f,v,g){for(var b,x,E=i(h),y=a(E),w=o(f,v),A=s(y),k=0,j=g||l,B=e?j(h,A):t||p?j(h,0):void 0;A>k;k++)if((m||k in y)&&(x=w(b=y[k],k,E),n))if(e)B[k]=x;else if(x)switch(n){case 3:return!0;case 5:return b;case 6:return k;case 2:c(B,b)}else switch(n){case 4:return!1;case 7:c(B,b)}return d?-1:r||u?u:B}};n.exports={forEach:u(0),map:u(1),filter:u(2),some:u(3),every:u(4),find:u(5),findIndex:u(6),filterReject:u(7)}},function(n,e,t){var o=t(103),r=Function.prototype,a=r.apply,i=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(o?i.bind(a):function(){return i.apply(a,arguments)})},function(n,e,t){var o=t(15);n.exports=function(n){return"object"==typeof n?null!==n:o(n)}},function(n,e,t){var o=t(6),r=t(36),a=t(241),i=t(240),s=t(44),l=t(242),c=o.TypeError,u=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=r?i?function(n,e,t){if(s(n),e=l(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var o=d(n,e);o&&o.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:o.configurable,enumerable:"enumerable"in t?t.enumerable:o.enumerable,writable:!1})}return u(n,e,t)}:u:function(n,e,t){if(s(n),e=l(e),s(t),a)try{return u(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var o=t(6),r=t(15),a=t(128),i=o.TypeError;n.exports=function(n){if(r(n))return n;throw i(a(n)+" is not a function")}},function(n,e,t){var o=t(80);n.exports=function(n,e){var t=n[e];return null==t?void 0:o(t)}},function(n,e,t){var o=t(268),r=t(184).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return o(n,r)}},function(n,e,t){var o=t(449),r=t(452);n.exports=function(n,e){var t=r(n,e);return o(t)?t:void 0}},function(n,e,t){"use strict";var o=t(2),r=t(68).map;o({target:"Array",proto:!0,forced:!t(110)("map")},{map:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){t(422),t(423)},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var o=t(33);n.exports=o("navigator","userAgent")||""},function(n,e,t){var o=t(1),r=t(11),a=t(105),i=o.TypeError;n.exports=function(n){if(r(n))return n;throw i(a(n)+" is not a function")}},function(n,e,t){var o=t(37);n.exports=Array.isArray||function(n){return"Array"==o(n)}},function(n,e,t){var o=t(23).default;n.exports=function(n){return null!=n&&"object"==o(n)}},function(n,e,t){var o=t(6),r=t(15),a=t(130),i=t(358),s=t(162);n.exports=function(n,e,t,l){var c=!!l&&!!l.unsafe,u=!!l&&!!l.enumerable,d=!!l&&!!l.noTargetGet,p=l&&void 0!==l.name?l.name:e;return r(t)&&i(t,p,l),n===o?(u?n[e]=t:s(e,t),n):(c?!d&&n[e]&&(u=!0):delete n[e],u?n[e]=t:a(n,e,t),n)}},function(n,e,t){var o=t(6);n.exports=o.Promise},function(n,e,t){var o=t(96),r=t(3);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&o&&o<41}))},function(n,e,t){var o=t(65),r=t(178);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.22.5",mode:o?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.22.5/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){var o=t(9),r=t(13),a=Function.prototype,i=o&&Object.getOwnPropertyDescriptor,s=r(a,"name"),l=s&&"something"===function(){}.name,c=s&&(!o||o&&i(a,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var o=t(39),r=Math.max,a=Math.min;n.exports=function(n,e){var t=o(n);return t<0?r(t+e,0):a(t,e)}},function(n,e,t){"use strict";var o=t(131),r=t(18),a=t(78);n.exports=function(n,e,t){var i=o(e);i in n?r.f(n,i,a(0,t)):n[i]=t}},function(n,e,t){t(136)("iterator")},function(n,e,t){"use strict";t.d(e,"a",(function(){return r}));t(7);function o(n,e,t,o,r,a,i){try{var s=n[a](i),l=s.value}catch(n){return void t(n)}s.done?e(l):Promise.resolve(l).then(o,r)}function r(n){return function(){var e=this,t=arguments;return new Promise((function(r,a){var i=n.apply(e,t);function s(n){o(i,r,a,s,l,"next",n)}function l(n){o(i,r,a,s,l,"throw",n)}s(void 0)}))}}},function(n,e,t){"use strict";var o=t(5);e.a=new o.a},function(n,e,t){var o=t(2),r=t(26),a=t(158);o({target:"Object",stat:!0,forced:t(3)((function(){a(1)}))},{keys:function(n){return a(r(n))}})},function(n,e,t){var o=t(4),r=t(80),a=t(103),i=o(o.bind);n.exports=function(n,e){return r(n),void 0===e?n:a?i(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){t(2)({target:"Array",stat:!0},{isArray:t(81)})},function(n,e,t){var o,r,a=t(1),i=t(79),s=a.process,l=a.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(r=(o=u.split("."))[0]>0&&o[0]<4?1:+(o[0]+o[1])),!r&&i&&(!(o=i.match(/Edge\/(\d+)/))||o[1]>=74)&&(o=i.match(/Chrome\/(\d+)/))&&(r=+o[1]),n.exports=r},function(n,e,t){t(2)({target:"Object",stat:!0,sham:!t(9)},{create:t(50)})},function(n,e,t){var o=t(111),r=t(434),a=t(435),i=o?o.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?r(n):a(n)}},function(n,e,t){var o=t(233),r=t(234);n.exports=function(n){return o(r(n))}},function(n,e){n.exports={}},function(n,e,t){var o=t(6),r=t(84),a=t(15),i=t(252),s=t(129),l=t(28),c=t(380),u=t(52),d=t(238),p=r&&r.prototype,m=l("species"),h=!1,f=a(o.PromiseRejectionEvent),v=i("Promise",(function(){var n=s(r),e=n!==String(r);if(!e&&66===d)return!0;if(u&&(!p.catch||!p.finally))return!0;if(d>=51&&/native code/.test(n))return!1;var t=new r((function(n){n(1)})),o=function(n){n((function(){}),(function(){}))};return(t.constructor={})[m]=o,!(h=t.then((function(){}))instanceof o)||!e&&c&&!f}));n.exports={CONSTRUCTOR:v,REJECTION_EVENT:f,SUBCLASSING:h}},function(n,e,t){"use strict";var o=t(72),r=function(n){var e,t;this.promise=new n((function(n,o){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=o})),this.resolve=o(e),this.reject=o(t)};n.exports.f=function(n){return new r(n)}},function(n,e,t){var o=t(3);n.exports=!o((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var o=t(1),r=t(33),a=t(11),i=t(55),s=t(264),l=o.Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return a(e)&&i(e.prototype,l(n))}},function(n,e,t){var o=t(1).String;n.exports=function(n){try{return o(n)}catch(n){return"Object"}}},function(n,e){n.exports={}},function(n,e,t){var o=t(4);n.exports=o([].slice)},function(n,e){n.exports={}},function(n,e,t){var o=t(4),r=t(14),a=t(403);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=o(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,o){return r(t),a(o),e?n(t,o):t.__proto__=o,t}}():void 0)},function(n,e,t){var o=t(3),r=t(10),a=t(96),i=r("species");n.exports=function(n){return a>=51||!o((function(){var e=[];return(e.constructor={})[i]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){var o=t(56).Symbol;n.exports=o},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(95);var o=t(113);t(49),t(62),t(7),t(90),t(27),t(21),t(296);var r=t(150);t(31),t(19);function a(n){return function(n){if(Array.isArray(n))return Object(o.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(r.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function o(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}t.d(e,"a",(function(){return o}))},function(n,e,t){"use strict";var o=t(2),r=t(4),a=t(183).indexOf,i=t(66),s=r([].indexOf),l=!!s&&1/s([1],1,-0)<0,c=i("indexOf");o({target:"Array",proto:!0,forced:l||!c},{indexOf:function(n){var e=arguments.length>1?arguments[1]:void 0;return l?s(this,n,e)||0:a(this,n,e)}})},function(n,e,t){"use strict";var o=t(2),r=t(68).some;o({target:"Array",proto:!0,forced:!t(66)("some")},{some:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var o=t(2),r=t(4),a=t(122),i=t(35),s=t(66),l=r([].join),c=a!=Object,u=s("join",",");o({target:"Array",proto:!0,forced:c||!u},{join:function(n){return l(i(this),void 0===n?",":n)}})},function(n,e,t){"use strict";var o=t(2),r=t(1),a=t(3),i=t(81),s=t(16),l=t(26),c=t(34),u=t(89),d=t(154),p=t(110),m=t(10),h=t(96),f=m("isConcatSpreadable"),v=r.TypeError,g=h>=51||!a((function(){var n=[];return n[f]=!1,n.concat()[0]!==n})),b=p("concat"),x=function(n){if(!s(n))return!1;var e=n[f];return void 0!==e?!!e:i(n)};o({target:"Array",proto:!0,arity:1,forced:!g||!b},{concat:function(n){var e,t,o,r,a,i=l(this),s=d(i,0),p=0;for(e=-1,o=arguments.length;e<o;e++)if(x(a=-1===e?i:arguments[e])){if(p+(r=c(a))>9007199254740991)throw v("Maximum allowed index exceeded");for(t=0;t<r;t++,p++)t in a&&u(s,p,a[t])}else{if(p>=9007199254740991)throw v("Maximum allowed index exceeded");u(s,p++,a)}return s.length=p,s}})},function(n,e,t){var o=t(9),r=t(1),a=t(4),i=t(135),s=t(139),l=t(38),c=t(74).f,u=t(55),d=t(194),p=t(12),m=t(282),h=t(142),f=t(276),v=t(22),g=t(3),b=t(13),x=t(42).enforce,E=t(199),y=t(10),w=t(197),A=t(284),k=y("match"),j=r.RegExp,B=j.prototype,S=r.SyntaxError,C=a(B.exec),T=a("".charAt),I=a("".replace),z=a("".indexOf),F=a("".slice),D=/^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/,P=/a/g,O=/a/g,R=new j(P)!==P,_=h.MISSED_STICKY,M=h.UNSUPPORTED_Y,N=o&&(!R||_||w||A||g((function(){return O[k]=!1,j(P)!=P||j(O)==O||"/a/i"!=j(P,"i")})));if(i("RegExp",N)){for(var L=function(n,e){var t,o,r,a,i,c,h=u(B,this),f=d(n),v=void 0===e,g=[],E=n;if(!h&&f&&v&&n.constructor===L)return n;if((f||u(B,n))&&(n=n.source,v&&(e=m(E))),n=void 0===n?"":p(n),e=void 0===e?"":p(e),E=n,w&&"dotAll"in P&&(o=!!e&&z(e,"s")>-1)&&(e=I(e,/s/g,"")),t=e,_&&"sticky"in P&&(r=!!e&&z(e,"y")>-1)&&M&&(e=I(e,/y/g,"")),A&&(n=(a=function(n){for(var e,t=n.length,o=0,r="",a=[],i={},s=!1,l=!1,c=0,u="";o<=t;o++){if("\\"===(e=T(n,o)))e+=T(n,++o);else if("]"===e)s=!1;else if(!s)switch(!0){case"["===e:s=!0;break;case"("===e:C(D,F(n,o+1))&&(o+=2,l=!0),r+=e,c++;continue;case">"===e&&l:if(""===u||b(i,u))throw new S("Invalid capture group name");i[u]=!0,a[a.length]=[u,c],l=!1,u="";continue}l?u+=e:r+=e}return[r,a]}(n))[0],g=a[1]),i=s(j(n,e),h?this:B,L),(o||r||g.length)&&(c=x(i),o&&(c.dotAll=!0,c.raw=L(function(n){for(var e,t=n.length,o=0,r="",a=!1;o<=t;o++)"\\"!==(e=T(n,o))?a||"."!==e?("["===e?a=!0:"]"===e&&(a=!1),r+=e):r+="[\\s\\S]":r+=e+T(n,++o);return r}(n),t)),r&&(c.sticky=!0),g.length&&(c.groups=g)),n!==E)try{l(i,"source",""===E?"(?:)":E)}catch(n){}return i},q=c(j),J=0;q.length>J;)f(L,j,q[J++]);B.constructor=L,L.prototype=B,v(r,"RegExp",L,{constructor:!0})}E("RegExp")},function(n,e,t){var o=t(1),r=t(9),a=t(197),i=t(37),s=t(227),l=t(42).get,c=RegExp.prototype,u=o.TypeError;r&&a&&s(c,"dotAll",{configurable:!0,get:function(){if(this!==c){if("RegExp"===i(this))return!!l(this).dotAll;throw u("Incompatible receiver, RegExp required")}}})},function(n,e,t){var o=t(1),r=t(9),a=t(142).MISSED_STICKY,i=t(37),s=t(227),l=t(42).get,c=RegExp.prototype,u=o.TypeError;r&&a&&s(c,"sticky",{configurable:!0,get:function(){if(this!==c){if("RegExp"===i(this))return!!l(this).sticky;throw u("Incompatible receiver, RegExp required")}}})},function(n,e,t){var o=t(4),r=t(30),a=t(12),i=t(140),s=o("".replace),l="["+i+"]",c=RegExp("^"+l+l+"*"),u=RegExp(l+l+"*$"),d=function(n){return function(e){var t=a(r(e));return 1&n&&(t=s(t,c,"")),2&n&&(t=s(t,u,"")),t}};n.exports={start:d(1),end:d(2),trim:d(3)}},function(n,e,t){var o=t(1),r=t(4),a=t(3),i=t(37),s=o.Object,l=r("".split);n.exports=a((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?l(n,""):s(n)}:s},function(n,e,t){var o=t(1),r=t(185),a=t(11),i=t(37),s=t(10)("toStringTag"),l=o.Object,c="Arguments"==i(function(){return arguments}());n.exports=r?i:function(n){var e,t,o;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=l(n),s))?t:c?i(e):"Object"==(o=i(e))&&a(e.callee)?"Arguments":o}},function(n,e,t){var o=t(1),r=t(88),a=t(34),i=t(89),s=o.Array,l=Math.max;n.exports=function(n,e,t){for(var o=a(n),c=r(e,o),u=r(void 0===t?o:t,o),d=s(l(u-c,0)),p=0;c<u;c++,p++)i(d,p,n[c]);return d.length=p,d}},function(n,e,t){var o=t(2),r=t(33),a=t(69),i=t(17),s=t(4),l=t(3),c=t(81),u=t(11),d=t(16),p=t(104),m=t(107),h=t(85),f=r("JSON","stringify"),v=s(/./.exec),g=s("".charAt),b=s("".charCodeAt),x=s("".replace),E=s(1..toString),y=/[\uD800-\uDFFF]/g,w=/^[\uD800-\uDBFF]$/,A=/^[\uDC00-\uDFFF]$/,k=!h||l((function(){var n=r("Symbol")();return"[null]"!=f([n])||"{}"!=f({a:n})||"{}"!=f(Object(n))})),j=l((function(){return'"\\udf06\\ud834"'!==f("\udf06\ud834")||'"\\udead"'!==f("\udead")})),B=function(n,e){var t=m(arguments),o=e;if((d(e)||void 0!==n)&&!p(n))return c(e)||(e=function(n,e){if(u(o)&&(e=i(o,this,n,e)),!p(e))return e}),t[1]=e,a(f,null,t)},S=function(n,e,t){var o=g(t,e-1),r=g(t,e+1);return v(w,n)&&!v(A,r)||v(A,n)&&!v(w,o)?"\\u"+E(b(n,0),16):n};f&&o({target:"JSON",stat:!0,arity:3,forced:k||j},{stringify:function(n,e,t){var o=m(arguments),r=a(k?B:f,null,o);return j&&"string"==typeof r?x(r,y,S):r}})},function(n,e,t){var o=t(25);n.exports=!o((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var o=t(53);n.exports=o("navigator","userAgent")||""},function(n,e,t){var o=t(6).String;n.exports=function(n){try{return o(n)}catch(n){return"Object"}}},function(n,e,t){var o=t(24),r=t(15),a=t(161),i=o(Function.toString);r(a.inspectSource)||(a.inspectSource=function(n){return i(n)}),n.exports=a.inspectSource},function(n,e,t){var o=t(36),r=t(71),a=t(172);n.exports=o?function(n,e,t){return r.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var o=t(221),r=t(104);n.exports=function(n){var e=o(n,"string");return r(e)?e:e+""}},function(n,e,t){var o=t(4),r=0,a=Math.random(),i=o(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++r+a,36)}},function(n,e,t){var o=t(1),r=t(16),a=o.document,i=r(a)&&r(a.createElement);n.exports=function(n){return i?a.createElement(n):{}}},function(n,e,t){var o=t(86),r=t(132),a=o("keys");n.exports=function(n){return a[n]||(a[n]=r(n))}},function(n,e,t){var o=t(3),r=t(11),a=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t==u||t!=c&&(r(e)?o(e):!!e)},s=i.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",u=i.POLYFILL="P";n.exports=i},function(n,e,t){var o=t(396),r=t(13),a=t(270),i=t(18).f;n.exports=function(n){var e=o.Symbol||(o.Symbol={});r(e,n)||i(e,n,{value:a.f(n)})}},function(n,e,t){var o=t(4),r=t(3),a=t(11),i=t(123),s=t(33),l=t(180),c=function(){},u=[],d=s("Reflect","construct"),p=/^\s*(?:class|function)\b/,m=o(p.exec),h=!p.exec(c),f=function(n){if(!a(n))return!1;try{return d(c,u,n),!0}catch(n){return!1}},v=function(n){if(!a(n))return!1;switch(i(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return h||!!m(p,l(n))}catch(n){return!0}};v.sham=!0,n.exports=!d||r((function(){var n;return f(f.call)||!f(Object)||!f((function(){n=!0}))||n}))?v:f},function(n,e,t){var o=t(1),r=t(13),a=t(11),i=t(26),s=t(134),l=t(273),c=s("IE_PROTO"),u=o.Object,d=u.prototype;n.exports=l?u.getPrototypeOf:function(n){var e=i(n);if(r(e,c))return e[c];var t=e.constructor;return a(t)&&e instanceof t?t.prototype:e instanceof u?d:null}},function(n,e,t){var o=t(11),r=t(16),a=t(109);n.exports=function(n,e,t){var i,s;return a&&o(i=e.constructor)&&i!==t&&r(s=i.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){"use strict";var o,r,a=t(17),i=t(4),s=t(12),l=t(283),c=t(142),u=t(86),d=t(50),p=t(42).get,m=t(197),h=t(284),f=u("native-string-replace",String.prototype.replace),v=RegExp.prototype.exec,g=v,b=i("".charAt),x=i("".indexOf),E=i("".replace),y=i("".slice),w=(r=/b*/g,a(v,o=/a/,"a"),a(v,r,"a"),0!==o.lastIndex||0!==r.lastIndex),A=c.BROKEN_CARET,k=void 0!==/()??/.exec("")[1];(w||k||A||m||h)&&(g=function(n){var e,t,o,r,i,c,u,m=this,h=p(m),j=s(n),B=h.raw;if(B)return B.lastIndex=m.lastIndex,e=a(g,B,j),m.lastIndex=B.lastIndex,e;var S=h.groups,C=A&&m.sticky,T=a(l,m),I=m.source,z=0,F=j;if(C&&(T=E(T,"y",""),-1===x(T,"g")&&(T+="g"),F=y(j,m.lastIndex),m.lastIndex>0&&(!m.multiline||m.multiline&&"\n"!==b(j,m.lastIndex-1))&&(I="(?: "+I+")",F=" "+F,z++),t=new RegExp("^(?:"+I+")",T)),k&&(t=new RegExp("^"+I+"$(?!\\s)",T)),w&&(o=m.lastIndex),r=a(v,C?t:m,F),C?r?(r.input=y(r.input,z),r[0]=y(r[0],z),r.index=m.lastIndex,m.lastIndex+=r[0].length):m.lastIndex=0:w&&r&&(m.lastIndex=m.global?r.index+r[0].length:o),k&&r&&r.length>1&&a(f,r[0],t,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(r[i]=void 0)})),r&&S)for(r.groups=c=d(null),i=0;i<S.length;i++)c[(u=S[i])[0]]=r[u[1]];return r}),n.exports=g},function(n,e,t){var o=t(3),r=t(1).RegExp,a=o((function(){var n=r("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),i=a||o((function(){return!r("a","y").sticky})),s=a||o((function(){var n=r("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:s,MISSED_STICKY:i,UNSUPPORTED_Y:a}},function(n,e,t){"use strict";t(20);var o=t(4),r=t(22),a=t(141),i=t(3),s=t(10),l=t(38),c=s("species"),u=RegExp.prototype;n.exports=function(n,e,t,d){var p=s(n),m=!i((function(){var e={};return e[p]=function(){return 7},7!=""[n](e)})),h=m&&!i((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[c]=function(){return t},t.flags="",t[p]=/./[p]),t.exec=function(){return e=!0,null},t[p](""),!e}));if(!m||!h||t){var f=o(/./[p]),v=e(p,""[n],(function(n,e,t,r,i){var s=o(n),l=e.exec;return l===a||l===u.exec?m&&!i?{done:!0,value:f(e,t,r)}:{done:!0,value:s(t,e,r)}:{done:!1}}));r(String.prototype,n,v[0]),r(u,p,v[1])}d&&l(u[p],"sham",!0)}},function(n,e,t){var o=t(1),r=t(17),a=t(14),i=t(11),s=t(37),l=t(141),c=o.TypeError;n.exports=function(n,e){var t=n.exec;if(i(t)){var o=r(t,n,e);return null!==o&&a(o),o}if("RegExp"===s(n))return r(l,n,e);throw c("RegExp#exec called on incompatible receiver")}},function(n,e,t){var o=t(439),r=t(440),a=t(441),i=t(442),s=t(443);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=r,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var o=t(300);n.exports=function(n,e){for(var t=n.length;t--;)if(o(n[t][0],e))return t;return-1}},function(n,e,t){var o=t(75)(Object,"create");n.exports=o},function(n,e,t){t(76);var o=t(461);n.exports=function(n,e){var t=n.__data__;return o(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var o=t(209);n.exports=function(n){if("string"==typeof n||o(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return r}));t(40),t(7),t(61),t(296),t(27),t(20),t(46);var o=t(113);function r(n,e){if(n){if("string"==typeof n)return Object(o.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(o.a)(n,e):void 0}}},function(n,e,t){var o=t(23).default;t(214),t(19),t(41),t(7),t(47),t(31),t(77),t(20),t(45),t(46),t(40);var r=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,s=/^0o[0-7]+$/i,l=parseInt,c="object"==("undefined"==typeof global?"undefined":o(global))&&global&&global.Object===Object&&global,u="object"==("undefined"==typeof self?"undefined":o(self))&&self&&self.Object===Object&&self,d=c||u||Function("return this")(),p=Object.prototype.toString,m=Math.max,h=Math.min,f=function(){return d.Date.now()};function v(n){var e=o(n);return!!n&&("object"==e||"function"==e)}function g(n){return"symbol"==o(n)||function(n){return!!n&&"object"==o(n)}(n)&&"[object Symbol]"==p.call(n)}function b(n){if("number"==typeof n)return n;if(g(n))return NaN;if(v(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=v(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(r,"");var t=i.test(n);return t||s.test(n)?l(n.slice(2),t?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var o,r,a,i,s,l,c=0,u=!1,d=!1,p=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function g(e){var t=o,a=r;return o=r=void 0,c=e,i=n.apply(a,t)}function x(n){return c=n,s=setTimeout(y,e),u?g(n):i}function E(n){var t=n-l;return void 0===l||t>=e||t<0||d&&n-c>=a}function y(){var n=f();if(E(n))return w(n);s=setTimeout(y,function(n){var t=e-(n-l);return d?h(t,a-(n-c)):t}(n))}function w(n){return s=void 0,p&&o?g(n):(o=r=void 0,i)}function A(){var n=f(),t=E(n);if(o=arguments,r=this,l=n,t){if(void 0===s)return x(l);if(d)return s=setTimeout(y,e),g(l)}return void 0===s&&(s=setTimeout(y,e)),i}return e=b(e)||0,v(t)&&(u=!!t.leading,a=(d="maxWait"in t)?m(b(t.maxWait)||0,e):a,p="trailing"in t?!!t.trailing:p),A.cancel=function(){void 0!==s&&clearTimeout(s),c=0,o=l=r=s=void 0},A.flush=function(){return void 0===s?i:w(f())},A}},function(n,e,t){var o,r;t(23).default;t(77),t(20),t(45),t(40),t(114),void 0===(r="function"==typeof(o=function(){var n,e,t={version:"0.2.0"},o=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(o[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,o.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(o.barSelector),u=o.speed,d=o.easing;return l.offsetWidth,i((function(e){""===o.positionUsing&&(o.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var r;return(r="translate3d"===o.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===o.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,r}(n,u,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){return t.status||t.set(0),o.trickle&&function n(){setTimeout((function(){t.status&&(t.trickle(),n())}),o.trickleSpeed)}(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*o.trickleRate)},n=0,e=0,t.promise=function(o){return o&&"resolved"!==o.state()?(0===e&&t.start(),n++,e++,o.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=o.template;var r,i=e.querySelector(o.barSelector),l=n?"-100":a(t.status||0),u=document.querySelector(o.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),o.showSpinner||(r=e.querySelector(o.spinnerSelector))&&p(r),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(o.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var o,r=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((o=n[r]+a)in t)return o;return e}(t))}function o(n,e,o){e=t(e),n.style[e]=o}return function(n,e){var t,r,a=arguments;if(2==a.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&o(n,t,r);else o(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),o=t+e;l(t,e)||(n.className=o.substring(1))}function u(n,e){var t,o=d(n);l(n,e)&&(t=o.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?o.call(e,t,e,n):o)||(n.exports=r)},function(n,e,t){var o=t(10),r=t(50),a=t(18),i=o("unscopables"),s=Array.prototype;null==s[i]&&a.f(s,i,{configurable:!0,value:r(null)}),n.exports=function(n){s[i][n]=!0}},function(n,e,t){var o=t(398);n.exports=function(n,e){return new(o(n))(0===e?0:e)}},function(n,e,t){"use strict";var o=t(2),r=t(1),a=t(88),i=t(39),s=t(34),l=t(26),c=t(154),u=t(89),d=t(110)("splice"),p=r.TypeError,m=Math.max,h=Math.min;o({target:"Array",proto:!0,forced:!d},{splice:function(n,e){var t,o,r,d,f,v,g=l(this),b=s(g),x=a(n,b),E=arguments.length;if(0===E?t=o=0:1===E?(t=0,o=b-x):(t=E-2,o=h(m(i(e),0),b-x)),b+t-o>9007199254740991)throw p("Maximum allowed length exceeded");for(r=c(g,o),d=0;d<o;d++)(f=x+d)in g&&u(r,d,g[f]);if(r.length=o,t<o){for(d=x;d<b-o;d++)v=d+t,(f=d+o)in g?g[v]=g[f]:delete g[v];for(d=b;d>b-o+t;d--)delete g[d-1]}else if(t>o)for(d=b-o;d>x;d--)v=d+t-1,(f=d+o-1)in g?g[v]=g[f]:delete g[v];for(d=0;d<t;d++)g[d+x]=arguments[d+2];return g.length=b-o+t,r}})},function(n,e,t){var o=t(1),r=t(55),a=o.TypeError;n.exports=function(n,e){if(r(e,n))return n;throw a("Incorrect invocation")}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var o=t(268),r=t(184);n.exports=Object.keys||function(n){return o(n,r)}},function(n,e,t){var o=t(123),r=t(73),a=t(108),i=t(10)("iterator");n.exports=function(n){if(null!=n)return r(n,i)||r(n,"@@iterator")||a[o(n)]}},function(n,e,t){var o=t(24),r=o({}.toString),a=o("".slice);n.exports=function(n){return a(r(n),8,-1)}},function(n,e,t){var o=t(6),r=t(162),a=o["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=a},function(n,e,t){var o=t(6),r=Object.defineProperty;n.exports=function(n,e){try{r(o,n,{value:e,configurable:!0,writable:!0})}catch(t){o[n]=e}return e}},function(n,e,t){var o=t(6),r=t(234),a=o.Object;n.exports=function(n){return a(r(n))}},function(n,e,t){var o,r=t(44),a=t(350),i=t(169),s=t(168),l=t(248),c=t(165),u=t(170),d=u("IE_PROTO"),p=function(){},m=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e},f=function(){try{o=new ActiveXObject("htmlfile")}catch(n){}var n,e;f="undefined"!=typeof document?document.domain&&o?h(o):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F):h(o);for(var t=i.length;t--;)delete f.prototype[i[t]];return f()};s[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=r(n),t=new p,p.prototype=null,t[d]=n):t=f(),void 0===e?t:a.f(t,e)}},function(n,e,t){var o=t(6),r=t(70),a=o.document,i=r(a)&&r(a.createElement);n.exports=function(n){return i?a.createElement(n):{}}},function(n,e,t){var o=t(24);n.exports=o({}.isPrototypeOf)},function(n,e,t){var o=t(72);n.exports=function(n,e){var t=n[e];return null==t?void 0:o(t)}},function(n,e){n.exports={}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var o=t(235),r=t(236),a=o("keys");n.exports=function(n){return a[n]||(a[n]=r(n))}},function(n,e,t){var o,r,a,i=t(356),s=t(6),l=t(24),c=t(70),u=t(130),d=t(43),p=t(161),m=t(170),h=t(168),f=s.TypeError,v=s.WeakMap;if(i||p.state){var g=p.state||(p.state=new v),b=l(g.get),x=l(g.has),E=l(g.set);o=function(n,e){if(x(g,n))throw new f("Object already initialized");return e.facade=n,E(g,n,e),e},r=function(n){return b(g,n)||{}},a=function(n){return x(g,n)}}else{var y=m("state");h[y]=!0,o=function(n,e){if(d(n,y))throw new f("Object already initialized");return e.facade=n,u(n,y,e),e},r=function(n){return d(n,y)?n[y]:{}},a=function(n){return d(n,y)}}n.exports={set:o,get:r,has:a,enforce:function(n){return a(n)?r(n):o(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=r(e)).type!==n)throw f("Incompatible receiver, "+n+" required");return t}}}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var o=t(36),r=t(32),a=t(249),i=t(172),s=t(99),l=t(242),c=t(43),u=t(241),d=Object.getOwnPropertyDescriptor;e.f=o?d:function(n,e){if(n=s(n),e=l(e),u)try{return d(n,e)}catch(n){}if(c(n,e))return i(!r(a.f,n,e),n[e])}},function(n,e,t){var o=t(71).f,r=t(43),a=t(28)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!r(n,a)&&o(n,a,{configurable:!0,value:e})}},function(n,e,t){var o=t(160),r=t(6);n.exports="process"==o(r.process)},function(n,e,t){var o=t(24),r=t(72),a=t(126),i=o(o.bind);n.exports=function(n,e){return r(n),void 0===e?n:a?i(n,e):function(){return n.apply(e,arguments)}}},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e,t){var o=t(1),r=t(179),a=o["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=a},function(n,e,t){var o=t(1),r=Object.defineProperty;n.exports=function(n,e){try{r(o,n,{value:e,configurable:!0,writable:!0})}catch(t){o[n]=e}return e}},function(n,e,t){var o=t(4),r=t(11),a=t(178),i=o(Function.toString);r(a.inspectSource)||(a.inspectSource=function(n){return i(n)}),n.exports=a.inspectSource},function(n,e,t){var o=t(13),r=t(182),a=t(67),i=t(18);n.exports=function(n,e,t){for(var s=r(e),l=i.f,c=a.f,u=0;u<s.length;u++){var d=s[u];o(n,d)||t&&o(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var o=t(33),r=t(4),a=t(74),i=t(157),s=t(14),l=r([].concat);n.exports=o("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e,t){var o=t(35),r=t(88),a=t(34),i=function(n){return function(e,t,i){var s,l=o(e),c=a(l),u=r(i,c);if(n&&t!=t){for(;c>u;)if((s=l[u++])!=s)return!0}else for(;c>u;u++)if((n||u in l)&&l[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var o={};o[t(10)("toStringTag")]="z",n.exports="[object z]"===String(o)},function(n,e,t){var o=t(9),r=t(266),a=t(18),i=t(14),s=t(35),l=t(158);e.f=o&&!r?Object.defineProperties:function(n,e){i(n);for(var t,o=s(e),r=l(e),c=r.length,u=0;c>u;)a.f(n,t=r[u++],o[t]);return n}},function(n,e,t){var o=t(37),r=t(35),a=t(74).f,i=t(124),s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return s&&"Window"==o(n)?function(n){try{return a(n)}catch(n){return i(s)}}(n):a(r(n))}},function(n,e,t){"use strict";var o=t(2),r=t(17),a=t(65),i=t(87),s=t(11),l=t(332),c=t(138),u=t(109),d=t(48),p=t(38),m=t(22),h=t(10),f=t(108),v=t(272),g=i.PROPER,b=i.CONFIGURABLE,x=v.IteratorPrototype,E=v.BUGGY_SAFARI_ITERATORS,y=h("iterator"),w=function(){return this};n.exports=function(n,e,t,i,h,v,A){l(t,e,i);var k,j,B,S=function(n){if(n===h&&F)return F;if(!E&&n in I)return I[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},C=e+" Iterator",T=!1,I=n.prototype,z=I[y]||I["@@iterator"]||h&&I[h],F=!E&&z||S(h),D="Array"==e&&I.entries||z;if(D&&(k=c(D.call(new n)))!==Object.prototype&&k.next&&(a||c(k)===x||(u?u(k,x):s(k[y])||m(k,y,w)),d(k,C,!0,!0),a&&(f[C]=w)),g&&"values"==h&&z&&"values"!==z.name&&(!a&&b?p(I,"name","values"):(T=!0,F=function(){return r(z,this)})),h)if(j={values:S("values"),keys:v?F:S("keys"),entries:S("entries")},A)for(B in j)(E||T||!(B in I))&&m(I,B,j[B]);else o({target:e,proto:!0,forced:E||T},j);return a&&!A||I[y]===F||m(I,y,F,{name:h}),f[e]=F,j}},function(n,e,t){var o=t(33),r=t(136),a=t(48);r("toStringTag"),a(o("Symbol"),"Symbol")},function(n,e,t){var o=t(1);t(48)(o.JSON,"JSON",!0)},function(n,e,t){t(48)(Math,"Math",!0)},function(n,e,t){var o=t(2),r=t(3),a=t(26),i=t(138),s=t(273);o({target:"Object",stat:!0,forced:r((function(){i(1)})),sham:!s},{getPrototypeOf:function(n){return i(a(n))}})},function(n,e,t){t(2)({target:"Object",stat:!0},{setPrototypeOf:t(109)})},function(n,e,t){var o=t(16),r=t(37),a=t(10)("match");n.exports=function(n){var e;return o(n)&&(void 0!==(e=n[a])?!!e:"RegExp"==r(n))}},function(n,e,t){var o=t(2),r=t(279),a=t(3),i=t(16),s=t(196).onFreeze,l=Object.freeze;o({target:"Object",stat:!0,forced:a((function(){l(1)})),sham:!r},{freeze:function(n){return l&&i(n)?l(s(n)):n}})},function(n,e,t){var o=t(2),r=t(4),a=t(106),i=t(16),s=t(13),l=t(18).f,c=t(74),u=t(187),d=t(280),p=t(132),m=t(279),h=!1,f=p("meta"),v=0,g=function(n){l(n,f,{value:{objectID:"O"+v++,weakData:{}}})},b=n.exports={enable:function(){b.enable=function(){},h=!0;var n=c.f,e=r([].splice),t={};t[f]=1,n(t).length&&(c.f=function(t){for(var o=n(t),r=0,a=o.length;r<a;r++)if(o[r]===f){e(o,r,1);break}return o},o({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:u.f}))},fastKey:function(n,e){if(!i(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!s(n,f)){if(!d(n))return"F";if(!e)return"E";g(n)}return n[f].objectID},getWeakData:function(n,e){if(!s(n,f)){if(!d(n))return!0;if(!e)return!1;g(n)}return n[f].weakData},onFreeze:function(n){return m&&h&&d(n)&&!s(n,f)&&g(n),n}};a[f]=!0},function(n,e,t){var o=t(3),r=t(1).RegExp;n.exports=o((function(){var n=r(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){"use strict";var o=t(222).charAt;n.exports=function(n,e,t){return e+(t?o(n,e).length:1)}},function(n,e,t){"use strict";var o=t(33),r=t(18),a=t(10),i=t(9),s=a("species");n.exports=function(n){var e=o(n),t=r.f;i&&e&&!e[s]&&t(e,s,{configurable:!0,get:function(){return this}})}},function(n,e,t){var o=t(2),r=t(1),a=t(48);o({global:!0},{Reflect:{}}),a(r.Reflect,"Reflect",!0)},function(n,e,t){var o=t(2),r=t(1),a=t(4),i=r.Date,s=a(i.prototype.getTime);o({target:"Date",stat:!0},{now:function(){return s(new i)}})},function(n,e,t){var o=t(433),r=t(82),a=Object.prototype,i=a.hasOwnProperty,s=a.propertyIsEnumerable,l=o(function(){return arguments}())?o:function(n){return r(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var o=t(75)(t(56),"Map");n.exports=o},function(n,e,t){var o=t(23).default;n.exports=function(n){var e=o(n);return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var o=t(453),r=t(460),a=t(462),i=t(463),s=t(464);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=r,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){t(58),t(7),t(59),n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var o=t(23).default;t(20),t(46);var r=t(51),a=t(209),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=o(n);return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(s.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var o=t(23).default,r=t(98),a=t(82);n.exports=function(n){return"symbol"==o(n)||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.d(e,"a",(function(){return r}));t(95);t(49),t(62),t(7),t(90),t(27),t(21);var o=t(150);t(31),t(19);function r(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var o,r,a=[],i=!0,s=!1;try{for(t=t.call(n);!(i=(o=t.next()).done)&&(a.push(o.value),!e||a.length!==e);i=!0);}catch(n){s=!0,r=n}finally{try{i||null==t.return||t.return()}finally{if(s)throw r}}return a}}(n,e)||Object(o.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";var o=t(69),r=t(17),a=t(4),i=t(143),s=t(194),l=t(14),c=t(30),u=t(285),d=t(198),p=t(60),m=t(12),h=t(73),f=t(124),v=t(144),g=t(141),b=t(142),x=t(3),E=b.UNSUPPORTED_Y,y=Math.min,w=[].push,A=a(/./.exec),k=a(w),j=a("".slice);i("split",(function(n,e,t){var a;return a="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var a=m(c(this)),i=void 0===t?4294967295:t>>>0;if(0===i)return[];if(void 0===n)return[a];if(!s(n))return r(e,a,n,i);for(var l,u,d,p=[],h=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),v=0,b=new RegExp(n.source,h+"g");(l=r(g,b,a))&&!((u=b.lastIndex)>v&&(k(p,j(a,v,l.index)),l.length>1&&l.index<a.length&&o(w,p,f(l,1)),d=l[0].length,v=u,p.length>=i));)b.lastIndex===l.index&&b.lastIndex++;return v===a.length?!d&&A(b,"")||k(p,""):k(p,j(a,v)),p.length>i?f(p,0,i):p}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:r(e,this,n,t)}:e,[function(e,t){var o=c(this),i=null==e?void 0:h(e,n);return i?r(i,e,o,t):r(a,m(o),e,t)},function(n,o){var r=l(this),i=m(n),s=t(a,r,i,o,a!==e);if(s.done)return s.value;var c=u(r,RegExp),h=r.unicode,f=(r.ignoreCase?"i":"")+(r.multiline?"m":"")+(r.unicode?"u":"")+(E?"g":"y"),g=new c(E?"^(?:"+r.source+")":r,f),b=void 0===o?4294967295:o>>>0;if(0===b)return[];if(0===i.length)return null===v(g,i)?[i]:[];for(var x=0,w=0,A=[];w<i.length;){g.lastIndex=E?0:w;var B,S=v(g,E?j(i,w):i);if(null===S||(B=y(p(g.lastIndex+(E?w:0)),i.length))===x)w=d(i,w,h);else{if(k(A,j(i,x,w)),A.length===b)return A;for(var C=1;C<=S.length-1;C++)if(k(A,S[C]),A.length===b)return A;w=x=B}}return k(A,j(i,x)),A}]}),!!x((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),E)},function(n,e,t){"use strict";var o=t(17),r=t(143),a=t(14),i=t(60),s=t(12),l=t(30),c=t(73),u=t(198),d=t(144);r("match",(function(n,e,t){return[function(e){var t=l(this),r=null==e?void 0:c(e,n);return r?o(r,e,t):new RegExp(e)[n](s(t))},function(n){var o=a(this),r=s(n),l=t(e,o,r);if(l.done)return l.value;if(!o.global)return d(o,r);var c=o.unicode;o.lastIndex=0;for(var p,m=[],h=0;null!==(p=d(o,r));){var f=s(p[0]);m[h]=f,""===f&&(o.lastIndex=u(r,i(o.lastIndex),c)),h++}return 0===h?null:m}]}))},function(n,e,t){var o=t(2),r=t(429);o({global:!0,forced:parseInt!=r},{parseInt:r})},function(n,e,t){var o=t(2),r=t(287);o({target:"Function",proto:!0,forced:Function.bind!==r},{bind:r})},function(n,e,t){"use strict";var o=t(2),r=t(68).every;o({target:"Array",proto:!0,forced:!t(66)("every")},{every:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var o=t(2),r=t(4),a=t(80),i=t(26),s=t(34),l=t(12),c=t(3),u=t(339),d=t(66),p=t(417),m=t(418),h=t(96),f=t(419),v=[],g=r(v.sort),b=r(v.push),x=c((function(){v.sort(void 0)})),E=c((function(){v.sort(null)})),y=d("sort"),w=!c((function(){if(h)return h<70;if(!(p&&p>3)){if(m)return!0;if(f)return f<603;var n,e,t,o,r="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(o=0;o<47;o++)v.push({k:e+o,v:t})}for(v.sort((function(n,e){return e.v-n.v})),o=0;o<v.length;o++)e=v[o].k.charAt(0),r.charAt(r.length-1)!==e&&(r+=e);return"DGBEFHACIJK"!==r}}));o({target:"Array",proto:!0,forced:x||!E||!y||!w},{sort:function(n){void 0!==n&&a(n);var e=i(this);if(w)return void 0===n?g(e):g(e,n);var t,o,r=[],c=s(e);for(o=0;o<c;o++)o in e&&b(r,e[o]);for(u(r,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:l(e)>l(t)?1:-1}}(n)),t=r.length,o=0;o<t;)e[o]=r[o++];for(;o<c;)delete e[o++];return e}})},function(n,e,t){var o=t(1).TypeError;n.exports=function(n,e){if(n<e)throw o("Not enough arguments");return n}},function(n,e,t){"use strict";var o=t(2),r=t(121).trim;o({target:"String",proto:!0,forced:t(329)("trim")},{trim:function(){return r(this)}})},function(n,e,t){"use strict";var o={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,a=r&&!o.call({1:2},1);e.f=a?function(n){var e=r(this,n);return!!e&&e.enumerable}:o},function(n,e,t){var o=t(1),r=t(17),a=t(16),i=t(104),s=t(73),l=t(394),c=t(10),u=o.TypeError,d=c("toPrimitive");n.exports=function(n,e){if(!a(n)||i(n))return n;var t,o=s(n,d);if(o){if(void 0===e&&(e="default"),t=r(o,n,e),!a(t)||i(t))return t;throw u("Can't convert object to primitive value")}return void 0===e&&(e="number"),l(n,e)}},function(n,e,t){var o=t(4),r=t(39),a=t(12),i=t(30),s=o("".charAt),l=o("".charCodeAt),c=o("".slice),u=function(n){return function(e,t){var o,u,d=a(i(e)),p=r(t),m=d.length;return p<0||p>=m?n?"":void 0:(o=l(d,p))<55296||o>56319||p+1===m||(u=l(d,p+1))<56320||u>57343?n?s(d,p):o:n?c(d,p,p+2):u-56320+(o-55296<<10)+65536}};n.exports={codeAt:u(!1),charAt:u(!0)}},function(n,e,t){"use strict";var o=t(2),r=t(4),a=t(81),i=r([].reverse),s=[1,2];o({target:"Array",proto:!0,forced:String(s)===String(s.reverse())},{reverse:function(){return a(this)&&(this.length=this.length),i(this)}})},function(n,e,t){var o=t(37),r=t(1);n.exports="process"==o(r.process)},function(n,e,t){var o=t(1),r=t(194),a=o.TypeError;n.exports=function(n){if(r(n))throw a("The method doesn't accept regular expressions");return n}},function(n,e,t){var o=t(10)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[o]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){var o=t(267),r=t(18);n.exports=function(n,e,t){return t.get&&o(t.get,e,{getter:!0}),t.set&&o(t.set,e,{setter:!0}),r.f(n,e,t)}},function(n,e,t){var o=t(1),r=t(17),a=t(80),i=t(14),s=t(105),l=t(159),c=o.TypeError;n.exports=function(n,e){var t=arguments.length<2?l(n):e;if(a(t))return i(r(t,n));throw c(s(n)+" is not iterable")}},function(n,e,t){var o=t(22);n.exports=function(n,e,t){for(var r in e)o(n,r,e[r],t);return n}},function(n,e,t){var o=t(2),r=t(9),a=t(186).f;o({target:"Object",stat:!0,forced:Object.defineProperties!==a,sham:!r},{defineProperties:a})},function(n,e,t){t(64),n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){"use strict";var o=t(1),r=t(39),a=t(12),i=t(30),s=o.RangeError;n.exports=function(n){var e=a(i(this)),t="",o=r(n);if(o<0||o==1/0)throw s("Wrong number of repetitions");for(;o>0;(o>>>=1)&&(e+=e))1&o&&(t+=e);return t}},function(n,e,t){var o=t(6),r=t(24),a=t(25),i=t(160),s=o.Object,l=r("".split);n.exports=a((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?l(n,""):s(n)}:s},function(n,e,t){var o=t(6).TypeError;n.exports=function(n){if(null==n)throw o("Can't call method on "+n);return n}},function(n,e,t){var o=t(52),r=t(161);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.22.5",mode:o?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.22.5/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){var o=t(24),r=0,a=Math.random(),i=o(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++r+a,36)}},function(n,e,t){var o=t(238),r=t(25);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&o&&o<41}))},function(n,e,t){var o,r,a=t(6),i=t(127),s=a.process,l=a.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(r=(o=u.split("."))[0]>0&&o[0]<4?1:+(o[0]+o[1])),!r&&i&&(!(o=i.match(/Edge\/(\d+)/))||o[1]>=74)&&(o=i.match(/Chrome\/(\d+)/))&&(r=+o[1]),n.exports=r},function(n,e,t){var o=t(237);n.exports=o&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var o=t(36),r=t(25);n.exports=o&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var o=t(36),r=t(25),a=t(165);n.exports=!o&&!r((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var o=t(351),r=t(243);n.exports=function(n){var e=o(n,"string");return r(e)?e:e+""}},function(n,e,t){var o=t(6),r=t(53),a=t(15),i=t(166),s=t(239),l=o.Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return a(e)&&i(e.prototype,l(n))}},function(n,e,t){var o=t(245),r=t(169);n.exports=Object.keys||function(n){return o(n,r)}},function(n,e,t){var o=t(24),r=t(43),a=t(99),i=t(353).indexOf,s=t(168),l=o([].push);n.exports=function(n,e){var t,o=a(n),c=0,u=[];for(t in o)!r(s,t)&&r(o,t)&&l(u,t);for(;e.length>c;)r(o,t=e[c++])&&(~i(u,t)||l(u,t));return u}},function(n,e){var t=Math.ceil,o=Math.floor;n.exports=function(n){var e=+n;return e!=e||0===e?0:(e>0?o:t)(e)}},function(n,e,t){var o=t(355);n.exports=function(n){return o(n.length)}},function(n,e,t){var o=t(53);n.exports=o("document","documentElement")},function(n,e,t){"use strict";var o={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,a=r&&!o.call({1:2},1);e.f=a?function(n){var e=r(this,n);return!!e&&e.enumerable}:o},function(n,e,t){var o=t(36),r=t(43),a=Function.prototype,i=o&&Object.getOwnPropertyDescriptor,s=r(a,"name"),l=s&&"something"===function(){}.name,c=s&&(!o||o&&i(a,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var o=t(25),r=t(15),a=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t==u||t!=c&&(r(e)?o(e):!!e)},s=i.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",u=i.POLYFILL="P";n.exports=i},function(n,e,t){"use strict";var o,r,a,i=t(25),s=t(15),l=t(164),c=t(254),u=t(83),d=t(28),p=t(52),m=d("iterator"),h=!1;[].keys&&("next"in(a=[].keys())?(r=c(c(a)))!==Object.prototype&&(o=r):h=!0),null==o||i((function(){var n={};return o[m].call(n)!==n}))?o={}:p&&(o=l(o)),s(o[m])||u(o,m,(function(){return this})),n.exports={IteratorPrototype:o,BUGGY_SAFARI_ITERATORS:h}},function(n,e,t){var o=t(6),r=t(43),a=t(15),i=t(163),s=t(170),l=t(363),c=s("IE_PROTO"),u=o.Object,d=u.prototype;n.exports=l?u.getPrototypeOf:function(n){var e=i(n);if(r(e,c))return e[c];var t=e.constructor;return a(t)&&e instanceof t?t.prototype:e instanceof u?d:null}},function(n,e,t){var o=t(24),r=t(44),a=t(364);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=o(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,o){return r(t),a(o),e?n(t,o):t.__proto__=o,t}}():void 0)},function(n,e,t){var o=t(44),r=t(369),a=t(28)("species");n.exports=function(n,e){var t,i=o(n).constructor;return void 0===i||null==(t=o(i)[a])?e:r(t)}},function(n,e,t){var o=t(6),r=t(371),a=t(15),i=t(160),s=t(28)("toStringTag"),l=o.Object,c="Arguments"==i(function(){return arguments}());n.exports=r?i:function(n){var e,t,o;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=l(n),s))?t:c?i(e):"Object"==(o=i(e))&&a(e.callee)?"Arguments":o}},function(n,e,t){var o,r,a,i,s=t(6),l=t(372),c=t(176),u=t(15),d=t(43),p=t(25),m=t(248),h=t(373),f=t(165),v=t(374),g=t(259),b=t(175),x=s.setImmediate,E=s.clearImmediate,y=s.process,w=s.Dispatch,A=s.Function,k=s.MessageChannel,j=s.String,B=0,S={};try{o=s.location}catch(n){}var C=function(n){if(d(S,n)){var e=S[n];delete S[n],e()}},T=function(n){return function(){C(n)}},I=function(n){C(n.data)},z=function(n){s.postMessage(j(n),o.protocol+"//"+o.host)};x&&E||(x=function(n){v(arguments.length,1);var e=u(n)?n:A(n),t=h(arguments,1);return S[++B]=function(){l(e,void 0,t)},r(B),B},E=function(n){delete S[n]},b?r=function(n){y.nextTick(T(n))}:w&&w.now?r=function(n){w.now(T(n))}:k&&!g?(i=(a=new k).port2,a.port1.onmessage=I,r=c(i.postMessage,i)):s.addEventListener&&u(s.postMessage)&&!s.importScripts&&o&&"file:"!==o.protocol&&!p(z)?(r=z,s.addEventListener("message",I,!1)):r="onreadystatechange"in f("script")?function(n){m.appendChild(f("script")).onreadystatechange=function(){m.removeChild(this),C(n)}}:function(n){setTimeout(T(n),0)}),n.exports={set:x,clear:E}},function(n,e,t){var o=t(127);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(o)},function(n,e,t){var o=t(6),r=t(176),a=t(32),i=t(44),s=t(128),l=t(382),c=t(247),u=t(166),d=t(383),p=t(261),m=t(384),h=o.TypeError,f=function(n,e){this.stopped=n,this.result=e},v=f.prototype;n.exports=function(n,e,t){var o,g,b,x,E,y,w,A=t&&t.that,k=!(!t||!t.AS_ENTRIES),j=!(!t||!t.IS_ITERATOR),B=!(!t||!t.INTERRUPTED),S=r(e,A),C=function(n){return o&&m(o,"normal",n),new f(!0,n)},T=function(n){return k?(i(n),B?S(n[0],n[1],C):S(n[0],n[1])):B?S(n,C):S(n)};if(j)o=n;else{if(!(g=p(n)))throw h(s(n)+" is not iterable");if(l(g)){for(b=0,x=c(n);x>b;b++)if((E=T(n[b]))&&u(v,E))return E;return new f(!1)}o=d(n,g)}for(y=o.next;!(w=a(y,o)).done;){try{E=T(w.value)}catch(n){m(o,"throw",n)}if("object"==typeof E&&E&&u(v,E))return E}return new f(!1)}},function(n,e,t){var o=t(257),r=t(167),a=t(100),i=t(28)("iterator");n.exports=function(n){if(null!=n)return r(n,i)||r(n,"@@iterator")||a[o(n)]}},function(n,e,t){var o=t(84),r=t(385),a=t(101).CONSTRUCTOR;n.exports=a||!r((function(n){o.all(n).then(void 0,(function(){}))}))},function(n,e,t){var o=t(44),r=t(70),a=t(102);n.exports=function(n,e){if(o(n),r(e)&&e.constructor===n)return e;var t=a.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){var o=t(85);n.exports=o&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var o=t(9),r=t(3),a=t(133);n.exports=!o&&!r((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var o=t(9),r=t(3);n.exports=o&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var o=t(3),r=t(11),a=t(13),i=t(9),s=t(87).CONFIGURABLE,l=t(180),c=t(42),u=c.enforce,d=c.get,p=Object.defineProperty,m=i&&!o((function(){return 8!==p((function(){}),"length",{value:8}).length})),h=String(String).split("String"),f=n.exports=function(n,e,t){if("Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!a(n,"name")||s&&n.name!==e)&&p(n,"name",{value:e,configurable:!0}),m&&t&&a(t,"arity")&&n.length!==t.arity&&p(n,"length",{value:t.arity}),t&&a(t,"constructor")&&t.constructor){if(i)try{p(n,"prototype",{writable:!1})}catch(n){}}else n.prototype=void 0;var o=u(n);return a(o,"source")||(o.source=h.join("string"==typeof e?e:"")),n};Function.prototype.toString=f((function(){return r(this)&&d(this).source||l(this)}),"toString")},function(n,e,t){var o=t(4),r=t(13),a=t(35),i=t(183).indexOf,s=t(106),l=o([].push);n.exports=function(n,e){var t,o=a(n),c=0,u=[];for(t in o)!r(s,t)&&r(o,t)&&l(u,t);for(;e.length>c;)r(o,t=e[c++])&&(~i(u,t)||l(u,t));return u}},function(n,e,t){var o=t(33);n.exports=o("document","documentElement")},function(n,e,t){var o=t(10);e.f=o},function(n,e,t){var o=t(85);n.exports=o&&!!Symbol.for&&!!Symbol.keyFor},function(n,e,t){"use strict";var o,r,a,i=t(3),s=t(11),l=t(50),c=t(138),u=t(22),d=t(10),p=t(65),m=d("iterator"),h=!1;[].keys&&("next"in(a=[].keys())?(r=c(c(a)))!==Object.prototype&&(o=r):h=!0),null==o||i((function(){var n={};return o[m].call(n)!==n}))?o={}:p&&(o=l(o)),s(o[m])||u(o,m,(function(){return this})),n.exports={IteratorPrototype:o,BUGGY_SAFARI_ITERATORS:h}},function(n,e,t){var o=t(3);n.exports=!o((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var o=t(133)("span").classList,r=o&&o.constructor&&o.constructor.prototype;n.exports=r===Object.prototype?void 0:r},function(n,e,t){var o=t(18).f;n.exports=function(n,e,t){t in n||o(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var o=t(12);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:o(n)}},function(n,e,t){"use strict";var o=t(68).forEach,r=t(66)("forEach");n.exports=r?[].forEach:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var o=t(3);n.exports=!o((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var o=t(3),r=t(16),a=t(37),i=t(281),s=Object.isExtensible,l=o((function(){s(1)}));n.exports=l||i?function(n){return!!r(n)&&((!i||"ArrayBuffer"!=a(n))&&(!s||s(n)))}:s},function(n,e,t){var o=t(3);n.exports=o((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,e,t){var o=t(17),r=t(13),a=t(55),i=t(283),s=RegExp.prototype;n.exports=function(n){var e=n.flags;return void 0!==e||"flags"in s||r(n,"flags")||!a(s,n)?e:o(i,n)}},function(n,e,t){"use strict";var o=t(14);n.exports=function(){var n=o(this),e="";return n.hasIndices&&(e+="d"),n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var o=t(3),r=t(1).RegExp;n.exports=o((function(){var n=r("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e,t){var o=t(14),r=t(286),a=t(10)("species");n.exports=function(n,e){var t,i=o(n).constructor;return void 0===i||null==(t=o(i)[a])?e:r(t)}},function(n,e,t){var o=t(1),r=t(137),a=t(105),i=o.TypeError;n.exports=function(n){if(r(n))return n;throw i(a(n)+" is not a constructor")}},function(n,e,t){"use strict";var o=t(1),r=t(4),a=t(80),i=t(16),s=t(13),l=t(107),c=t(103),u=o.Function,d=r([].concat),p=r([].join),m={},h=function(n,e,t){if(!s(m,e)){for(var o=[],r=0;r<e;r++)o[r]="a["+r+"]";m[e]=u("C,a","return new C("+p(o,",")+")")}return m[e](n,t)};n.exports=c?u.bind:function(n){var e=a(this),t=e.prototype,o=l(arguments,1),r=function(){var t=d(o,l(arguments));return this instanceof r?h(e,t.length,t):e.apply(n,t)};return i(t)&&(r.prototype=t),r}},function(n,e,t){var o=t(1),r=t(94),a=t(17),i=t(14),s=t(105),l=t(289),c=t(34),u=t(55),d=t(228),p=t(159),m=t(290),h=o.TypeError,f=function(n,e){this.stopped=n,this.result=e},v=f.prototype;n.exports=function(n,e,t){var o,g,b,x,E,y,w,A=t&&t.that,k=!(!t||!t.AS_ENTRIES),j=!(!t||!t.IS_ITERATOR),B=!(!t||!t.INTERRUPTED),S=r(e,A),C=function(n){return o&&m(o,"normal",n),new f(!0,n)},T=function(n){return k?(i(n),B?S(n[0],n[1],C):S(n[0],n[1])):B?S(n,C):S(n)};if(j)o=n;else{if(!(g=p(n)))throw h(s(n)+" is not iterable");if(l(g)){for(b=0,x=c(n);x>b;b++)if((E=T(n[b]))&&u(v,E))return E;return new f(!1)}o=d(n,g)}for(y=o.next;!(w=a(y,o)).done;){try{E=T(w.value)}catch(n){m(o,"throw",n)}if("object"==typeof E&&E&&u(v,E))return E}return new f(!1)}},function(n,e,t){var o=t(10),r=t(108),a=o("iterator"),i=Array.prototype;n.exports=function(n){return void 0!==n&&(r.Array===n||i[a]===n)}},function(n,e,t){var o=t(17),r=t(14),a=t(73);n.exports=function(n,e,t){var i,s;r(n);try{if(!(i=a(n,"return"))){if("throw"===e)throw t;return t}i=o(i,n)}catch(n){s=!0,i=n}if("throw"===e)throw t;if(s)throw i;return r(i),t}},function(n,e,t){var o=t(10)("iterator"),r=!1;try{var a=0,i={next:function(){return{done:!!a++}},return:function(){r=!0}};i[o]=function(){return this},Array.from(i,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!r)return!1;var t=!1;try{var a={};a[o]=function(){return{next:function(){return{done:t=!0}}}},n(a)}catch(n){}return t}},function(n,e,t){"use strict";var o=t(9),r=t(1),a=t(4),i=t(135),s=t(22),l=t(13),c=t(139),u=t(55),d=t(104),p=t(221),m=t(3),h=t(74).f,f=t(67).f,v=t(18).f,g=t(293),b=t(121).trim,x=r.Number,E=x.prototype,y=r.TypeError,w=a("".slice),A=a("".charCodeAt),k=function(n){var e=p(n,"number");return"bigint"==typeof e?e:j(e)},j=function(n){var e,t,o,r,a,i,s,l,c=p(n,"number");if(d(c))throw y("Cannot convert a Symbol value to a number");if("string"==typeof c&&c.length>2)if(c=b(c),43===(e=A(c,0))||45===e){if(88===(t=A(c,2))||120===t)return NaN}else if(48===e){switch(A(c,1)){case 66:case 98:o=2,r=49;break;case 79:case 111:o=8,r=55;break;default:return+c}for(i=(a=w(c,2)).length,s=0;s<i;s++)if((l=A(a,s))<48||l>r)return NaN;return parseInt(a,o)}return+c};if(i("Number",!x(" 0o1")||!x("0b1")||x("+0x1"))){for(var B,S=function(n){var e=arguments.length<1?0:x(k(n)),t=this;return u(E,t)&&m((function(){g(t)}))?c(Object(e),t,S):e},C=o?h(x):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),T=0;C.length>T;T++)l(x,B=C[T])&&!l(S,B)&&v(S,B,f(x,B));S.prototype=E,E.constructor=S,s(r,"Number",S,{constructor:!0})}},function(n,e,t){var o=t(4);n.exports=o(1..valueOf)},function(n,e,t){var o=t(1),r=t(69),a=t(11),i=t(79),s=t(107),l=t(218),c=/MSIE .\./.test(i),u=o.Function,d=function(n){return c?function(e,t){var o=l(arguments.length,1)>2,i=a(e)?e:u(e),c=o?s(arguments,2):void 0;return n(o?function(){r(i,this,c)}:i,t)}:n};n.exports={setTimeout:d(o.setTimeout),setInterval:d(o.setInterval)}},function(n,e,t){var o,r,a,i,s=t(1),l=t(69),c=t(94),u=t(11),d=t(13),p=t(3),m=t(269),h=t(107),f=t(133),v=t(218),g=t(426),b=t(224),x=s.setImmediate,E=s.clearImmediate,y=s.process,w=s.Dispatch,A=s.Function,k=s.MessageChannel,j=s.String,B=0,S={};try{o=s.location}catch(n){}var C=function(n){if(d(S,n)){var e=S[n];delete S[n],e()}},T=function(n){return function(){C(n)}},I=function(n){C(n.data)},z=function(n){s.postMessage(j(n),o.protocol+"//"+o.host)};x&&E||(x=function(n){v(arguments.length,1);var e=u(n)?n:A(n),t=h(arguments,1);return S[++B]=function(){l(e,void 0,t)},r(B),B},E=function(n){delete S[n]},b?r=function(n){y.nextTick(T(n))}:w&&w.now?r=function(n){w.now(T(n))}:k&&!g?(i=(a=new k).port2,a.port1.onmessage=I,r=c(i.postMessage,i)):s.addEventListener&&u(s.postMessage)&&!s.importScripts&&o&&"file:"!==o.protocol&&!p(z)?(r=z,s.addEventListener("message",I,!1)):r="onreadystatechange"in f("script")?function(n){m.appendChild(f("script")).onreadystatechange=function(){m.removeChild(this),C(n)}}:function(n){setTimeout(T(n),0)}),n.exports={set:x,clear:E}},function(n,e,t){var o=t(2),r=t(341);o({target:"Array",stat:!0,forced:!t(291)((function(n){Array.from(n)}))},{from:r})},function(n,e){n.exports=function(n,e){for(var t=-1,o=e.length,r=n.length;++t<o;)n[r+t]=e[t];return n}},function(n,e,t){var o=t(23).default,r="object"==("undefined"==typeof global?"undefined":o(global))&&global&&global.Object===Object&&global;n.exports=r},function(n,e,t){var o=t(145),r=t(444),a=t(445),i=t(446),s=t(447),l=t(448);function c(n){var e=this.__data__=new o(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=a,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var o=t(98),r=t(204);n.exports=function(n){if(!r(n))return!1;var e=o(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e,t){t(19),t(41),t(7),t(47);var o=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return o.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var o=t(465),r=t(82);n.exports=function n(e,t,a,i,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:o(e,t,a,i,n,s))}},function(n,e,t){var o=t(305),r=t(468),a=t(306);n.exports=function(n,e,t,i,s,l){var c=1&t,u=n.length,d=e.length;if(u!=d&&!(c&&d>u))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,f=!0,v=2&t?new o:void 0;for(l.set(n,e),l.set(e,n);++h<u;){var g=n[h],b=e[h];if(i)var x=c?i(b,g,h,e,n,l):i(g,b,h,n,e,l);if(void 0!==x){if(x)continue;f=!1;break}if(v){if(!r(e,(function(n,e){if(!a(v,e)&&(g===n||s(g,n,t,i,l)))return v.push(e)}))){f=!1;break}}else if(g!==b&&!s(g,b,t,i,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var o=t(205),r=t(466),a=t(467);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new o;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=r,i.prototype.has=a,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var o=t(478),r=t(484),a=t(311);n.exports=function(n){return a(n)?o(n):r(n)}},function(n,e,t){(function(n){var o=t(23).default,r=t(56),a=t(480),i="object"==o(e)&&e&&!e.nodeType&&e,s=i&&"object"==o(n)&&n&&!n.nodeType&&n,l=s&&s.exports===i?r.Buffer:void 0,c=(l?l.isBuffer:void 0)||a;n.exports=c}).call(this,t(231)(n))},function(n,e,t){var o=t(23).default;t(20),t(46);var r=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var t=o(n);return!!(e=null==e?9007199254740991:e)&&("number"==t||"symbol"!=t&&r.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var o=t(481),r=t(482),a=t(483),i=a&&a.isTypedArray,s=i?r(i):o;n.exports=s},function(n,e,t){var o=t(301),r=t(207);n.exports=function(n){return null!=n&&r(n.length)&&!o(n)}},function(n,e,t){"use strict";var o=t(1),r=t(4),a=t(9),i=t(489),s=t(87),l=t(38),c=t(229),u=t(3),d=t(156),p=t(39),m=t(60),h=t(490),f=t(491),v=t(138),g=t(109),b=t(74).f,x=t(18).f,E=t(343),y=t(124),w=t(48),A=t(42),k=s.PROPER,j=s.CONFIGURABLE,B=A.get,S=A.set,C=o.ArrayBuffer,T=C,I=T&&T.prototype,z=o.DataView,F=z&&z.prototype,D=Object.prototype,P=o.Array,O=o.RangeError,R=r(E),_=r([].reverse),M=f.pack,N=f.unpack,L=function(n){return[255&n]},q=function(n){return[255&n,n>>8&255]},J=function(n){return[255&n,n>>8&255,n>>16&255,n>>24&255]},$=function(n){return n[3]<<24|n[2]<<16|n[1]<<8|n[0]},V=function(n){return M(n,23,4)},U=function(n){return M(n,52,8)},H=function(n,e){x(n.prototype,e,{get:function(){return B(this)[e]}})},W=function(n,e,t,o){var r=h(t),a=B(n);if(r+e>a.byteLength)throw O("Wrong index");var i=B(a.buffer).bytes,s=r+a.byteOffset,l=y(i,s,s+e);return o?l:_(l)},G=function(n,e,t,o,r,a){var i=h(t),s=B(n);if(i+e>s.byteLength)throw O("Wrong index");for(var l=B(s.buffer).bytes,c=i+s.byteOffset,u=o(+r),d=0;d<e;d++)l[c+d]=u[a?d:e-d-1]};if(i){var X=k&&"ArrayBuffer"!==C.name;if(u((function(){C(1)}))&&u((function(){new C(-1)}))&&!u((function(){return new C,new C(1.5),new C(NaN),X&&!j})))X&&j&&l(C,"name","ArrayBuffer");else{(T=function(n){return d(this,I),new C(h(n))}).prototype=I;for(var Y,Z=b(C),K=0;Z.length>K;)(Y=Z[K++])in T||l(T,Y,C[Y]);I.constructor=T}g&&v(F)!==D&&g(F,D);var Q=new z(new T(2)),nn=r(F.setInt8);Q.setInt8(0,2147483648),Q.setInt8(1,2147483649),!Q.getInt8(0)&&Q.getInt8(1)||c(F,{setInt8:function(n,e){nn(this,n,e<<24>>24)},setUint8:function(n,e){nn(this,n,e<<24>>24)}},{unsafe:!0})}else I=(T=function(n){d(this,I);var e=h(n);S(this,{bytes:R(P(e),0),byteLength:e}),a||(this.byteLength=e)}).prototype,F=(z=function(n,e,t){d(this,F),d(n,I);var o=B(n).byteLength,r=p(e);if(r<0||r>o)throw O("Wrong offset");if(r+(t=void 0===t?o-r:m(t))>o)throw O("Wrong length");S(this,{buffer:n,byteLength:t,byteOffset:r}),a||(this.buffer=n,this.byteLength=t,this.byteOffset=r)}).prototype,a&&(H(T,"byteLength"),H(z,"buffer"),H(z,"byteLength"),H(z,"byteOffset")),c(F,{getInt8:function(n){return W(this,1,n)[0]<<24>>24},getUint8:function(n){return W(this,1,n)[0]},getInt16:function(n){var e=W(this,2,n,arguments.length>1?arguments[1]:void 0);return(e[1]<<8|e[0])<<16>>16},getUint16:function(n){var e=W(this,2,n,arguments.length>1?arguments[1]:void 0);return e[1]<<8|e[0]},getInt32:function(n){return $(W(this,4,n,arguments.length>1?arguments[1]:void 0))},getUint32:function(n){return $(W(this,4,n,arguments.length>1?arguments[1]:void 0))>>>0},getFloat32:function(n){return N(W(this,4,n,arguments.length>1?arguments[1]:void 0),23)},getFloat64:function(n){return N(W(this,8,n,arguments.length>1?arguments[1]:void 0),52)},setInt8:function(n,e){G(this,1,n,L,e)},setUint8:function(n,e){G(this,1,n,L,e)},setInt16:function(n,e){G(this,2,n,q,e,arguments.length>2?arguments[2]:void 0)},setUint16:function(n,e){G(this,2,n,q,e,arguments.length>2?arguments[2]:void 0)},setInt32:function(n,e){G(this,4,n,J,e,arguments.length>2?arguments[2]:void 0)},setUint32:function(n,e){G(this,4,n,J,e,arguments.length>2?arguments[2]:void 0)},setFloat32:function(n,e){G(this,4,n,V,e,arguments.length>2?arguments[2]:void 0)},setFloat64:function(n,e){G(this,8,n,U,e,arguments.length>2?arguments[2]:void 0)}});w(T,"ArrayBuffer"),w(z,"DataView"),n.exports={ArrayBuffer:T,DataView:z}},function(n,e,t){var o=t(75)(t(56),"Set");n.exports=o},function(n,e,t){var o=t(204);n.exports=function(n){return n==n&&!o(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var o=t(317),r=t(149);n.exports=function(n,e){for(var t=0,a=(e=o(e,n)).length;null!=n&&t<a;)n=n[r(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var o=t(51),r=t(208),a=t(498),i=t(501);n.exports=function(n,e){return o(n)?n:r(n,e)?[n]:a(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var o=t(2),r=t(33),a=t(69),i=t(287),s=t(286),l=t(14),c=t(16),u=t(50),d=t(3),p=r("Reflect","construct"),m=Object.prototype,h=[].push,f=d((function(){function n(){}return!(p((function(){}),[],n)instanceof n)})),v=!d((function(){p((function(){}))})),g=f||v;o({target:"Reflect",stat:!0,forced:g,sham:g},{construct:function(n,e){s(n),l(e);var t=arguments.length<3?n:s(arguments[2]);if(v&&!f)return p(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var o=[null];return a(h,o,e),new(a(i,n,o))}var r=t.prototype,d=u(c(r)?r:m),g=a(n,d,e);return c(g)?g:d}})},function(n,e,t){},function(n,e,t){},function(n,e,t){var o=t(431),r=t(436),a=t(510),i=t(518),s=t(527),l=t(345),c=a((function(n){var e=l(n);return s(e)&&(e=void 0),i(o(n,1,s,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */t(20);var o=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=o.exec(t);if(!r)return t;var a="",i=0,s=0;for(i=r.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(a+=t.substring(s,i)),s=i+1,a+=e}return s!==i?a+t.substring(s,i):a}},function(n,e,t){var o=t(23).default;t(215),t(201),t(41),t(20),t(46),t(118),t(119),t(120),t(47),t(116),t(31),t(19),function(){"use strict";function t(){var n=window,e=document;if(!("scrollBehavior"in e.documentElement.style)||!0===n.__forceSmoothScrollPolyfill__){var t,r=n.HTMLElement||n.Element,a={scroll:n.scroll||n.scrollTo,scrollBy:n.scrollBy,elementScroll:r.prototype.scroll||l,scrollIntoView:r.prototype.scrollIntoView},i=n.performance&&n.performance.now?n.performance.now.bind(n.performance):Date.now,s=(t=n.navigator.userAgent,new RegExp(["MSIE ","Trident/","Edge/"].join("|")).test(t)?1:0);n.scroll=n.scrollTo=function(){void 0!==arguments[0]&&(!0!==c(arguments[0])?f.call(n,e.body,void 0!==arguments[0].left?~~arguments[0].left:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?~~arguments[0].top:n.scrollY||n.pageYOffset):a.scroll.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!==o(arguments[0])?arguments[0]:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:n.scrollY||n.pageYOffset))},n.scrollBy=function(){void 0!==arguments[0]&&(c(arguments[0])?a.scrollBy.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!==o(arguments[0])?arguments[0]:0,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:0):f.call(n,e.body,~~arguments[0].left+(n.scrollX||n.pageXOffset),~~arguments[0].top+(n.scrollY||n.pageYOffset)))},r.prototype.scroll=r.prototype.scrollTo=function(){if(void 0!==arguments[0])if(!0!==c(arguments[0])){var n=arguments[0].left,e=arguments[0].top;f.call(this,this,void 0===n?this.scrollLeft:~~n,void 0===e?this.scrollTop:~~e)}else{if("number"==typeof arguments[0]&&void 0===arguments[1])throw new SyntaxError("Value could not be converted");a.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left:"object"!==o(arguments[0])?~~arguments[0]:this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top:void 0!==arguments[1]?~~arguments[1]:this.scrollTop)}},r.prototype.scrollBy=function(){void 0!==arguments[0]&&(!0!==c(arguments[0])?this.scroll({left:~~arguments[0].left+this.scrollLeft,top:~~arguments[0].top+this.scrollTop,behavior:arguments[0].behavior}):a.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left+this.scrollLeft:~~arguments[0]+this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top+this.scrollTop:~~arguments[1]+this.scrollTop))},r.prototype.scrollIntoView=function(){if(!0!==c(arguments[0])){var t=m(this),o=t.getBoundingClientRect(),r=this.getBoundingClientRect();t!==e.body?(f.call(this,t,t.scrollLeft+r.left-o.left,t.scrollTop+r.top-o.top),"fixed"!==n.getComputedStyle(t).position&&n.scrollBy({left:o.left,top:o.top,behavior:"smooth"})):n.scrollBy({left:r.left,top:r.top,behavior:"smooth"})}else a.scrollIntoView.call(this,void 0===arguments[0]||arguments[0])}}function l(n,e){this.scrollLeft=n,this.scrollTop=e}function c(n){if(null===n||"object"!==o(n)||void 0===n.behavior||"auto"===n.behavior||"instant"===n.behavior)return!0;if("object"===o(n)&&"smooth"===n.behavior)return!1;throw new TypeError("behavior member of ScrollOptions "+n.behavior+" is not a valid value for enumeration ScrollBehavior.")}function u(n,e){return"Y"===e?n.clientHeight+s<n.scrollHeight:"X"===e?n.clientWidth+s<n.scrollWidth:void 0}function d(e,t){var o=n.getComputedStyle(e,null)["overflow"+t];return"auto"===o||"scroll"===o}function p(n){var e=u(n,"Y")&&d(n,"Y"),t=u(n,"X")&&d(n,"X");return e||t}function m(n){for(;n!==e.body&&!1===p(n);)n=n.parentNode||n.host;return n}function h(e){var t,o,r,a,s=(i()-e.startTime)/468;a=s=s>1?1:s,t=.5*(1-Math.cos(Math.PI*a)),o=e.startX+(e.x-e.startX)*t,r=e.startY+(e.y-e.startY)*t,e.method.call(e.scrollable,o,r),o===e.x&&r===e.y||n.requestAnimationFrame(h.bind(n,e))}function f(t,o,r){var s,c,u,d,p=i();t===e.body?(s=n,c=n.scrollX||n.pageXOffset,u=n.scrollY||n.pageYOffset,d=a.scroll):(s=t,c=t.scrollLeft,u=t.scrollTop,d=l),h({scrollable:s,method:d,startTime:p,startX:c,startY:u,x:o,y:r})}}"object"===o(e)&&void 0!==n?n.exports={polyfill:t}:t()}()},function(n,e,t){"use strict";var o=t(2),r=t(68).find,a=t(153),i=!0;"find"in[]&&Array(1).find((function(){i=!1})),o({target:"Array",proto:!0,forced:i},{find:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}}),a("find")},function(n,e,t){"use strict";var o=t(17),r=t(143),a=t(14),i=t(30),s=t(539),l=t(12),c=t(73),u=t(144);r("search",(function(n,e,t){return[function(e){var t=i(this),r=null==e?void 0:c(e,n);return r?o(r,e,t):new RegExp(e)[n](l(t))},function(n){var o=a(this),r=l(n),i=t(e,o,r);if(i.done)return i.value;var c=o.lastIndex;s(c,0)||(o.lastIndex=0);var d=u(o,r);return s(o.lastIndex,c)||(o.lastIndex=c),null===d?-1:d.index}]}))},function(n,e,t){var o=t(87).PROPER,r=t(3),a=t(140);n.exports=function(n){return r((function(){return!!a[n]()||"​᠎"!=="​᠎"[n]()||o&&a[n].name!==n}))}},function(n,e,t){"use strict";var o=t(2),r=t(183).includes,a=t(3),i=t(153);o({target:"Array",proto:!0,forced:a((function(){return!Array(1).includes()}))},{includes:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}}),i("includes")},function(n,e,t){"use strict";var o=t(2),r=t(4),a=t(225),i=t(30),s=t(12),l=t(226),c=r("".indexOf);o({target:"String",proto:!0,forced:!l("includes")},{includes:function(n){return!!~c(s(i(this)),s(a(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var o=t(272).IteratorPrototype,r=t(50),a=t(78),i=t(48),s=t(108),l=function(){return this};n.exports=function(n,e,t,c){var u=e+" Iterator";return n.prototype=r(o,{next:a(+!c,t)}),i(n,u,!1,!0),s[u]=l,n}},function(n,e,t){"use strict";var o=t(35),r=t(153),a=t(108),i=t(42),s=t(18).f,l=t(188),c=t(65),u=t(9),d=i.set,p=i.getterFor("Array Iterator");n.exports=l(Array,"Array",(function(n,e){d(this,{type:"Array Iterator",target:o(n),index:0,kind:e})}),(function(){var n=p(this),e=n.target,t=n.kind,o=n.index++;return!e||o>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:o,done:!1}:"values"==t?{value:e[o],done:!1}:{value:[o,e[o]],done:!1}}),"values");var m=a.Arguments=a.Array;if(r("keys"),r("values"),r("entries"),!c&&u&&"values"!==m.name)try{s(m,"name",{value:"values"})}catch(n){}},function(n,e,t){var o=t(2),r=t(9),a=t(182),i=t(35),s=t(67),l=t(89);o({target:"Object",stat:!0,sham:!r},{getOwnPropertyDescriptors:function(n){for(var e,t,o=i(n),r=s.f,c=a(o),u={},d=0;c.length>d;)void 0!==(t=r(o,e=c[d++]))&&l(u,e,t);return u}})},function(n,e,t){"use strict";var o=t(2),r=t(336).left,a=t(66),i=t(96),s=t(224);o({target:"Array",proto:!0,forced:!a("reduce")||!s&&i>79&&i<83},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){var o=t(1),r=t(80),a=t(26),i=t(122),s=t(34),l=o.TypeError,c=function(n){return function(e,t,o,c){r(t);var u=a(e),d=i(u),p=s(u),m=n?p-1:0,h=n?-1:1;if(o<2)for(;;){if(m in d){c=d[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw l("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in d&&(c=t(c,d[m],m,u));return c}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var o,r=t(2),a=t(4),i=t(67).f,s=t(60),l=t(12),c=t(225),u=t(30),d=t(226),p=t(65),m=a("".startsWith),h=a("".slice),f=Math.min,v=d("startsWith");r({target:"String",proto:!0,forced:!!(p||v||(o=i(String.prototype,"startsWith"),!o||o.writable))&&!v},{startsWith:function(n){var e=l(u(this));c(n);var t=s(f(arguments.length>1?arguments[1]:void 0,e.length)),o=l(n);return m?m(e,o,t):h(e,t,t+o.length)===o}})},function(n,e,t){var o=t(2),r=t(410);o({global:!0,forced:parseFloat!=r},{parseFloat:r})},function(n,e,t){var o=t(124),r=Math.floor,a=function(n,e){var t=n.length,l=r(t/2);return t<8?i(n,e):s(n,a(o(n,0,l),e),a(o(n,l),e),e)},i=function(n,e){for(var t,o,r=n.length,a=1;a<r;){for(o=a,t=n[a];o&&e(n[o-1],t)>0;)n[o]=n[--o];o!==a++&&(n[o]=t)}return n},s=function(n,e,t,o){for(var r=e.length,a=t.length,i=0,s=0;i<r||s<a;)n[i+s]=i<r&&s<a?o(e[i],t[s])<=0?e[i++]:t[s++]:i<r?e[i++]:t[s++];return n};n.exports=a},function(n,e,t){var o=t(2),r=t(3),a=t(35),i=t(67).f,s=t(9),l=r((function(){i(1)}));o({target:"Object",stat:!0,forced:!s||l,sham:!s},{getOwnPropertyDescriptor:function(n,e){return i(a(n),e)}})},function(n,e,t){"use strict";var o=t(1),r=t(94),a=t(17),i=t(26),s=t(430),l=t(289),c=t(137),u=t(34),d=t(89),p=t(228),m=t(159),h=o.Array;n.exports=function(n){var e=i(n),t=c(this),o=arguments.length,f=o>1?arguments[1]:void 0,v=void 0!==f;v&&(f=r(f,o>2?arguments[2]:void 0));var g,b,x,E,y,w,A=m(e),k=0;if(!A||this==h&&l(A))for(g=u(e),b=t?new this(g):h(g);g>k;k++)w=v?f(e[k],k):e[k],d(b,k,w);else for(y=(E=p(e,A)).next,b=t?new this:[];!(x=a(y,E)).done;k++)w=v?s(E,f,[x.value,k],!0):x.value,d(b,k,w);return b.length=k,b}},function(n,e,t){"use strict";var o=t(2),r=t(1),a=t(312),i=t(199),s=a.ArrayBuffer;o({global:!0,constructor:!0,forced:r.ArrayBuffer!==s},{ArrayBuffer:s}),i("ArrayBuffer")},function(n,e,t){"use strict";var o=t(26),r=t(88),a=t(34);n.exports=function(n){for(var e=o(this),t=a(e),i=arguments.length,s=r(i>1?arguments[1]:void 0,t),l=i>2?arguments[2]:void 0,c=void 0===l?t:r(l,t);c>s;)e[s++]=n;return e}},function(n,e,t){"use strict";var o=t(2),r=t(4),a=t(3),i=t(312),s=t(14),l=t(88),c=t(60),u=t(285),d=i.ArrayBuffer,p=i.DataView,m=p.prototype,h=r(d.prototype.slice),f=r(m.getUint8),v=r(m.setUint8);o({target:"ArrayBuffer",proto:!0,unsafe:!0,forced:a((function(){return!new d(2).slice(1,void 0).byteLength}))},{slice:function(n,e){if(h&&void 0===e)return h(s(this),n);for(var t=s(this).byteLength,o=l(n,t),r=l(void 0===e?t:e,t),a=new(u(this,d))(c(r-o)),i=new p(this),m=new p(a),g=0;o<r;)v(m,g++,f(i,o++));return a}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){t(2)({target:"String",proto:!0},{repeat:t(232)})},function(n,e,t){n.exports=t(540)},function(n,e,t){"use strict";var o=t(99),r=t(349),a=t(100),i=t(171),s=t(71).f,l=t(357),c=t(52),u=t(36),d=i.set,p=i.getterFor("Array Iterator");n.exports=l(Array,"Array",(function(n,e){d(this,{type:"Array Iterator",target:o(n),index:0,kind:e})}),(function(){var n=p(this),e=n.target,t=n.kind,o=n.index++;return!e||o>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:o,done:!1}:"values"==t?{value:e[o],done:!1}:{value:[o,e[o]],done:!1}}),"values");var m=a.Arguments=a.Array;if(r("keys"),r("values"),r("entries"),!c&&u&&"values"!==m.name)try{s(m,"name",{value:"values"})}catch(n){}},function(n,e,t){var o=t(28),r=t(164),a=t(71),i=o("unscopables"),s=Array.prototype;null==s[i]&&a.f(s,i,{configurable:!0,value:r(null)}),n.exports=function(n){s[i][n]=!0}},function(n,e,t){var o=t(36),r=t(240),a=t(71),i=t(44),s=t(99),l=t(244);e.f=o&&!r?Object.defineProperties:function(n,e){i(n);for(var t,o=s(e),r=l(e),c=r.length,u=0;c>u;)a.f(n,t=r[u++],o[t]);return n}},function(n,e,t){var o=t(6),r=t(32),a=t(70),i=t(243),s=t(167),l=t(352),c=t(28),u=o.TypeError,d=c("toPrimitive");n.exports=function(n,e){if(!a(n)||i(n))return n;var t,o=s(n,d);if(o){if(void 0===e&&(e="default"),t=r(o,n,e),!a(t)||i(t))return t;throw u("Can't convert object to primitive value")}return void 0===e&&(e="number"),l(n,e)}},function(n,e,t){var o=t(6),r=t(32),a=t(15),i=t(70),s=o.TypeError;n.exports=function(n,e){var t,o;if("string"===e&&a(t=n.toString)&&!i(o=r(t,n)))return o;if(a(t=n.valueOf)&&!i(o=r(t,n)))return o;if("string"!==e&&a(t=n.toString)&&!i(o=r(t,n)))return o;throw s("Can't convert object to primitive value")}},function(n,e,t){var o=t(99),r=t(354),a=t(247),i=function(n){return function(e,t,i){var s,l=o(e),c=a(l),u=r(i,c);if(n&&t!=t){for(;c>u;)if((s=l[u++])!=s)return!0}else for(;c>u;u++)if((n||u in l)&&l[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){var o=t(246),r=Math.max,a=Math.min;n.exports=function(n,e){var t=o(n);return t<0?r(t+e,0):a(t,e)}},function(n,e,t){var o=t(246),r=Math.min;n.exports=function(n){return n>0?r(o(n),9007199254740991):0}},function(n,e,t){var o=t(6),r=t(15),a=t(129),i=o.WeakMap;n.exports=r(i)&&/native code/.test(a(i))},function(n,e,t){"use strict";var o=t(54),r=t(32),a=t(52),i=t(250),s=t(15),l=t(362),c=t(254),u=t(255),d=t(174),p=t(130),m=t(83),h=t(28),f=t(100),v=t(253),g=i.PROPER,b=i.CONFIGURABLE,x=v.IteratorPrototype,E=v.BUGGY_SAFARI_ITERATORS,y=h("iterator"),w=function(){return this};n.exports=function(n,e,t,i,h,v,A){l(t,e,i);var k,j,B,S=function(n){if(n===h&&F)return F;if(!E&&n in I)return I[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},C=e+" Iterator",T=!1,I=n.prototype,z=I[y]||I["@@iterator"]||h&&I[h],F=!E&&z||S(h),D="Array"==e&&I.entries||z;if(D&&(k=c(D.call(new n)))!==Object.prototype&&k.next&&(a||c(k)===x||(u?u(k,x):s(k[y])||m(k,y,w)),d(k,C,!0,!0),a&&(f[C]=w)),g&&"values"==h&&z&&"values"!==z.name&&(!a&&b?p(I,"name","values"):(T=!0,F=function(){return r(z,this)})),h)if(j={values:S("values"),keys:v?F:S("keys"),entries:S("entries")},A)for(B in j)(E||T||!(B in I))&&m(I,B,j[B]);else o({target:e,proto:!0,forced:E||T},j);return a&&!A||I[y]===F||m(I,y,F,{name:h}),f[e]=F,j}},function(n,e,t){var o=t(25),r=t(15),a=t(43),i=t(36),s=t(250).CONFIGURABLE,l=t(129),c=t(171),u=c.enforce,d=c.get,p=Object.defineProperty,m=i&&!o((function(){return 8!==p((function(){}),"length",{value:8}).length})),h=String(String).split("String"),f=n.exports=function(n,e,t){if("Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!a(n,"name")||s&&n.name!==e)&&p(n,"name",{value:e,configurable:!0}),m&&t&&a(t,"arity")&&n.length!==t.arity&&p(n,"length",{value:t.arity}),t&&a(t,"constructor")&&t.constructor){if(i)try{p(n,"prototype",{writable:!1})}catch(n){}}else n.prototype=void 0;var o=u(n);return a(o,"source")||(o.source=h.join("string"==typeof e?e:"")),n};Function.prototype.toString=f((function(){return r(this)&&d(this).source||l(this)}),"toString")},function(n,e,t){var o=t(43),r=t(360),a=t(173),i=t(71);n.exports=function(n,e,t){for(var s=r(e),l=i.f,c=a.f,u=0;u<s.length;u++){var d=s[u];o(n,d)||t&&o(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var o=t(53),r=t(24),a=t(361),i=t(251),s=t(44),l=r([].concat);n.exports=o("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e,t){var o=t(245),r=t(169).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return o(n,r)}},function(n,e,t){"use strict";var o=t(253).IteratorPrototype,r=t(164),a=t(172),i=t(174),s=t(100),l=function(){return this};n.exports=function(n,e,t,c){var u=e+" Iterator";return n.prototype=r(o,{next:a(+!c,t)}),i(n,u,!1,!0),s[u]=l,n}},function(n,e,t){var o=t(25);n.exports=!o((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var o=t(6),r=t(15),a=o.String,i=o.TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw i("Can't set "+a(n)+" as a prototype")}},function(n,e,t){t(366),t(381),t(386),t(387),t(388),t(389)},function(n,e,t){"use strict";var o,r,a,i=t(54),s=t(52),l=t(175),c=t(6),u=t(32),d=t(83),p=t(255),m=t(174),h=t(367),f=t(72),v=t(15),g=t(70),b=t(368),x=t(256),E=t(258).set,y=t(375),w=t(378),A=t(177),k=t(379),j=t(171),B=t(84),S=t(101),C=t(102),T=S.CONSTRUCTOR,I=S.REJECTION_EVENT,z=S.SUBCLASSING,F=j.getterFor("Promise"),D=j.set,P=B&&B.prototype,O=B,R=P,_=c.TypeError,M=c.document,N=c.process,L=C.f,q=L,J=!!(M&&M.createEvent&&c.dispatchEvent),$=function(n){var e;return!(!g(n)||!v(e=n.then))&&e},V=function(n,e){var t,o,r,a=e.value,i=1==e.state,s=i?n.ok:n.fail,l=n.resolve,c=n.reject,d=n.domain;try{s?(i||(2===e.rejection&&X(e),e.rejection=1),!0===s?t=a:(d&&d.enter(),t=s(a),d&&(d.exit(),r=!0)),t===n.promise?c(_("Promise-chain cycle")):(o=$(t))?u(o,t,l,c):l(t)):c(a)}catch(n){d&&!r&&d.exit(),c(n)}},U=function(n,e){n.notified||(n.notified=!0,y((function(){for(var t,o=n.reactions;t=o.get();)V(t,n);n.notified=!1,e&&!n.rejection&&W(n)})))},H=function(n,e,t){var o,r;J?((o=M.createEvent("Event")).promise=e,o.reason=t,o.initEvent(n,!1,!0),c.dispatchEvent(o)):o={promise:e,reason:t},!I&&(r=c["on"+n])?r(o):"unhandledrejection"===n&&w("Unhandled promise rejection",t)},W=function(n){u(E,c,(function(){var e,t=n.facade,o=n.value;if(G(n)&&(e=A((function(){l?N.emit("unhandledRejection",o,t):H("unhandledrejection",t,o)})),n.rejection=l||G(n)?2:1,e.error))throw e.value}))},G=function(n){return 1!==n.rejection&&!n.parent},X=function(n){u(E,c,(function(){var e=n.facade;l?N.emit("rejectionHandled",e):H("rejectionhandled",e,n.value)}))},Y=function(n,e,t){return function(o){n(e,o,t)}},Z=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,U(n,!0))},K=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw _("Promise can't be resolved itself");var o=$(e);o?y((function(){var t={done:!1};try{u(o,e,Y(K,t,n),Y(Z,t,n))}catch(e){Z(t,e,n)}})):(n.value=e,n.state=1,U(n,!1))}catch(e){Z({done:!1},e,n)}}};if(T&&(R=(O=function(n){b(this,R),f(n),u(o,this);var e=F(this);try{n(Y(K,e),Y(Z,e))}catch(n){Z(e,n)}}).prototype,(o=function(n){D(this,{type:"Promise",done:!1,notified:!1,parent:!1,reactions:new k,rejection:!1,state:0,value:void 0})}).prototype=d(R,"then",(function(n,e){var t=F(this),o=L(x(this,O));return t.parent=!0,o.ok=!v(n)||n,o.fail=v(e)&&e,o.domain=l?N.domain:void 0,0==t.state?t.reactions.add(o):y((function(){V(o,t)})),o.promise})),r=function(){var n=new o,e=F(n);this.promise=n,this.resolve=Y(K,e),this.reject=Y(Z,e)},C.f=L=function(n){return n===O||void 0===n?new r(n):q(n)},!s&&v(B)&&P!==Object.prototype)){a=P.then,z||d(P,"then",(function(n,e){var t=this;return new O((function(n,e){u(a,t,n,e)})).then(n,e)}),{unsafe:!0});try{delete P.constructor}catch(n){}p&&p(P,R)}i({global:!0,constructor:!0,wrap:!0,forced:T},{Promise:O}),m(O,"Promise",!1,!0),h("Promise")},function(n,e,t){"use strict";var o=t(53),r=t(71),a=t(28),i=t(36),s=a("species");n.exports=function(n){var e=o(n),t=r.f;i&&e&&!e[s]&&t(e,s,{configurable:!0,get:function(){return this}})}},function(n,e,t){var o=t(6),r=t(166),a=o.TypeError;n.exports=function(n,e){if(r(e,n))return n;throw a("Incorrect invocation")}},function(n,e,t){var o=t(6),r=t(370),a=t(128),i=o.TypeError;n.exports=function(n){if(r(n))return n;throw i(a(n)+" is not a constructor")}},function(n,e,t){var o=t(24),r=t(25),a=t(15),i=t(257),s=t(53),l=t(129),c=function(){},u=[],d=s("Reflect","construct"),p=/^\s*(?:class|function)\b/,m=o(p.exec),h=!p.exec(c),f=function(n){if(!a(n))return!1;try{return d(c,u,n),!0}catch(n){return!1}},v=function(n){if(!a(n))return!1;switch(i(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return h||!!m(p,l(n))}catch(n){return!0}};v.sham=!0,n.exports=!d||r((function(){var n;return f(f.call)||!f(Object)||!f((function(){n=!0}))||n}))?v:f},function(n,e,t){var o={};o[t(28)("toStringTag")]="z",n.exports="[object z]"===String(o)},function(n,e,t){var o=t(126),r=Function.prototype,a=r.apply,i=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(o?i.bind(a):function(){return i.apply(a,arguments)})},function(n,e,t){var o=t(24);n.exports=o([].slice)},function(n,e,t){var o=t(6).TypeError;n.exports=function(n,e){if(n<e)throw o("Not enough arguments");return n}},function(n,e,t){var o,r,a,i,s,l,c,u,d=t(6),p=t(176),m=t(173).f,h=t(258).set,f=t(259),v=t(376),g=t(377),b=t(175),x=d.MutationObserver||d.WebKitMutationObserver,E=d.document,y=d.process,w=d.Promise,A=m(d,"queueMicrotask"),k=A&&A.value;k||(o=function(){var n,e;for(b&&(n=y.domain)&&n.exit();r;){e=r.fn,r=r.next;try{e()}catch(n){throw r?i():a=void 0,n}}a=void 0,n&&n.enter()},f||b||g||!x||!E?!v&&w&&w.resolve?((c=w.resolve(void 0)).constructor=w,u=p(c.then,c),i=function(){u(o)}):b?i=function(){y.nextTick(o)}:(h=p(h,d),i=function(){h(o)}):(s=!0,l=E.createTextNode(""),new x(o).observe(l,{characterData:!0}),i=function(){l.data=s=!s})),n.exports=k||function(n){var e={fn:n,next:void 0};a&&(a.next=e),r||(r=e,i()),a=e}},function(n,e,t){var o=t(127),r=t(6);n.exports=/ipad|iphone|ipod/i.test(o)&&void 0!==r.Pebble},function(n,e,t){var o=t(127);n.exports=/web0s(?!.*chrome)/i.test(o)},function(n,e,t){var o=t(6);n.exports=function(n,e){var t=o.console;t&&t.error&&(1==arguments.length?t.error(n):t.error(n,e))}},function(n,e){var t=function(){this.head=null,this.tail=null};t.prototype={add:function(n){var e={item:n,next:null};this.head?this.tail.next=e:this.head=e,this.tail=e},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=t},function(n,e){n.exports="object"==typeof window&&"object"!=typeof Deno},function(n,e,t){"use strict";var o=t(54),r=t(32),a=t(72),i=t(102),s=t(177),l=t(260);o({target:"Promise",stat:!0,forced:t(262)},{all:function(n){var e=this,t=i.f(e),o=t.resolve,c=t.reject,u=s((function(){var t=a(e.resolve),i=[],s=0,u=1;l(n,(function(n){var a=s++,l=!1;u++,r(t,e,n).then((function(n){l||(l=!0,i[a]=n,--u||o(i))}),c)})),--u||o(i)}));return u.error&&c(u.value),t.promise}})},function(n,e,t){var o=t(28),r=t(100),a=o("iterator"),i=Array.prototype;n.exports=function(n){return void 0!==n&&(r.Array===n||i[a]===n)}},function(n,e,t){var o=t(6),r=t(32),a=t(72),i=t(44),s=t(128),l=t(261),c=o.TypeError;n.exports=function(n,e){var t=arguments.length<2?l(n):e;if(a(t))return i(r(t,n));throw c(s(n)+" is not iterable")}},function(n,e,t){var o=t(32),r=t(44),a=t(167);n.exports=function(n,e,t){var i,s;r(n);try{if(!(i=a(n,"return"))){if("throw"===e)throw t;return t}i=o(i,n)}catch(n){s=!0,i=n}if("throw"===e)throw t;if(s)throw i;return r(i),t}},function(n,e,t){var o=t(28)("iterator"),r=!1;try{var a=0,i={next:function(){return{done:!!a++}},return:function(){r=!0}};i[o]=function(){return this},Array.from(i,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!r)return!1;var t=!1;try{var a={};a[o]=function(){return{next:function(){return{done:t=!0}}}},n(a)}catch(n){}return t}},function(n,e,t){"use strict";var o=t(54),r=t(52),a=t(101).CONSTRUCTOR,i=t(84),s=t(53),l=t(15),c=t(83),u=i&&i.prototype;if(o({target:"Promise",proto:!0,forced:a,real:!0},{catch:function(n){return this.then(void 0,n)}}),!r&&l(i)){var d=s("Promise").prototype.catch;u.catch!==d&&c(u,"catch",d,{unsafe:!0})}},function(n,e,t){"use strict";var o=t(54),r=t(32),a=t(72),i=t(102),s=t(177),l=t(260);o({target:"Promise",stat:!0,forced:t(262)},{race:function(n){var e=this,t=i.f(e),o=t.reject,c=s((function(){var i=a(e.resolve);l(n,(function(n){r(i,e,n).then(t.resolve,o)}))}));return c.error&&o(c.value),t.promise}})},function(n,e,t){"use strict";var o=t(54),r=t(32),a=t(102);o({target:"Promise",stat:!0,forced:t(101).CONSTRUCTOR},{reject:function(n){var e=a.f(this);return r(e.reject,void 0,n),e.promise}})},function(n,e,t){"use strict";var o=t(54),r=t(53),a=t(52),i=t(84),s=t(101).CONSTRUCTOR,l=t(263),c=r("Promise"),u=a&&!s;o({target:"Promise",stat:!0,forced:a||s},{resolve:function(n){return l(u&&this===c?i:this,n)}})},function(n,e,t){var o=t(54),r=t(391);o({target:"Object",stat:!0,arity:2,forced:Object.assign!==r},{assign:r})},function(n,e,t){"use strict";var o=t(36),r=t(24),a=t(32),i=t(25),s=t(244),l=t(251),c=t(249),u=t(163),d=t(233),p=Object.assign,m=Object.defineProperty,h=r([].concat);n.exports=!p||i((function(){if(o&&1!==p({b:1},p(m({},"a",{enumerable:!0,get:function(){m(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=p({},n)[t]||"abcdefghijklmnopqrst"!=s(p({},e)).join("")}))?function(n,e){for(var t=u(n),r=arguments.length,i=1,p=l.f,m=c.f;r>i;)for(var f,v=d(arguments[i++]),g=p?h(s(v),p(v)):s(v),b=g.length,x=0;b>x;)f=g[x++],o&&!a(m,v,f)||(t[f]=v[f]);return t}:p},function(n,e,t){"use strict";var o=t(54),r=t(52),a=t(84),i=t(25),s=t(53),l=t(15),c=t(256),u=t(263),d=t(83),p=a&&a.prototype;if(o({target:"Promise",proto:!0,real:!0,forced:!!a&&i((function(){p.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=c(this,s("Promise")),t=l(n);return this.then(t?function(t){return u(e,n()).then((function(){return t}))}:n,t?function(t){return u(e,n()).then((function(){throw t}))}:n)}}),!r&&l(a)){var m=s("Promise").prototype.finally;p.finally!==m&&d(p,"finally",m,{unsafe:!0})}},function(n,e,t){"use strict";var o=t(2),r=t(1),a=t(17),i=t(4),s=t(65),l=t(9),c=t(85),u=t(3),d=t(13),p=t(55),m=t(14),h=t(35),f=t(131),v=t(12),g=t(78),b=t(50),x=t(158),E=t(74),y=t(187),w=t(157),A=t(67),k=t(18),j=t(186),B=t(220),S=t(22),C=t(86),T=t(134),I=t(106),z=t(132),F=t(10),D=t(270),P=t(136),O=t(397),R=t(48),_=t(42),M=t(68).forEach,N=T("hidden"),L=_.set,q=_.getterFor("Symbol"),J=Object.prototype,$=r.Symbol,V=$&&$.prototype,U=r.TypeError,H=r.QObject,W=A.f,G=k.f,X=y.f,Y=B.f,Z=i([].push),K=C("symbols"),Q=C("op-symbols"),nn=C("wks"),en=!H||!H.prototype||!H.prototype.findChild,tn=l&&u((function(){return 7!=b(G({},"a",{get:function(){return G(this,"a",{value:7}).a}})).a}))?function(n,e,t){var o=W(J,e);o&&delete J[e],G(n,e,t),o&&n!==J&&G(J,e,o)}:G,on=function(n,e){var t=K[n]=b(V);return L(t,{type:"Symbol",tag:n,description:e}),l||(t.description=e),t},rn=function(n,e,t){n===J&&rn(Q,e,t),m(n);var o=f(e);return m(t),d(K,o)?(t.enumerable?(d(n,N)&&n[N][o]&&(n[N][o]=!1),t=b(t,{enumerable:g(0,!1)})):(d(n,N)||G(n,N,g(1,{})),n[N][o]=!0),tn(n,o,t)):G(n,o,t)},an=function(n,e){m(n);var t=h(e),o=x(t).concat(un(t));return M(o,(function(e){l&&!a(sn,t,e)||rn(n,e,t[e])})),n},sn=function(n){var e=f(n),t=a(Y,this,e);return!(this===J&&d(K,e)&&!d(Q,e))&&(!(t||!d(this,e)||!d(K,e)||d(this,N)&&this[N][e])||t)},ln=function(n,e){var t=h(n),o=f(e);if(t!==J||!d(K,o)||d(Q,o)){var r=W(t,o);return!r||!d(K,o)||d(t,N)&&t[N][o]||(r.enumerable=!0),r}},cn=function(n){var e=X(h(n)),t=[];return M(e,(function(n){d(K,n)||d(I,n)||Z(t,n)})),t},un=function(n){var e=n===J,t=X(e?Q:h(n)),o=[];return M(t,(function(n){!d(K,n)||e&&!d(J,n)||Z(o,K[n])})),o};c||(S(V=($=function(){if(p(V,this))throw U("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?v(arguments[0]):void 0,e=z(n),t=function(n){this===J&&a(t,Q,n),d(this,N)&&d(this[N],e)&&(this[N][e]=!1),tn(this,e,g(1,n))};return l&&en&&tn(J,e,{configurable:!0,set:t}),on(e,n)}).prototype,"toString",(function(){return q(this).tag})),S($,"withoutSetter",(function(n){return on(z(n),n)})),B.f=sn,k.f=rn,j.f=an,A.f=ln,E.f=y.f=cn,w.f=un,D.f=function(n){return on(F(n),n)},l&&(G(V,"description",{configurable:!0,get:function(){return q(this).description}}),s||S(J,"propertyIsEnumerable",sn,{unsafe:!0}))),o({global:!0,constructor:!0,wrap:!0,forced:!c,sham:!c},{Symbol:$}),M(x(nn),(function(n){P(n)})),o({target:"Symbol",stat:!0,forced:!c},{useSetter:function(){en=!0},useSimple:function(){en=!1}}),o({target:"Object",stat:!0,forced:!c,sham:!l},{create:function(n,e){return void 0===e?b(n):an(b(n),e)},defineProperty:rn,defineProperties:an,getOwnPropertyDescriptor:ln}),o({target:"Object",stat:!0,forced:!c},{getOwnPropertyNames:cn}),O(),R($,"Symbol"),I[N]=!0},function(n,e,t){var o=t(1),r=t(17),a=t(11),i=t(16),s=o.TypeError;n.exports=function(n,e){var t,o;if("string"===e&&a(t=n.toString)&&!i(o=r(t,n)))return o;if(a(t=n.valueOf)&&!i(o=r(t,n)))return o;if("string"!==e&&a(t=n.toString)&&!i(o=r(t,n)))return o;throw s("Can't convert object to primitive value")}},function(n,e,t){var o=t(1),r=t(11),a=t(180),i=o.WeakMap;n.exports=r(i)&&/native code/.test(a(i))},function(n,e,t){var o=t(1);n.exports=o},function(n,e,t){var o=t(17),r=t(33),a=t(10),i=t(22);n.exports=function(){var n=r("Symbol"),e=n&&n.prototype,t=e&&e.valueOf,s=a("toPrimitive");e&&!e[s]&&i(e,s,(function(n){return o(t,this)}),{arity:1})}},function(n,e,t){var o=t(1),r=t(81),a=t(137),i=t(16),s=t(10)("species"),l=o.Array;n.exports=function(n){var e;return r(n)&&(e=n.constructor,(a(e)&&(e===l||r(e.prototype))||i(e)&&null===(e=e[s]))&&(e=void 0)),void 0===e?l:e}},function(n,e,t){var o=t(2),r=t(33),a=t(13),i=t(12),s=t(86),l=t(271),c=s("string-to-symbol-registry"),u=s("symbol-to-string-registry");o({target:"Symbol",stat:!0,forced:!l},{for:function(n){var e=i(n);if(a(c,e))return c[e];var t=r("Symbol")(e);return c[e]=t,u[t]=e,t}})},function(n,e,t){var o=t(2),r=t(13),a=t(104),i=t(105),s=t(86),l=t(271),c=s("symbol-to-string-registry");o({target:"Symbol",stat:!0,forced:!l},{keyFor:function(n){if(!a(n))throw TypeError(i(n)+" is not a symbol");if(r(c,n))return c[n]}})},function(n,e,t){var o=t(2),r=t(85),a=t(3),i=t(157),s=t(26);o({target:"Object",stat:!0,forced:!r||a((function(){i.f(1)}))},{getOwnPropertySymbols:function(n){var e=i.f;return e?e(s(n)):[]}})},function(n,e,t){"use strict";var o=t(185),r=t(123);n.exports=o?{}.toString:function(){return"[object "+r(this)+"]"}},function(n,e,t){var o=t(1),r=t(11),a=o.String,i=o.TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw i("Can't set "+a(n)+" as a prototype")}},function(n,e,t){t(136)("asyncIterator")},function(n,e,t){"use strict";var o=t(33),r=t(13),a=t(38),i=t(55),s=t(109),l=t(181),c=t(276),u=t(139),d=t(277),p=t(406),m=t(407),h=t(408),f=t(9),v=t(65);n.exports=function(n,e,t,g){var b=g?2:1,x=n.split("."),E=x[x.length-1],y=o.apply(null,x);if(y){var w=y.prototype;if(!v&&r(w,"cause")&&delete w.cause,!t)return y;var A=o("Error"),k=e((function(n,e){var t=d(g?e:n,void 0),o=g?new y(n):new y;return void 0!==t&&a(o,"message",t),h&&a(o,"stack",m(o.stack,2)),this&&i(w,this)&&u(o,this,k),arguments.length>b&&p(o,arguments[b]),o}));if(k.prototype=w,"Error"!==E?s?s(k,A):l(k,A,{name:!0}):f&&"stackTraceLimit"in y&&(c(k,y,"stackTraceLimit"),c(k,y,"prepareStackTrace")),l(k,y),!v)try{w.name!==E&&a(w,"name",E),w.constructor=k}catch(n){}return k}}},function(n,e,t){var o=t(16),r=t(38);n.exports=function(n,e){o(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var o=t(4),r=Error,a=o("".replace),i=String(r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(i);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){var o=t(3),r=t(78);n.exports=!o((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var o=t(9),r=t(3),a=t(14),i=t(50),s=t(277),l=Error.prototype.toString,c=r((function(){if(o){var n=i(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==l.call(n))return!0}return"2: 1"!==l.call({message:1,name:2})||"Error"!==l.call({})}));n.exports=c?function(){var n=a(this),e=s(n.name,"Error"),t=s(n.message);return e?t?e+": "+t:e:t}:l},function(n,e,t){var o=t(1),r=t(3),a=t(4),i=t(12),s=t(121).trim,l=t(140),c=a("".charAt),u=o.parseFloat,d=o.Symbol,p=d&&d.iterator,m=1/u(l+"-0")!=-1/0||p&&!r((function(){u(Object(p))}));n.exports=m?function(n){var e=s(i(n)),t=u(e);return 0===t&&"-"==c(e,0)?-0:t}:u},function(n,e,t){var o=t(4),r=t(26),a=Math.floor,i=o("".charAt),s=o("".replace),l=o("".slice),c=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,u=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,o,d,p){var m=t+n.length,h=o.length,f=u;return void 0!==d&&(d=r(d),f=c),s(p,f,(function(r,s){var c;switch(i(s,0)){case"$":return"$";case"&":return n;case"`":return l(e,0,t);case"'":return l(e,m);case"<":c=d[l(s,1,-1)];break;default:var u=+s;if(0===u)return r;if(u>h){var p=a(u/10);return 0===p?r:p<=h?void 0===o[p-1]?i(s,1):o[p-1]+i(s,1):r}c=o[u-1]}return void 0===c?"":c}))}},function(n,e,t){t(2)({target:"Reflect",stat:!0},{ownKeys:t(182)})},function(n,e,t){t(414)},function(n,e,t){"use strict";t(415)("Set",(function(n){return function(){return n(this,arguments.length?arguments[0]:void 0)}}),t(416))},function(n,e,t){"use strict";var o=t(2),r=t(1),a=t(4),i=t(135),s=t(22),l=t(196),c=t(288),u=t(156),d=t(11),p=t(16),m=t(3),h=t(291),f=t(48),v=t(139);n.exports=function(n,e,t){var g=-1!==n.indexOf("Map"),b=-1!==n.indexOf("Weak"),x=g?"set":"add",E=r[n],y=E&&E.prototype,w=E,A={},k=function(n){var e=a(y[n]);s(y,n,"add"==n?function(n){return e(this,0===n?0:n),this}:"delete"==n?function(n){return!(b&&!p(n))&&e(this,0===n?0:n)}:"get"==n?function(n){return b&&!p(n)?void 0:e(this,0===n?0:n)}:"has"==n?function(n){return!(b&&!p(n))&&e(this,0===n?0:n)}:function(n,t){return e(this,0===n?0:n,t),this})};if(i(n,!d(E)||!(b||y.forEach&&!m((function(){(new E).entries().next()})))))w=t.getConstructor(e,n,g,x),l.enable();else if(i(n,!0)){var j=new w,B=j[x](b?{}:-0,1)!=j,S=m((function(){j.has(1)})),C=h((function(n){new E(n)})),T=!b&&m((function(){for(var n=new E,e=5;e--;)n[x](e,e);return!n.has(-0)}));C||((w=e((function(n,e){u(n,y);var t=v(new E,n,w);return null!=e&&c(e,t[x],{that:t,AS_ENTRIES:g}),t}))).prototype=y,y.constructor=w),(S||T)&&(k("delete"),k("has"),g&&k("get")),(T||B)&&k(x),b&&y.clear&&delete y.clear}return A[n]=w,o({global:!0,constructor:!0,forced:w!=E},A),f(w,n),b||t.setStrong(w,n,g),w}},function(n,e,t){"use strict";var o=t(18).f,r=t(50),a=t(229),i=t(94),s=t(156),l=t(288),c=t(188),u=t(199),d=t(9),p=t(196).fastKey,m=t(42),h=m.set,f=m.getterFor;n.exports={getConstructor:function(n,e,t,c){var u=n((function(n,o){s(n,m),h(n,{type:e,index:r(null),first:void 0,last:void 0,size:0}),d||(n.size=0),null!=o&&l(o,n[c],{that:n,AS_ENTRIES:t})})),m=u.prototype,v=f(e),g=function(n,e,t){var o,r,a=v(n),i=b(n,e);return i?i.value=t:(a.last=i={index:r=p(e,!0),key:e,value:t,previous:o=a.last,next:void 0,removed:!1},a.first||(a.first=i),o&&(o.next=i),d?a.size++:n.size++,"F"!==r&&(a.index[r]=i)),n},b=function(n,e){var t,o=v(n),r=p(e);if("F"!==r)return o.index[r];for(t=o.first;t;t=t.next)if(t.key==e)return t};return a(m,{clear:function(){for(var n=v(this),e=n.index,t=n.first;t;)t.removed=!0,t.previous&&(t.previous=t.previous.next=void 0),delete e[t.index],t=t.next;n.first=n.last=void 0,d?n.size=0:this.size=0},delete:function(n){var e=v(this),t=b(this,n);if(t){var o=t.next,r=t.previous;delete e.index[t.index],t.removed=!0,r&&(r.next=o),o&&(o.previous=r),e.first==t&&(e.first=o),e.last==t&&(e.last=r),d?e.size--:this.size--}return!!t},forEach:function(n){for(var e,t=v(this),o=i(n,arguments.length>1?arguments[1]:void 0);e=e?e.next:t.first;)for(o(e.value,e.key,this);e&&e.removed;)e=e.previous},has:function(n){return!!b(this,n)}}),a(m,t?{get:function(n){var e=b(this,n);return e&&e.value},set:function(n,e){return g(this,0===n?0:n,e)}}:{add:function(n){return g(this,n=0===n?0:n,n)}}),d&&o(m,"size",{get:function(){return v(this).size}}),u},setStrong:function(n,e,t){var o=e+" Iterator",r=f(e),a=f(o);c(n,e,(function(n,e){h(this,{type:o,target:n,state:r(n),kind:e,last:void 0})}),(function(){for(var n=a(this),e=n.kind,t=n.last;t&&t.removed;)t=t.previous;return n.target&&(n.last=t=t?t.next:n.state.first)?"keys"==e?{value:t.key,done:!1}:"values"==e?{value:t.value,done:!1}:{value:[t.key,t.value],done:!1}:(n.target=void 0,{value:void 0,done:!0})}),t?"entries":"values",!t,!0),u(e)}}},function(n,e,t){var o=t(79).match(/firefox\/(\d+)/i);n.exports=!!o&&+o[1]},function(n,e,t){var o=t(79);n.exports=/MSIE|Trident/.test(o)},function(n,e,t){var o=t(79).match(/AppleWebKit\/(\d+)\./);n.exports=!!o&&+o[1]},function(n,e,t){var o=t(2),r=t(3),a=t(187).f;o({target:"Object",stat:!0,forced:r((function(){return!Object.getOwnPropertyNames(1)}))},{getOwnPropertyNames:a})},function(n,e,t){var o=t(2),r=t(280);o({target:"Object",stat:!0,forced:Object.isExtensible!==r},{isExtensible:r})},function(n,e,t){var o=t(2),r=t(1),a=t(294).setInterval;o({global:!0,bind:!0,forced:r.setInterval!==a},{setInterval:a})},function(n,e,t){var o=t(2),r=t(1),a=t(294).setTimeout;o({global:!0,bind:!0,forced:r.setTimeout!==a},{setTimeout:a})},function(n,e,t){t(425),t(427)},function(n,e,t){var o=t(2),r=t(1),a=t(295).clear;o({global:!0,bind:!0,enumerable:!0,forced:r.clearImmediate!==a},{clearImmediate:a})},function(n,e,t){var o=t(79);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(o)},function(n,e,t){var o=t(2),r=t(1),a=t(295).set;o({global:!0,bind:!0,enumerable:!0,forced:r.setImmediate!==a},{setImmediate:a})},function(n,e,t){var o=t(2),r=t(3),a=t(16),i=t(37),s=t(281),l=Object.isFrozen;o({target:"Object",stat:!0,forced:r((function(){l(1)}))||s},{isFrozen:function(n){return!a(n)||(!(!s||"ArrayBuffer"!=i(n))||!!l&&l(n))}})},function(n,e,t){var o=t(1),r=t(3),a=t(4),i=t(12),s=t(121).trim,l=t(140),c=o.parseInt,u=o.Symbol,d=u&&u.iterator,p=/^[+-]?0x/i,m=a(p.exec),h=8!==c(l+"08")||22!==c(l+"0x16")||d&&!r((function(){c(Object(d))}));n.exports=h?function(n,e){var t=s(i(n));return c(t,e>>>0||(m(p,t)?16:10))}:c},function(n,e,t){var o=t(14),r=t(290);n.exports=function(n,e,t,a){try{return a?e(o(t)[0],t[1]):e(t)}catch(e){r(n,"throw",e)}}},function(n,e,t){var o=t(297),r=t(432);n.exports=function n(e,t,a,i,s){var l=-1,c=e.length;for(a||(a=r),s||(s=[]);++l<c;){var u=e[l];t>0&&a(u)?t>1?n(u,t-1,a,i,s):o(s,u):i||(s[s.length]=u)}return s}},function(n,e,t){var o=t(111),r=t(202),a=t(51),i=o?o.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||r(n)||!!(i&&n&&n[i])}},function(n,e,t){var o=t(98),r=t(82);n.exports=function(n){return r(n)&&"[object Arguments]"==o(n)}},function(n,e,t){t(19),t(41),t(7),t(47);var o=t(111),r=Object.prototype,a=r.hasOwnProperty,i=r.toString,s=o?o.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var o=!0}catch(n){}var r=i.call(n);return o&&(e?n[s]=t:delete n[s]),r}},function(n,e,t){t(19),t(41),t(7),t(47);var o=Object.prototype.toString;n.exports=function(n){return o.call(n)}},function(n,e,t){var o=t(23).default,r=t(437),a=t(496),i=t(210),s=t(51),l=t(507);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==o(n)?s(n)?a(n[0],n[1]):r(n):l(n)}},function(n,e,t){var o=t(438),r=t(495),a=t(315);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||o(t,n,e)}}},function(n,e,t){var o=t(299),r=t(303);n.exports=function(n,e,t,a){var i=t.length,s=i,l=!a;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var u=(c=t[i])[0],d=n[u],p=c[1];if(l&&c[2]){if(void 0===d&&!(u in n))return!1}else{var m=new o;if(a)var h=a(d,p,u,n,e,m);if(!(void 0===h?r(p,d,3,a,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){t(155);var o=t(146),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=o(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var o=t(146);n.exports=function(n){var e=this.__data__,t=o(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var o=t(146);n.exports=function(n){return o(this.__data__,n)>-1}},function(n,e,t){var o=t(146);n.exports=function(n,e){var t=this.__data__,r=o(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var o=t(145);n.exports=function(){this.__data__=new o,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var o=t(145),r=t(203),a=t(205);n.exports=function(n,e){var t=this.__data__;if(t instanceof o){var i=t.__data__;if(!r||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){t(19),t(41),t(7),t(47),t(118),t(119),t(20),t(120),t(45),t(46);var o=t(301),r=t(450),a=t(204),i=t(302),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,d=c.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||r(n))&&(o(n)?p:s).test(i(n))}},function(n,e,t){t(20),t(7),t(21);var o,r=t(451),a=(o=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+o:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var o=t(56)["__core-js_shared__"];n.exports=o},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var o=t(454),r=t(145),a=t(203);n.exports=function(){this.size=0,this.__data__={hash:new o,map:new(a||r),string:new o}}},function(n,e,t){var o=t(455),r=t(456),a=t(457),i=t(458),s=t(459);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=r,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var o=t(147);n.exports=function(){this.__data__=o?o(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var o=t(147),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(o){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var o=t(147),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return o?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var o=t(147);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=o&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var o=t(148);n.exports=function(n){var e=o(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e,t){var o=t(23).default;n.exports=function(n){var e=o(n);return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var o=t(148);n.exports=function(n){return o(this,n).get(n)}},function(n,e,t){var o=t(148);n.exports=function(n){return o(this,n).has(n)}},function(n,e,t){var o=t(148);n.exports=function(n,e){var t=o(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var o=t(299),r=t(304),a=t(469),i=t(472),s=t(488),l=t(51),c=t(308),u=t(310),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,f){var v=l(n),g=l(e),b=v?"[object Array]":s(n),x=g?"[object Array]":s(e),E=(b="[object Arguments]"==b?d:b)==d,y=(x="[object Arguments]"==x?d:x)==d,w=b==x;if(w&&c(n)){if(!c(e))return!1;v=!0,E=!1}if(w&&!E)return f||(f=new o),v||u(n)?r(n,e,t,m,h,f):a(n,e,b,t,m,h,f);if(!(1&t)){var A=E&&p.call(n,"__wrapped__"),k=y&&p.call(e,"__wrapped__");if(A||k){var j=A?n.value():n,B=k?e.value():e;return f||(f=new o),h(j,B,t,m,f)}}return!!w&&(f||(f=new o),i(n,e,t,m,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length;++t<o;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){t(61);var o=t(111),r=t(470),a=t(300),i=t(304),s=t(471),l=t(206),c=o?o.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,o,c,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&o;if(m||(m=l),n.size!=e.size&&!h)return!1;var f=p.get(n);if(f)return f==e;o|=2,p.set(n,e);var v=i(m(n),m(e),o,c,d,p);return p.delete(n),v;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var o=t(56).Uint8Array;n.exports=o},function(n,e,t){t(58),t(7),t(59),n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,o){t[++e]=[o,n]})),t}},function(n,e,t){var o=t(473),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,i,s){var l=1&t,c=o(n),u=c.length;if(u!=o(e).length&&!l)return!1;for(var d=u;d--;){var p=c[d];if(!(l?p in e:r.call(e,p)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var f=!0;s.set(n,e),s.set(e,n);for(var v=l;++d<u;){var g=n[p=c[d]],b=e[p];if(a)var x=l?a(b,g,p,e,n,s):a(g,b,p,n,e,s);if(!(void 0===x?g===b||i(g,b,t,a,s):x)){f=!1;break}v||(v="constructor"==p)}if(f&&!v){var E=n.constructor,y=e.constructor;E==y||!("constructor"in n)||!("constructor"in e)||"function"==typeof E&&E instanceof E&&"function"==typeof y&&y instanceof y||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var o=t(474),r=t(475),a=t(307);n.exports=function(n){return o(n,a,r)}},function(n,e,t){var o=t(297),r=t(51);n.exports=function(n,e,t){var a=e(n);return r(n)?a:o(a,t(n))}},function(n,e,t){t(49);var o=t(476),r=t(477),a=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),o(i(n),(function(e){return a.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length,r=0,a=[];++t<o;){var i=n[t];e(i,t,n)&&(a[r++]=i)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var o=t(479),r=t(202),a=t(51),i=t(308),s=t(309),l=t(310),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),u=!t&&r(n),d=!t&&!u&&i(n),p=!t&&!u&&!d&&l(n),m=t||u||d||p,h=m?o(n.length,String):[],f=h.length;for(var v in n)!e&&!c.call(n,v)||m&&("length"==v||d&&("offset"==v||"parent"==v)||p&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||s(v,f))||h.push(v);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,o=Array(n);++t<n;)o[t]=e(t);return o}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var o=t(98),r=t(207),a=t(82),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&r(n.length)&&!!i[o(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var o=t(23).default,r=t(298),a="object"==o(e)&&e&&!e.nodeType&&e,i=a&&"object"==o(n)&&n&&!n.nodeType&&n,s=i&&i.exports===a&&r.process,l=function(){try{var n=i&&i.require&&i.require("util").types;return n||s&&s.binding&&s.binding("util")}catch(n){}}();n.exports=l}).call(this,t(231)(n))},function(n,e,t){var o=t(485),r=t(486),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!o(n))return r(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){t(93);var o=t(487)(Object.keys,Object);n.exports=o},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){t(342),t(344),t(7);var o=t(492),r=t(203),a=t(493),i=t(313),s=t(494),l=t(98),c=t(302),u=c(o),d=c(r),p=c(a),m=c(i),h=c(s),f=l;(o&&"[object DataView]"!=f(new o(new ArrayBuffer(1)))||r&&"[object Map]"!=f(new r)||a&&"[object Promise]"!=f(a.resolve())||i&&"[object Set]"!=f(new i)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,o=t?c(t):"";if(o)switch(o){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e){n.exports="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView},function(n,e,t){var o=t(1),r=t(39),a=t(60),i=o.RangeError;n.exports=function(n){if(void 0===n)return 0;var e=r(n),t=a(e);if(e!==t)throw i("Wrong length or index");return t}},function(n,e,t){var o=t(1).Array,r=Math.abs,a=Math.pow,i=Math.floor,s=Math.log,l=Math.LN2;n.exports={pack:function(n,e,t){var c,u,d,p=o(t),m=8*t-e-1,h=(1<<m)-1,f=h>>1,v=23===e?a(2,-24)-a(2,-77):0,g=n<0||0===n&&1/n<0?1:0,b=0;for((n=r(n))!=n||n===1/0?(u=n!=n?1:0,c=h):(c=i(s(n)/l),n*(d=a(2,-c))<1&&(c--,d*=2),(n+=c+f>=1?v/d:v*a(2,1-f))*d>=2&&(c++,d/=2),c+f>=h?(u=0,c=h):c+f>=1?(u=(n*d-1)*a(2,e),c+=f):(u=n*a(2,f-1)*a(2,e),c=0));e>=8;)p[b++]=255&u,u/=256,e-=8;for(c=c<<e|u,m+=e;m>0;)p[b++]=255&c,c/=256,m-=8;return p[--b]|=128*g,p},unpack:function(n,e){var t,o=n.length,r=8*o-e-1,i=(1<<r)-1,s=i>>1,l=r-7,c=o-1,u=n[c--],d=127&u;for(u>>=7;l>0;)d=256*d+n[c--],l-=8;for(t=d&(1<<-l)-1,d>>=-l,l+=e;l>0;)t=256*t+n[c--],l-=8;if(0===d)d=1-s;else{if(d===i)return t?NaN:u?-1/0:1/0;t+=a(2,e),d-=s}return(u?-1:1)*t*a(2,d-e)}}},function(n,e,t){var o=t(75)(t(56),"DataView");n.exports=o},function(n,e,t){var o=t(75)(t(56),"Promise");n.exports=o},function(n,e,t){var o=t(75)(t(56),"WeakMap");n.exports=o},function(n,e,t){var o=t(314),r=t(307);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var a=e[t],i=n[a];e[t]=[a,i,o(i)]}return e}},function(n,e,t){var o=t(303),r=t(497),a=t(504),i=t(208),s=t(314),l=t(315),c=t(149);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=r(t,n);return void 0===i&&i===e?a(t,n):o(e,i,3)}}},function(n,e,t){var o=t(316);n.exports=function(n,e,t){var r=null==n?void 0:o(n,e);return void 0===r?t:r}},function(n,e,t){t(20),t(45);var o=t(499),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,i=o((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,o,r){e.push(o?r.replace(a,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var o=t(500);n.exports=function(n){var e=o(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){t(31),t(19);var o=t(205);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function t(){var o=arguments,r=e?e.apply(this,o):o[0],a=t.cache;if(a.has(r))return a.get(r);var i=n.apply(this,o);return t.cache=a.set(r,i)||a,i};return t.cache=new(r.Cache||o),t}r.Cache=o,n.exports=r},function(n,e,t){var o=t(502);n.exports=function(n){return null==n?"":o(n)}},function(n,e,t){t(19),t(41),t(7),t(47);var o=t(111),r=t(503),a=t(51),i=t(209),s=o?o.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return r(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length,r=Array(o);++t<o;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var o=t(505),r=t(506);n.exports=function(n,e){return null!=n&&r(n,e,o)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var o=t(317),r=t(202),a=t(51),i=t(309),s=t(207),l=t(149);n.exports=function(n,e,t){for(var c=-1,u=(e=o(e,n)).length,d=!1;++c<u;){var p=l(e[c]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++c!=u?d:!!(u=null==n?0:n.length)&&s(u)&&i(p,u)&&(a(n)||r(n))}},function(n,e,t){var o=t(508),r=t(509),a=t(208),i=t(149);n.exports=function(n){return a(n)?o(i(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var o=t(316);n.exports=function(n){return function(e){return o(e,n)}}},function(n,e,t){var o=t(210),r=t(511),a=t(513);n.exports=function(n,e){return a(r(n,e,o),n+"")}},function(n,e,t){var o=t(512),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var a=arguments,i=-1,s=r(a.length-e,0),l=Array(s);++i<s;)l[i]=a[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=a[i];return c[e]=t(l),o(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var o=t(514),r=t(517)(o);n.exports=r},function(n,e,t){var o=t(515),r=t(516),a=t(210),i=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:o(e),writable:!0})}:a;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var o=t(75),r=function(){try{var n=o(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e,t){t(201),t(41);var o=Date.now;n.exports=function(n){var e=0,t=0;return function(){var r=o(),a=16-(r-t);if(t=r,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var o=t(305),r=t(519),a=t(524),i=t(306),s=t(525),l=t(206);n.exports=function(n,e,t){var c=-1,u=r,d=n.length,p=!0,m=[],h=m;if(t)p=!1,u=a;else if(d>=200){var f=e?null:s(n);if(f)return l(f);p=!1,u=i,h=new o}else h=e?[]:m;n:for(;++c<d;){var v=n[c],g=e?e(v):v;if(v=t||0!==v?v:0,p&&g==g){for(var b=h.length;b--;)if(h[b]===g)continue n;e&&h.push(g),m.push(v)}else u(h,g,t)||(h!==m&&h.push(g),m.push(v))}return m}},function(n,e,t){var o=t(520);n.exports=function(n,e){return!!(null==n?0:n.length)&&o(n,e,0)>-1}},function(n,e,t){var o=t(521),r=t(522),a=t(523);n.exports=function(n,e,t){return e==e?a(n,e,t):o(n,r,t)}},function(n,e){n.exports=function(n,e,t,o){for(var r=n.length,a=t+(o?1:-1);o?a--:++a<r;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var o=t-1,r=n.length;++o<r;)if(n[o]===e)return o;return-1}},function(n,e){n.exports=function(n,e,t){for(var o=-1,r=null==n?0:n.length;++o<r;)if(t(e,n[o]))return!0;return!1}},function(n,e,t){var o=t(313),r=t(526),a=t(206),i=o&&1/a(new o([,-0]))[1]==1/0?function(n){return new o(n)}:r;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var o=t(311),r=t(82);n.exports=function(n){return r(n)&&o(n)}},function(n,e,t){},function(n,e,t){"use strict";t(318)},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(319)},function(n,e,t){"use strict";t(320)},function(n,e,t){"use strict";t(322)},function(n,e,t){"use strict";t(323)},function(n,e,t){"use strict";var o=t(2),r=t(4),a=t(30),i=t(39),s=t(12),l=r("".slice),c=Math.max,u=Math.min;o({target:"String",proto:!0,forced:!"".substr||"b"!=="ab".substr(-1)},{substr:function(n,e){var t,o,r=s(a(this)),d=r.length,p=i(n);return p===1/0&&(p=0),p<0&&(p=c(d+p,0)),(t=void 0===e?d:i(e))<=0||t===1/0||p>=(o=u(p+t,d))?"":l(r,p,o)}})},function(n,e,t){"use strict";var o=t(2),r=t(1),a=t(4),i=t(39),s=t(293),l=t(232),c=t(3),u=r.RangeError,d=r.String,p=Math.floor,m=a(l),h=a("".slice),f=a(1..toFixed),v=function(n,e,t){return 0===e?t:e%2==1?v(n,e-1,t*n):v(n*n,e/2,t)},g=function(n,e,t){for(var o=-1,r=t;++o<6;)r+=e*n[o],n[o]=r%1e7,r=p(r/1e7)},b=function(n,e){for(var t=6,o=0;--t>=0;)o+=n[t],n[t]=p(o/e),o=o%e*1e7},x=function(n){for(var e=6,t="";--e>=0;)if(""!==t||0===e||0!==n[e]){var o=d(n[e]);t=""===t?o:t+m("0",7-o.length)+o}return t};o({target:"Number",proto:!0,forced:c((function(){return"0.000"!==f(8e-5,3)||"1"!==f(.9,0)||"1.25"!==f(1.255,2)||"1000000000000000128"!==f(0xde0b6b3a7640080,0)}))||!c((function(){f({})}))},{toFixed:function(n){var e,t,o,r,a=s(this),l=i(n),c=[0,0,0,0,0,0],p="",f="0";if(l<0||l>20)throw u("Incorrect fraction digits");if(a!=a)return"NaN";if(a<=-1e21||a>=1e21)return d(a);if(a<0&&(p="-",a=-a),a>1e-21)if(t=(e=function(n){for(var e=0,t=n;t>=4096;)e+=12,t/=4096;for(;t>=2;)e+=1,t/=2;return e}(a*v(2,69,1))-69)<0?a*v(2,-e,1):a/v(2,e,1),t*=4503599627370496,(e=52-e)>0){for(g(c,0,t),o=l;o>=7;)g(c,1e7,0),o-=7;for(g(c,v(10,o,1),0),o=e-1;o>=23;)b(c,1<<23),o-=23;b(c,1<<o),g(c,1,1),b(c,2),f=x(c)}else g(c,0,t),g(c,1<<-e,0),f=x(c)+m("0",l);return f=l>0?p+((r=f.length)<=l?"0."+m("0",l-r)+f:h(f,0,r-l)+"."+h(f,r-l)):p+f}})},function(n,e){n.exports=Object.is||function(n,e){return n===e?0!==n||1/n==1/e:n!=n&&e!=e}},function(n,e,t){"use strict";t.r(e);t(348),t(365),t(390),t(392);var o=t(57),r=t(91),a=(t(40),t(7),t(27),t(21),t(76),t(63),t(5)),i=t(8);t(31),t(19),t(41),t(47),t(20),t(45),t(95),t(219),t(58),t(59),t(212),t(116),t(93),t(61),t(195),t(217),t(216),t(114),t(118),t(119),t(120),t(537),t(346),t(125),t(46),t(213),t(97),t(64),t(155),t(115),t(538),t(117),t(49),t(62),t(189),t(190),t(191),t(223),t(328),t(230);function s(n,e){for(var t in e)n[t]=e[t];return n}var l=/[!'()*]/g,c=function(n){return"%"+n.charCodeAt(0).toString(16)},u=/%2C/g,d=function(n){return encodeURIComponent(n).replace(l,c).replace(u,",")};function p(n){try{return decodeURIComponent(n)}catch(n){0}return n}var m=function(n){return null==n||"object"===Object(i.a)(n)?n:String(n)};function h(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),o=p(t.shift()),r=t.length>0?p(t.join("=")):null;void 0===e[o]?e[o]=r:Array.isArray(e[o])?e[o].push(r):e[o]=[e[o],r]})),e):e}function f(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return d(e);if(Array.isArray(t)){var o=[];return t.forEach((function(n){void 0!==n&&(null===n?o.push(d(e)):o.push(d(e)+"="+d(n)))})),o.join("&")}return d(e)+"="+d(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var v=/\/?$/;function g(n,e,t,o){var r=o&&o.options.stringifyQuery,a=e.query||{};try{a=b(a)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:y(e,r),matched:n?E(n):[]};return t&&(i.redirectedFrom=y(t,r)),Object.freeze(i)}function b(n){if(Array.isArray(n))return n.map(b);if(n&&"object"===Object(i.a)(n)){var e={};for(var t in n)e[t]=b(n[t]);return e}return n}var x=g(null,{path:"/"});function E(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function y(n,e){var t=n.path,o=n.query;void 0===o&&(o={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||f)(o)+r}function w(n,e,t){return e===x?n===e:!!e&&(n.path&&e.path?n.path.replace(v,"")===e.path.replace(v,"")&&(t||n.hash===e.hash&&A(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&A(n.query,e.query)&&A(n.params,e.params))))}function A(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),o=Object.keys(e).sort();return t.length===o.length&&t.every((function(t,r){var a=n[t];if(o[r]!==t)return!1;var s=e[t];return null==a||null==s?a===s:"object"===Object(i.a)(a)&&"object"===Object(i.a)(s)?A(a,s):String(a)===String(s)}))}function k(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var o in t.instances){var r=t.instances[o],a=t.enteredCbs[o];if(r&&a){delete t.enteredCbs[o];for(var i=0;i<a.length;i++)r._isBeingDestroyed||a[i](r)}}}}var j={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,o=e.children,r=e.parent,a=e.data;a.routerView=!0;for(var i=r.$createElement,l=t.name,c=r.$route,u=r._routerViewCache||(r._routerViewCache={}),d=0,p=!1;r&&r._routerRoot!==r;){var m=r.$vnode?r.$vnode.data:{};m.routerView&&d++,m.keepAlive&&r._directInactive&&r._inactive&&(p=!0),r=r.$parent}if(a.routerViewDepth=d,p){var h=u[l],f=h&&h.component;return f?(h.configProps&&B(f,a,h.route,h.configProps),i(f,a,o)):i()}var v=c.matched[d],g=v&&v.components[l];if(!v||!g)return u[l]=null,i();u[l]={component:g},a.registerRouteInstance=function(n,e){var t=v.instances[l];(e&&t!==n||!e&&t===n)&&(v.instances[l]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){v.instances[l]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==v.instances[l]&&(v.instances[l]=n.componentInstance),k(c)};var b=v.props&&v.props[l];return b&&(s(u[l],{route:c,configProps:b}),B(g,a,c,b)),i(g,a,o)}};function B(n,e,t,o){var r=e.props=function(n,e){switch(Object(i.a)(e)){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,o);if(r){r=e.props=s({},r);var a=e.attrs=e.attrs||{};for(var l in r)n.props&&l in n.props||(a[l]=r[l],delete r[l])}}function S(n,e,t){var o=n.charAt(0);if("/"===o)return n;if("?"===o||"#"===o)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var a=n.replace(/^\//,"").split("/"),i=0;i<a.length;i++){var s=a[i];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function C(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var T=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},I=V,z=R,F=function(n,e){return M(R(n,e),e)},D=M,P=$,O=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function R(n,e){for(var t,o=[],r=0,a=0,i="",s=e&&e.delimiter||"/";null!=(t=O.exec(n));){var l=t[0],c=t[1],u=t.index;if(i+=n.slice(a,u),a=u+l.length,c)i+=c[1];else{var d=n[a],p=t[2],m=t[3],h=t[4],f=t[5],v=t[6],g=t[7];i&&(o.push(i),i="");var b=null!=p&&null!=d&&d!==p,x="+"===v||"*"===v,E="?"===v||"*"===v,y=t[2]||s,w=h||f;o.push({name:m||r++,prefix:p||"",delimiter:y,optional:E,repeat:x,partial:b,asterisk:!!g,pattern:w?L(w):g?".*":"[^"+N(y)+"]+?"})}}return a<n.length&&(i+=n.substr(a)),i&&o.push(i),o}function _(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function M(n,e){for(var t=new Array(n.length),o=0;o<n.length;o++)"object"===Object(i.a)(n[o])&&(t[o]=new RegExp("^(?:"+n[o].pattern+")$",J(e)));return function(e,o){for(var r="",a=e||{},i=(o||{}).pretty?_:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,u=a[l.name];if(null==u){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(T(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(c=i(u[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(u),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function N(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function L(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function q(n,e){return n.keys=e,n}function J(n){return n&&n.sensitive?"":"i"}function $(n,e,t){T(e)||(t=e||t,e=[]);for(var o=(t=t||{}).strict,r=!1!==t.end,a="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)a+=N(s);else{var l=N(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),a+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=N(t.delimiter||"/"),d=a.slice(-u.length)===u;return o||(a=(d?a.slice(0,-u.length):a)+"(?:"+u+"(?=$))?"),a+=r?"$":o&&d?"":"(?="+u+"|$)",q(new RegExp("^"+a,J(t)),e)}function V(n,e,t){return T(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var o=0;o<t.length;o++)e.push({name:o,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return q(n,e)}(n,e):T(n)?function(n,e,t){for(var o=[],r=0;r<n.length;r++)o.push(V(n[r],e,t).source);return q(new RegExp("(?:"+o.join("|")+")",J(t)),e)}(n,e,t):function(n,e,t){return $(R(n,t),e,t)}(n,e,t)}I.parse=z,I.compile=F,I.tokensToFunction=D,I.tokensToRegExp=P;var U=Object.create(null);function H(n,e,t){e=e||{};try{var o=U[n]||(U[n]=I.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),o(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function W(n,e,t,o){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var a=(r=s({},n)).params;return a&&"object"===Object(i.a)(a)&&(r.params=s({},a)),r}if(!r.path&&r.params&&e){(r=s({},r))._normalized=!0;var l=s(s({},e.params),r.params);if(e.name)r.name=e.name,r.params=l;else if(e.matched.length){var c=e.matched[e.matched.length-1].path;r.path=H(c,l,e.path)}else 0;return r}var u=function(n){var e="",t="",o=n.indexOf("#");o>=0&&(e=n.slice(o),n=n.slice(0,o));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),d=e&&e.path||"/",p=u.path?S(u.path,d,t||r.append):d,f=function(n,e,t){void 0===e&&(e={});var o,r=t||h;try{o=r(n||"")}catch(n){o={}}for(var a in e){var i=e[a];o[a]=Array.isArray(i)?i.map(m):m(i)}return o}(u.query,r.query,o&&o.options.parseQuery),v=r.hash||u.hash;return v&&"#"!==v.charAt(0)&&(v="#"+v),{_normalized:!0,path:p,query:f,hash:v}}var G,X=function(){},Y={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,o=this.$route,r=t.resolve(this.to,o,this.append),a=r.location,i=r.route,l=r.href,c={},u=t.options.linkActiveClass,d=t.options.linkExactActiveClass,p=null==u?"router-link-active":u,m=null==d?"router-link-exact-active":d,h=null==this.activeClass?p:this.activeClass,f=null==this.exactActiveClass?m:this.exactActiveClass,b=i.redirectedFrom?g(null,W(i.redirectedFrom),null,t):i;c[f]=w(o,b,this.exactPath),c[h]=this.exact||this.exactPath?c[f]:function(n,e){return 0===n.path.replace(v,"/").indexOf(e.path.replace(v,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(o,b);var x=c[f]?this.ariaCurrentValue:null,E=function(n){Z(n)&&(e.replace?t.replace(a,X):t.push(a,X))},y={click:Z};Array.isArray(this.event)?this.event.forEach((function(n){y[n]=E})):y[this.event]=E;var A={class:c},k=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:i,navigate:E,isActive:c[h],isExactActive:c[f]});if(k){if(1===k.length)return k[0];if(k.length>1||!k.length)return 0===k.length?n():n("span",{},k)}if("a"===this.tag)A.on=y,A.attrs={href:l,"aria-current":x};else{var j=function n(e){var t;if(e)for(var o=0;o<e.length;o++){if("a"===(t=e[o]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(j){j.isStatic=!1;var B=j.data=s({},j.data);for(var S in B.on=B.on||{},B.on){var C=B.on[S];S in y&&(B.on[S]=Array.isArray(C)?C:[C])}for(var T in y)T in B.on?B.on[T].push(y[T]):B.on[T]=E;var I=j.data.attrs=s({},j.data.attrs);I.href=l,I["aria-current"]=x}else A.on=y}return n(this.tag,A,this.$slots.default)}};function Z(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var K="undefined"!=typeof window;function Q(n,e,t,o,r){var a=e||[],i=t||Object.create(null),s=o||Object.create(null);n.forEach((function(n){!function n(e,t,o,r,a,i){var s=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return C(e.path+"/"+n)}(s,a,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var d={path:u,regex:nn(u,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:i,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var a=i?C(i+"/"+r.path):void 0;n(e,t,o,r,d,a)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==r.alias)for(var p=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:r.children};n(e,t,o,h,a,d.path||"/")}l&&(o[l]||(o[l]=d))}(a,i,s,n,r)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:i,nameMap:s}}function nn(n,e){return I(n,[],e)}function en(n,e){var t=Q(n),o=t.pathList,r=t.pathMap,a=t.nameMap;function s(n,t,s){var l=W(n,t,!1,e),u=l.name;if(u){var d=a[u];if(!d)return c(null,l);var p=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!==Object(i.a)(l.params)&&(l.params={}),t&&"object"===Object(i.a)(t.params))for(var m in t.params)!(m in l.params)&&p.indexOf(m)>-1&&(l.params[m]=t.params[m]);return l.path=H(d.path,l.params),c(d,l,s)}if(l.path){l.params={};for(var h=0;h<o.length;h++){var f=o[h],v=r[f];if(tn(v.regex,l.path,l.params))return c(v,l,s)}}return c(null,l)}function l(n,t){var o=n.redirect,r="function"==typeof o?o(g(n,t,null,e)):o;if("string"==typeof r&&(r={path:r}),!r||"object"!==Object(i.a)(r))return c(null,t);var l=r,u=l.name,d=l.path,p=t.query,m=t.hash,h=t.params;if(p=l.hasOwnProperty("query")?l.query:p,m=l.hasOwnProperty("hash")?l.hash:m,h=l.hasOwnProperty("params")?l.params:h,u){a[u];return s({_normalized:!0,name:u,query:p,hash:m,params:h},void 0,t)}if(d){var f=function(n,e){return S(n,e.parent?e.parent.path:"/",!0)}(d,n);return s({_normalized:!0,path:H(f,h),query:p,hash:m},void 0,t)}return c(null,t)}function c(n,t,o){return n&&n.redirect?l(n,o||t):n&&n.matchAs?function(n,e,t){var o=s({_normalized:!0,path:H(t,e.params)});if(o){var r=o.matched,a=r[r.length-1];return e.params=o.params,c(a,e)}return c(null,e)}(0,t,n.matchAs):g(n,t,o,e)}return{match:s,addRoute:function(n,e){var t="object"!==Object(i.a)(n)?a[n]:void 0;Q([e||n],o,r,a,t),t&&t.alias.length&&Q(t.alias.map((function(n){return{path:n,children:[e]}})),o,r,a,t)},getRoutes:function(){return o.map((function(n){return r[n]}))},addRoutes:function(n){Q(n,o,r,a)}}}function tn(n,e,t){var o=e.match(n);if(!o)return!1;if(!t)return!0;for(var r=1,a=o.length;r<a;++r){var i=n.keys[r-1];i&&(t[i.name||"pathMatch"]="string"==typeof o[r]?p(o[r]):o[r])}return!0}var on=K&&window.performance&&window.performance.now?window.performance:Date;function rn(){return on.now().toFixed(3)}var an=rn();function sn(){return an}function ln(n){return an=n}var cn=Object.create(null);function un(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=s({},window.history.state);return t.key=sn(),window.history.replaceState(t,"",e),window.addEventListener("popstate",mn),function(){window.removeEventListener("popstate",mn)}}function dn(n,e,t,o){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var a=function(){var n=sn();if(n)return cn[n]}(),i=r.call(n,e,t,o?a:null);i&&("function"==typeof i.then?i.then((function(n){bn(n,a)})).catch((function(n){0})):bn(i,a))}))}}function pn(){var n=sn();n&&(cn[n]={x:window.pageXOffset,y:window.pageYOffset})}function mn(n){pn(),n.state&&n.state.key&&ln(n.state.key)}function hn(n){return vn(n.x)||vn(n.y)}function fn(n){return{x:vn(n.x)?n.x:window.pageXOffset,y:vn(n.y)?n.y:window.pageYOffset}}function vn(n){return"number"==typeof n}var gn=/^#\d/;function bn(n,e){var t,o="object"===Object(i.a)(n);if(o&&"string"==typeof n.selector){var r=gn.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var a=n.offset&&"object"===Object(i.a)(n.offset)?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),o=n.getBoundingClientRect();return{x:o.left-t.left-e.x,y:o.top-t.top-e.y}}(r,a={x:vn((t=a).x)?t.x:0,y:vn(t.y)?t.y:0})}else hn(n)&&(e=fn(n))}else o&&hn(n)&&(e=fn(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var xn,En=K&&((-1===(xn=window.navigator.userAgent).indexOf("Android 2.")&&-1===xn.indexOf("Android 4.0")||-1===xn.indexOf("Mobile Safari")||-1!==xn.indexOf("Chrome")||-1!==xn.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function yn(n,e){pn();var t=window.history;try{if(e){var o=s({},t.state);o.key=sn(),t.replaceState(o,"",n)}else t.pushState({key:ln(rn())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function wn(n){yn(n,!0)}function An(n,e,t){!function o(r){r>=n.length?t():n[r]?e(n[r],(function(){o(r+1)})):o(r+1)}(0)}var kn={redirected:2,aborted:4,cancelled:8,duplicated:16};function jn(n,e){return Sn(n,e,kn.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Cn.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Bn(n,e){return Sn(n,e,kn.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Sn(n,e,t,o){var r=new Error(o);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var Cn=["params","query","hash"];function Tn(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function In(n,e){return Tn(n)&&n._isRouter&&(null==e||n.type===e)}function zn(n){return function(e,t,o){var r=!1,a=0,i=null;Fn(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,a++;var l,c=On((function(e){var r;((r=e).__esModule||Pn&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:G.extend(e),t.components[s]=e,--a<=0&&o()})),u=On((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=Tn(n)?n:new Error(e),o(i))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,u)}}})),r||o()}}function Fn(n,e){return Dn(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Dn(n){return Array.prototype.concat.apply([],n)}var Pn="function"==typeof Symbol&&"symbol"===Object(i.a)(Symbol.toStringTag);function On(n){var e=!1;return function(){for(var t=[],o=arguments.length;o--;)t[o]=arguments[o];if(!e)return e=!0,n.apply(this,t)}}var Rn=function(n,e){this.router=n,this.base=function(n){if(!n)if(K){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=x,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function _n(n,e,t,o){var r=Fn(n,(function(n,o,r,a){var i=function(n,e){"function"!=typeof n&&(n=G.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,o,r,a)})):t(i,o,r,a)}));return Dn(o?r.reverse():r)}function Mn(n,e){if(e)return function(){return n.apply(e,arguments)}}Rn.prototype.listen=function(n){this.cb=n},Rn.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Rn.prototype.onError=function(n){this.errorCbs.push(n)},Rn.prototype.transitionTo=function(n,e,t){var o,r=this;try{o=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(o,(function(){r.updateRoute(o),e&&e(o),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(o,a)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(o)})))}),(function(n){t&&t(n),n&&!r.ready&&(In(n,kn.redirected)&&a===x||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},Rn.prototype.confirmTransition=function(n,e,t){var o=this,r=this.current;this.pending=n;var a,s,l=function(n){!In(n)&&Tn(n)&&(o.errorCbs.length?o.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},c=n.matched.length-1,u=r.matched.length-1;if(w(n,r)&&c===u&&n.matched[c]===r.matched[u])return this.ensureURL(),n.hash&&dn(this.router,r,n,!1),l(((s=Sn(a=r,n,kn.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",s));var d=function(n,e){var t,o=Math.max(n.length,e.length);for(t=0;t<o&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),p=d.updated,m=d.deactivated,h=d.activated,f=[].concat(function(n){return _n(n,"beforeRouteLeave",Mn,!0)}(m),this.router.beforeHooks,function(n){return _n(n,"beforeRouteUpdate",Mn)}(p),h.map((function(n){return n.beforeEnter})),zn(h)),v=function(e,t){if(o.pending!==n)return l(Bn(r,n));try{e(n,r,(function(e){!1===e?(o.ensureURL(!0),l(function(n,e){return Sn(n,e,kn.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):Tn(e)?(o.ensureURL(!0),l(e)):"string"==typeof e||"object"===Object(i.a)(e)&&("string"==typeof e.path||"string"==typeof e.name)?(l(jn(r,n)),"object"===Object(i.a)(e)&&e.replace?o.replace(e):o.push(e)):t(e)}))}catch(n){l(n)}};An(f,v,(function(){An(function(n){return _n(n,"beforeRouteEnter",(function(n,e,t,o){return function(n,e,t){return function(o,r,a){return n(o,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,o)}))}(h).concat(o.router.resolveHooks),v,(function(){if(o.pending!==n)return l(Bn(r,n));o.pending=null,e(n),o.router.app&&o.router.app.$nextTick((function(){k(n)}))}))}))},Rn.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Rn.prototype.setupListeners=function(){},Rn.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=x,this.pending=null};var Nn=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Ln(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,o=En&&t;o&&this.listeners.push(un());var r=function(){var t=n.current,r=Ln(n.base);n.current===x&&r===n._startLocation||n.transitionTo(r,(function(n){o&&dn(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var o=this,r=this.current;this.transitionTo(n,(function(n){yn(C(o.base+n.fullPath)),dn(o.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this,r=this.current;this.transitionTo(n,(function(n){wn(C(o.base+n.fullPath)),dn(o.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Ln(this.base)!==this.current.fullPath){var e=C(this.base+this.current.fullPath);n?yn(e):wn(e)}},e.prototype.getCurrentLocation=function(){return Ln(this.base)},e}(Rn);function Ln(n){var e=window.location.pathname,t=e.toLowerCase(),o=n.toLowerCase();return!n||t!==o&&0!==t.indexOf(C(o+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var qn=function(n){function e(e,t,o){n.call(this,e,t),o&&function(n){var e=Ln(n);if(!/^\/#/.test(e))return window.location.replace(C(n+"/#"+e)),!0}(this.base)||Jn()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=En&&e;t&&this.listeners.push(un());var o=function(){var e=n.current;Jn()&&n.transitionTo($n(),(function(o){t&&dn(n.router,o,e,!0),En||Hn(o.fullPath)}))},r=En?"popstate":"hashchange";window.addEventListener(r,o),this.listeners.push((function(){window.removeEventListener(r,o)}))}},e.prototype.push=function(n,e,t){var o=this,r=this.current;this.transitionTo(n,(function(n){Un(n.fullPath),dn(o.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this,r=this.current;this.transitionTo(n,(function(n){Hn(n.fullPath),dn(o.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;$n()!==e&&(n?Un(e):Hn(e))},e.prototype.getCurrentLocation=function(){return $n()},e}(Rn);function Jn(){var n=$n();return"/"===n.charAt(0)||(Hn("/"+n),!1)}function $n(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Vn(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Un(n){En?yn(Vn(n)):window.location.hash=n}function Hn(n){En?wn(Vn(n)):window.location.replace(Vn(n))}var Wn=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var o=this;this.transitionTo(n,(function(n){o.stack=o.stack.slice(0,o.index+1).concat(n),o.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this;this.transitionTo(n,(function(n){o.stack=o.stack.slice(0,o.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var o=this.stack[t];this.confirmTransition(o,(function(){var n=e.current;e.index=t,e.updateRoute(o),e.router.afterHooks.forEach((function(e){e&&e(o,n)}))}),(function(n){In(n,kn.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Rn),Gn=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=en(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!En&&!1!==n.fallback,this.fallback&&(e="hash"),K||(e="abstract"),this.mode=e,e){case"history":this.history=new Nn(this,n.base);break;case"hash":this.history=new qn(this,n.base,this.fallback);break;case"abstract":this.history=new Wn(this,n.base);break;default:0}},Xn={currentRoute:{configurable:!0}};function Yn(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Gn.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Xn.currentRoute.get=function(){return this.history&&this.history.current},Gn.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Nn||t instanceof qn){var o=function(n){t.setupListeners(),function(n){var o=t.current,r=e.options.scrollBehavior;En&&r&&"fullPath"in n&&dn(e,n,o,!1)}(n)};t.transitionTo(t.getCurrentLocation(),o,o)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Gn.prototype.beforeEach=function(n){return Yn(this.beforeHooks,n)},Gn.prototype.beforeResolve=function(n){return Yn(this.resolveHooks,n)},Gn.prototype.afterEach=function(n){return Yn(this.afterHooks,n)},Gn.prototype.onReady=function(n,e){this.history.onReady(n,e)},Gn.prototype.onError=function(n){this.history.onError(n)},Gn.prototype.push=function(n,e,t){var o=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){o.history.push(n,e,t)}));this.history.push(n,e,t)},Gn.prototype.replace=function(n,e,t){var o=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){o.history.replace(n,e,t)}));this.history.replace(n,e,t)},Gn.prototype.go=function(n){this.history.go(n)},Gn.prototype.back=function(){this.go(-1)},Gn.prototype.forward=function(){this.go(1)},Gn.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Gn.prototype.resolve=function(n,e,t){var o=W(n,e=e||this.history.current,t,this),r=this.match(o,e),a=r.redirectedFrom||r.fullPath;return{location:o,route:r,href:function(n,e,t){var o="hash"===t?"#"+e:e;return n?C(n+"/"+o):o}(this.history.base,a,this.mode),normalizedTo:o,resolved:r}},Gn.prototype.getRoutes=function(){return this.matcher.getRoutes()},Gn.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==x&&this.history.transitionTo(this.history.getCurrentLocation())},Gn.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==x&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Gn.prototype,Xn),Gn.install=function n(e){if(!n.installed||G!==e){n.installed=!0,G=e;var t=function(n){return void 0!==n},o=function(n,e){var o=n.$options._parentVnode;t(o)&&t(o=o.data)&&t(o=o.registerRouteInstance)&&o(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,o(this,this)},destroyed:function(){o(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",j),e.component("RouterLink",Y);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Gn.version="3.5.4",Gn.isNavigationFailure=In,Gn.NavigationFailureType=kn,Gn.START_LOCATION=x,K&&window.Vue&&window.Vue.use(Gn);var Zn=Gn;t(334),t(192),t(335),t(337);function Kn(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}var Qn=t(0),ne=t(112),ee=t(211),te=t(324),oe=t.n(te),re=t(325),ae=t.n(re),ie={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(ee.a)(n,1)[0]})).map((function(n){var e=Object(ee.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(ae()(n[t]),'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=le(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(ne.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=ce(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return oe()([{name:"description",content:this.$description}],n,this.siteMeta,ue)},updateCanonicalLink:function(){se(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",le(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){ce(null,this.currentMetaTags),se()}};function se(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function le(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function ce(n,e){if(e&&Object(ne.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function ue(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var o=t[e];if(n.hasOwnProperty(o))return n[o]+o}return JSON.stringify(n)}var de=t(151),pe=t.n(de),me={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:pe()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),o=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+o,i=0;i<t.length;i++){var s=t[i],l=t[i+1],c=0===i&&0===o||o>=s.parentElement.offsetTop+10&&(!l||o<l.parentElement.offsetTop-10),u=decodeURIComponent(this.$route.hash);if(c&&u!==decodeURIComponent(s.hash)){var d=s;if(a===r)for(var p=i+1;p<t.length;p++)if(u===decodeURIComponent(t[p].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(d.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},he=t(152),fe=t.n(he),ve={mounted:function(){var n=this;fe.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||a.a.component(n.name)||fe.a.start(),t()})),this.$router.afterEach((function(){fe.a.done(),n.isSidebarOpen=!1}))}},ge=t(326),be=t.n(ge),xe=(t(528),{mounted:function(){be.a.polyfill()}}),Ee=(t(77),{data:function(){return{showCopyButton:!0}},computed:{iconClass:function(){return!0},iconTitle:function(){return"Copy"},alignStyle:function(){var n={top:"0.5em"};return n},color:function(){return"#ffffff"}},methods:{success:function(){var n=this;this.showCopyButton=!this.showCopyButton,setTimeout((function(){n.reset()}),500)},reset:function(){this.showCopyButton=!this.showCopyButton}}}),ye=(t(529),t(29)),we=Object(ye.a)(Ee,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("svg",{directives:[{name:"show",rawName:"v-show",value:n.showCopyButton,expression:"showCopyButton"}],staticClass:"copy-button",class:{hover:n.iconClass},style:n.alignStyle,attrs:{role:"img",xmlns:"http://www.w3.org/2000/svg",width:"24px",height:"24px",viewBox:"0 0 24 24","aria-labelledby":"copyIconTitle",stroke:n.color,"stroke-width":"2","stroke-linecap":"square","stroke-linejoin":"miter",fill:"none",color:n.color},on:{click:n.success}},[t("title",{attrs:{id:"copyIconTitle"}},[n._v(n._s(n.iconTitle))]),n._v(" "),t("rect",{attrs:{width:"12",height:"14",x:"8",y:"7"}}),n._v(" "),t("polyline",{attrs:{points:"16 3 4 3 4 17"}})]),n._v(" "),t("svg",{directives:[{name:"show",rawName:"v-show",value:!n.showCopyButton,expression:"!showCopyButton"}],staticClass:"copy-ok",style:n.alignStyle,attrs:{role:"img",xmlns:"http://www.w3.org/2000/svg",width:"24px",height:"24px",viewBox:"0 0 24 24","aria-labelledby":"okIconTitle",stroke:"#3eaf7c","stroke-width":"2","stroke-linecap":"square","stroke-linejoin":"miter",fill:"none",color:"#3eaf7c"}},[t("title",{attrs:{id:"okIconTitle"}},[n._v("Ok")]),n._v(" "),t("polyline",{attrs:{points:"4 13 9 18 20 7"}})])])}),[],!1,null,"4f47a0ca",null).exports,Ae=(t(530),[ie,me,ve,xe,{updated:function(){document.querySelectorAll('div[class*="language-"]').forEach((function(n){if(!n.classList.contains("xiaopanda-code-copy")){var e=new(a.a.extend(we));e.$mount();var t=e.$el;n.prepend(t),n.classList.add("xiaopanda-code-copy"),t.addEventListener("click",(function(){var e=n.querySelector("code");if(navigator.clipboard)navigator.clipboard.writeText(e.innerText).then((function(){}));else{var t=document.createElement("textarea");document.body.appendChild(t),t.value=e.innerText,t.select(),document.execCommand("copy"),t.remove()}var o=n.style.transition,r=n.style.background;n.style.transition="background 200ms",n.style.background="#2c3e50",setTimeout((function(){n.style.transition=o,n.style.background=r}),200)}))}}))}}]),ke={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Object(Qn.h)("layout",n),a.a.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},je=Object(ye.a)(ke,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;Object(Qn.f)(je,"mixins",Ae);var Be=[{name:"v-7dd30b36",path:"/",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-7dd30b36").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-6c71d7d8",path:"/%E4%BC%98%E8%B4%A8%E9%93%BE%E6%8E%A5.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-6c71d7d8").then(t)}},{path:"/优质链接.html",redirect:"/%E4%BC%98%E8%B4%A8%E9%93%BE%E6%8E%A5.html"},{path:"/优质链接.html",redirect:"/%E4%BC%98%E8%B4%A8%E9%93%BE%E6%8E%A5.html"},{name:"v-35a28194",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/2D%E4%B8%8E3D%E8%BD%AC%E6%8D%A2.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-35a28194").then(t)}},{path:"/前端开发/Css/Css3/2D与3D转换.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/2D%E4%B8%8E3D%E8%BD%AC%E6%8D%A2.html"},{path:"/前端开发/Css/Css3/2D与3D转换.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/2D%E4%B8%8E3D%E8%BD%AC%E6%8D%A2.html"},{name:"v-288dfe3c",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%9B%92%E6%A8%A1%E5%9E%8B.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-288dfe3c").then(t)}},{path:"/前端开发/Css/Css3/基础与盒模型.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%9B%92%E6%A8%A1%E5%9E%8B.html"},{path:"/前端开发/Css/Css3/基础与盒模型.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%9B%92%E6%A8%A1%E5%9E%8B.html"},{name:"v-57a6865a",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-57a6865a").then(t)}},{path:"/前端开发/Css/Css3/浮动与定位.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D.html"},{path:"/前端开发/Css/Css3/浮动与定位.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D.html"},{name:"v-39e06f8c",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%83%8C%E6%99%AF%E4%B8%8E%E6%B8%90%E5%8F%98.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-39e06f8c").then(t)}},{path:"/前端开发/Css/Css3/背景与渐变.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%83%8C%E6%99%AF%E4%B8%8E%E6%B8%90%E5%8F%98.html"},{path:"/前端开发/Css/Css3/背景与渐变.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%83%8C%E6%99%AF%E4%B8%8E%E6%B8%90%E5%8F%98.html"},{name:"v-4c4aff17",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%BE%B9%E6%A1%86%E5%9C%86%E8%A7%92%E4%B8%8E%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-4c4aff17").then(t)}},{path:"/前端开发/Css/Css3/边框圆角与盒子阴影.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%BE%B9%E6%A1%86%E5%9C%86%E8%A7%92%E4%B8%8E%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1.html"},{path:"/前端开发/Css/Css3/边框圆角与盒子阴影.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%BE%B9%E6%A1%86%E5%9C%86%E8%A7%92%E4%B8%8E%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1.html"},{name:"v-73b464c0",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-73b464c0").then(t)}},{path:"/前端开发/Css/Css3/过渡与动画.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB.html"},{path:"/前端开发/Css/Css3/过渡与动画.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB.html"},{name:"v-2433b719",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Flex%E5%B8%83%E5%B1%80.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-2433b719").then(t)}},{path:"/前端开发/Css/Flex布局.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Flex%E5%B8%83%E5%B1%80.html"},{path:"/前端开发/Css/Flex布局.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Flex%E5%B8%83%E5%B1%80.html"},{name:"v-c9df4500",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Sass.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-c9df4500").then(t)}},{path:"/前端开发/Css/Sass.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Sass.html"},{path:"/前端开发/Css/Sass.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Sass.html"},{name:"v-0934a038",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/%E7%8E%A9%E8%BD%ACCSS%E8%89%BA%E6%9C%AF%E4%B9%8B%E7%BE%8E/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-0934a038").then(t)}},{path:"/前端开发/Css/玩转CSS艺术之美/回流重绘.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/%E7%8E%A9%E8%BD%ACCSS%E8%89%BA%E6%9C%AF%E4%B9%8B%E7%BE%8E/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98.html"},{path:"/前端开发/Css/玩转CSS艺术之美/回流重绘.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/%E7%8E%A9%E8%BD%ACCSS%E8%89%BA%E6%9C%AF%E4%B9%8B%E7%BE%8E/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98.html"},{name:"v-6400ccc0",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/%E7%8E%A9%E8%BD%ACCSS%E8%89%BA%E6%9C%AF%E4%B9%8B%E7%BE%8E/%E6%B5%8F%E8%A7%88%E5%99%A8.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-6400ccc0").then(t)}},{path:"/前端开发/Css/玩转CSS艺术之美/浏览器.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/%E7%8E%A9%E8%BD%ACCSS%E8%89%BA%E6%9C%AF%E4%B9%8B%E7%BE%8E/%E6%B5%8F%E8%A7%88%E5%99%A8.html"},{path:"/前端开发/Css/玩转CSS艺术之美/浏览器.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/%E7%8E%A9%E8%BD%ACCSS%E8%89%BA%E6%9C%AF%E4%B9%8B%E7%BE%8E/%E6%B5%8F%E8%A7%88%E5%99%A8.html"},{name:"v-619cc960",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Html.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-619cc960").then(t)}},{path:"/前端开发/Html.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Html.html"},{path:"/前端开发/Html.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Html.html"},{name:"v-cbef54ee",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Class%E7%B1%BB.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-cbef54ee").then(t)}},{path:"/前端开发/JavaScript/ES6/Class类.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Class%E7%B1%BB.html"},{path:"/前端开发/JavaScript/ES6/Class类.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Class%E7%B1%BB.html"},{name:"v-7bee9c99",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/ES6%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-7bee9c99").then(t)}},{path:"/前端开发/JavaScript/ES6/ES6的新增方法.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/ES6%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.html"},{path:"/前端开发/JavaScript/ES6/ES6的新增方法.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/ES6%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.html"},{name:"v-54a8f500",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Generator.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-54a8f500").then(t)}},{path:"/前端开发/JavaScript/ES6/Generator.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Generator.html"},{path:"/前端开发/JavaScript/ES6/Generator.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Generator.html"},{name:"v-b6571256",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Module%E6%A8%A1%E5%9D%97.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-b6571256").then(t)}},{path:"/前端开发/JavaScript/ES6/Module模块.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Module%E6%A8%A1%E5%9D%97.html"},{path:"/前端开发/JavaScript/ES6/Module模块.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Module%E6%A8%A1%E5%9D%97.html"},{name:"v-1af69640",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Promise.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-1af69640").then(t)}},{path:"/前端开发/JavaScript/ES6/Promise.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Promise.html"},{path:"/前端开发/JavaScript/ES6/Promise.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Promise.html"},{name:"v-e7f7dee2",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-e7f7dee2").then(t)}},{path:"/前端开发/JavaScript/ES6/Set和Map数据结构.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"},{path:"/前端开发/JavaScript/ES6/Set和Map数据结构.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"},{name:"v-7381bf8a",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/let%E5%92%8Cconst.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-7381bf8a").then(t)}},{path:"/前端开发/JavaScript/ES6/let和const.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/let%E5%92%8Cconst.html"},{path:"/前端开发/JavaScript/ES6/let和const.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/let%E5%92%8Cconst.html"},{name:"v-3a0007c8",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E4%B8%8E%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-3a0007c8").then(t)}},{path:"/前端开发/JavaScript/ES6/剩余参数与展开运算符.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E4%B8%8E%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6.html"},{path:"/前端开发/JavaScript/ES6/剩余参数与展开运算符.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E4%B8%8E%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6.html"},{name:"v-1a83c4d8",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-1a83c4d8").then(t)}},{path:"/前端开发/JavaScript/ES6/模板字符串与箭头函数.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0.html"},{path:"/前端开发/JavaScript/ES6/模板字符串与箭头函数.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0.html"},{name:"v-01a65d50",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E5%A2%9E%E5%BC%BA%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-01a65d50").then(t)}},{path:"/前端开发/JavaScript/ES6/对象字面量的增强与函数参数的默认值.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E5%A2%9E%E5%BC%BA%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC.html"},{path:"/前端开发/JavaScript/ES6/对象字面量的增强与函数参数的默认值.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E5%A2%9E%E5%BC%BA%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC.html"},{name:"v-0c0f2fc9",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-0c0f2fc9").then(t)}},{path:"/前端开发/JavaScript/ES6/解构赋值.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html"},{path:"/前端开发/JavaScript/ES6/解构赋值.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html"},{name:"v-30659e0a",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E9%81%8D%E5%8E%86%E5%99%A8%E4%B8%8Efor...of%E5%BE%AA%E7%8E%AF.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-30659e0a").then(t)}},{path:"/前端开发/JavaScript/ES6/遍历器与for...of循环.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E9%81%8D%E5%8E%86%E5%99%A8%E4%B8%8Efor...of%E5%BE%AA%E7%8E%AF.html"},{path:"/前端开发/JavaScript/ES6/遍历器与for...of循环.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E9%81%8D%E5%8E%86%E5%99%A8%E4%B8%8Efor...of%E5%BE%AA%E7%8E%AF.html"},{name:"v-76290fb8",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/BOM.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-76290fb8").then(t)}},{path:"/前端开发/JavaScript/JS基础/BOM.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/BOM.html"},{path:"/前端开发/JavaScript/JS基础/BOM.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/BOM.html"},{name:"v-542bb398",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/DOM.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-542bb398").then(t)}},{path:"/前端开发/JavaScript/JS基础/DOM.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/DOM.html"},{path:"/前端开发/JavaScript/JS基础/DOM.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/DOM.html"},{name:"v-1cd5d196",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-1cd5d196").then(t)}},{path:"/前端开发/JavaScript/JS基础/函数.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0.html"},{path:"/前端开发/JavaScript/JS基础/函数.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0.html"},{name:"v-0905848e",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-0905848e").then(t)}},{path:"/前端开发/JavaScript/JS基础/变量与数据类型.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"},{path:"/前端开发/JavaScript/JS基础/变量与数据类型.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"},{name:"v-861bc42a",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%AC%A6.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-861bc42a").then(t)}},{path:"/前端开发/JavaScript/JS基础/操作符.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%AC%A6.html"},{path:"/前端开发/JavaScript/JS基础/操作符.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%AC%A6.html"},{name:"v-3b874c4a",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-3b874c4a").then(t)}},{path:"/前端开发/JavaScript/JS基础/数组.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84.html"},{path:"/前端开发/JavaScript/JS基础/数组.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84.html"},{name:"v-773a8648",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-773a8648").then(t)}},{path:"/前端开发/JavaScript/JS基础/正则表达式.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"},{path:"/前端开发/JavaScript/JS基础/正则表达式.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"},{name:"v-4fa67b80",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-4fa67b80").then(t)}},{path:"/前端开发/JavaScript/JS基础/面向对象.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"},{path:"/前端开发/JavaScript/JS基础/面向对象.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"},{name:"v-94f2abb4",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-94f2abb4").then(t)}},{path:"/前端开发/JavaScript/JS基础/流程控制语句.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html"},{path:"/前端开发/JavaScript/JS基础/流程控制语句.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html"},{name:"v-0267583d",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-0267583d").then(t)}},{path:"/前端开发/JavaScript/JS设计模式/面向对象.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"},{path:"/前端开发/JavaScript/JS设计模式/面向对象.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"},{name:"v-58f9bc27",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-58f9bc27").then(t)}},{path:"/前端开发/JavaScript/深入理解javascript原型和闭包.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85.html"},{path:"/前端开发/JavaScript/深入理解javascript原型和闭包.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85.html"},{name:"v-00baf344",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E5%9F%BA%E7%A1%80.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-00baf344").then(t)}},{path:"/前端开发/TypeScript/TS基础.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E5%9F%BA%E7%A1%80.html"},{path:"/前端开发/TypeScript/TS基础.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E5%9F%BA%E7%A1%80.html"},{name:"v-b93431e0",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E8%BF%9B%E9%98%B6.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-b93431e0").then(t)}},{path:"/前端开发/TypeScript/TS进阶.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E8%BF%9B%E9%98%B6.html"},{path:"/前端开发/TypeScript/TS进阶.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E8%BF%9B%E9%98%B6.html"},{name:"v-dd911646",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/AntDesgin%E7%BB%84%E4%BB%B6%E5%BA%93.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-dd911646").then(t)}},{path:"/前端开发/前端框架/React/AntDesgin组件库.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/AntDesgin%E7%BB%84%E4%BB%B6%E5%BA%93.html"},{path:"/前端开发/前端框架/React/AntDesgin组件库.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/AntDesgin%E7%BB%84%E4%BB%B6%E5%BA%93.html"},{name:"v-132c28d6",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/JSX%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-132c28d6").then(t)}},{path:"/前端开发/前端框架/React/JSX核心语法.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/JSX%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95.html"},{path:"/前端开发/前端框架/React/JSX核心语法.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/JSX%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95.html"},{name:"v-f89e44c8",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-f89e44c8").then(t)}},{path:"/前端开发/TypeScript/TS面向对象.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"},{path:"/前端开发/TypeScript/TS面向对象.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"},{name:"v-6eeb162e",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React-router.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-6eeb162e").then(t)}},{path:"/前端开发/前端框架/React/React-router.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React-router.html"},{path:"/前端开发/前端框架/React/React-router.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React-router.html"},{name:"v-18f59fc6",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/ReactHook.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-18f59fc6").then(t)}},{path:"/前端开发/前端框架/React/ReactHook.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/ReactHook.html"},{path:"/前端开发/前端框架/React/ReactHook.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/ReactHook.html"},{name:"v-0b0e011c",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%8ETypeScript.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-0b0e011c").then(t)}},{path:"/前端开发/前端框架/React/React与TypeScript.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%8ETypeScript.html"},{path:"/前端开发/前端框架/React/React与TypeScript.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%8ETypeScript.html"},{name:"v-1d8ccd1e",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%ADaxios.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-1d8ccd1e").then(t)}},{path:"/前端开发/前端框架/React/React中axios.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%ADaxios.html"},{path:"/前端开发/前端框架/React/React中axios.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%ADaxios.html"},{name:"v-78a84160",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%AD%E7%9A%84CSS.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-78a84160").then(t)}},{path:"/前端开发/前端框架/React/React中的CSS.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%AD%E7%9A%84CSS.html"},{path:"/前端开发/前端框架/React/React中的CSS.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%AD%E7%9A%84CSS.html"},{name:"v-159e0fe2",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-159e0fe2").then(t)}},{path:"/前端开发/前端框架/React/React好用的库.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93.html"},{path:"/前端开发/前端框架/React/React好用的库.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93.html"},{name:"v-998970b8",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%9A%84SSR.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-998970b8").then(t)}},{path:"/前端开发/前端框架/React/React的SSR.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%9A%84SSR.html"},{path:"/前端开发/前端框架/React/React的SSR.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%9A%84SSR.html"},{name:"v-f594f93a",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%9A%84%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-f594f93a").then(t)}},{path:"/前端开发/前端框架/React/React的过渡动画.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%9A%84%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB.html"},{path:"/前端开发/前端框架/React/React的过渡动画.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%9A%84%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB.html"},{name:"v-2fd9779b",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-2fd9779b").then(t)}},{path:"/前端开发/前端框架/React/React组件化开发.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html"},{path:"/前端开发/前端框架/React/React组件化开发.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html"},{name:"v-0cd5d1ed",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E8%84%9A%E6%89%8B%E6%9E%B6.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-0cd5d1ed").then(t)}},{path:"/前端开发/前端框架/React/React脚手架.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E8%84%9A%E6%89%8B%E6%9E%B6.html"},{path:"/前端开发/前端框架/React/React脚手架.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E8%84%9A%E6%89%8B%E6%9E%B6.html"},{name:"v-f421c146",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/Redux.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-f421c146").then(t)}},{path:"/前端开发/前端框架/React/Redux.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/Redux.html"},{path:"/前端开发/前端框架/React/Redux.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/Redux.html"},{name:"v-3694fad4",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue2%E6%BA%90%E7%A0%81%E5%85%A8%E6%96%B9%E4%BD%8D%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-3694fad4").then(t)}},{path:"/前端开发/前端框架/Vue/Vue2源码全方位深入解析.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue2%E6%BA%90%E7%A0%81%E5%85%A8%E6%96%B9%E4%BD%8D%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90.html"},{path:"/前端开发/前端框架/Vue/Vue2源码全方位深入解析.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue2%E6%BA%90%E7%A0%81%E5%85%A8%E6%96%B9%E4%BD%8D%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90.html"},{name:"v-fe61dbea",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue3.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-fe61dbea").then(t)}},{path:"/前端开发/前端框架/Vue/Vue3.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue3.html"},{path:"/前端开发/前端框架/Vue/Vue3.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue3.html"},{name:"v-078bbb46",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/VueRouter.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-078bbb46").then(t)}},{path:"/前端开发/前端框架/Vue/VueRouter.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/VueRouter.html"},{path:"/前端开发/前端框架/Vue/VueRouter.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/VueRouter.html"},{name:"v-bef5cc7e",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/VueX.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-bef5cc7e").then(t)}},{path:"/前端开发/前端框架/Vue/VueX.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/VueX.html"},{path:"/前端开发/前端框架/Vue/VueX.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/VueX.html"},{name:"v-c3b1654e",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue%E6%A0%B8%E5%BF%83.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-c3b1654e").then(t)}},{path:"/前端开发/前端框架/Vue/Vue核心.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue%E6%A0%B8%E5%BF%83.html"},{path:"/前端开发/前端框架/Vue/Vue核心.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue%E6%A0%B8%E5%BF%83.html"},{name:"v-3092cb6e",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-3092cb6e").then(t)}},{path:"/前端开发/微信小程序.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html"},{path:"/前端开发/微信小程序.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html"},{name:"v-187547cf",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-187547cf").then(t)}},{path:"/前端开发/前端框架/Vue/Vue组件化编程.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B.html"},{path:"/前端开发/前端框架/Vue/Vue组件化编程.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B.html"},{name:"v-1fdb8159",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8Web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-1fdb8159").then(t)}},{path:"/前端开发/移动开发/移动Web开发入门.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8Web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8.html"},{path:"/前端开发/移动开发/移动Web开发入门.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8Web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8.html"},{name:"v-15a2f62d",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/JavaScript.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-15a2f62d").then(t)}},{path:"/前端开发/重学前端/JavaScript.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/JavaScript.html"},{path:"/前端开发/重学前端/JavaScript.html",redirect:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/JavaScript.html"},{name:"v-2ede98c9",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Html%E9%9D%A2%E8%AF%95%E9%A2%98.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-2ede98c9").then(t)}},{path:"/前端面试/Html面试题.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Html%E9%9D%A2%E8%AF%95%E9%A2%98.html"},{path:"/前端面试/Html面试题.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Html%E9%9D%A2%E8%AF%95%E9%A2%98.html"},{name:"v-1180216e",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Css%E9%9D%A2%E8%AF%95%E9%A2%98.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-1180216e").then(t)}},{path:"/前端面试/Css面试题.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Css%E9%9D%A2%E8%AF%95%E9%A2%98.html"},{path:"/前端面试/Css面试题.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Css%E9%9D%A2%E8%AF%95%E9%A2%98.html"},{name:"v-3eb9b545",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/JS%E9%9D%A2%E8%AF%95%E9%A2%98.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-3eb9b545").then(t)}},{path:"/前端面试/JS面试题.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/JS%E9%9D%A2%E8%AF%95%E9%A2%98.html"},{path:"/前端面试/JS面试题.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/JS%E9%9D%A2%E8%AF%95%E9%A2%98.html"},{name:"v-469764e9",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Vue%E9%9D%A2%E8%AF%95%E9%A2%98.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-469764e9").then(t)}},{path:"/前端面试/Vue面试题.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Vue%E9%9D%A2%E8%AF%95%E9%A2%98.html"},{path:"/前端面试/Vue面试题.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Vue%E9%9D%A2%E8%AF%95%E9%A2%98.html"},{name:"v-69ca47ce",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-69ca47ce").then(t)}},{path:"/前端面试/手撕代码.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81.html"},{path:"/前端面试/手撕代码.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81.html"},{name:"v-30c5f9aa",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%BD%91&%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-30c5f9aa").then(t)}},{path:"/前端面试/计网&浏览器面试题.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%BD%91&%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98.html"},{path:"/前端面试/计网&浏览器面试题.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%BD%91&%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98.html"},{name:"v-85f3b0ec",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.12%E6%8A%80%E6%9C%AF%E9%9D%A2.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-85f3b0ec").then(t)}},{path:"/前端面试/面试复盘/21.10.12技术面.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.12%E6%8A%80%E6%9C%AF%E9%9D%A2.html"},{path:"/前端面试/面试复盘/21.10.12技术面.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.12%E6%8A%80%E6%9C%AF%E9%9D%A2.html"},{name:"v-a312ef94",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.20%E6%8A%80%E6%9C%AF%E9%9D%A2%E5%A4%8D%E7%9B%98.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-a312ef94").then(t)}},{path:"/前端面试/面试复盘/21.10.20技术面复盘.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.20%E6%8A%80%E6%9C%AF%E9%9D%A2%E5%A4%8D%E7%9B%98.html"},{path:"/前端面试/面试复盘/21.10.20技术面复盘.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.20%E6%8A%80%E6%9C%AF%E9%9D%A2%E5%A4%8D%E7%9B%98.html"},{name:"v-61e67f96",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.21%E6%8A%80%E6%9C%AF%E9%9D%A2%E5%A4%8D%E7%9B%98.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-61e67f96").then(t)}},{path:"/前端面试/面试复盘/21.10.21技术面复盘.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.21%E6%8A%80%E6%9C%AF%E9%9D%A2%E5%A4%8D%E7%9B%98.html"},{path:"/前端面试/面试复盘/21.10.21技术面复盘.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.21%E6%8A%80%E6%9C%AF%E9%9D%A2%E5%A4%8D%E7%9B%98.html"},{name:"v-3408f9af",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.9.14%E4%B8%80%E9%9D%A2%E5%A4%8D%E7%9B%98.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-3408f9af").then(t)}},{path:"/前端面试/面试复盘/21.9.14一面复盘.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.9.14%E4%B8%80%E9%9D%A2%E5%A4%8D%E7%9B%98.html"},{path:"/前端面试/面试复盘/21.9.14一面复盘.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.9.14%E4%B8%80%E9%9D%A2%E5%A4%8D%E7%9B%98.html"},{name:"v-8097d612",path:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Ajax&Fetch%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-8097d612").then(t)}},{path:"/基础知识/前端相关/Ajax&Fetch与跨域请求.html",redirect:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Ajax&Fetch%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82.html"},{path:"/基础知识/前端相关/Ajax&Fetch与跨域请求.html",redirect:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Ajax&Fetch%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82.html"},{name:"v-7863fde9",path:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-7863fde9").then(t)}},{path:"/基础知识/前端相关/前后端数据交互与HTTP协议.html",redirect:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE.html"},{path:"/基础知识/前端相关/前后端数据交互与HTTP协议.html",redirect:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE.html"},{name:"v-6fb355dc",path:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-6fb355dc").then(t)}},{path:"/基础知识/前端相关/本地存储.html",redirect:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.html"},{path:"/基础知识/前端相关/本地存储.html",redirect:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.html"},{name:"v-185bbf26",path:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/01.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-185bbf26").then(t)}},{path:"/基础知识/前端相关/浏览器工作原理与实践/01.html",redirect:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/01.html"},{path:"/基础知识/前端相关/浏览器工作原理与实践/01.html",redirect:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/01.html"},{name:"v-3cae5cfe",path:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-3cae5cfe").then(t)}},{path:"/基础知识/前端相关/浏览器工作原理与实践/思维导图.html",redirect:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html"},{path:"/基础知识/前端相关/浏览器工作原理与实践/思维导图.html",redirect:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html"},{name:"v-83959742",path:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%A6%82%E8%BF%B0%E7%AF%87.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-83959742").then(t)}},{path:"/基础知识/计算机通识/计算机网络/概述篇.html",redirect:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%A6%82%E8%BF%B0%E7%AF%87.html"},{path:"/基础知识/计算机通识/计算机网络/概述篇.html",redirect:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%A6%82%E8%BF%B0%E7%AF%87.html"},{name:"v-66d6172e",path:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-66d6172e").then(t)}},{path:"/开发工具/Docker.html",redirect:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker.html"},{path:"/开发工具/Docker.html",redirect:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker.html"},{name:"v-5cace148",path:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-5cace148").then(t)}},{path:"/开发工具/git.html",redirect:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git.html"},{path:"/开发工具/git.html",redirect:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git.html"},{name:"v-82023764",path:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/homebrew.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-82023764").then(t)}},{path:"/开发工具/homebrew.html",redirect:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/homebrew.html"},{path:"/开发工具/homebrew.html",redirect:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/homebrew.html"},{name:"v-40014b6e",path:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Babel.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-40014b6e").then(t)}},{path:"/开发工具/前端工具/Babel.html",redirect:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Babel.html"},{path:"/开发工具/前端工具/Babel.html",redirect:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Babel.html"},{name:"v-d895e9e4",path:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Mock.js.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-d895e9e4").then(t)}},{path:"/开发工具/前端工具/Mock.js.html",redirect:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Mock.js.html"},{path:"/开发工具/前端工具/Mock.js.html",redirect:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Mock.js.html"},{name:"v-7201f9e4",path:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Webpack.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-7201f9e4").then(t)}},{path:"/开发工具/前端工具/Webpack.html",redirect:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Webpack.html"},{path:"/开发工具/前端工具/Webpack.html",redirect:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Webpack.html"},{name:"v-5c684536",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/CSS%E5%85%B3%E4%BA%8Edeep%E7%9A%84%E7%94%A8%E6%B3%95.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-5c684536").then(t)}},{path:"/开发记录/CSS/CSS关于deep的用法.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/CSS%E5%85%B3%E4%BA%8Edeep%E7%9A%84%E7%94%A8%E6%B3%95.html"},{path:"/开发记录/CSS/CSS关于deep的用法.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/CSS%E5%85%B3%E4%BA%8Edeep%E7%9A%84%E7%94%A8%E6%B3%95.html"},{name:"v-cfd1bbbe",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/CSS%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-cfd1bbbe").then(t)}},{path:"/开发记录/CSS/CSS文本溢出处理方式.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/CSS%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F.html"},{path:"/开发记录/CSS/CSS文本溢出处理方式.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/CSS%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F.html"},{name:"v-1d9f91d2",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/calc%E5%87%BD%E6%95%B0.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-1d9f91d2").then(t)}},{path:"/开发记录/CSS/calc函数.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/calc%E5%87%BD%E6%95%B0.html"},{path:"/开发记录/CSS/calc函数.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/calc%E5%87%BD%E6%95%B0.html"},{name:"v-03875860",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/Array.prototype.slice.call()&Array.from()%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-03875860").then(t)}},{path:"/开发记录/JS/Array.prototype.slice.call()&Array.from()的应用和理解.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/Array.prototype.slice.call()&Array.from()%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3.html"},{path:"/开发记录/JS/Array.prototype.slice.call()&Array.from()的应用和理解.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/Array.prototype.slice.call()&Array.from()%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3.html"},{name:"v-43456df0",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E5%85%B3%E4%BA%8Easync%E5%92%8Cawait.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-43456df0").then(t)}},{path:"/开发记录/JS/关于async和await.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E5%85%B3%E4%BA%8Easync%E5%92%8Cawait.html"},{path:"/开发记录/JS/关于async和await.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E5%85%B3%E4%BA%8Easync%E5%92%8Cawait.html"},{name:"v-27816f24",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/js%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-27816f24").then(t)}},{path:"/开发记录/JS/js的严格模式.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/js%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html"},{path:"/开发记录/JS/js的严格模式.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/js%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html"},{name:"v-e25d7d4c",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84delete%E5%85%83%E7%B4%A0.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-e25d7d4c").then(t)}},{path:"/开发记录/JS/数组delete元素.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84delete%E5%85%83%E7%B4%A0.html"},{path:"/开发记录/JS/数组delete元素.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84delete%E5%85%83%E7%B4%A0.html"},{name:"v-d81aa7ca",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%A0%B9%E6%8D%AE%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8E%BB%E9%87%8D.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-d81aa7ca").then(t)}},{path:"/开发记录/JS/数组对象根据对象中指定的属性去重.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%A0%B9%E6%8D%AE%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8E%BB%E9%87%8D.html"},{path:"/开发记录/JS/数组对象根据对象中指定的属性去重.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%A0%B9%E6%8D%AE%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8E%BB%E9%87%8D.html"},{name:"v-3fe0e2ee",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%8A%B6%E6%80%81%E5%B1%9E%E6%80%A7%E5%A6%82%E4%BD%95%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-3fe0e2ee").then(t)}},{path:"/开发记录/JS/数组对象根据数据项状态属性如何筛选数据.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%8A%B6%E6%80%81%E5%B1%9E%E6%80%A7%E5%A6%82%E4%BD%95%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE.html"},{path:"/开发记录/JS/数组对象根据数据项状态属性如何筛选数据.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%8A%B6%E6%80%81%E5%B1%9E%E6%80%A7%E5%A6%82%E4%BD%95%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE.html"},{name:"v-29760d32",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E7%90%86%E8%A7%A3js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-29760d32").then(t)}},{path:"/开发记录/JS/理解js事件循环.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E7%90%86%E8%A7%A3js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html"},{path:"/开发记录/JS/理解js事件循环.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E7%90%86%E8%A7%A3js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html"},{name:"v-4a906e56",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-4a906e56").then(t)}},{path:"/开发记录/JS/重新理解闭包.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85.html"},{path:"/开发记录/JS/重新理解闭包.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85.html"},{name:"v-2eca1248",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Node/%E5%9C%A8Vuekoa%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E5%92%8Ccookie%E9%97%AE%E9%A2%98.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-2eca1248").then(t)}},{path:"/开发记录/Node/在Vuekoa项目中如何解决跨域和cookie问题.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Node/%E5%9C%A8Vuekoa%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E5%92%8Ccookie%E9%97%AE%E9%A2%98.html"},{path:"/开发记录/Node/在Vuekoa项目中如何解决跨域和cookie问题.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Node/%E5%9C%A8Vuekoa%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E5%92%8Ccookie%E9%97%AE%E9%A2%98.html"},{name:"v-820a830c",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Node/%E8%AE%B0%E4%B8%80%E6%AC%A1koa2%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-820a830c").then(t)}},{path:"/开发记录/Node/记一次koa2项目部署过程.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Node/%E8%AE%B0%E4%B8%80%E6%AC%A1koa2%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B.html"},{path:"/开发记录/Node/记一次koa2项目部署过程.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Node/%E8%AE%B0%E4%B8%80%E6%AC%A1koa2%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B.html"},{name:"v-7933b2a2",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/React/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-7933b2a2").then(t)}},{path:"/开发记录/React/开发流程管理平台学习心得.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/React/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97.html"},{path:"/开发记录/React/开发流程管理平台学习心得.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/React/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97.html"},{name:"v-8bf3fad8",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/Vue3ElementPlusKoa2%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-8bf3fad8").then(t)}},{path:"/开发记录/Vue/Vue3ElementPlusKoa2全栈开发后台系统学习记录.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/Vue3ElementPlusKoa2%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html"},{path:"/开发记录/Vue/Vue3ElementPlusKoa2全栈开发后台系统学习记录.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/Vue3ElementPlusKoa2%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html"},{name:"v-4ce5dc34",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/vueecharts%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A1%A8%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-4ce5dc34").then(t)}},{path:"/开发记录/Vue/vueecharts数据报表项目学习心得.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/vueecharts%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A1%A8%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97.html"},{path:"/开发记录/Vue/vueecharts数据报表项目学习心得.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/vueecharts%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A1%A8%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97.html"},{name:"v-1c966386",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/vue%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%95%8C%E9%9D%A2%E5%88%B7%E6%96%B0.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-1c966386").then(t)}},{path:"/开发记录/Vue/vue如何实现界面刷新.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/vue%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%95%8C%E9%9D%A2%E5%88%B7%E6%96%B0.html"},{path:"/开发记录/Vue/vue如何实现界面刷新.html",redirect:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/vue%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%95%8C%E9%9D%A2%E5%88%B7%E6%96%B0.html"},{name:"v-379c6be0",path:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-379c6be0").then(t)}},{path:"/数据库/MySQL.html",redirect:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html"},{path:"/数据库/MySQL.html",redirect:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html"},{name:"v-92a93060",path:"/%E6%95%B0%E6%8D%AE%E5%BA%93/mongoDB.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-92a93060").then(t)}},{path:"/数据库/mongoDB.html",redirect:"/%E6%95%B0%E6%8D%AE%E5%BA%93/mongoDB.html"},{path:"/数据库/mongoDB.html",redirect:"/%E6%95%B0%E6%8D%AE%E5%BA%93/mongoDB.html"},{name:"v-ef44e3ec",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%9B%BE.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-ef44e3ec").then(t)}},{path:"/数据结构算法/图.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%9B%BE.html"},{path:"/数据结构算法/图.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%9B%BE.html"},{name:"v-efde0330",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-efde0330").then(t)}},{path:"/数据结构算法/",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"},{path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/index.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"},{path:"/数据结构算法/",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"},{name:"v-180fb8c6",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-180fb8c6").then(t)}},{path:"/数据结构算法/字典.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8.html"},{path:"/数据结构算法/字典.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8.html"},{name:"v-275267e8",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%A0%88.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-275267e8").then(t)}},{path:"/数据结构算法/栈.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%A0%88.html"},{path:"/数据结构算法/栈.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%A0%88.html"},{name:"v-7230c420",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-7230c420").then(t)}},{path:"/数据结构算法/链表.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8.html"},{path:"/数据结构算法/链表.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8.html"},{name:"v-3e3f78e7",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%A0%91.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-3e3f78e7").then(t)}},{path:"/数据结构算法/树.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%A0%91.html"},{path:"/数据结构算法/树.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%A0%91.html"},{name:"v-d0433916",path:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/koa2%E6%A1%86%E6%9E%B6.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-d0433916").then(t)}},{path:"/服务端开发/koa2框架.html",redirect:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/koa2%E6%A1%86%E6%9E%B6.html"},{path:"/服务端开发/koa2框架.html",redirect:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/koa2%E6%A1%86%E6%9E%B6.html"},{name:"v-2c160162",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-2c160162").then(t)}},{path:"/数据结构算法/队列.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97.html"},{path:"/数据结构算法/队列.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97.html"},{name:"v-7fa1a73e",path:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/node%E5%85%A5%E9%97%A8/Node.js%E5%A4%84%E7%90%86HTTP.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-7fa1a73e").then(t)}},{path:"/服务端开发/node入门/Node.js处理HTTP.html",redirect:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/node%E5%85%A5%E9%97%A8/Node.js%E5%A4%84%E7%90%86HTTP.html"},{path:"/服务端开发/node入门/Node.js处理HTTP.html",redirect:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/node%E5%85%A5%E9%97%A8/Node.js%E5%A4%84%E7%90%86HTTP.html"},{name:"v-7306dc59",path:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5node/%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-7306dc59").then(t)}},{path:"/服务端开发/深入node/全局对象和模块化开发.html",redirect:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5node/%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91.html"},{path:"/服务端开发/深入node/全局对象和模块化开发.html",redirect:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5node/%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91.html"},{name:"v-f174bee6",path:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5node/%E9%82%82%E9%80%85Node.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-f174bee6").then(t)}},{path:"/服务端开发/深入node/邂逅Node.html",redirect:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5node/%E9%82%82%E9%80%85Node.html"},{path:"/服务端开发/深入node/邂逅Node.html",redirect:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5node/%E9%82%82%E9%80%85Node.html"},{name:"v-d326b974",path:"/%E6%9D%82%E8%AE%B0.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-d326b974").then(t)}},{path:"/杂记.html",redirect:"/%E6%9D%82%E8%AE%B0.html"},{path:"/杂记.html",redirect:"/%E6%9D%82%E8%AE%B0.html"},{name:"v-565c38b5",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%88.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-565c38b5").then(t)}},{path:"/数据结构算法/集合.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%88.html"},{path:"/数据结构算法/集合.html",redirect:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%88.html"},{name:"v-3f1e209c",path:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/node%E5%85%A5%E9%97%A8/Node.js%E5%9F%BA%E7%A1%80.html",component:je,beforeEnter:function(n,e,t){Object(Qn.a)("Layout","v-3f1e209c").then(t)}},{path:"/服务端开发/node入门/Node.js基础.html",redirect:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/node%E5%85%A5%E9%97%A8/Node.js%E5%9F%BA%E7%A1%80.html"},{path:"/服务端开发/node入门/Node.js基础.html",redirect:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/node%E5%85%A5%E9%97%A8/Node.js%E5%9F%BA%E7%A1%80.html"},{path:"*",component:je}],Se={title:"zfh's notes",description:"一个互联网前端民工的开发笔记库",base:"/",headTags:[["link",{rel:"icon",href:"/favicon.ico"}],["link",{rel:"manifest",href:"/manifest.json"}],["meta",{name:"theme-color",content:"#ffd214"}],["meta",{name:"apple-mobile-web-app-capable",content:"yes"}]],pages:[{title:"Home",frontmatter:{home:!0,heroImage:"https://zfh-oss.oss-cn-shanghai.aliyuncs.com/docs-assets/assets/feDog.png",heroText:"zfh's notes:)",tagline:"无他,惟手熟尔",actionText:"My Blog →",actionLink:"https://zfhblog.top",features:[{title:"🧑🏻‍💻关于作者",details:"菜鸟前端"},{title:"🖥网站内容",details:"关于我接触、学习到的开发技术的笔记以及平时开发记录下来的问题"},{title:"🤔网站愿景",details:"笔记千锤百炼,努力成为一名合格的前端开发工程师"}],footer:"Copyright © 2020-2022 FANHANG ZHANG",readingShow:"top"},regularPath:"/",relativePath:"README.md",key:"v-7dd30b36",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022年07月18日",lastUpdatedTimestamp:1658156035e3},{title:"优质链接🔗",frontmatter:{title:"优质链接🔗",sidebar:"auto",readingShow:"top"},regularPath:"/%E4%BC%98%E8%B4%A8%E9%93%BE%E6%8E%A5.html",relativePath:"优质链接.md",key:"v-6c71d7d8",path:"/%E4%BC%98%E8%B4%A8%E9%93%BE%E6%8E%A5.html",headers:[{level:2,title:"编程导航网站",slug:"编程导航网站",normalizedTitle:"编程导航网站",charIndex:2},{level:2,title:"大佬博客",slug:"大佬博客",normalizedTitle:"大佬博客",charIndex:31},{level:2,title:"前端效率工具",slug:"前端效率工具",normalizedTitle:"前端效率工具",charIndex:177},{level:2,title:"CSS 相关",slug:"css-相关",normalizedTitle:"css 相关",charIndex:310},{level:2,title:"JS/TS 相关",slug:"js-ts-相关",normalizedTitle:"js/ts 相关",charIndex:338},{level:2,title:"前端面试",slug:"前端面试",normalizedTitle:"前端面试",charIndex:449},{level:2,title:"前端成长",slug:"前端成长",normalizedTitle:"前端成长",charIndex:479},{level:2,title:"很酷的项目",slug:"很酷的项目",normalizedTitle:"很酷的项目",charIndex:526},{level:2,title:"后台管理系统框架",slug:"后台管理系统框架",normalizedTitle:"后台管理系统框架",charIndex:559},{level:2,title:"嗯？",slug:"嗯",normalizedTitle:"嗯？",charIndex:666}],headersStr:"编程导航网站 大佬博客 前端效率工具 CSS 相关 JS/TS 相关 前端面试 前端成长 很酷的项目 后台管理系统框架 嗯？",content:"# 编程导航网站\n\n * 编程导航\n * 程序员盒子\n\n\n# 大佬博客\n\n * 花裤衩（vue-element-admin 作者，字节前端 ）\n * 张鑫旭 （css 大神）\n * 廖雪峰\n * 阮一峰（《ES6 入门教程作者》）\n * jspang\n * 被删的前端游乐场（腾讯前端，《前端的进击作者》）\n * 大圣前端编程自学网(学习路线)\n\n\n# 前端效率工具\n\n * iconfont\n * botcdn\n * RGB 颜色值与十六进制颜色码转换工具\n * 简单好用的在线接口 MOCK 平台\n * codepen:一个快速编写前端 demo 的在线平台\n * js 代码可视化执行\n * 天行 API\n\n\n# CSS 相关\n\n * css：游戏学 flex\n\n\n# JS/TS 相关\n\n * 现代 JavaScript 教程\n * javascript-guidebook\n * TypeScript 入门教程\n * ES6 入门教程\n * 可能国内最好的系统学习 TS 的教程\n\n\n# 前端面试\n\n * web 前端面试 - 面试官系列\n\n\n# 前端成长\n\n * 数据可视化\n\n * 开发者：前端学习路线\n\n * 前端小白学习路径\n\n\n# 很酷的项目\n\n * 网易云 api\n * 夕水的个人项目\n\n\n# 后台管理系统框架\n\n * vue-element-admin\n * cool-admin\n * LIN-CMS\n * amis，baidu 低代码前端框架，仅适合开发后台管理系统,不适合需要高度定制的项目\n\n\n# 嗯？\n\n * 程序员做饭指南",normalizedContent:"# 编程导航网站\n\n * 编程导航\n * 程序员盒子\n\n\n# 大佬博客\n\n * 花裤衩（vue-element-admin 作者，字节前端 ）\n * 张鑫旭 （css 大神）\n * 廖雪峰\n * 阮一峰（《es6 入门教程作者》）\n * jspang\n * 被删的前端游乐场（腾讯前端，《前端的进击作者》）\n * 大圣前端编程自学网(学习路线)\n\n\n# 前端效率工具\n\n * iconfont\n * botcdn\n * rgb 颜色值与十六进制颜色码转换工具\n * 简单好用的在线接口 mock 平台\n * codepen:一个快速编写前端 demo 的在线平台\n * js 代码可视化执行\n * 天行 api\n\n\n# css 相关\n\n * css：游戏学 flex\n\n\n# js/ts 相关\n\n * 现代 javascript 教程\n * javascript-guidebook\n * typescript 入门教程\n * es6 入门教程\n * 可能国内最好的系统学习 ts 的教程\n\n\n# 前端面试\n\n * web 前端面试 - 面试官系列\n\n\n# 前端成长\n\n * 数据可视化\n\n * 开发者：前端学习路线\n\n * 前端小白学习路径\n\n\n# 很酷的项目\n\n * 网易云 api\n * 夕水的个人项目\n\n\n# 后台管理系统框架\n\n * vue-element-admin\n * cool-admin\n * lin-cms\n * amis，baidu 低代码前端框架，仅适合开发后台管理系统,不适合需要高度定制的项目\n\n\n# 嗯？\n\n * 程序员做饭指南",charsets:{cjk:!0},lastUpdated:"2022年07月31日",lastUpdatedTimestamp:1659277691e3},{title:"2D与3D转换",frontmatter:{title:"2D与3D转换",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/2D%E4%B8%8E3D%E8%BD%AC%E6%8D%A2.html",relativePath:"前端开发/Css/Css3/2D与3D转换.md",key:"v-35a28194",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/2D%E4%B8%8E3D%E8%BD%AC%E6%8D%A2.html",headers:[{level:2,title:"2d 变形",slug:"_2d-变形",normalizedTitle:"2d 变形",charIndex:2},{level:3,title:"旋转变形",slug:"旋转变形",normalizedTitle:"旋转变形",charIndex:12},{level:3,title:"transform-origin 属性",slug:"transform-origin-属性",normalizedTitle:"transform-origin 属性",charIndex:120},{level:3,title:"缩放变形",slug:"缩放变形",normalizedTitle:"缩放变形",charIndex:219},{level:3,title:"斜切变形",slug:"斜切变形",normalizedTitle:"斜切变形",charIndex:301},{level:3,title:"位移变形",slug:"位移变形",normalizedTitle:"位移变形",charIndex:410},{level:2,title:"3d 旋转",slug:"_3d-旋转",normalizedTitle:"3d 旋转",charIndex:607},{level:3,title:"perspective 属性",slug:"perspective-属性",normalizedTitle:"perspective 属性",charIndex:698},{level:2,title:"空间移动",slug:"空间移动",normalizedTitle:"空间移动",charIndex:852},{level:3,title:"制作一个正方体",slug:"制作一个正方体",normalizedTitle:"制作一个正方体",charIndex:955}],headersStr:"2d 变形 旋转变形 transform-origin 属性 缩放变形 斜切变形 位移变形 3d 旋转 perspective 属性 空间移动 制作一个正方体",content:'# 2d 变形\n\n\n# 旋转变形\n\n * 将 transform 属性的值设置为 rotate()，即可实现旋转变形\n\ntransform: rotate(45deg);\n\n\n * 若角度为正，则顺时针方向旋转，否则逆时针方向旋转\n\n\n# transform-origin 属性\n\n可以使用 transform-origin 属性设置自己的自定义变换原点，默认是以中心点作为变换原点\n\ntransform-origin(MDN)\n\n\n# 缩放变形\n\n * 将 transform 属性的值设置为 scale()，即可实现缩放变形\n * 当数值小于 1 时，表示缩小元素；大于 1 表示放大元素\n\n\n# 斜切变形\n\n将 transform 属性的值设置为 skew()，即可实现斜切变形\n\ntransform: skew(10deg, 20deg) \x3c!---- 第一个值是x斜切角度。第二个值为y斜切角度>;\n\n\n\n# 位移变形\n\n将 transform 属性的值设置为 translate()，即可实现位移变形（以自己为参考点 ）\n\n\x3c!--  translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。 --\x3e\ntransform:translate(-50%,-50%)\ntransform:translate(100px,200px)\n\n\n\n# 3d 旋转\n\n将 transform 属性的值设置为 rotateX（）或者 rotateY（），即可实现绕横轴、纵轴旋转\n\n注：rotateZ 和 rotate 效果一样\n\n\n# perspective 属性\n\nperspective 属性用来定义透视强度，可以理解为“人眼到舞台的距离”，单位是 px\n\n<div class="box">\n    => 舞台 必须设置perspective属性\n    <p></p>\n    => 设置transform属性\n</div>\n\n\n\n# 空间移动\n\n * 当元素进行 3D 旋转后，即可继续添加 translateX()、 translateY()、 translateZ()属性让元素在空间进行移动\n\n * 以当前的旋转面形成坐标轴\n\n\n# 制作一个正方体\n\nSee the Pen 制作一个正方体 by zhangfanhang (@zhangfanhang) on CodePen.',normalizedContent:'# 2d 变形\n\n\n# 旋转变形\n\n * 将 transform 属性的值设置为 rotate()，即可实现旋转变形\n\ntransform: rotate(45deg);\n\n\n * 若角度为正，则顺时针方向旋转，否则逆时针方向旋转\n\n\n# transform-origin 属性\n\n可以使用 transform-origin 属性设置自己的自定义变换原点，默认是以中心点作为变换原点\n\ntransform-origin(mdn)\n\n\n# 缩放变形\n\n * 将 transform 属性的值设置为 scale()，即可实现缩放变形\n * 当数值小于 1 时，表示缩小元素；大于 1 表示放大元素\n\n\n# 斜切变形\n\n将 transform 属性的值设置为 skew()，即可实现斜切变形\n\ntransform: skew(10deg, 20deg) \x3c!---- 第一个值是x斜切角度。第二个值为y斜切角度>;\n\n\n\n# 位移变形\n\n将 transform 属性的值设置为 translate()，即可实现位移变形（以自己为参考点 ）\n\n\x3c!--  translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。 --\x3e\ntransform:translate(-50%,-50%)\ntransform:translate(100px,200px)\n\n\n\n# 3d 旋转\n\n将 transform 属性的值设置为 rotatex（）或者 rotatey（），即可实现绕横轴、纵轴旋转\n\n注：rotatez 和 rotate 效果一样\n\n\n# perspective 属性\n\nperspective 属性用来定义透视强度，可以理解为“人眼到舞台的距离”，单位是 px\n\n<div class="box">\n    => 舞台 必须设置perspective属性\n    <p></p>\n    => 设置transform属性\n</div>\n\n\n\n# 空间移动\n\n * 当元素进行 3d 旋转后，即可继续添加 translatex()、 translatey()、 translatez()属性让元素在空间进行移动\n\n * 以当前的旋转面形成坐标轴\n\n\n# 制作一个正方体\n\nsee the pen 制作一个正方体 by zhangfanhang (@zhangfanhang) on codepen.',charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"基础与盒模型",frontmatter:{title:"基础与盒模型",date:"2022/05/09 21:08:38",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%9B%92%E6%A8%A1%E5%9E%8B.html",relativePath:"前端开发/Css/Css3/基础与盒模型.md",key:"v-288dfe3c",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%9B%92%E6%A8%A1%E5%9E%8B.html",headers:[{level:2,title:"css3 简介",slug:"css3-简介",normalizedTitle:"css3 简介",charIndex:2},{level:2,title:"css3 书写位置",slug:"css3-书写位置",normalizedTitle:"css3 书写位置",charIndex:114},{level:3,title:"内嵌式",slug:"内嵌式",normalizedTitle:"内嵌式",charIndex:128},{level:3,title:"外链式",slug:"外链式",normalizedTitle:"外链式",charIndex:176},{level:3,title:"导入式",slug:"导入式",normalizedTitle:"导入式",charIndex:260},{level:3,title:"行内式",slug:"行内式",normalizedTitle:"行内式",charIndex:403},{level:2,title:"CSS 选择器与伪类",slug:"css-选择器与伪类",normalizedTitle:"css 选择器与伪类",charIndex:443},{level:3,title:"标签选择器",slug:"标签选择器",normalizedTitle:"标签选择器",charIndex:458},{level:3,title:"ID 选择器",slug:"id-选择器",normalizedTitle:"id 选择器",charIndex:694},{level:3,title:"class 选择器",slug:"class-选择器",normalizedTitle:"class 选择器",charIndex:843},{level:3,title:"原子类",slug:"原子类",normalizedTitle:"原子类",charIndex:968},{level:3,title:"复合选择器",slug:"复合选择器",normalizedTitle:"复合选择器",charIndex:1121},{level:3,title:"伪类",slug:"伪类",normalizedTitle:"伪类",charIndex:451},{level:2,title:"CSS3 选择器与伪元素",slug:"css3-选择器与伪元素",normalizedTitle:"css3 选择器与伪元素",charIndex:1692},{level:3,title:"元素关系选择器",slug:"元素关系选择器",normalizedTitle:"元素关系选择器",charIndex:1709},{level:3,title:"序号选择器",slug:"序号选择器",normalizedTitle:"序号选择器",charIndex:1848},{level:3,title:"属性选择器",slug:"属性选择器",normalizedTitle:"属性选择器",charIndex:2346},{level:3,title:"伪元素",slug:"伪元素",normalizedTitle:"伪元素",charIndex:1701},{level:2,title:"层叠性和优先级",slug:"层叠性和优先级",normalizedTitle:"层叠性和优先级",charIndex:3552},{level:3,title:"层叠(cascade)性",slug:"层叠-cascade-性",normalizedTitle:"层叠(cascade)性",charIndex:3564},{level:3,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1353},{level:2,title:"常用文本样式属性",slug:"常用文本样式属性",normalizedTitle:"常用文本样式属性",charIndex:4895},{level:3,title:"color",slug:"color",normalizedTitle:"color",charIndex:420},{level:3,title:"font-size",slug:"font-size",normalizedTitle:"font-size",charIndex:1403},{level:3,title:"font-wight",slug:"font-wight",normalizedTitle:"font-wight",charIndex:5028},{level:3,title:"font-style",slug:"font-style",normalizedTitle:"font-style",charIndex:5096},{level:3,title:"text-decoration",slug:"text-decoration",normalizedTitle:"text-decoration",charIndex:664},{level:2,title:"字体属性:font-family",slug:"字体属性-font-family",normalizedTitle:"字体属性:font-family",charIndex:5237},{level:2,title:"段落和行相关属性",slug:"段落和行相关属性",normalizedTitle:"段落和行相关属性",charIndex:5907},{level:3,title:"text-indent",slug:"text-indent",normalizedTitle:"text-indent",charIndex:5920},{level:3,title:"line-height",slug:"line-height",normalizedTitle:"line-height",charIndex:5997},{level:2,title:"font 合写属性",slug:"font-合写属性",normalizedTitle:"font 合写属性",charIndex:6195},{level:2,title:"继承性",slug:"继承性",normalizedTitle:"继承性",charIndex:6220},{level:2,title:"盒模型",slug:"盒模型",normalizedTitle:"盒模型",charIndex:6944},{level:3,title:"hight 和 width",slug:"hight-和-width",normalizedTitle:"hight 和 width",charIndex:6952},{level:3,title:"padding",slug:"padding",normalizedTitle:"padding",charIndex:7244},{level:3,title:"margin",slug:"margin",normalizedTitle:"margin",charIndex:7546},{level:3,title:"盒模型种类和 box-sizing 属性",slug:"盒模型种类和-box-sizing-属性",normalizedTitle:"盒模型种类和 box-sizing 属性",charIndex:8460},{level:3,title:"行内元素与块级元素",slug:"行内元素与块级元素",normalizedTitle:"行内元素与块级元素",charIndex:9043}],headersStr:"css3 简介 css3 书写位置 内嵌式 外链式 导入式 行内式 CSS 选择器与伪类 标签选择器 ID 选择器 class 选择器 原子类 复合选择器 伪类 CSS3 选择器与伪元素 元素关系选择器 序号选择器 属性选择器 伪元素 层叠性和优先级 层叠(cascade)性 优先级 常用文本样式属性 color font-size font-wight font-style text-decoration 字体属性:font-family 段落和行相关属性 text-indent line-height font 合写属性 继承性 盒模型 hight 和 width padding margin 盒模型种类和 box-sizing 属性 行内元素与块级元素",content:"# css3 简介\n\n * CSS(cascading style sheet，层叠样式表)是用来给HTML 标签添加样式的语言\n\n * CSS3是 CSS 的最新版本，增加了大量的样式、动画、3D 特效和移动端特性等\n\n\n# css3 书写位置\n\n\n# 内嵌式\n\n在 head 标签对中，添加 style标签对，然后在里面书写 css 样式\n\n\n# 外链式\n\n单独创建css 文件，在head标签中，通过 link引入\n\n<link rel=\"stylesheet\" href=\"index.css\" />\n\n\n\n# 导入式\n\n * 导入式是最不常见的样式表导入方法\n * 使用导入式引入的样式表，不会等待 CSS文件加载完毕，而是会立即渲染 HTML 结构\n * 必须写在 style 标签的最开始\n\n<style>\n    @import url(style.css);\n</style>\n\n\n\n# 行内式\n\n<div style=\"color:red\"></div>\n\n\n\n# CSS 选择器与伪类\n\n\n# 标签选择器\n\n * 标签选择器也称元素选择器、类型选择器，它直接使用元素的标签名当做选择器，将选择页面上所有该种标签\n\n * 标签选择器将选择页面上所有该种标签，无论这个标签所处位置的深浅\n\n * 标签选择器“覆盖面”非常大，所以通常用于标签的初始化\n\nul {\n    /* 去掉无序列表的小圆点 */\n    list-style: none;\n}\na {\n    /* 去掉超级链接的下划线 */\n    text-decoration: none;\n}\n\n\n\n# ID 选择器\n\n * 标签可以有 id 属性，是这个标签的唯一标识\n\n * id的名称只能由字母、数字、下划线、短横构成，且不能以数字开头，字母区分大小写，但习惯上一般为小写字母\n\n * 同一个页面上不能有相同 id 的标签\n\n * CSS 选择器可以使用井号#前缀，选择指定id 的标签\n\n\n# class 选择器\n\n * class 属性表示“类名”\n\n * 类名的命名规范和 id 的命名规范相同\n\n * 使用点.前缀选择指定 class 的标签\n\n * 多个标签可以为相同类名\n\n * 同一个标签可以同时属于多个类，类名用空格隔开\n\n\n# 原子类\n\n在做网页项目前，可以将所有的常用字号、文字颜色、行高外边距、内边距等都设置为单独的类\n\n.color-red {\n    color: red;\n}\n\n\nHTML标签就可以“按需选择”它的类名了，这样可以非常快速的添加一些常见样式\n\n<p class=\"color-red\"></p>\n\n\n\n# 复合选择器\n\n选择器名称   示例           示例的意义\n后代选择器   .box .spec   选择类名为 box 的标签内部的类名为 spec 的标签\n交集选择器   li.spec      选择既是 li 标签，也属于 spec 类的标签\n并集选择器   ul,ol        选择所有 ul 和 ol 标签\n\n\n# 伪类\n\n:root\n\n:root 这个CSS伪类匹配文档树的根元素。对于 HTML来说，:root表示html 元素，除了优先级更高之外，与html选择器相同。\n\n/* :root优先级更高 */\n:root {\n    font-size: 100px;\n}\nhtml {\n    font-size: 200px;\n}\n\n\n伪类是添加到选择器的描述性词语，指定要选择的元素的特殊状态，超级链接拥有 4 个特殊状态:\n\n伪类          意义\na:link      没有被访问的超级链接\nA:visited   已经被访问过的超级链接\na:hover     正被鼠标悬停的超级链接\nA:active    正被激活的超级链接 🔗（按下按键但是还没有松开按键）\n\na 标签的伪类书写，要按照“爱恨准则”的顺序，否则会有伪类不生效: LOVE HATE\n\n其他伪类见：css 伪类\n\n\n# CSS3 选择器与伪元素\n\n\n# 元素关系选择器\n\n名称        举例       意义\n子选择器      div>p    div 的子标签 p\n相邻兄弟选择器   img+p    图片后面紧跟着的段落将被选中\n通用兄弟选择器   p~span   p 元素之后的所有同层级 span 元素\n\n\n# 序号选择器\n\n注意\n\n这种写法是错误的：\n\n/* ❌ */\n.box1:first-child {\n    color: red;\n}\n\n\nfirst-child只是一个修饰词语，还需要在前面指定具体是那种标签\n\n/* √ */\n.box1 p:first-child {\n    color: red;\n}\n\n\n:nth-child(odd)表示选中所有序号为偶数的子元素，:nth-child(even)表示选中所有序号为奇数的子元素 除此之外还可以这样写：nth-child(an+b),表示从 b 开始每 a 个选一个\n\n举例                     意义\n:first-child           第 1 个子元素\n:last-child            最后 1 个子元素\n:nth-child(3)          第 3 个子元素\n:nth-of-type(3)        第 3 个某类型子元素\n:nth-last-child(3)     倒数第 3 个子元素\n:nth-last-of-type(3)   倒数第 3 个某类型子元素\n\n\n# 属性选择器\n\n举例                 意义\nimg[alt]           选择有 alt 属性的 img 标签\nimg[alt='故宫']      选择 alt 属性是故宫的 img 标签\nimg[alt^='北京']     选择 alt 属性以北京开头的 img 标签\nimg[alt$='夜景']     选择 alt 属性以夜景结尾的 img 标签\nimg[alt*='美']      选择有 alt 属性中含有美字的 img 标签\nimg[alt~='手机拍摄']   选择有 alt 属性中有空格隔开的手机拍摄字样的 img 标签\nimg[alt|='参赛作品']   选择有 alt 属性以\"参赛作用-”开头的 img 标签\n\n属性选择器不太常用；可以配合自定义属性使用:见 DOM章节\n\n\n# 伪元素\n\n伪元素的特性及其区别\n\n 1. 伪类本质上是为了弥补常规 CSS 选择器的不足，以便获取到更多信息；\n 2. 伪元素本质上是创建了一个有内容的虚拟容器；\n 3. CSS3 中伪类和伪元素的语法不同；\n 4. 可以同时使用多个伪类，而只能同时使用一个伪元素；\n\nCSS3 新增了“伪元素”特性，顾名思义，表示虚拟动态创建的元素\n\n伪元素用双冒号表示\n\n实际项目中可以结合iconfont完成小图标的添加\n\n# ::before ::after\n\n * ::before创建一个伪元素，其将成为匹配选中的元素的第一个子元素，必须设置content属性表示其中的内容\n\ndiv::before {\n    content: '★';\n}\n\n\n * ::after创建一个伪元素，其将成为匹配选中的元素的最后一个子元素，必须设置content属性表示其中的内容\n\n# ::selection\n\n::selection css 伪元素应用于文档中被用户高亮的部分（使用鼠标圈选的部分）\n\n<style>\n    #box1::selection {\n        background-color: green;\n    }\n</style>\n<body>\n    <div id=\"box1\">====>用鼠标选择我看看，我的背景颜色是绿色吗?<====</div>\n</body>\n\n\n# ::first-letter ::first-line\n\n * ::first-letter会选中某元素中（必须是块级元素）第一行的第一个字母\n * ::first-line会选中某元素中（必须是块级元素）第一行全部文字\n\n<style>\n    #box2::first-letter {\n        font-size: 30px;\n    }\n</style>\n<body>\n    <div id=\"box2\">没错，这是一句话</div>\n</body>\n\n\n\n# 层叠性和优先级\n\n\n# 层叠(cascade)性\n\nCSS 处理冲突的一种能力，称之为层叠性\n\n在多个选择器选择同一个标签，然后又设置了相同的属性，才会发生层叠\n\n当发生层叠时，哪个选择器设置的属性起作用，是由优先级来确定\n\n\n# 优先级\n\n浏览器通过优先级来判断哪些属性值与一个元素最为相关，从而在该元素上应用这些属性值\n\n优先级就是分配给指定的 CSS 声明的一个权重，它由 匹配的选择器中的 每一种选择器类型的 数值 决定\n\n而当优先级与多个 CSS 声明中任意一个声明的优先级相等的时候，CSS 中最后的那个声明将会被应用到元素上\n\n# CSS 权重的理解\n\n每一个 css 的选择器都有一个相对的重要程度值，也就是权重的值，简称“权值”\n\ncss 通过 css 选择器的权重占比，来计算 css 选择规则的总权值，从而确定 定义样式规则的 优先级次序\n\ncss 选择规则的优先级 是按照 css 选择器的权值的比较 来确定的\n\n# css 优先级规则\n\n * css 选择规则的权值不同时，权值高的优先\n\n * css 选择规则的权值相同时，后定义的规则优先\n\n * css 属性后面加 !important 时，无条件绝对优先\n\n# 权值的计算\n\n权值等级划分， 一般来说是划分 4 个等级：\n\n * 第一等级：代表 内联样式，如 style=\"\"，权值为 1,0,0,0；\n\n * 第二等级：代表 ID 选择器，如 #id=\"\", 权值为 0,1,0,0；\n\n * 第三等级：代表 calss | 伪类 | 属性选择器，如 .class | :hover,:link,:target | [type], 权值 0,0,1,0；\n\n * 第四等级：代表 标签 | 伪元素 选择器，如 p | ::after, ::before, ::fist-inline, ::selection, 权值 0,0,0,1；\n\n此外，通用选择器（*），元素关系选择器不在 4 等级之内，所以它们的权值都为 0,0,0,0；继承的样式没有权值\n\n特殊的: :not()伪类不参与优先级计算，但:not() 里边的 “选择器” 是参与优先级计算:参考,eg:选择器 div.outer p 和选择器 div:not(.outer) p 的优先级是相同的，:not 被忽略掉了，:not(.outer)中的.outer 正常计数\n\n权值计算 公式：权值 = 第一等级选择器个数，第二等级选择器个数，第三等级选择器个数，第四等级选择器个数\n\n比较规则：\n\n * 1,0,0,0 > 0,99,99,99。也就是说从左往右逐个等级比较，前一等级相等才往后比。\n * 无论是行间、内部和外部样式，都是按照这个规则来进行比较。而不是直观的行间>内部>外部样式；ID>class>元素。之所以有这样的错觉，是因为确实行间为第一等的权重，所以它的权重是最高的。而内部样式可能一般写在了外部样式引用了之后，所以覆盖掉了之前的。\n * 在权重相同的情况下，后面的样式会覆盖掉前面的样式。\n * 通用选择器（*），元素关系选择器，虽然权值为 0,0,0,0，但是也比继承的样式优先，0 权值比无权值优先。\n\n\n# 常用文本样式属性\n\n\n# color\n\ncolor 属性可以设置文本内容的前景色\n\ncolor 属性主要可以用英语单词、十六进制、rgb()、rgba()等表示\n\n\n# font-size\n\n网页文字正文字号通常是 16p×，浏览器最小支持 10px 字号\n\n\n# font-wight\n\n设置字体的粗细程度，通常使用normal（正常粗细与 400 等值）和bold（加粗与 700 等值）\n\n\n# font-style\n\n设置字体的倾斜，常用属性值：italic （设置为倾斜字体）\n\n\n# text-decoration\n\n设置文本的修饰线外观的（下划线，删除线）\n\n * underline 下划线\n * line-through 删除线\n * none 没有下划线\n\n\n# 字体属性:font-family\n\nwebfont 阿里巴巴在线字体\n\n设置字体：\n\nfont-family: serif, 'Times New Roman', '微软雅黑';\n\n\n * 字体可以是列表形式，一般英语字体放到前面，后面的字体是前面的字体的“后备”字体\n\n * 字体名称中有空格，必须用引号包裹\n\n定义字体：\n\n字体文件根据操作系统和浏览器不同，有eot,woff2,woff,ttf,svg文件格式，需要同时有这五种文件\n\n@font-face {\n    font-family: 'YourWebFontName';\n    src: url('YourWebFontName.eot'); /* IE9 Compat Modes */\n    src: url('YourWebFontName.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n            url('YourWebFontName.woff') format('woff'),\n        /* Modern Browsers */ url('YourWebFontName.ttf') format('truetype'), /* Safari, Android, iOS */\n            url('YourWebFontName.svg#YourWebFontName') format('svg'); /* Legacy iOS */\n}\n\n\n\n# 段落和行相关属性\n\n\n# text-indent\n\n定义文本内容之前的缩进量，缩进两个字符应该写作:\n\n/* em表示字符宽度 */\ntext-indent: 2em;\n\n\n\n# line-height\n\n行高=第一行的字符顶端到下一行字符的顶端的距离\n\n属性的单位\n\n * 可以是以 px 为单位的数值\n\n * 也可以是没有单位的数值 表示字号的倍数 这是最推荐的写法\n\n * 也可以是百分数，表示字号的倍数\n\n# 单行文本垂直居中\n\n * 设置行高等于盒子高度，即可实现单行文本垂直居中\n\n\n\n * 设置 text-align:center 即可实现文本水平居中\n\n\n# font 合写属性\n\n参考 MDN 文档\n\n\n# 继承性\n\n * 继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代\n * 并不是所有的属性都可以被继承，只有以color/font-/text-/line-开头的属性才可以被继承\n * CSS 继承性中的特殊性：a标签的字体颜色和下划线是不能继承的，h标签的字体大小是不能继承的,如果我们想要修改超链接和 h 标签的样式，我们只能通过单独选择出来进行单独的设置\n\n在继承的情况下，选择器权重计算失效，而是就近原则\n\neg:\n\n<style>\n    /* 远 */\n    #box1 #box2 {\n        color: red;\n    }\n    /* 近，所以文字是蓝色的 */\n    .box1 .box3 {\n        color: blue;\n    }\n</style>\n<body>\n    <div id=\"box1\" class=\"box1\">\n        <div id=\"box2\" class=\"box2\">\n            <div id=\"box3\" class=\"box3\">\n                <p>我是文字</p>\n            </div>\n        </div>\n    </div>\n</body>\n\n\n和上面的代码同样的结构，文字的颜色依然是蓝色:\n\n<style>\n    /* 继承 */\n    #box1 #box2 #box3 {\n        color: red;\n    }\n    /* 选中 */\n    p {\n        color: blue;\n    }\n</style>\n\n\n\n# 盒模型\n\n\n# hight 和 width\n\n相关优质文章\n\n前端小知识--为什么你写的 height:100%不起作用？\n\n学透 CSS-7 个场景让你深入理解 min/max - width/height\n\n * 行内元素的宽度就是它内容的宽度。\n\n * 当块级元素(div,h,li)没有设置 width 属性的时候，默认为父元素的宽度，但这并不意味着 width 可以继承\n\n为什么 width 不继承？\n\n<div>\n    <p></p>\n</div>\n\n\ndiv 的元素宽度是 500px，如果 width 可以继承，那么 p 元素的 width 应该也是 500px，我给 p 加了 padding：20px，那么最终 p 的宽度应该是 width+paddingleft+paddingright = 500+20+20 = 540px 但是我们审查之后，可以发现，p 的宽度依然是 500px，显然 p 仅仅独占一行，并没有继承 width\n\n * 块级元素的height属性如果不设置，他将自动被内容撑开，如果没有内容，则 height 默认为 0\n\n\n# padding\n\n内边距:盒子边框内壁到文字的距离\n\n# 写法\n\n 1. 四数值写法：上 右 下 左\n 2. 三数值写法：上 左右 下\n 3. 二数值写法：上下 左右\n\n注：marin 写法和 padding 一样\n\n\n# margin\n\n外边距:盒子与盒子之前的距离\n\n单位为百分比时， 以包含元素宽度的百分比指定外边距\n\n# margin 的塌陷\n\n注意\n\n水平方向没有 margin 塌陷。\n\n在垂直方向如果有两个元素的外边距有相遇，在浏览器中加载的真正的外边距不是两个间距的加和，而是两个边距中值比较大的，边距小的塌陷到了边距值大的值内部。\n\n# 两种情况\n\n 1. 同级元素塌陷：上面的元素有下边距，下面的元素有上边距，两个边距相遇，真正盒子间距离是较大的那个值。\n 2. 父子元素塌陷：父子元素之间也会出现 margin 塌陷，\n\n（1）父元素和子元素都设置了同方向的 margin-top 值，两个属性之间没有其他内容进行隔离，导致两个属性相遇，发生 margin 塌陷。\n（2）本身父元素与上一个元素的距离是 0，子元素如果设置了垂直方向的上边距，会带着父级元素一起掉下来（父元素的上边距 0 塌陷到了子元素的上边距 50 里面）。\n\n# 解决方法\n\n（1）同级元素：如果两个元素垂直方向有间距，只需要设置给一个元素，不要进行拆分。\n（2）父子元素：让两个边距不要相遇，中间可以使用父元素 border 或 padding 将边距分隔开；更加常用的方法，父子盒模型之间的距离就不要用子元素的 margin 去设置，而是用父元素的 padding 挤出来。给父级元素添加overflow:hidden，也可以解决这个问题\n\n# 默认 margin\n\n一些元素(body,ul,p)有默认的 margin，开始要清除\n\n* {\n    margin: 0;\n    padding: 0;\n}\n\n\n# 盒子的水平居中\n\nmargin:0 auto 在不同场景下生效条件\n\n块级元素：给定要居中的块级元素的宽度。\n\n行内元素：① 设置 display:block；② 给定要居中的行内元素的宽度。（行内元素设置成块级元素后可以对其宽高进行设置）\n\n行内块元素：设置 display:block。（如 input、button、img 等元素，自带宽度可以不用设置其宽度）\n\n.box {\n    margin: 0 auto;\n}\n\n\n\n# 盒模型种类和 box-sizing 属性\n\n# content-box\n\nW3C标准的盒子模型（标准盒模型）\n\n\n\n# border-box\n\nIE 标准的盒子模型（怪异盒模型）\n\n\n\n# 区别\n\n * content-box\n\nwidth = content(内容的宽度)\n\n标准盒模型下盒子的大小 = content + border + padding + margin\n\n * border-box\n\nwidth = content(内容的宽度) + padding+ border\n\n怪异盒模型下盒子的大小=width（包含content + border + padding） + margin\n\n# 总结\n\n * 标准盒模型在定义 width 宽度后，后面写 padding 和 border 是会改变盒子实际大小。如果需要保持固定大小，需要进行计算。\n\n * 怪异盒模型在定义 width 宽度后，不管怎么写 padding 和 border 宽度都固定在书写时的 width。但是有可能导致内容被压缩，导致布局异常。\n\n# box-sizing 属性\n\n将盒子添加了 box-sizing:border-box 之后，盒子的 width，height 就表示盒子实际占有的宽高，即 padding，border 变为“内缩”，不在“外扩”\n\n\n# 行内元素与块级元素\n\n# 区别\n\n# 行内元素\n\n 1. 可以和其他元素处于一行，不用必须另起一行。\n 2. 元素的高度、宽度及顶部和底部边距不可设置。可以设置padding-left,padding-right,margin-left,margin-right （水平方向有效，竖直方向无效）,可以设置行高line-height\n 3. 元素的宽度就是它包含的文字、图片的宽度。\n\n常见的行内元素有：a、input、img、span\n\n注意\n\n经过测试行内元素的 padding-top 无论设置多大都没有任何效果,而 padding-bottom 在显示效果上确实增加了 ,但其实设置的是无效的。并不会对他周围的元素产生任何影响。\n\n    <style>\n        *{\n            margin: 0;\n            padding: 0;\n        }\n        #small{\n            padding-top:100px;\n            padding-bottom:200px;\n            background-color: red;\n        }\n    </style>\n</head>\n<body>\n    <span id=\"small\">我是span标签</span>\n    <div>我是div标签</div>\n</body>\n\n\n效果图：\n\n\n\n# 块级元素\n\n 1. 每个块级元素都是独自占一行，其后的元素也只能另起一行，并不能两个元素共用一行。\n 2. 元素的高度、宽度、行高和顶底边距都是可以设置的。\n 3. 元素的宽度如果不设置的话，默认为父元素的宽度。\n\n常见的块级元素有 div、p、h1...h6、ol、ul、dl、li、table、form\n\n# 行内块\n\nimg和表单元素是特殊的行内块，他们既可以设置宽度高度，也能并排显示\n\n# 相互转换\n\n使用 dispaly属性\n\n/* 转换为块级元素 */\ndisplay: block;\n/* 转换为行内元素 */\ndisplay: inline;\n/* 转换为行内块元素 */\ndispaly: inline-block;\n\n\n# 元素的隐藏\n\n * 使用 display:none;可以将元素隐藏，元素将彻底放弃位置，如同没有写它的标签一样\n * 使用 visibility:hidden;可以也可以将元素隐藏，但是元素不会放弃自己的位置",normalizedContent:"# css3 简介\n\n * css(cascading style sheet，层叠样式表)是用来给html 标签添加样式的语言\n\n * css3是 css 的最新版本，增加了大量的样式、动画、3d 特效和移动端特性等\n\n\n# css3 书写位置\n\n\n# 内嵌式\n\n在 head 标签对中，添加 style标签对，然后在里面书写 css 样式\n\n\n# 外链式\n\n单独创建css 文件，在head标签中，通过 link引入\n\n<link rel=\"stylesheet\" href=\"index.css\" />\n\n\n\n# 导入式\n\n * 导入式是最不常见的样式表导入方法\n * 使用导入式引入的样式表，不会等待 css文件加载完毕，而是会立即渲染 html 结构\n * 必须写在 style 标签的最开始\n\n<style>\n    @import url(style.css);\n</style>\n\n\n\n# 行内式\n\n<div style=\"color:red\"></div>\n\n\n\n# css 选择器与伪类\n\n\n# 标签选择器\n\n * 标签选择器也称元素选择器、类型选择器，它直接使用元素的标签名当做选择器，将选择页面上所有该种标签\n\n * 标签选择器将选择页面上所有该种标签，无论这个标签所处位置的深浅\n\n * 标签选择器“覆盖面”非常大，所以通常用于标签的初始化\n\nul {\n    /* 去掉无序列表的小圆点 */\n    list-style: none;\n}\na {\n    /* 去掉超级链接的下划线 */\n    text-decoration: none;\n}\n\n\n\n# id 选择器\n\n * 标签可以有 id 属性，是这个标签的唯一标识\n\n * id的名称只能由字母、数字、下划线、短横构成，且不能以数字开头，字母区分大小写，但习惯上一般为小写字母\n\n * 同一个页面上不能有相同 id 的标签\n\n * css 选择器可以使用井号#前缀，选择指定id 的标签\n\n\n# class 选择器\n\n * class 属性表示“类名”\n\n * 类名的命名规范和 id 的命名规范相同\n\n * 使用点.前缀选择指定 class 的标签\n\n * 多个标签可以为相同类名\n\n * 同一个标签可以同时属于多个类，类名用空格隔开\n\n\n# 原子类\n\n在做网页项目前，可以将所有的常用字号、文字颜色、行高外边距、内边距等都设置为单独的类\n\n.color-red {\n    color: red;\n}\n\n\nhtml标签就可以“按需选择”它的类名了，这样可以非常快速的添加一些常见样式\n\n<p class=\"color-red\"></p>\n\n\n\n# 复合选择器\n\n选择器名称   示例           示例的意义\n后代选择器   .box .spec   选择类名为 box 的标签内部的类名为 spec 的标签\n交集选择器   li.spec      选择既是 li 标签，也属于 spec 类的标签\n并集选择器   ul,ol        选择所有 ul 和 ol 标签\n\n\n# 伪类\n\n:root\n\n:root 这个css伪类匹配文档树的根元素。对于 html来说，:root表示html 元素，除了优先级更高之外，与html选择器相同。\n\n/* :root优先级更高 */\n:root {\n    font-size: 100px;\n}\nhtml {\n    font-size: 200px;\n}\n\n\n伪类是添加到选择器的描述性词语，指定要选择的元素的特殊状态，超级链接拥有 4 个特殊状态:\n\n伪类          意义\na:link      没有被访问的超级链接\na:visited   已经被访问过的超级链接\na:hover     正被鼠标悬停的超级链接\na:active    正被激活的超级链接 🔗（按下按键但是还没有松开按键）\n\na 标签的伪类书写，要按照“爱恨准则”的顺序，否则会有伪类不生效: love hate\n\n其他伪类见：css 伪类\n\n\n# css3 选择器与伪元素\n\n\n# 元素关系选择器\n\n名称        举例       意义\n子选择器      div>p    div 的子标签 p\n相邻兄弟选择器   img+p    图片后面紧跟着的段落将被选中\n通用兄弟选择器   p~span   p 元素之后的所有同层级 span 元素\n\n\n# 序号选择器\n\n注意\n\n这种写法是错误的：\n\n/* ❌ */\n.box1:first-child {\n    color: red;\n}\n\n\nfirst-child只是一个修饰词语，还需要在前面指定具体是那种标签\n\n/* √ */\n.box1 p:first-child {\n    color: red;\n}\n\n\n:nth-child(odd)表示选中所有序号为偶数的子元素，:nth-child(even)表示选中所有序号为奇数的子元素 除此之外还可以这样写：nth-child(an+b),表示从 b 开始每 a 个选一个\n\n举例                     意义\n:first-child           第 1 个子元素\n:last-child            最后 1 个子元素\n:nth-child(3)          第 3 个子元素\n:nth-of-type(3)        第 3 个某类型子元素\n:nth-last-child(3)     倒数第 3 个子元素\n:nth-last-of-type(3)   倒数第 3 个某类型子元素\n\n\n# 属性选择器\n\n举例                 意义\nimg[alt]           选择有 alt 属性的 img 标签\nimg[alt='故宫']      选择 alt 属性是故宫的 img 标签\nimg[alt^='北京']     选择 alt 属性以北京开头的 img 标签\nimg[alt$='夜景']     选择 alt 属性以夜景结尾的 img 标签\nimg[alt*='美']      选择有 alt 属性中含有美字的 img 标签\nimg[alt~='手机拍摄']   选择有 alt 属性中有空格隔开的手机拍摄字样的 img 标签\nimg[alt|='参赛作品']   选择有 alt 属性以\"参赛作用-”开头的 img 标签\n\n属性选择器不太常用；可以配合自定义属性使用:见 dom章节\n\n\n# 伪元素\n\n伪元素的特性及其区别\n\n 1. 伪类本质上是为了弥补常规 css 选择器的不足，以便获取到更多信息；\n 2. 伪元素本质上是创建了一个有内容的虚拟容器；\n 3. css3 中伪类和伪元素的语法不同；\n 4. 可以同时使用多个伪类，而只能同时使用一个伪元素；\n\ncss3 新增了“伪元素”特性，顾名思义，表示虚拟动态创建的元素\n\n伪元素用双冒号表示\n\n实际项目中可以结合iconfont完成小图标的添加\n\n# ::before ::after\n\n * ::before创建一个伪元素，其将成为匹配选中的元素的第一个子元素，必须设置content属性表示其中的内容\n\ndiv::before {\n    content: '★';\n}\n\n\n * ::after创建一个伪元素，其将成为匹配选中的元素的最后一个子元素，必须设置content属性表示其中的内容\n\n# ::selection\n\n::selection css 伪元素应用于文档中被用户高亮的部分（使用鼠标圈选的部分）\n\n<style>\n    #box1::selection {\n        background-color: green;\n    }\n</style>\n<body>\n    <div id=\"box1\">====>用鼠标选择我看看，我的背景颜色是绿色吗?<====</div>\n</body>\n\n\n# ::first-letter ::first-line\n\n * ::first-letter会选中某元素中（必须是块级元素）第一行的第一个字母\n * ::first-line会选中某元素中（必须是块级元素）第一行全部文字\n\n<style>\n    #box2::first-letter {\n        font-size: 30px;\n    }\n</style>\n<body>\n    <div id=\"box2\">没错，这是一句话</div>\n</body>\n\n\n\n# 层叠性和优先级\n\n\n# 层叠(cascade)性\n\ncss 处理冲突的一种能力，称之为层叠性\n\n在多个选择器选择同一个标签，然后又设置了相同的属性，才会发生层叠\n\n当发生层叠时，哪个选择器设置的属性起作用，是由优先级来确定\n\n\n# 优先级\n\n浏览器通过优先级来判断哪些属性值与一个元素最为相关，从而在该元素上应用这些属性值\n\n优先级就是分配给指定的 css 声明的一个权重，它由 匹配的选择器中的 每一种选择器类型的 数值 决定\n\n而当优先级与多个 css 声明中任意一个声明的优先级相等的时候，css 中最后的那个声明将会被应用到元素上\n\n# css 权重的理解\n\n每一个 css 的选择器都有一个相对的重要程度值，也就是权重的值，简称“权值”\n\ncss 通过 css 选择器的权重占比，来计算 css 选择规则的总权值，从而确定 定义样式规则的 优先级次序\n\ncss 选择规则的优先级 是按照 css 选择器的权值的比较 来确定的\n\n# css 优先级规则\n\n * css 选择规则的权值不同时，权值高的优先\n\n * css 选择规则的权值相同时，后定义的规则优先\n\n * css 属性后面加 !important 时，无条件绝对优先\n\n# 权值的计算\n\n权值等级划分， 一般来说是划分 4 个等级：\n\n * 第一等级：代表 内联样式，如 style=\"\"，权值为 1,0,0,0；\n\n * 第二等级：代表 id 选择器，如 #id=\"\", 权值为 0,1,0,0；\n\n * 第三等级：代表 calss | 伪类 | 属性选择器，如 .class | :hover,:link,:target | [type], 权值 0,0,1,0；\n\n * 第四等级：代表 标签 | 伪元素 选择器，如 p | ::after, ::before, ::fist-inline, ::selection, 权值 0,0,0,1；\n\n此外，通用选择器（*），元素关系选择器不在 4 等级之内，所以它们的权值都为 0,0,0,0；继承的样式没有权值\n\n特殊的: :not()伪类不参与优先级计算，但:not() 里边的 “选择器” 是参与优先级计算:参考,eg:选择器 div.outer p 和选择器 div:not(.outer) p 的优先级是相同的，:not 被忽略掉了，:not(.outer)中的.outer 正常计数\n\n权值计算 公式：权值 = 第一等级选择器个数，第二等级选择器个数，第三等级选择器个数，第四等级选择器个数\n\n比较规则：\n\n * 1,0,0,0 > 0,99,99,99。也就是说从左往右逐个等级比较，前一等级相等才往后比。\n * 无论是行间、内部和外部样式，都是按照这个规则来进行比较。而不是直观的行间>内部>外部样式；id>class>元素。之所以有这样的错觉，是因为确实行间为第一等的权重，所以它的权重是最高的。而内部样式可能一般写在了外部样式引用了之后，所以覆盖掉了之前的。\n * 在权重相同的情况下，后面的样式会覆盖掉前面的样式。\n * 通用选择器（*），元素关系选择器，虽然权值为 0,0,0,0，但是也比继承的样式优先，0 权值比无权值优先。\n\n\n# 常用文本样式属性\n\n\n# color\n\ncolor 属性可以设置文本内容的前景色\n\ncolor 属性主要可以用英语单词、十六进制、rgb()、rgba()等表示\n\n\n# font-size\n\n网页文字正文字号通常是 16p×，浏览器最小支持 10px 字号\n\n\n# font-wight\n\n设置字体的粗细程度，通常使用normal（正常粗细与 400 等值）和bold（加粗与 700 等值）\n\n\n# font-style\n\n设置字体的倾斜，常用属性值：italic （设置为倾斜字体）\n\n\n# text-decoration\n\n设置文本的修饰线外观的（下划线，删除线）\n\n * underline 下划线\n * line-through 删除线\n * none 没有下划线\n\n\n# 字体属性:font-family\n\nwebfont 阿里巴巴在线字体\n\n设置字体：\n\nfont-family: serif, 'times new roman', '微软雅黑';\n\n\n * 字体可以是列表形式，一般英语字体放到前面，后面的字体是前面的字体的“后备”字体\n\n * 字体名称中有空格，必须用引号包裹\n\n定义字体：\n\n字体文件根据操作系统和浏览器不同，有eot,woff2,woff,ttf,svg文件格式，需要同时有这五种文件\n\n@font-face {\n    font-family: 'yourwebfontname';\n    src: url('yourwebfontname.eot'); /* ie9 compat modes */\n    src: url('yourwebfontname.eot?#iefix') format('embedded-opentype'), /* ie6-ie8 */\n            url('yourwebfontname.woff') format('woff'),\n        /* modern browsers */ url('yourwebfontname.ttf') format('truetype'), /* safari, android, ios */\n            url('yourwebfontname.svg#yourwebfontname') format('svg'); /* legacy ios */\n}\n\n\n\n# 段落和行相关属性\n\n\n# text-indent\n\n定义文本内容之前的缩进量，缩进两个字符应该写作:\n\n/* em表示字符宽度 */\ntext-indent: 2em;\n\n\n\n# line-height\n\n行高=第一行的字符顶端到下一行字符的顶端的距离\n\n属性的单位\n\n * 可以是以 px 为单位的数值\n\n * 也可以是没有单位的数值 表示字号的倍数 这是最推荐的写法\n\n * 也可以是百分数，表示字号的倍数\n\n# 单行文本垂直居中\n\n * 设置行高等于盒子高度，即可实现单行文本垂直居中\n\n\n\n * 设置 text-align:center 即可实现文本水平居中\n\n\n# font 合写属性\n\n参考 mdn 文档\n\n\n# 继承性\n\n * 继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代\n * 并不是所有的属性都可以被继承，只有以color/font-/text-/line-开头的属性才可以被继承\n * css 继承性中的特殊性：a标签的字体颜色和下划线是不能继承的，h标签的字体大小是不能继承的,如果我们想要修改超链接和 h 标签的样式，我们只能通过单独选择出来进行单独的设置\n\n在继承的情况下，选择器权重计算失效，而是就近原则\n\neg:\n\n<style>\n    /* 远 */\n    #box1 #box2 {\n        color: red;\n    }\n    /* 近，所以文字是蓝色的 */\n    .box1 .box3 {\n        color: blue;\n    }\n</style>\n<body>\n    <div id=\"box1\" class=\"box1\">\n        <div id=\"box2\" class=\"box2\">\n            <div id=\"box3\" class=\"box3\">\n                <p>我是文字</p>\n            </div>\n        </div>\n    </div>\n</body>\n\n\n和上面的代码同样的结构，文字的颜色依然是蓝色:\n\n<style>\n    /* 继承 */\n    #box1 #box2 #box3 {\n        color: red;\n    }\n    /* 选中 */\n    p {\n        color: blue;\n    }\n</style>\n\n\n\n# 盒模型\n\n\n# hight 和 width\n\n相关优质文章\n\n前端小知识--为什么你写的 height:100%不起作用？\n\n学透 css-7 个场景让你深入理解 min/max - width/height\n\n * 行内元素的宽度就是它内容的宽度。\n\n * 当块级元素(div,h,li)没有设置 width 属性的时候，默认为父元素的宽度，但这并不意味着 width 可以继承\n\n为什么 width 不继承？\n\n<div>\n    <p></p>\n</div>\n\n\ndiv 的元素宽度是 500px，如果 width 可以继承，那么 p 元素的 width 应该也是 500px，我给 p 加了 padding：20px，那么最终 p 的宽度应该是 width+paddingleft+paddingright = 500+20+20 = 540px 但是我们审查之后，可以发现，p 的宽度依然是 500px，显然 p 仅仅独占一行，并没有继承 width\n\n * 块级元素的height属性如果不设置，他将自动被内容撑开，如果没有内容，则 height 默认为 0\n\n\n# padding\n\n内边距:盒子边框内壁到文字的距离\n\n# 写法\n\n 1. 四数值写法：上 右 下 左\n 2. 三数值写法：上 左右 下\n 3. 二数值写法：上下 左右\n\n注：marin 写法和 padding 一样\n\n\n# margin\n\n外边距:盒子与盒子之前的距离\n\n单位为百分比时， 以包含元素宽度的百分比指定外边距\n\n# margin 的塌陷\n\n注意\n\n水平方向没有 margin 塌陷。\n\n在垂直方向如果有两个元素的外边距有相遇，在浏览器中加载的真正的外边距不是两个间距的加和，而是两个边距中值比较大的，边距小的塌陷到了边距值大的值内部。\n\n# 两种情况\n\n 1. 同级元素塌陷：上面的元素有下边距，下面的元素有上边距，两个边距相遇，真正盒子间距离是较大的那个值。\n 2. 父子元素塌陷：父子元素之间也会出现 margin 塌陷，\n\n（1）父元素和子元素都设置了同方向的 margin-top 值，两个属性之间没有其他内容进行隔离，导致两个属性相遇，发生 margin 塌陷。\n（2）本身父元素与上一个元素的距离是 0，子元素如果设置了垂直方向的上边距，会带着父级元素一起掉下来（父元素的上边距 0 塌陷到了子元素的上边距 50 里面）。\n\n# 解决方法\n\n（1）同级元素：如果两个元素垂直方向有间距，只需要设置给一个元素，不要进行拆分。\n（2）父子元素：让两个边距不要相遇，中间可以使用父元素 border 或 padding 将边距分隔开；更加常用的方法，父子盒模型之间的距离就不要用子元素的 margin 去设置，而是用父元素的 padding 挤出来。给父级元素添加overflow:hidden，也可以解决这个问题\n\n# 默认 margin\n\n一些元素(body,ul,p)有默认的 margin，开始要清除\n\n* {\n    margin: 0;\n    padding: 0;\n}\n\n\n# 盒子的水平居中\n\nmargin:0 auto 在不同场景下生效条件\n\n块级元素：给定要居中的块级元素的宽度。\n\n行内元素：① 设置 display:block；② 给定要居中的行内元素的宽度。（行内元素设置成块级元素后可以对其宽高进行设置）\n\n行内块元素：设置 display:block。（如 input、button、img 等元素，自带宽度可以不用设置其宽度）\n\n.box {\n    margin: 0 auto;\n}\n\n\n\n# 盒模型种类和 box-sizing 属性\n\n# content-box\n\nw3c标准的盒子模型（标准盒模型）\n\n\n\n# border-box\n\nie 标准的盒子模型（怪异盒模型）\n\n\n\n# 区别\n\n * content-box\n\nwidth = content(内容的宽度)\n\n标准盒模型下盒子的大小 = content + border + padding + margin\n\n * border-box\n\nwidth = content(内容的宽度) + padding+ border\n\n怪异盒模型下盒子的大小=width（包含content + border + padding） + margin\n\n# 总结\n\n * 标准盒模型在定义 width 宽度后，后面写 padding 和 border 是会改变盒子实际大小。如果需要保持固定大小，需要进行计算。\n\n * 怪异盒模型在定义 width 宽度后，不管怎么写 padding 和 border 宽度都固定在书写时的 width。但是有可能导致内容被压缩，导致布局异常。\n\n# box-sizing 属性\n\n将盒子添加了 box-sizing:border-box 之后，盒子的 width，height 就表示盒子实际占有的宽高，即 padding，border 变为“内缩”，不在“外扩”\n\n\n# 行内元素与块级元素\n\n# 区别\n\n# 行内元素\n\n 1. 可以和其他元素处于一行，不用必须另起一行。\n 2. 元素的高度、宽度及顶部和底部边距不可设置。可以设置padding-left,padding-right,margin-left,margin-right （水平方向有效，竖直方向无效）,可以设置行高line-height\n 3. 元素的宽度就是它包含的文字、图片的宽度。\n\n常见的行内元素有：a、input、img、span\n\n注意\n\n经过测试行内元素的 padding-top 无论设置多大都没有任何效果,而 padding-bottom 在显示效果上确实增加了 ,但其实设置的是无效的。并不会对他周围的元素产生任何影响。\n\n    <style>\n        *{\n            margin: 0;\n            padding: 0;\n        }\n        #small{\n            padding-top:100px;\n            padding-bottom:200px;\n            background-color: red;\n        }\n    </style>\n</head>\n<body>\n    <span id=\"small\">我是span标签</span>\n    <div>我是div标签</div>\n</body>\n\n\n效果图：\n\n\n\n# 块级元素\n\n 1. 每个块级元素都是独自占一行，其后的元素也只能另起一行，并不能两个元素共用一行。\n 2. 元素的高度、宽度、行高和顶底边距都是可以设置的。\n 3. 元素的宽度如果不设置的话，默认为父元素的宽度。\n\n常见的块级元素有 div、p、h1...h6、ol、ul、dl、li、table、form\n\n# 行内块\n\nimg和表单元素是特殊的行内块，他们既可以设置宽度高度，也能并排显示\n\n# 相互转换\n\n使用 dispaly属性\n\n/* 转换为块级元素 */\ndisplay: block;\n/* 转换为行内元素 */\ndisplay: inline;\n/* 转换为行内块元素 */\ndispaly: inline-block;\n\n\n# 元素的隐藏\n\n * 使用 display:none;可以将元素隐藏，元素将彻底放弃位置，如同没有写它的标签一样\n * 使用 visibility:hidden;可以也可以将元素隐藏，但是元素不会放弃自己的位置",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"浮动与定位",frontmatter:{title:"浮动与定位",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D.html",relativePath:"前端开发/Css/Css3/浮动与定位.md",key:"v-57a6865a",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D.html",headers:[{level:2,title:"浮动",slug:"浮动",normalizedTitle:"浮动",charIndex:2},{level:3,title:"浮动使用的要点",slug:"浮动使用的要点",normalizedTitle:"浮动使用的要点",charIndex:21},{level:3,title:"浮动的顺序贴靠特性",slug:"浮动的顺序贴靠特性",normalizedTitle:"浮动的顺序贴靠特性",charIndex:77},{level:3,title:"浮动的元素一定能设置宽高",slug:"浮动的元素一定能设置宽高",normalizedTitle:"浮动的元素一定能设置宽高",charIndex:128},{level:3,title:"利用浮动实现网页布局",slug:"利用浮动实现网页布局",normalizedTitle:"利用浮动实现网页布局",charIndex:206},{level:3,title:"BFC 规范和浏览器差异",slug:"bfc-规范和浏览器差异",normalizedTitle:"bfc 规范和浏览器差异",charIndex:296},{level:3,title:"清除浮动",slug:"清除浮动",normalizedTitle:"清除浮动",charIndex:908},{level:2,title:"定位",slug:"定位",normalizedTitle:"定位",charIndex:1965},{level:3,title:"相对定位",slug:"相对定位",normalizedTitle:"相对定位",charIndex:1972},{level:3,title:"绝对定位",slug:"绝对定位",normalizedTitle:"绝对定位",charIndex:2155},{level:3,title:"固定定位",slug:"固定定位",normalizedTitle:"固定定位",charIndex:2316},{level:3,title:"粘性定位",slug:"粘性定位",normalizedTitle:"粘性定位",charIndex:3035}],headersStr:"浮动 浮动使用的要点 浮动的顺序贴靠特性 浮动的元素一定能设置宽高 利用浮动实现网页布局 BFC 规范和浏览器差异 清除浮动 定位 相对定位 绝对定位 固定定位 粘性定位",content:"# 浮动\n\n最本质功能：实现并排\n\n\n# 浮动使用的要点\n\n * 要浮动，并排的盒子都要设置浮动\n * 父盒子要有足够的宽度，否则子盒子会掉下去\n\n\n# 浮动的顺序贴靠特性\n\n子盒子会按顺序进行贴靠，如果没有足够空间，则会寻找再前一个兄弟元素\n\n\n\n\n# 浮动的元素一定能设置宽高\n\n浮动的元素不再区分块级元素、行内元素，已经脱离了标准文档流，一律能够设置宽度和高度，即使它是 span 或者 a 标签\n\n\n# 利用浮动实现网页布局\n\n * 垂直显示的盒子，不要设置浮动，只有并排显示的盒子才要设置浮动\n * “大盒子带着小盒子跑”，一个大盒子中，又是一个小天地内部可以继续使用浮动\n\n\n# BFC 规范和浏览器差异\n\nBFC（ Box Formatting Context，块级格式化上下文）是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然\n\n一个盒子不设置 height，当内容子元素都浮动时，无法撑起自身我们就说这个盒子没有形成 BFC\n\nSee the Pen Untitled by zhangfanhang (@zhangfanhang) on CodePen.\n\n# 如何创建 BFC\n\n 1. float 的值不是 none\n 2. positon的值不是 static 或者 relative\n 3. display 的值是 inline-block,flex,或者 inline-flex\n 4. overflow:hidden\n\noverflow:hidden 的三个作用\n\n 1. 溢出隐藏:给一个元素中设置 overflow:hidden，那么该元素的内容若超出了给定的宽度和高度属性，那么超出的部分将会被隐藏，不占位。一般情况下，在页面中，一般溢出后会显示省略号，比如，当一行文本超出固定宽度就隐藏超出的内容显示省略号。\n\noverflow: hidden; /*溢出隐藏*/\nwhite-space: nowrap; /*规定文本不进行换行*/\ntext-overflow: ellipsis; /*当对象内文本溢出时显示省略标记（...）*/\n\n\n 2. 清除浮动(即形成BFC)\n 3. 解决外边距塌陷(即形成BFC)\n\n# BFC 的作用\n\n 1. 清除浮动\n 2. BFC 可以取消盒子margin 塌陷\n 3. BFC 可以可以阻止元素被浮动元素覆盖(没有实战意义，本身是一种错误的现象，要浮动都浮动)\n\n\n# 清除浮动\n\n清除浮动：浮动一定要封闭到一个盒子中，否则就会对页面后续元素产生影响\n\n# 清除浮动的方法\n\n父盒子没有设置高度，就会出现下图的问题:\n\n\n\n    <style>\n    *{\n        margin:0;\n        padding:0;\n    }\n        p{\n            float: left;\n            width: 100px;\n            height: 100px;\n            background-color:orange;\n            margin-right: 20px;\n        }\n    </style>\n</head>\n<body>\n    <div>\n        <p></p>\n        <p></p>\n    </div>\n    <div>\n        <p></p>\n        <p></p>\n    </div>\n</body>\n\n\n因为盒子内容不知道的情况下不好设置高度,可采用下面几张方法：\n\n 1. 让内部有浮动的父盒子形成 BFC，它就能关闭住内部的浮动。此时最好的方法就是 overflow:hidden 属性\n\n 2. 给后面的父盒子设置 clear:both 属性。clear 表示清除浮动对自己的影响，both 表示左右浮动都清除（不太推荐，此时两个父盒子的高度仍然为 0,margin 失效）\n\n 3. 使用::after伪元素给盒子添加最后一个子元素，并且给::after 设置 clear:both(margin有效)\n\n/*   给两个盒子加上clearfix类名    */\n.clearfix::after {\n    content: '';\n    clear: both;\n    /*  一定要转为块级元素  */\n    display: block;\n}\n\n\n 4. 在两个盒子之间加一个div 盒子，设置clear:both（此时两个父盒子仍然没有高度，margin 失效，但是可以通过设置两个父盒子之间的盒子的高度实现缝隙效果）\n\n\n# 定位\n\n\n# 相对定位\n\nposition:relative;\n\n * 盒子可以相对自己原来的位置进行位置调整，称为相对定位\n * 相对定位的元素，会在“老家留坑”，本质上仍然是在原来的位置，只不过渲染在新的地方而已，渲染的图形可以比喻成“影子”，不会对页面其他元素产生任何影响，有可能会出现覆盖其他元素的情况\n\n# 用途\n\n 1. 微调元素位置\n 2. 相对定位的元素，可以用作绝对定位的参考盒子\n\n\n# 绝对定位\n\nposition:absloute;\n\n盒子可以在浏览器中以坐标进行位置精准描述，拥有自己的绝对位置\n\n# 绝对定位脱离标准文档流\n\n * 绝对定位的元素脱离标准文档流，将释放自己的位置，对其他元素不会产生任何干扰，而是对它们进行压盖。\n * 脱离标准文档流的方法：浮动、绝对定位、固定定位\n\n# 绝对定位的参考盒子\n\n * 绝对定位的盒子会以自己祖先元素中，离自己最近的拥有定位属性的盒子，当做基准点。这个盒子通常是相对定位的，所以这个性质也叫作“ 子绝父相 ”\n * 如果所有的父元素都没有显式地定义position属性，绝对定位的盒子会根据浏览器视口来定位\n\n# 绝对定位的盒子垂直水平居中\n\nposition: absloute;\n/* 距离浏览器上边50%  */\ntop: 50%;\nmargin-top: -自己高度的一半;\nleft: 50%;\nmargin-left: -自己宽度的一半;\n\n\n在不知道自身宽高的情况下，可以利用 translate()来进行水平垂直居中\n\nposition: absolute;\ntop: 50%;\nleft: 50%;\n/* translate(-50%,-50%)作用是，往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。  */\ntransform: translate(-50%, -50%);\n\n\n# 堆叠顺序 z-index 属性\n\nz-index 仅能在定位元素上奏效,元素可拥有负的z-index属性值\n\nz- index数值大的能够压住数值小的\n\n# 用途\n\n 1. 压盖、遮罩效果\n 2. css精灵图\n 3. 结合 js 实现动画\n\n\n# 固定定位\n\nposition:fixed\n\n * 固定定位与绝对定位相似，但元素的包含块为 viewport视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素\n * 固定定位脱离标准文档流\n\n# 用途\n\n 1. 返回顶部\n 2. 楼层导航\n\n> 代码见： BOM 章节\n\n\n# 粘性定位\n\nposition:sticky 粘性定位的几种巧妙应用\n\nposition: sticky;\n\n * 粘性元素根据滚动位置在相对relative和固定fixed之间切换。起先它会被相对定位，直到在视口中遇到给定的偏移位置为止 - 然后将其“粘贴”在适当的位置\n * 粘性定位元素不会脱离文档流，依然占据文档流的指定位置\n\nSee the Pen 粘性定位小demo-1 by zhangfanhang (@zhangfanhang) on CodePen.",normalizedContent:"# 浮动\n\n最本质功能：实现并排\n\n\n# 浮动使用的要点\n\n * 要浮动，并排的盒子都要设置浮动\n * 父盒子要有足够的宽度，否则子盒子会掉下去\n\n\n# 浮动的顺序贴靠特性\n\n子盒子会按顺序进行贴靠，如果没有足够空间，则会寻找再前一个兄弟元素\n\n\n\n\n# 浮动的元素一定能设置宽高\n\n浮动的元素不再区分块级元素、行内元素，已经脱离了标准文档流，一律能够设置宽度和高度，即使它是 span 或者 a 标签\n\n\n# 利用浮动实现网页布局\n\n * 垂直显示的盒子，不要设置浮动，只有并排显示的盒子才要设置浮动\n * “大盒子带着小盒子跑”，一个大盒子中，又是一个小天地内部可以继续使用浮动\n\n\n# bfc 规范和浏览器差异\n\nbfc（ box formatting context，块级格式化上下文）是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然\n\n一个盒子不设置 height，当内容子元素都浮动时，无法撑起自身我们就说这个盒子没有形成 bfc\n\nsee the pen untitled by zhangfanhang (@zhangfanhang) on codepen.\n\n# 如何创建 bfc\n\n 1. float 的值不是 none\n 2. positon的值不是 static 或者 relative\n 3. display 的值是 inline-block,flex,或者 inline-flex\n 4. overflow:hidden\n\noverflow:hidden 的三个作用\n\n 1. 溢出隐藏:给一个元素中设置 overflow:hidden，那么该元素的内容若超出了给定的宽度和高度属性，那么超出的部分将会被隐藏，不占位。一般情况下，在页面中，一般溢出后会显示省略号，比如，当一行文本超出固定宽度就隐藏超出的内容显示省略号。\n\noverflow: hidden; /*溢出隐藏*/\nwhite-space: nowrap; /*规定文本不进行换行*/\ntext-overflow: ellipsis; /*当对象内文本溢出时显示省略标记（...）*/\n\n\n 2. 清除浮动(即形成bfc)\n 3. 解决外边距塌陷(即形成bfc)\n\n# bfc 的作用\n\n 1. 清除浮动\n 2. bfc 可以取消盒子margin 塌陷\n 3. bfc 可以可以阻止元素被浮动元素覆盖(没有实战意义，本身是一种错误的现象，要浮动都浮动)\n\n\n# 清除浮动\n\n清除浮动：浮动一定要封闭到一个盒子中，否则就会对页面后续元素产生影响\n\n# 清除浮动的方法\n\n父盒子没有设置高度，就会出现下图的问题:\n\n\n\n    <style>\n    *{\n        margin:0;\n        padding:0;\n    }\n        p{\n            float: left;\n            width: 100px;\n            height: 100px;\n            background-color:orange;\n            margin-right: 20px;\n        }\n    </style>\n</head>\n<body>\n    <div>\n        <p></p>\n        <p></p>\n    </div>\n    <div>\n        <p></p>\n        <p></p>\n    </div>\n</body>\n\n\n因为盒子内容不知道的情况下不好设置高度,可采用下面几张方法：\n\n 1. 让内部有浮动的父盒子形成 bfc，它就能关闭住内部的浮动。此时最好的方法就是 overflow:hidden 属性\n\n 2. 给后面的父盒子设置 clear:both 属性。clear 表示清除浮动对自己的影响，both 表示左右浮动都清除（不太推荐，此时两个父盒子的高度仍然为 0,margin 失效）\n\n 3. 使用::after伪元素给盒子添加最后一个子元素，并且给::after 设置 clear:both(margin有效)\n\n/*   给两个盒子加上clearfix类名    */\n.clearfix::after {\n    content: '';\n    clear: both;\n    /*  一定要转为块级元素  */\n    display: block;\n}\n\n\n 4. 在两个盒子之间加一个div 盒子，设置clear:both（此时两个父盒子仍然没有高度，margin 失效，但是可以通过设置两个父盒子之间的盒子的高度实现缝隙效果）\n\n\n# 定位\n\n\n# 相对定位\n\nposition:relative;\n\n * 盒子可以相对自己原来的位置进行位置调整，称为相对定位\n * 相对定位的元素，会在“老家留坑”，本质上仍然是在原来的位置，只不过渲染在新的地方而已，渲染的图形可以比喻成“影子”，不会对页面其他元素产生任何影响，有可能会出现覆盖其他元素的情况\n\n# 用途\n\n 1. 微调元素位置\n 2. 相对定位的元素，可以用作绝对定位的参考盒子\n\n\n# 绝对定位\n\nposition:absloute;\n\n盒子可以在浏览器中以坐标进行位置精准描述，拥有自己的绝对位置\n\n# 绝对定位脱离标准文档流\n\n * 绝对定位的元素脱离标准文档流，将释放自己的位置，对其他元素不会产生任何干扰，而是对它们进行压盖。\n * 脱离标准文档流的方法：浮动、绝对定位、固定定位\n\n# 绝对定位的参考盒子\n\n * 绝对定位的盒子会以自己祖先元素中，离自己最近的拥有定位属性的盒子，当做基准点。这个盒子通常是相对定位的，所以这个性质也叫作“ 子绝父相 ”\n * 如果所有的父元素都没有显式地定义position属性，绝对定位的盒子会根据浏览器视口来定位\n\n# 绝对定位的盒子垂直水平居中\n\nposition: absloute;\n/* 距离浏览器上边50%  */\ntop: 50%;\nmargin-top: -自己高度的一半;\nleft: 50%;\nmargin-left: -自己宽度的一半;\n\n\n在不知道自身宽高的情况下，可以利用 translate()来进行水平垂直居中\n\nposition: absolute;\ntop: 50%;\nleft: 50%;\n/* translate(-50%,-50%)作用是，往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。  */\ntransform: translate(-50%, -50%);\n\n\n# 堆叠顺序 z-index 属性\n\nz-index 仅能在定位元素上奏效,元素可拥有负的z-index属性值\n\nz- index数值大的能够压住数值小的\n\n# 用途\n\n 1. 压盖、遮罩效果\n 2. css精灵图\n 3. 结合 js 实现动画\n\n\n# 固定定位\n\nposition:fixed\n\n * 固定定位与绝对定位相似，但元素的包含块为 viewport视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素\n * 固定定位脱离标准文档流\n\n# 用途\n\n 1. 返回顶部\n 2. 楼层导航\n\n> 代码见： bom 章节\n\n\n# 粘性定位\n\nposition:sticky 粘性定位的几种巧妙应用\n\nposition: sticky;\n\n * 粘性元素根据滚动位置在相对relative和固定fixed之间切换。起先它会被相对定位，直到在视口中遇到给定的偏移位置为止 - 然后将其“粘贴”在适当的位置\n * 粘性定位元素不会脱离文档流，依然占据文档流的指定位置\n\nsee the pen 粘性定位小demo-1 by zhangfanhang (@zhangfanhang) on codepen.",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"背景与渐变",frontmatter:{title:"背景与渐变",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%83%8C%E6%99%AF%E4%B8%8E%E6%B8%90%E5%8F%98.html",relativePath:"前端开发/Css/Css3/背景与渐变.md",key:"v-39e06f8c",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%83%8C%E6%99%AF%E4%B8%8E%E6%B8%90%E5%8F%98.html",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:2},{level:3,title:"bgckground-color",slug:"bgckground-color",normalizedTitle:"bgckground-color",charIndex:9},{level:3,title:"background-image",slug:"background-image",normalizedTitle:"background-image",charIndex:86},{level:3,title:"background-repeat",slug:"background-repeat",normalizedTitle:"background-repeat",charIndex:163},{level:3,title:"background-size",slug:"background-size",normalizedTitle:"background-size",charIndex:272},{level:3,title:"background-clip",slug:"background-clip",normalizedTitle:"background-clip",charIndex:575},{level:3,title:"background-attachment",slug:"background-attachment",normalizedTitle:"background-attachment",charIndex:733},{level:3,title:"background-position",slug:"background-position",normalizedTitle:"background-position",charIndex:870},{level:3,title:"CSS 精灵",slug:"css-精灵",normalizedTitle:"css 精灵",charIndex:1001},{level:3,title:"background 综合属性",slug:"background-综合属性",normalizedTitle:"background 综合属性",charIndex:1155},{level:2,title:"渐变",slug:"渐变",normalizedTitle:"渐变",charIndex:1296},{level:3,title:"线性渐变",slug:"线性渐变",normalizedTitle:"线性渐变",charIndex:1303},{level:3,title:"径向渐变",slug:"径向渐变",normalizedTitle:"径向渐变",charIndex:1574}],headersStr:"背景 bgckground-color background-image background-repeat background-size background-clip background-attachment background-position CSS 精灵 background 综合属性 渐变 线性渐变 径向渐变",content:"# 背景\n\n\n# bgckground-color\n\n * 表示背景颜色\n * 可以用十六进制，rgb(),rgba()\n * padding 区域是有背景颜色的\n\n\n# background-image\n\n用来设置背景图片，图片路径要写到 ur1()圆括号中，可以是相对路径，也可以是 http://开头的绝对路径\n\n\n# background-repeat\n\n用来设置背景的重复模式\n\n * repeat:x，y 均平铺（默认）\n * repeat-x:x 平铺\n * repeat-y:y 平铺\n * no-repeat:不平铺\n\n\n# background-size\n\n * 属性用来设置背景图片的尺寸\n\nbackground-size：100px 200px；宽度 高度\n\n\n * 值也可以用百分数来设置，表示为盒子宽、高的百分之多少\n * 需要等比例设置的值，写 auto\n\n# contain 和 cover\n\n * contain 和 cover 是两个特殊的 background-size 的值\n\n * contain 表示将背景图片智能改变尺寸以容纳到盒子里\n\n * cover 表示将背景图片智能改变尺寸以撑满盒子\n   \n   注意\n   \n   \n\n上面是 contain:很明显 cover 会裁剪图片 :::\n\n\n# background-clip\n\n用来设置元素的背景裁切到哪个盒子\n\n * border-box:背景延伸至边框（默认值）\n * padding-box:背景延伸至内边（ padding），不会绘制到边框处（仅在 dotted、 dashed 边框可察觉）\n * content-box:背景被裁剪至内容区\n\n\n# background-attachment\n\n决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。\n\n * fixed:自己滚动条不动，外部滚动条不动\n * local:自己滚动条动，外部滚动条动\n * scroll:自己滚动条不动，外部滚动条动（默认值）\n\n\n# background-position\n\n * 可以设置背景图片出现在盒子的什么位置\n\nbackground-position：100px 200px；\n\n\n * 可以用 top、 bottom、 center、left、right 描述图片出现的位置\n\n\n# CSS 精灵\n\n * CSS 精灵：将多个小图标合并制作到一张图片上，使用 background-position 属性单独显示其中一个，这样的技术叫做 CSS 精灵技术，也叫作 CSS 雪碧图\n * CSS 精灵可以減少 HTTP 请求数，加快网页显示速度。缺点也很明显：不方便测量、后期改动麻烦\n\n\n# background 综合属性\n\n更多细节见 MDN 文档\n\nbackground\n\nbackground: white url(images/archer.png) no-repeat center center；;\n\n\n从左到右：背景颜色 背景图片 背景重复 背景位置\n\n\n# 渐变\n\n\n# 线性渐变\n\n * 盒子的 background-image 属性可以用 linear-gradient()形式创建线性渐变背景\n\nbackground-image: linear-gradient(to right, blue, red);\n\n\nto 渐变方向 开始颜色 结束颜色\n\n * 渐变方向也可以写成度数 eg:45deg\n\n * 可以有多个颜色值，并且可以用百分数定义它们出现的位置\n\nbackground-image: linear-gradient(to right, blue, yellow 20%, red);\n\n\n\n# 径向渐变\n\n盒子的 background- image 属性可以用 radial- gradient()形式创建径向渐变背景\n\nbackground-image: radial-gradient(50% 50%, blue, red);\n\n\n百分数代表圆心坐标",normalizedContent:"# 背景\n\n\n# bgckground-color\n\n * 表示背景颜色\n * 可以用十六进制，rgb(),rgba()\n * padding 区域是有背景颜色的\n\n\n# background-image\n\n用来设置背景图片，图片路径要写到 ur1()圆括号中，可以是相对路径，也可以是 http://开头的绝对路径\n\n\n# background-repeat\n\n用来设置背景的重复模式\n\n * repeat:x，y 均平铺（默认）\n * repeat-x:x 平铺\n * repeat-y:y 平铺\n * no-repeat:不平铺\n\n\n# background-size\n\n * 属性用来设置背景图片的尺寸\n\nbackground-size：100px 200px；宽度 高度\n\n\n * 值也可以用百分数来设置，表示为盒子宽、高的百分之多少\n * 需要等比例设置的值，写 auto\n\n# contain 和 cover\n\n * contain 和 cover 是两个特殊的 background-size 的值\n\n * contain 表示将背景图片智能改变尺寸以容纳到盒子里\n\n * cover 表示将背景图片智能改变尺寸以撑满盒子\n   \n   注意\n   \n   \n\n上面是 contain:很明显 cover 会裁剪图片 :::\n\n\n# background-clip\n\n用来设置元素的背景裁切到哪个盒子\n\n * border-box:背景延伸至边框（默认值）\n * padding-box:背景延伸至内边（ padding），不会绘制到边框处（仅在 dotted、 dashed 边框可察觉）\n * content-box:背景被裁剪至内容区\n\n\n# background-attachment\n\n决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。\n\n * fixed:自己滚动条不动，外部滚动条不动\n * local:自己滚动条动，外部滚动条动\n * scroll:自己滚动条不动，外部滚动条动（默认值）\n\n\n# background-position\n\n * 可以设置背景图片出现在盒子的什么位置\n\nbackground-position：100px 200px；\n\n\n * 可以用 top、 bottom、 center、left、right 描述图片出现的位置\n\n\n# css 精灵\n\n * css 精灵：将多个小图标合并制作到一张图片上，使用 background-position 属性单独显示其中一个，这样的技术叫做 css 精灵技术，也叫作 css 雪碧图\n * css 精灵可以減少 http 请求数，加快网页显示速度。缺点也很明显：不方便测量、后期改动麻烦\n\n\n# background 综合属性\n\n更多细节见 mdn 文档\n\nbackground\n\nbackground: white url(images/archer.png) no-repeat center center；;\n\n\n从左到右：背景颜色 背景图片 背景重复 背景位置\n\n\n# 渐变\n\n\n# 线性渐变\n\n * 盒子的 background-image 属性可以用 linear-gradient()形式创建线性渐变背景\n\nbackground-image: linear-gradient(to right, blue, red);\n\n\nto 渐变方向 开始颜色 结束颜色\n\n * 渐变方向也可以写成度数 eg:45deg\n\n * 可以有多个颜色值，并且可以用百分数定义它们出现的位置\n\nbackground-image: linear-gradient(to right, blue, yellow 20%, red);\n\n\n\n# 径向渐变\n\n盒子的 background- image 属性可以用 radial- gradient()形式创建径向渐变背景\n\nbackground-image: radial-gradient(50% 50%, blue, red);\n\n\n百分数代表圆心坐标",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"边框圆角与盒子阴影",frontmatter:{title:"边框圆角与盒子阴影",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%BE%B9%E6%A1%86%E5%9C%86%E8%A7%92%E4%B8%8E%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1.html",relativePath:"前端开发/Css/Css3/边框圆角与盒子阴影.md",key:"v-4c4aff17",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%BE%B9%E6%A1%86%E5%9C%86%E8%A7%92%E4%B8%8E%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1.html",headers:[{level:2,title:"边框",slug:"边框",normalizedTitle:"边框",charIndex:2},{level:3,title:"边框的三要素",slug:"边框的三要素",normalizedTitle:"边框的三要素",charIndex:9},{level:3,title:"四个方向的边框",slug:"四个方向的边框",normalizedTitle:"四个方向的边框",charIndex:266},{level:2,title:"圆角",slug:"圆角",normalizedTitle:"圆角",charIndex:686},{level:3,title:"border-radius 属性",slug:"border-radius-属性",normalizedTitle:"border-radius 属性",charIndex:693},{level:3,title:"单独设置四个圆角",slug:"单独设置四个圆角",normalizedTitle:"单独设置四个圆角",charIndex:771},{level:3,title:"也可以利用小属性单独设置四个圆角",slug:"也可以利用小属性单独设置四个圆角",normalizedTitle:"也可以利用小属性单独设置四个圆角",charIndex:836},{level:3,title:"百分比为单位",slug:"百分比为单位",normalizedTitle:"百分比为单位",charIndex:888},{level:3,title:"正圆形",slug:"正圆形",normalizedTitle:"正圆形",charIndex:943},{level:2,title:"盒子阴影",slug:"盒子阴影",normalizedTitle:"盒子阴影",charIndex:975},{level:3,title:"box-shadow属性",slug:"box-shadow属性",normalizedTitle:"box-shadow属性",charIndex:984},{level:3,title:"阴影延展",slug:"阴影延展",normalizedTitle:"阴影延展",charIndex:1096},{level:3,title:"内阴影",slug:"内阴影",normalizedTitle:"内阴影",charIndex:1153},{level:3,title:"多阴影",slug:"多阴影",normalizedTitle:"多阴影",charIndex:1215}],headersStr:"边框 边框的三要素 四个方向的边框 圆角 border-radius 属性 单独设置四个圆角 也可以利用小属性单独设置四个圆角 百分比为单位 正圆形 盒子阴影 box-shadow属性 阴影延展 内阴影 多阴影",content:"# 边框\n\n\n# 边框的三要素\n\n * border属性\n\nborder:1px solid red\n//  线宽度 线型  线颜色                                                                 \n\n\n * 线型\n\n 1. solid实线\n 2. dashed虚线\n 3. dotted 点状线\n\n * 边框的三要素可以拆分为小属性\n\n 1. border-width 线宽\n 2. border-style 线型\n 3. border-color 线颜色\n\n\n# 四个方向的边框\n\nborder-top //上边框 \n......\n\n\n\n * 同样，四个方向边框的三要素也可以拆分为小属性\n\nborder-top-width //上边框宽度\nborder-top-style //上边框线型\n......\n\n\n * 去掉边框\n\nborder-left: none // 属性即可以去掉左边框，以此类推\n\n\n * 利用边框制作三角形\n\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-bottom: 100px solid red;\n\n\n * 在给表格加边框时,消除边框之间的缝隙:\n   \n   table{\n     border-collapse:collapse;\n   }\n   \n   \n\n\n# 圆角\n\n\n# border-radius 属性\n\nborder-radius 属性的值通常为px单位。表示圆角的半径。\n\nborder-radius:10px\n\n\n\n# 单独设置四个圆角\n\nborder-radius:10px 20px 30px 40px\n// 左上 右上 右下 左下 \n\n\n\n# 也可以利用小属性单独设置四个圆角\n\nborder-top-left-radius //左上角\n\n\n\n# 百分比为单位\n\nborder-radius属性的值也可以用百分比做单位，表示圆角起始于每条边的哪里。\n\n\n# 正圆形\n\n  border-radius: 50%;\n\n\n\n# 盒子阴影\n\n\n# box-shadow属性\n\nbox-shadow 属性用来实现盒子的阴影\n\n  box-shadow: 10px 20px 30px rgba(0, 0, 0, 0.4);\n// x偏移，y偏移，模糊量，颜色  \n\n\n\n# 阴影延展\n\nbox-shadow:10px 20px 30px 40px rgba(0,0,0,.4)\n\n\n\n# 内阴影\n\nbox-shadow:inset 10px 20px 30px 40px rgba(0,0,0,.4)\n\n\n\n# 多阴影\n\nbox-shadow 属性值可以用逗号隔开多个，表示携带多个阴影\n\n  box-shadow: 10px 20px 30px 40px blue, 10px 20px 100px 40px green;\n",normalizedContent:"# 边框\n\n\n# 边框的三要素\n\n * border属性\n\nborder:1px solid red\n//  线宽度 线型  线颜色                                                                 \n\n\n * 线型\n\n 1. solid实线\n 2. dashed虚线\n 3. dotted 点状线\n\n * 边框的三要素可以拆分为小属性\n\n 1. border-width 线宽\n 2. border-style 线型\n 3. border-color 线颜色\n\n\n# 四个方向的边框\n\nborder-top //上边框 \n......\n\n\n\n * 同样，四个方向边框的三要素也可以拆分为小属性\n\nborder-top-width //上边框宽度\nborder-top-style //上边框线型\n......\n\n\n * 去掉边框\n\nborder-left: none // 属性即可以去掉左边框，以此类推\n\n\n * 利用边框制作三角形\n\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-bottom: 100px solid red;\n\n\n * 在给表格加边框时,消除边框之间的缝隙:\n   \n   table{\n     border-collapse:collapse;\n   }\n   \n   \n\n\n# 圆角\n\n\n# border-radius 属性\n\nborder-radius 属性的值通常为px单位。表示圆角的半径。\n\nborder-radius:10px\n\n\n\n# 单独设置四个圆角\n\nborder-radius:10px 20px 30px 40px\n// 左上 右上 右下 左下 \n\n\n\n# 也可以利用小属性单独设置四个圆角\n\nborder-top-left-radius //左上角\n\n\n\n# 百分比为单位\n\nborder-radius属性的值也可以用百分比做单位，表示圆角起始于每条边的哪里。\n\n\n# 正圆形\n\n  border-radius: 50%;\n\n\n\n# 盒子阴影\n\n\n# box-shadow属性\n\nbox-shadow 属性用来实现盒子的阴影\n\n  box-shadow: 10px 20px 30px rgba(0, 0, 0, 0.4);\n// x偏移，y偏移，模糊量，颜色  \n\n\n\n# 阴影延展\n\nbox-shadow:10px 20px 30px 40px rgba(0,0,0,.4)\n\n\n\n# 内阴影\n\nbox-shadow:inset 10px 20px 30px 40px rgba(0,0,0,.4)\n\n\n\n# 多阴影\n\nbox-shadow 属性值可以用逗号隔开多个，表示携带多个阴影\n\n  box-shadow: 10px 20px 30px 40px blue, 10px 20px 100px 40px green;\n",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"过渡与动画",frontmatter:{title:"过渡与动画",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB.html",relativePath:"前端开发/Css/Css3/过渡与动画.md",key:"v-73b464c0",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Css3/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB.html",headers:[{level:2,title:"过渡",slug:"过渡",normalizedTitle:"过渡",charIndex:2},{level:3,title:"兼容性",slug:"兼容性",normalizedTitle:"兼容性",charIndex:69},{level:3,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:178},{level:3,title:"参数",slug:"参数",normalizedTitle:"参数",charIndex:221},{level:3,title:"哪些属性可以参与过渡",slug:"哪些属性可以参与过渡",normalizedTitle:"哪些属性可以参与过渡",charIndex:438},{level:3,title:"注意项",slug:"注意项",normalizedTitle:"注意项",charIndex:570},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:61},{level:3,title:"动画的定义和调用",slug:"动画的定义和调用",normalizedTitle:"动画的定义和调用",charIndex:1068},{level:3,title:"animation-iteration-count",slug:"animation-iteration-count",normalizedTitle:"animation-iteration-count",charIndex:1423},{level:3,title:"animation-direction",slug:"animation-direction",normalizedTitle:"animation-direction",charIndex:1544},{level:3,title:"animation-fill-mode",slug:"animation-fill-mode",normalizedTitle:"animation-fill-mode",charIndex:1684},{level:3,title:"animation-play-state",slug:"animation-play-state",normalizedTitle:"animation-play-state",charIndex:1823},{level:3,title:"多关键帧动画",slug:"多关键帧动画",normalizedTitle:"多关键帧动画",charIndex:2025},{level:3,title:"Animate.css",slug:"animate-css",normalizedTitle:"animate.css",charIndex:2419},{level:2,title:"过渡与动画的对比",slug:"过渡与动画的对比",normalizedTitle:"过渡与动画的对比",charIndex:2502},{level:3,title:"transition 过渡",slug:"transition-过渡",normalizedTitle:"transition 过渡",charIndex:6},{level:3,title:"animation 动画",slug:"animation-动画",normalizedTitle:"animation 动画",charIndex:2660},{level:3,title:"应用场景分析",slug:"应用场景分析",normalizedTitle:"应用场景分析",charIndex:2785}],headersStr:"过渡 兼容性 基本使用 参数 哪些属性可以参与过渡 注意项 动画 动画的定义和调用 animation-iteration-count animation-direction animation-fill-mode animation-play-state 多关键帧动画 Animate.css 过渡与动画的对比 transition 过渡 animation 动画 应用场景分析",content:'# 过渡\n\ntransition 过渡属性是 CSS3 浓墨重彩的特性，过渡可以为一个元素在不同样式之间变化自动添加“补间动画"\n\n\n# 兼容性\n\n * 过渡从 IE10 开始兼容，移动端兼容良好\n * 曾几何时，网页上的动画特效基本都是由 Javascript 定时器实现的，现在逐步改为使用 CSS3 过渡\n * 优点：动画更细腻，内存开销小\n\n\n# 基本使用\n\ntransition: width 1s linear 0s;\n\n\n\n# 参数\n\ntransition: all 1s cubic-bezier(0.46, 1.02, 0.49, -0.86) 0s;\n\n\n1:什么属性要过渡 2：动画时长 3：变化速度曲线 4：延迟时间\n\n * 如果要所有属性都参与过渡，可以写 all\n * transition 的第三个参数就是缓动参数，也是变化速度曲线\n * 网站https://cubic-bezier.com/可以生成贝塞尔曲线，可以自定义动画缓动参数\n\n\n# 哪些属性可以参与过渡\n\n * 所有数值类型的属性，都可以参与过渡，比如 Width、 height、left、top、 border- radius、 opacity\n * 背景颜色和文字颜色都可以被过渡\n * 所有变形（包括 2D 和 3D）都能被过渡\n\n\n# 注意项\n\n# 过渡与动画的时间要写单位\n\ntransition 属性中的过渡时间 transition-duration、延时时间 transition-delay，animation 属性中的动画时间 animation-duration、动画延时时间 animation-delay 都需要写单位，不写则会没有过渡、动画效果。\n\n# 最好设置初始状态\n\n部分需要过渡的属性，如果不设置初始状态，会没有过渡效果 以 left 值为例，当不设置 left 的初始值时：\n\n\n\n.box {\n    width: 100px;\n    height: 100px;\n    position: relative;\n    background-color: black;\n    /* 初始时，添加上left值 */\n    left: 0;\n    transition: all 1s linear 0s;\n}\n.box:hover {\n    left: 200px;\n}\n\n\n添加之后：\n\n\n\n# 过渡要定义在元素的开始状态上，而不是结束状态上\n\n\n# 动画\n\nanimation\n\n\n# 动画的定义和调用\n\n * 可以使用@ keyframes 来定义动画， keyframes 表示“关键帧”\n\n@keyframes r {\n    from {\n        transform: rotate(0);\n    }\n    to {\n        transform: rotate(360deg);\n    }\n}\n\n\n * 定义动画之后，就可以使用 animation 属性调用动画\n\nanimation: r 1s linear 0s 1;\n\n\n从左到右依次为：动画名称，总时长，缓动效果，延迟，执行次数\n\n对应属性名称:animation-name，animation-duration, animation-timing-function，animation-delay\n\n\n# animation-iteration-count\n\n第5个参数定义动画在结束前运行的次数 可以是 1 次 无限循环.\n\nanimation: r 1s linear 0s infinite;\n\n\ninfinite:无限循环播放动画\n\n\n# animation-direction\n\n第6个参数CSS 属性指示动画是否反向播放\n\nanimation: r 1s linear 0s infinite reverse;\n\n\n如果想让动画的第 2、4、6…（偶数次）自动逆向执行， 使用 alternate 参数即可\n\n\n# animation-fill-mode\n\n第7个参数设置 CSS 动画在执行之前和之后如何将样式应用于其目标\n\nanimation: r 1s linear 0s 1 reverse forwards;\n\n\n如果想让动画停止在最后结束状态，那么要加上 forwards\n\n\n# animation-play-state\n\n第8个参数定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。恢复一个已暂停的动画，将从它开始暂停的时候，而不是从动画序列的起点开始在动画。\n\nanimation-play-state: running;\n/* 暂停  */\nanimation-play-state: paused;\n\n\n\n# 多关键帧动画\n\n@keyframes bgColor {\n    0% {\n        background-color: rgb(219, 157, 157);\n    }\n    20% {\n        background-color: rgb(1, 19, 34);\n    }\n    40% {\n        background-color: rgb(94, 255, 0);\n    }\n    60% {\n        background-color: rgb(0, 17, 255);\n    }\n    80% {\n        background-color: rgb(217, 255, 0);\n    }\n    100% {\n        background-color: rgb(234, 0, 255);\n    }\n}\n\n\n\n# Animate.css\n\nAnimate.css是强大的跨平台的预设 css3 动画库\n\n * Animate.css 中文网\n * animate.css\n\n\n# 过渡与动画的对比\n\n\n# transition 过渡\n\n * 令一个或多个可以用数值表示的 css 属性值发生变化时产生过渡效果；\n * 触发条件：需要触发一个事件，比如鼠标触发等。\n * 精确性：只能设定头尾，设置过渡属性没有中间的过程，动画是一步到位。\n * 循环：只能触发一次，不能产生重复发生动画。\n\n\n# animation 动画\n\n * 可设置多个关键帧，实现自由动画。\n * 触发条件：不需要触发任何事件也可随时间变化达到一种动画效果。\n * 精确性：支持多帧动画效果，可绘制复杂动画。\n * 循环：可以反复执行动画，支持正向逆向及交替运行。\n\n\n# 应用场景分析\n\n# transition 过渡\n\n如果要简单的 from to 效果，用 transition。比如简单的按钮动画。\n\n# animation 动画：\n\n如果要灵活定制多个帧以及循环，用 animation。比如变色效果。',normalizedContent:'# 过渡\n\ntransition 过渡属性是 css3 浓墨重彩的特性，过渡可以为一个元素在不同样式之间变化自动添加“补间动画"\n\n\n# 兼容性\n\n * 过渡从 ie10 开始兼容，移动端兼容良好\n * 曾几何时，网页上的动画特效基本都是由 javascript 定时器实现的，现在逐步改为使用 css3 过渡\n * 优点：动画更细腻，内存开销小\n\n\n# 基本使用\n\ntransition: width 1s linear 0s;\n\n\n\n# 参数\n\ntransition: all 1s cubic-bezier(0.46, 1.02, 0.49, -0.86) 0s;\n\n\n1:什么属性要过渡 2：动画时长 3：变化速度曲线 4：延迟时间\n\n * 如果要所有属性都参与过渡，可以写 all\n * transition 的第三个参数就是缓动参数，也是变化速度曲线\n * 网站https://cubic-bezier.com/可以生成贝塞尔曲线，可以自定义动画缓动参数\n\n\n# 哪些属性可以参与过渡\n\n * 所有数值类型的属性，都可以参与过渡，比如 width、 height、left、top、 border- radius、 opacity\n * 背景颜色和文字颜色都可以被过渡\n * 所有变形（包括 2d 和 3d）都能被过渡\n\n\n# 注意项\n\n# 过渡与动画的时间要写单位\n\ntransition 属性中的过渡时间 transition-duration、延时时间 transition-delay，animation 属性中的动画时间 animation-duration、动画延时时间 animation-delay 都需要写单位，不写则会没有过渡、动画效果。\n\n# 最好设置初始状态\n\n部分需要过渡的属性，如果不设置初始状态，会没有过渡效果 以 left 值为例，当不设置 left 的初始值时：\n\n\n\n.box {\n    width: 100px;\n    height: 100px;\n    position: relative;\n    background-color: black;\n    /* 初始时，添加上left值 */\n    left: 0;\n    transition: all 1s linear 0s;\n}\n.box:hover {\n    left: 200px;\n}\n\n\n添加之后：\n\n\n\n# 过渡要定义在元素的开始状态上，而不是结束状态上\n\n\n# 动画\n\nanimation\n\n\n# 动画的定义和调用\n\n * 可以使用@ keyframes 来定义动画， keyframes 表示“关键帧”\n\n@keyframes r {\n    from {\n        transform: rotate(0);\n    }\n    to {\n        transform: rotate(360deg);\n    }\n}\n\n\n * 定义动画之后，就可以使用 animation 属性调用动画\n\nanimation: r 1s linear 0s 1;\n\n\n从左到右依次为：动画名称，总时长，缓动效果，延迟，执行次数\n\n对应属性名称:animation-name，animation-duration, animation-timing-function，animation-delay\n\n\n# animation-iteration-count\n\n第5个参数定义动画在结束前运行的次数 可以是 1 次 无限循环.\n\nanimation: r 1s linear 0s infinite;\n\n\ninfinite:无限循环播放动画\n\n\n# animation-direction\n\n第6个参数css 属性指示动画是否反向播放\n\nanimation: r 1s linear 0s infinite reverse;\n\n\n如果想让动画的第 2、4、6…（偶数次）自动逆向执行， 使用 alternate 参数即可\n\n\n# animation-fill-mode\n\n第7个参数设置 css 动画在执行之前和之后如何将样式应用于其目标\n\nanimation: r 1s linear 0s 1 reverse forwards;\n\n\n如果想让动画停止在最后结束状态，那么要加上 forwards\n\n\n# animation-play-state\n\n第8个参数定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。恢复一个已暂停的动画，将从它开始暂停的时候，而不是从动画序列的起点开始在动画。\n\nanimation-play-state: running;\n/* 暂停  */\nanimation-play-state: paused;\n\n\n\n# 多关键帧动画\n\n@keyframes bgcolor {\n    0% {\n        background-color: rgb(219, 157, 157);\n    }\n    20% {\n        background-color: rgb(1, 19, 34);\n    }\n    40% {\n        background-color: rgb(94, 255, 0);\n    }\n    60% {\n        background-color: rgb(0, 17, 255);\n    }\n    80% {\n        background-color: rgb(217, 255, 0);\n    }\n    100% {\n        background-color: rgb(234, 0, 255);\n    }\n}\n\n\n\n# animate.css\n\nanimate.css是强大的跨平台的预设 css3 动画库\n\n * animate.css 中文网\n * animate.css\n\n\n# 过渡与动画的对比\n\n\n# transition 过渡\n\n * 令一个或多个可以用数值表示的 css 属性值发生变化时产生过渡效果；\n * 触发条件：需要触发一个事件，比如鼠标触发等。\n * 精确性：只能设定头尾，设置过渡属性没有中间的过程，动画是一步到位。\n * 循环：只能触发一次，不能产生重复发生动画。\n\n\n# animation 动画\n\n * 可设置多个关键帧，实现自由动画。\n * 触发条件：不需要触发任何事件也可随时间变化达到一种动画效果。\n * 精确性：支持多帧动画效果，可绘制复杂动画。\n * 循环：可以反复执行动画，支持正向逆向及交替运行。\n\n\n# 应用场景分析\n\n# transition 过渡\n\n如果要简单的 from to 效果，用 transition。比如简单的按钮动画。\n\n# animation 动画：\n\n如果要灵活定制多个帧以及循环，用 animation。比如变色效果。',charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"flex布局",frontmatter:{title:"flex布局",sidebarDepth:2,readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Flex%E5%B8%83%E5%B1%80.html",relativePath:"前端开发/Css/Flex布局.md",key:"v-2433b719",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Flex%E5%B8%83%E5%B1%80.html",headers:[{level:2,title:"基础概念",slug:"基础概念",normalizedTitle:"基础概念",charIndex:2},{level:2,title:"容器的属性",slug:"容器的属性",normalizedTitle:"容器的属性",charIndex:273},{level:3,title:"display",slug:"display",normalizedTitle:"display",charIndex:283},{level:3,title:"flex-direction",slug:"flex-direction",normalizedTitle:"flex-direction",charIndex:454},{level:3,title:"flex-wrap",slug:"flex-wrap",normalizedTitle:"flex-wrap",charIndex:614},{level:3,title:"flex-flow",slug:"flex-flow",normalizedTitle:"flex-flow",charIndex:807},{level:3,title:"justify-content",slug:"justify-content",normalizedTitle:"justify-content",charIndex:875},{level:3,title:"align-items",slug:"align-items",normalizedTitle:"align-items",charIndex:1062},{level:3,title:"align-content",slug:"align-content",normalizedTitle:"align-content",charIndex:1265},{level:2,title:"项目的属性",slug:"项目的属性",normalizedTitle:"项目的属性",charIndex:1544},{level:3,title:"order",slug:"order",normalizedTitle:"order",charIndex:1554},{level:3,title:"flex-grow",slug:"flex-grow",normalizedTitle:"flex-grow",charIndex:1597},{level:3,title:"flex-shrink",slug:"flex-shrink",normalizedTitle:"flex-shrink",charIndex:1839},{level:3,title:"flex-basis",slug:"flex-basis",normalizedTitle:"flex-basis",charIndex:2e3},{level:3,title:"flex",slug:"flex",normalizedTitle:"flex",charIndex:11},{level:3,title:"align-self",slug:"align-self",normalizedTitle:"align-self",charIndex:2919},{level:2,title:"flex 实现圣杯布局",slug:"flex-实现圣杯布局",normalizedTitle:"flex 实现圣杯布局",charIndex:3060}],headersStr:"基础概念 容器的属性 display flex-direction flex-wrap flex-flow justify-content align-items align-content 项目的属性 order flex-grow flex-shrink flex-basis flex align-self flex 实现圣杯布局",content:'# 基础概念\n\n * flex 容器：采用 flex 布局的元素，称为 flex 容器\n * flex项目：flex 容器的所有子元素自动成为容器成员，称为 flex 项目\n * 容器默认存在两根轴：水平的主轴main axis和垂直的交叉轴cross axis。主轴的开始位置叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做cross start，结束位置叫做 cross end\n * 项目默认沿主轴排列,单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size\n\n\n\n\n# 容器的属性\n\n\n# display\n\n决定了是否使用flex 布局\n\n两者区别\n\n在没有指定宽度的时候，属性设置为 flex 的宽度默认为父元素的宽度，属性设置为 inline-flex为它内容的宽度\n\n * display:flex;将对象作为弹性伸缩盒显示\n\n\n\n * diisplay:inline-flex;将对象作为内联块级弹性伸缩盒显示\n\n\n\n\n# flex-direction\n\n决定主轴的方向（即项目的排列方向）\n\n * row（默认值）主轴为水平方向，起点在左端\n\n\n\n * row-reverse 主轴为水平方向，起点在右端\n\n\n\n * column 主轴为垂直方向，起点在上沿\n\n\n\n * column-reverse 主轴为垂直方向，起点在下沿\n\n\n\n\n# flex-wrap\n\n默认情况下，项目都排在一条线（又称“轴线”）上，flex-wrap 属性定义，如一果条轴线排不下，如何换行\n\n * nowrap（默认值） 不换行\n   \n   注意\n   \n   如果项目的宽度加和超过容器的宽度会自动压缩每个项目的宽度，坚决不换行！\n\n\n\n * wrap换行 第一行在上方\n\n\n\n * wrap-reverse 换行 第一行在下方\n\n\n\n\n# flex-flow\n\nflex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap\n\n\n# justify-content\n\n定义了项目在主轴上的对齐方式\n\n * flex-start(默认值) 左对齐\n\n\n\n * flex-end 右对齐\n\n\n\n * center 居中\n\n\n\n * space-between 两端对齐，项目之间的间隔都相等\n\n\n\n * space-around 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍\n\n\n\n\n# align-items\n\n定义项目在交叉轴上如何对齐\n\n * stretch(默认值)：如果 Flex 项目未设置交叉轴方向的大小或设为 auto，将占满整个容器交叉轴方向的大小\n\n\n\n * flex-start 交叉轴的起点对齐\n\n\n\n * flex-end 交叉轴的终点对齐\n\n\n\n * center 交叉轴的中点对齐(垂直居中)\n\n\n\n * baseline 项目的第一行文字的基线对齐\n\n\n\n\n# align-content\n\n定义了存在多根主轴线时，flex 项目在交叉轴上的对齐方式\n\n如果项目只有一根主轴线 ，该属性不起作用\n\n * stretch(默认值) 主轴线平分 Flex 容器交叉轴方向上的空间\n\n\n\n * flex-start 交叉轴的起点对齐\n\n\n\n * flex-end 交叉轴的终点对齐\n\n!\n\n * center与交叉轴的中点对齐\n\n\n\n * space-between 与交叉轴的两端对齐，轴线之间的间隔平均分布\n\n\n\n * space-around 每根轴线两侧的间隔都相等，所以轴线之间的间隔比轴线与边框大一倍\n\n\n\n\n# 项目的属性\n\n\n# order\n\n属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。\n\n\n\n\n# flex-grow\n\n * 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n * 如果所有项目的 flex-grow 属性都为 1，则它们将等分主轴剩余空间（如果有的话）。如果一个项目的flex-grow 属性为 2，其他项目都为 1，则前者占据的主轴剩余空间将是其他项的 2 倍。\n\n\n\n * 如果有的项目有 flex-grow 属性，有的项目没有 flex-grow 属性,但有 width 属性，有 flex-grow属性的项目将等分主轴剩余空间\n\n\n\n\n# flex-shrink\n\n属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n * 如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。\n * 负值对该属性无效。\n\n\n\n\n# flex-basis\n\n * 优先级高于 width(或height)\n * 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n\n# flex\n\n属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为 0 1 auto。后两个属性可选。\n\n# 关键字值\n\n# 单值语法\n\n * 一个无单位数(number),会被当作 flex:number 1 0;\n   * flex:1 ; 平分剩余空间\n * 一个有效的宽度width值，它会被当作flex-basis 的值(会被当作flex:1 1 width)\n * 关键字 none，auto或initial\n   * flex: auto; 元素会根据自身的宽度与高度来确定尺寸，但是会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 flex 容器。这相当于将属性设置为 "flex: 1 1 auto"\n   * flex: initial;元素会根据自身宽高设置尺寸。它会缩短自身以适应 flex 容器，但不会伸长并吸收 flex 容器中的额外自由空间来适应 flex 容器 。相当于将属性设置为"flex: 0 1 auto"\n   * flex: none; 元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应 flex 容器。相当于将属性设置为"flex: 0 0 auto"\n\n# 双值语法\n\n第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值。第二个值必须为以下之一：\n\n * 一个无单位数：它会被当作 flex-shrink 的值\n * 一个有效的宽度值: 它会被当作 flex-basis 的值\n\n# 三值语法\n\n * 第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值\n * 第二个值必须为一个无单位数，并且它会被当作 flex-shrink 的值。\n * 第三个值必须为一个有效的宽度值， 并且它会被当作 flex-basis 的值\n\n\n# align-self\n\n属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items属性。\n\n * 该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。\n\n\n# flex 实现圣杯布局\n\nSee the Pen flex 实现圣杯布局 by zhangfanhang (@zhangfanhang) on CodePen.',normalizedContent:'# 基础概念\n\n * flex 容器：采用 flex 布局的元素，称为 flex 容器\n * flex项目：flex 容器的所有子元素自动成为容器成员，称为 flex 项目\n * 容器默认存在两根轴：水平的主轴main axis和垂直的交叉轴cross axis。主轴的开始位置叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做cross start，结束位置叫做 cross end\n * 项目默认沿主轴排列,单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size\n\n\n\n\n# 容器的属性\n\n\n# display\n\n决定了是否使用flex 布局\n\n两者区别\n\n在没有指定宽度的时候，属性设置为 flex 的宽度默认为父元素的宽度，属性设置为 inline-flex为它内容的宽度\n\n * display:flex;将对象作为弹性伸缩盒显示\n\n\n\n * diisplay:inline-flex;将对象作为内联块级弹性伸缩盒显示\n\n\n\n\n# flex-direction\n\n决定主轴的方向（即项目的排列方向）\n\n * row（默认值）主轴为水平方向，起点在左端\n\n\n\n * row-reverse 主轴为水平方向，起点在右端\n\n\n\n * column 主轴为垂直方向，起点在上沿\n\n\n\n * column-reverse 主轴为垂直方向，起点在下沿\n\n\n\n\n# flex-wrap\n\n默认情况下，项目都排在一条线（又称“轴线”）上，flex-wrap 属性定义，如一果条轴线排不下，如何换行\n\n * nowrap（默认值） 不换行\n   \n   注意\n   \n   如果项目的宽度加和超过容器的宽度会自动压缩每个项目的宽度，坚决不换行！\n\n\n\n * wrap换行 第一行在上方\n\n\n\n * wrap-reverse 换行 第一行在下方\n\n\n\n\n# flex-flow\n\nflex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap\n\n\n# justify-content\n\n定义了项目在主轴上的对齐方式\n\n * flex-start(默认值) 左对齐\n\n\n\n * flex-end 右对齐\n\n\n\n * center 居中\n\n\n\n * space-between 两端对齐，项目之间的间隔都相等\n\n\n\n * space-around 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍\n\n\n\n\n# align-items\n\n定义项目在交叉轴上如何对齐\n\n * stretch(默认值)：如果 flex 项目未设置交叉轴方向的大小或设为 auto，将占满整个容器交叉轴方向的大小\n\n\n\n * flex-start 交叉轴的起点对齐\n\n\n\n * flex-end 交叉轴的终点对齐\n\n\n\n * center 交叉轴的中点对齐(垂直居中)\n\n\n\n * baseline 项目的第一行文字的基线对齐\n\n\n\n\n# align-content\n\n定义了存在多根主轴线时，flex 项目在交叉轴上的对齐方式\n\n如果项目只有一根主轴线 ，该属性不起作用\n\n * stretch(默认值) 主轴线平分 flex 容器交叉轴方向上的空间\n\n\n\n * flex-start 交叉轴的起点对齐\n\n\n\n * flex-end 交叉轴的终点对齐\n\n!\n\n * center与交叉轴的中点对齐\n\n\n\n * space-between 与交叉轴的两端对齐，轴线之间的间隔平均分布\n\n\n\n * space-around 每根轴线两侧的间隔都相等，所以轴线之间的间隔比轴线与边框大一倍\n\n\n\n\n# 项目的属性\n\n\n# order\n\n属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。\n\n\n\n\n# flex-grow\n\n * 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n * 如果所有项目的 flex-grow 属性都为 1，则它们将等分主轴剩余空间（如果有的话）。如果一个项目的flex-grow 属性为 2，其他项目都为 1，则前者占据的主轴剩余空间将是其他项的 2 倍。\n\n\n\n * 如果有的项目有 flex-grow 属性，有的项目没有 flex-grow 属性,但有 width 属性，有 flex-grow属性的项目将等分主轴剩余空间\n\n\n\n\n# flex-shrink\n\n属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n * 如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。\n * 负值对该属性无效。\n\n\n\n\n# flex-basis\n\n * 优先级高于 width(或height)\n * 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n\n# flex\n\n属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为 0 1 auto。后两个属性可选。\n\n# 关键字值\n\n# 单值语法\n\n * 一个无单位数(number),会被当作 flex:number 1 0;\n   * flex:1 ; 平分剩余空间\n * 一个有效的宽度width值，它会被当作flex-basis 的值(会被当作flex:1 1 width)\n * 关键字 none，auto或initial\n   * flex: auto; 元素会根据自身的宽度与高度来确定尺寸，但是会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 flex 容器。这相当于将属性设置为 "flex: 1 1 auto"\n   * flex: initial;元素会根据自身宽高设置尺寸。它会缩短自身以适应 flex 容器，但不会伸长并吸收 flex 容器中的额外自由空间来适应 flex 容器 。相当于将属性设置为"flex: 0 1 auto"\n   * flex: none; 元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应 flex 容器。相当于将属性设置为"flex: 0 0 auto"\n\n# 双值语法\n\n第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值。第二个值必须为以下之一：\n\n * 一个无单位数：它会被当作 flex-shrink 的值\n * 一个有效的宽度值: 它会被当作 flex-basis 的值\n\n# 三值语法\n\n * 第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值\n * 第二个值必须为一个无单位数，并且它会被当作 flex-shrink 的值。\n * 第三个值必须为一个有效的宽度值， 并且它会被当作 flex-basis 的值\n\n\n# align-self\n\n属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items属性。\n\n * 该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。\n\n\n# flex 实现圣杯布局\n\nsee the pen flex 实现圣杯布局 by zhangfanhang (@zhangfanhang) on codepen.',charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"Sass",frontmatter:{title:"Sass",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Sass.html",relativePath:"前端开发/Css/Sass.md",key:"v-c9df4500",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/Sass.html",headers:[{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:104},{level:2,title:"嵌套",slug:"嵌套",normalizedTitle:"嵌套",charIndex:168},{level:2,title:"拆分，引入",slug:"拆分-引入",normalizedTitle:"拆分，引入",charIndex:325},{level:2,title:"Mixin 混入的使用",slug:"mixin-混入的使用",normalizedTitle:"mixin 混入的使用",charIndex:390},{level:2,title:"父选择器 &",slug:"父选择器",normalizedTitle:"父选择器 &amp;",charIndex:null}],headersStr:"变量 嵌套 拆分，引入 Mixin 混入的使用 父选择器 &",content:"注意\n\n以下不代表 scss 的所有功能，仅总结本人目前在项目大量使用过的功能\n\nSass 中文网\n\nscss 里加{}，加“;”\n\nsass 里不加{}，不加“;”\n\n根据个人习惯，使用 scss\n\n\n# 变量\n\n方便批量管理统一的样式\n\n$text-color: #555;\n$small-font: 14px+3px;\n\n\n\n# 嵌套\n\n减少代码重复次数\n\ndiv {\n    span {\n        // div span\n        color: red;\n        a {\n            // div span a\n            color: blue;\n        }\n    }\n}\n\n\n\n# 拆分，引入\n\n把代码拆分成若干个 scss 文件\n\n// 引入，相对路径\n@import 'header.scss';\n\n\n\n# Mixin 混入的使用\n\n// 超出文本隐藏\n@mixin singleline-ellipsis($width) {\n    width: $width;\n    overflow: hidden;\n    // 规定段落中的文字不进行换行\n    white-space: nowrap;\n    // 显示省略符号来代表被修剪的文本\n    text-overflow: ellipsis;\n}\n.text {\n    @include singleline-ellipsis(500px);\n}\n\n\n\n# 父选择器 &\n\n编译后的 CSS 文件中 & 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递\n\n#main {\n    color: black;\n    a {\n        font-weight: bold;\n        &:hover {\n            color: red;\n        }\n    }\n}\n\n\n编译为：\n\n    color: black;\n}\n#main a {\n    font-weight: bold;\n}\n#main a:hover {\n    color: red;\n}\n\n\n& 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如\n\n#main {\n    color: black;\n    &-sidebar {\n        border: 1px solid;\n    }\n    &.one {\n        color: red;\n    }\n}\n\n\n编译为：\n\n#main {\n    color: black;\n}\n#main-sidebar {\n    border: 1px solid;\n}\n#main.one {\n    color: red;\n}\n",normalizedContent:"注意\n\n以下不代表 scss 的所有功能，仅总结本人目前在项目大量使用过的功能\n\nsass 中文网\n\nscss 里加{}，加“;”\n\nsass 里不加{}，不加“;”\n\n根据个人习惯，使用 scss\n\n\n# 变量\n\n方便批量管理统一的样式\n\n$text-color: #555;\n$small-font: 14px+3px;\n\n\n\n# 嵌套\n\n减少代码重复次数\n\ndiv {\n    span {\n        // div span\n        color: red;\n        a {\n            // div span a\n            color: blue;\n        }\n    }\n}\n\n\n\n# 拆分，引入\n\n把代码拆分成若干个 scss 文件\n\n// 引入，相对路径\n@import 'header.scss';\n\n\n\n# mixin 混入的使用\n\n// 超出文本隐藏\n@mixin singleline-ellipsis($width) {\n    width: $width;\n    overflow: hidden;\n    // 规定段落中的文字不进行换行\n    white-space: nowrap;\n    // 显示省略符号来代表被修剪的文本\n    text-overflow: ellipsis;\n}\n.text {\n    @include singleline-ellipsis(500px);\n}\n\n\n\n# 父选择器 &\n\n编译后的 css 文件中 & 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递\n\n#main {\n    color: black;\n    a {\n        font-weight: bold;\n        &:hover {\n            color: red;\n        }\n    }\n}\n\n\n编译为：\n\n    color: black;\n}\n#main a {\n    font-weight: bold;\n}\n#main a:hover {\n    color: red;\n}\n\n\n& 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如\n\n#main {\n    color: black;\n    &-sidebar {\n        border: 1px solid;\n    }\n    &.one {\n        color: red;\n    }\n}\n\n\n编译为：\n\n#main {\n    color: black;\n}\n#main-sidebar {\n    border: 1px solid;\n}\n#main.one {\n    color: red;\n}\n",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"回流重绘",frontmatter:{title:"回流重绘",date:"2022/06/08 16:29:20",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/%E7%8E%A9%E8%BD%ACCSS%E8%89%BA%E6%9C%AF%E4%B9%8B%E7%BE%8E/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98.html",relativePath:"前端开发/Css/玩转CSS艺术之美/回流重绘.md",key:"v-0934a038",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/%E7%8E%A9%E8%BD%ACCSS%E8%89%BA%E6%9C%AF%E4%B9%8B%E7%BE%8E/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98.html",headers:[{level:2,title:"回流",slug:"回流",normalizedTitle:"回流",charIndex:2},{level:2,title:"重绘",slug:"重绘",normalizedTitle:"重绘",charIndex:312},{level:2,title:"属性分类",slug:"属性分类",normalizedTitle:"属性分类",charIndex:496},{level:2,title:"性能优化",slug:"性能优化",normalizedTitle:"性能优化",charIndex:364},{level:3,title:"使用 visibility:hidden 替换 display:none",slug:"使用-visibility-hidden-替换-display-none",normalizedTitle:"使用 visibility:hidden 替换 display:none",charIndex:2071},{level:3,title:"使用 transform 代替 top",slug:"使用-transform-代替-top",normalizedTitle:"使用 transform 代替 top",charIndex:2442},{level:3,title:"避免使用 Table 布局",slug:"避免使用-table-布局",normalizedTitle:"避免使用 table 布局",charIndex:2577},{level:3,title:"避免规则层级过多",slug:"避免规则层级过多",normalizedTitle:"避免规则层级过多",charIndex:2739},{level:3,title:"避免节点属性值放在循环里当成循环变量",slug:"避免节点属性值放在循环里当成循环变量",normalizedTitle:"避免节点属性值放在循环里当成循环变量",charIndex:2824},{level:3,title:"动态改变类而不改变样式",slug:"动态改变类而不改变样式",normalizedTitle:"动态改变类而不改变样式",charIndex:3126},{level:3,title:"将频繁回流重绘的节点设置为图层",slug:"将频繁回流重绘的节点设置为图层",normalizedTitle:"将频繁回流重绘的节点设置为图层",charIndex:3306},{level:3,title:"使用 requestAnimationFrame 作为动画帧",slug:"使用-requestanimationframe-作为动画帧",normalizedTitle:"使用 requestanimationframe 作为动画帧",charIndex:3569},{level:2,title:"属性排序",slug:"属性排序",normalizedTitle:"属性排序",charIndex:3735}],headersStr:"回流 重绘 属性分类 性能优化 使用 visibility:hidden 替换 display:none 使用 transform 代替 top 避免使用 Table 布局 避免规则层级过多 避免节点属性值放在循环里当成循环变量 动态改变类而不改变样式 将频繁回流重绘的节点设置为图层 使用 requestAnimationFrame 作为动画帧 属性排序",content:"# 回流\n\n回流又名重排，指几何属性需改变的渲染。但感觉回流这个词较高大上，后续统称回流吧。\n\n可理解成，将整个网页填白，对内容重新渲染一次。只不过以人眼的感官速度去看浏览器回流是不会有任何变化的，若你拥有闪电侠的感官速度去看浏览器回流(实质是将时间调慢)，就会发现每次回流都会将页面清空，再从左上角第一个像素点从左到右从上到下这样一点一点渲染，直至右下角最后一个像素点。每次回流都会呈现该过程，只是感受不到而已。\n\n渲染树的节点发生改变，影响了该节点的几何属性，导致该节点位置发生变化，此时就会触发浏览器回流并重新生成渲染树。回流意味着节点的几何属性改变，需重新计算并生成渲染树，导致渲染树的全部或部分发生变化。\n\n\n# 重绘\n\n重绘指更改外观属性而不影响几何属性的渲染。相比回流，重绘在两者中会温和一些，后续谈到的 CSS 性能优化就会基于该特点展开。\n\n渲染树的节点发生改变，但不影响该节点的几何属性。由此可见，回流对浏览器性能的消耗是高于重绘的，而且回流一定会伴随重绘，重绘却不一定伴随回流。\n\n为何回流一定会伴随重绘呢？整个节点的位置都变了，肯定要重新渲染它的外观属性啊！\n\n\n# 属性分类\n\n以下对一些常用的几何属性和外观属性分类，其实同种分类的属性都有一些共同点，各位同学可自行感受。推荐一个查询属性渲染状态的网站CssTriggers，可查看每个属性在渲染过程中发生了什么影响了什么。\n\n * 几何属性：包括布局、尺寸等可用数学几何衡量的属性\n * 布局：display、float、position、list、table、flex、columns、grid\n * 尺寸：margin、padding、border、width、height\n * 外观属性：包括界面、文字等可用状态向量描述的属性\n * 界面：appearance、outline、background、mask、box-shadow、box-reflect、filter、opacity、clip\n * 文字：text、font、word\n\n> 如何理解回流重绘\n\n有无更好的方式可帮助理解回流重绘呢？答案是有的。\n\n某一天星巴克发行一套很有纪念价值的杯子，男同胞们为了买到心仪的杯子给女友当惊喜礼物，通宵达旦搬张板凳去星巴克门口排队。此时形成的队伍是有序的，毕竟大家都是文明人，不可能随便插队吧，先到先拿，这个道理谁都懂！\n\n可是总有一些人不按常理出牌，别人排队排得那么辛苦，他一到来就仗着自己有钱有势人多马多，插队到最前面。若他插队成功，那么后面的人都要往后挪一位。此时队伍就要重新往后挪，甚至引发多人斗殴。但混乱的情况总会被控制下来，此时就得重新排队，而原先的队伍顺序经过这次斗殴就可能不按照原先的队伍顺序排队了。几何属性变了，就要重新排队，这个就是回流或重排。重新排队啊 😂！\n\n一位漂亮妹纸排队排得久肚子呱呱叫，就与另一位同伴交换，她去买早餐，而这位同伴代替她的位置。各位男同胞可能发现这位妹纸更漂亮了。没错，外观属性改变了，变漂亮了，但除了妹纸，其余人的位置和顺序都无发生变化，所以肯定不会发生上述重新排队的情况。外观属性变了，但几何属性没变，这个就是重绘。不用重新排队，还有漂亮妹纸看，大家都很乐意 🤔！\n\n\n# 性能优化\n\n回流重绘在操作节点样式时频繁出现，同时也存在很大程度上的性能问题。回流成本比重绘成本高得多，一个节点的回流很有可能导致子节点、兄弟节点或祖先节点的回流。在一些高性能电脑上也许无什么影响，但回流发生在手机上(明摆说某些安卓手机)，就会减缓加载速度和增加电量消耗。\n\n在上一章中引出一个定向法则：回流必定引发重绘，重绘不一定引发回流，可利用该法则解决一些因为回流重绘而引发的性能问题。在优化性能前，需了解什么情况可能产生性能问题，以下罗列一些常见的情况。\n\n * 改变窗口大小\n * 修改盒模型\n * 增删样式\n * 重构布局\n * 重设尺寸\n * 改变字体\n * 改动文字\n\n很多同学可能不知，回流重绘其实与浏览器的事件循环有关，以下源自对HTML 文档的理解。\n\n * 浏览器刷新频率为60Hz，即每16.6ms更新一次\n * 事件循环执行完成微任务\n * 判断document是否需更新\n * 判断resize/scroll事件是否存在，存在则触发事件\n * 判断Media Query是否触发\n * 更新动作并发送事件\n * 判断document.isFullScreen是否为true(全屏)\n * 执行requestAnimationFrame回调\n * 执行IntersectionObserver回调\n * 更新界面\n\n上述就是浏览器每一帧中可能会做到的事情，若在一帧中有空闲时间，就会执行requestIdleCallback回调。\n\n回到正题，通过定向法则回流必定引发重绘，重绘不一定引发回流可知道，尽量减少回流重绘，就是 CSS 性能优化中一个很好的指标。\n\n> 如何减少和避免回流重绘\n\n\n# 使用 visibility:hidden 替换 display:none\n\n笔者从以下四方面对比display:none和visibility:hidden，display:none简称DN，visibility:hidden简称VH。\n\n * 占位表现\n   * DN 不占据空间\n   * VH 占据空间\n * 触发影响\n   * DN 触发回流重绘\n   * VH 触发重绘\n * 过渡影响\n   * DN 影响过渡不影响动画\n   * VH 不影响过渡不影响动画\n * 株连效果\n   * DN 后自身及其子节点全都不可见\n   * VH 后自身及其子节点全都不可见但可声明子节点visibility:visible单独显示\n\n两者的占位表现、触发影响和株连效果就能说明VH代替DN的好处，从两者区别中就能找出恰当的答案了。\n\n\n# 使用 transform 代替 top\n\ntop是几何属性，操作top会改变节点位置从而引发回流，使用transform:translate3d(x,0,0)代替top，只会引发图层重绘，还会间接启动 GPU 加速，该情况在第 12 章变换与动画中会详细讲述。\n\n\n# 避免使用 Table 布局\n\n牵一发而动全身用在 Table 布局身上就很适合了，可能很小的一个改动就会造成整个<table>回流，有兴趣的同学可用Chrome Devtools的Performance调试看看，在此就不演示了。\n\n通常可用<ul>、<li>和<span>等标签取代<table>系列标签生成表格。\n\n\n# 避免规则层级过多\n\n浏览器的CSS解析器解析css文件时，对 CSS 规则是从右到左匹配查找，样式层级过多会影响回流重绘效率，建议保持 CSS 规则在3层左右。\n\n\n# 避免节点属性值放在循环里当成循环变量\n\nfor (let i = 0; i < 10000; i++) {\n    const top = document.getElementById('css').style.top\n    console.log(top)\n}\n\n\n呵呵，每次循环操作 DOM 都会发生回流，应该在循环外使用变量保存一些不会变化的 DOM 映射值。\n\nconst top = document.getElementById('css').style.top\nfor (let i = 0; i < 10000; i++) {\n    console.log(top)\n}\n\n\n\n# 动态改变类而不改变样式\n\n不要尝试每次操作 DOM 去改变节点样式，这样会频繁触发回流。\n\n更好的方式是使用新的类名预定义节点样式，在执行逻辑操作时收集并确认最终更换的类名集合，在适合时机一次性动态替换原来的类名集合。有点像vue的依赖收集机制，不知这样描述会不会更容易理解。\n\n各位同学可研究下这个强大的classList，它能满足笔者所说的需求。\n\n\n# 将频繁回流重绘的节点设置为图层\n\n上一章的渲染过程最后一步，提到将回流重绘生成的图层逐张合并并显示在屏幕上。可将其理解成Photoshop的图层，若不对图层添加关联，图层间是不会互相影响的。同理，在浏览器中设置频繁回流或重绘的节点为一张新图层，那么新图层就能够阻止节点的渲染行为影响别的节点，这张图层里如何变化都无法影响到其他图层。\n\n设置新图层有两种方式，将节点设置为<video>或<iframe>，为节点添加will-change。will-change是一个很叼的属性，在第 12 章变换与动画中会详细讲述。\n\n\n# 使用 requestAnimationFrame 作为动画帧\n\n动画速度越快，回流次数越多，上述有提到浏览器刷新频率为60Hz，即每16.6ms更新一次，而requestAnimationFrame()正是以16.6ms的速度更新一次。所以可用requestAnimationFrame()代替setInterval()。\n\n\n# 属性排序\n\n在进入属性排序这个话题前，先来看看以下两段 CSS 代码。\n\n.elem {\n    width: 200px;\n    background-color: #f66;\n    align-items: center;\n    color: #fff;\n    height: 200px;\n    justify-content: center;\n    font-size: 20px;\n    display: flex;\n}\n.elem {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 200px;\n    height: 200px;\n    background-color: #f66;\n    font-size: 20px;\n    color: #fff;\n}\n\n\n若不特别指明，可能各位同学觉得这两段代码无异样，顶多就是属性顺序不同。但仔细观察两段代码，就会发现第一段代码好像无依据地随便排列，而第二段代码好像按照某些规范顺序排列。\n\n属性排序指按照预设规范排列属性。提供一个预设的约定规范，依据该规范以一定的顺序排列所有属性。\n\n曾经笔者也是随机排列属性顺序，想到什么写什么，反正能实现就行。但反过来看，随意真的好吗，每次维护代码都需反复确认某个属性是否已经存在，混乱的属性排序让笔者有时无法在脑海里构思出更好的排版。所以笔者下意识去了解和认识属性排序，利用一些约定规范合理管理我的 CSS 代码。\n\n曾经有一个著名的 CSS 网站CSSTricks做了一份属性排序的调查问卷，调查结果如下。",normalizedContent:"# 回流\n\n回流又名重排，指几何属性需改变的渲染。但感觉回流这个词较高大上，后续统称回流吧。\n\n可理解成，将整个网页填白，对内容重新渲染一次。只不过以人眼的感官速度去看浏览器回流是不会有任何变化的，若你拥有闪电侠的感官速度去看浏览器回流(实质是将时间调慢)，就会发现每次回流都会将页面清空，再从左上角第一个像素点从左到右从上到下这样一点一点渲染，直至右下角最后一个像素点。每次回流都会呈现该过程，只是感受不到而已。\n\n渲染树的节点发生改变，影响了该节点的几何属性，导致该节点位置发生变化，此时就会触发浏览器回流并重新生成渲染树。回流意味着节点的几何属性改变，需重新计算并生成渲染树，导致渲染树的全部或部分发生变化。\n\n\n# 重绘\n\n重绘指更改外观属性而不影响几何属性的渲染。相比回流，重绘在两者中会温和一些，后续谈到的 css 性能优化就会基于该特点展开。\n\n渲染树的节点发生改变，但不影响该节点的几何属性。由此可见，回流对浏览器性能的消耗是高于重绘的，而且回流一定会伴随重绘，重绘却不一定伴随回流。\n\n为何回流一定会伴随重绘呢？整个节点的位置都变了，肯定要重新渲染它的外观属性啊！\n\n\n# 属性分类\n\n以下对一些常用的几何属性和外观属性分类，其实同种分类的属性都有一些共同点，各位同学可自行感受。推荐一个查询属性渲染状态的网站csstriggers，可查看每个属性在渲染过程中发生了什么影响了什么。\n\n * 几何属性：包括布局、尺寸等可用数学几何衡量的属性\n * 布局：display、float、position、list、table、flex、columns、grid\n * 尺寸：margin、padding、border、width、height\n * 外观属性：包括界面、文字等可用状态向量描述的属性\n * 界面：appearance、outline、background、mask、box-shadow、box-reflect、filter、opacity、clip\n * 文字：text、font、word\n\n> 如何理解回流重绘\n\n有无更好的方式可帮助理解回流重绘呢？答案是有的。\n\n某一天星巴克发行一套很有纪念价值的杯子，男同胞们为了买到心仪的杯子给女友当惊喜礼物，通宵达旦搬张板凳去星巴克门口排队。此时形成的队伍是有序的，毕竟大家都是文明人，不可能随便插队吧，先到先拿，这个道理谁都懂！\n\n可是总有一些人不按常理出牌，别人排队排得那么辛苦，他一到来就仗着自己有钱有势人多马多，插队到最前面。若他插队成功，那么后面的人都要往后挪一位。此时队伍就要重新往后挪，甚至引发多人斗殴。但混乱的情况总会被控制下来，此时就得重新排队，而原先的队伍顺序经过这次斗殴就可能不按照原先的队伍顺序排队了。几何属性变了，就要重新排队，这个就是回流或重排。重新排队啊 😂！\n\n一位漂亮妹纸排队排得久肚子呱呱叫，就与另一位同伴交换，她去买早餐，而这位同伴代替她的位置。各位男同胞可能发现这位妹纸更漂亮了。没错，外观属性改变了，变漂亮了，但除了妹纸，其余人的位置和顺序都无发生变化，所以肯定不会发生上述重新排队的情况。外观属性变了，但几何属性没变，这个就是重绘。不用重新排队，还有漂亮妹纸看，大家都很乐意 🤔！\n\n\n# 性能优化\n\n回流重绘在操作节点样式时频繁出现，同时也存在很大程度上的性能问题。回流成本比重绘成本高得多，一个节点的回流很有可能导致子节点、兄弟节点或祖先节点的回流。在一些高性能电脑上也许无什么影响，但回流发生在手机上(明摆说某些安卓手机)，就会减缓加载速度和增加电量消耗。\n\n在上一章中引出一个定向法则：回流必定引发重绘，重绘不一定引发回流，可利用该法则解决一些因为回流重绘而引发的性能问题。在优化性能前，需了解什么情况可能产生性能问题，以下罗列一些常见的情况。\n\n * 改变窗口大小\n * 修改盒模型\n * 增删样式\n * 重构布局\n * 重设尺寸\n * 改变字体\n * 改动文字\n\n很多同学可能不知，回流重绘其实与浏览器的事件循环有关，以下源自对html 文档的理解。\n\n * 浏览器刷新频率为60hz，即每16.6ms更新一次\n * 事件循环执行完成微任务\n * 判断document是否需更新\n * 判断resize/scroll事件是否存在，存在则触发事件\n * 判断media query是否触发\n * 更新动作并发送事件\n * 判断document.isfullscreen是否为true(全屏)\n * 执行requestanimationframe回调\n * 执行intersectionobserver回调\n * 更新界面\n\n上述就是浏览器每一帧中可能会做到的事情，若在一帧中有空闲时间，就会执行requestidlecallback回调。\n\n回到正题，通过定向法则回流必定引发重绘，重绘不一定引发回流可知道，尽量减少回流重绘，就是 css 性能优化中一个很好的指标。\n\n> 如何减少和避免回流重绘\n\n\n# 使用 visibility:hidden 替换 display:none\n\n笔者从以下四方面对比display:none和visibility:hidden，display:none简称dn，visibility:hidden简称vh。\n\n * 占位表现\n   * dn 不占据空间\n   * vh 占据空间\n * 触发影响\n   * dn 触发回流重绘\n   * vh 触发重绘\n * 过渡影响\n   * dn 影响过渡不影响动画\n   * vh 不影响过渡不影响动画\n * 株连效果\n   * dn 后自身及其子节点全都不可见\n   * vh 后自身及其子节点全都不可见但可声明子节点visibility:visible单独显示\n\n两者的占位表现、触发影响和株连效果就能说明vh代替dn的好处，从两者区别中就能找出恰当的答案了。\n\n\n# 使用 transform 代替 top\n\ntop是几何属性，操作top会改变节点位置从而引发回流，使用transform:translate3d(x,0,0)代替top，只会引发图层重绘，还会间接启动 gpu 加速，该情况在第 12 章变换与动画中会详细讲述。\n\n\n# 避免使用 table 布局\n\n牵一发而动全身用在 table 布局身上就很适合了，可能很小的一个改动就会造成整个<table>回流，有兴趣的同学可用chrome devtools的performance调试看看，在此就不演示了。\n\n通常可用<ul>、<li>和<span>等标签取代<table>系列标签生成表格。\n\n\n# 避免规则层级过多\n\n浏览器的css解析器解析css文件时，对 css 规则是从右到左匹配查找，样式层级过多会影响回流重绘效率，建议保持 css 规则在3层左右。\n\n\n# 避免节点属性值放在循环里当成循环变量\n\nfor (let i = 0; i < 10000; i++) {\n    const top = document.getelementbyid('css').style.top\n    console.log(top)\n}\n\n\n呵呵，每次循环操作 dom 都会发生回流，应该在循环外使用变量保存一些不会变化的 dom 映射值。\n\nconst top = document.getelementbyid('css').style.top\nfor (let i = 0; i < 10000; i++) {\n    console.log(top)\n}\n\n\n\n# 动态改变类而不改变样式\n\n不要尝试每次操作 dom 去改变节点样式，这样会频繁触发回流。\n\n更好的方式是使用新的类名预定义节点样式，在执行逻辑操作时收集并确认最终更换的类名集合，在适合时机一次性动态替换原来的类名集合。有点像vue的依赖收集机制，不知这样描述会不会更容易理解。\n\n各位同学可研究下这个强大的classlist，它能满足笔者所说的需求。\n\n\n# 将频繁回流重绘的节点设置为图层\n\n上一章的渲染过程最后一步，提到将回流重绘生成的图层逐张合并并显示在屏幕上。可将其理解成photoshop的图层，若不对图层添加关联，图层间是不会互相影响的。同理，在浏览器中设置频繁回流或重绘的节点为一张新图层，那么新图层就能够阻止节点的渲染行为影响别的节点，这张图层里如何变化都无法影响到其他图层。\n\n设置新图层有两种方式，将节点设置为<video>或<iframe>，为节点添加will-change。will-change是一个很叼的属性，在第 12 章变换与动画中会详细讲述。\n\n\n# 使用 requestanimationframe 作为动画帧\n\n动画速度越快，回流次数越多，上述有提到浏览器刷新频率为60hz，即每16.6ms更新一次，而requestanimationframe()正是以16.6ms的速度更新一次。所以可用requestanimationframe()代替setinterval()。\n\n\n# 属性排序\n\n在进入属性排序这个话题前，先来看看以下两段 css 代码。\n\n.elem {\n    width: 200px;\n    background-color: #f66;\n    align-items: center;\n    color: #fff;\n    height: 200px;\n    justify-content: center;\n    font-size: 20px;\n    display: flex;\n}\n.elem {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 200px;\n    height: 200px;\n    background-color: #f66;\n    font-size: 20px;\n    color: #fff;\n}\n\n\n若不特别指明，可能各位同学觉得这两段代码无异样，顶多就是属性顺序不同。但仔细观察两段代码，就会发现第一段代码好像无依据地随便排列，而第二段代码好像按照某些规范顺序排列。\n\n属性排序指按照预设规范排列属性。提供一个预设的约定规范，依据该规范以一定的顺序排列所有属性。\n\n曾经笔者也是随机排列属性顺序，想到什么写什么，反正能实现就行。但反过来看，随意真的好吗，每次维护代码都需反复确认某个属性是否已经存在，混乱的属性排序让笔者有时无法在脑海里构思出更好的排版。所以笔者下意识去了解和认识属性排序，利用一些约定规范合理管理我的 css 代码。\n\n曾经有一个著名的 css 网站csstricks做了一份属性排序的调查问卷，调查结果如下。",charsets:{cjk:!0},lastUpdated:"2022年06月11日",lastUpdatedTimestamp:1654956222e3},{title:"浏览器",frontmatter:{title:"浏览器",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/%E7%8E%A9%E8%BD%ACCSS%E8%89%BA%E6%9C%AF%E4%B9%8B%E7%BE%8E/%E6%B5%8F%E8%A7%88%E5%99%A8.html",relativePath:"前端开发/Css/玩转CSS艺术之美/浏览器.md",key:"v-6400ccc0",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Css/%E7%8E%A9%E8%BD%ACCSS%E8%89%BA%E6%9C%AF%E4%B9%8B%E7%BE%8E/%E6%B5%8F%E8%A7%88%E5%99%A8.html",headers:[{level:3,title:"渲染引擎",slug:"渲染引擎",normalizedTitle:"渲染引擎",charIndex:2},{level:2,title:"渲染过程",slug:"渲染过程",normalizedTitle:"渲染过程",charIndex:878},{level:3,title:"解析文件",slug:"解析文件",normalizedTitle:"解析文件",charIndex:990},{level:3,title:"绘制图层",slug:"绘制图层",normalizedTitle:"绘制图层",charIndex:1502},{level:3,title:"合成图层",slug:"合成图层",normalizedTitle:"合成图层",charIndex:1555}],headersStr:"渲染引擎 渲染过程 解析文件 绘制图层 合成图层",content:'# 渲染引擎\n\n渲染引擎又名浏览器内核，指负责对网页语法解析并渲染成一张可视化页面的解析器。它是浏览器最核心最重要的部位，不同内核对网页语法的解析也有不同，因此同一网页语法在不同内核的浏览器中的渲染效果也可能不同，这就是常说的浏览器差异性。\n\n上述提到的世界五大浏览器，在自身的发展过程中都使用了一种或多种浏览器内核作为自身的渲染引擎。\n\n * Google Chrome：Webkit(前期)、Blink(后期)\n * Apple Safari：Webkit\n * Mozilla Firefox：Gecko\n * ASA Opera：Presto(前期)、Blink(后期)\n * Microsoft IExplorer：Trident\n * Microsoft Edge：Trident(前期)、Blink(后期)\n\nIExplorer和Edge同是微软公司开发的浏览器产品，鉴于IExplorer存在很多为人诟病的问题，在后续的系统升级中逐渐使用Edge取代IExplorer在Windows上的位置\n\n\n因此20多年的浏览器发展史里，被大规模使用的浏览器内核也就这五个。\n\n * Blink内核：由谷歌公司和欧朋公司合作自研的内核，同时谷歌公司也将其作为开源内核架构Chromium的一部分发布，在Chrome 28+和Opear 15+中被使用。\n * Webkit内核：由苹果公司自研的内核，同时也是Blink内核的原型，在Chrome 1 ~ 28和Safari 1+中被使用。\n * Gecko内核：由网景公司自研的内核，先期在Navigator中使用，后期推广到Firefox上，在Firefox 1+中被使用。\n * Presto内核：由欧朋公司自研的内核，其渲染性能达到极致但牺牲了兼容性，目前已经废弃，在Opear 7 ~ 14中被使用。\n * Trident内核：由微软公司自研的内核，由于其被包含在全世界使用率最高的Windows操作系统中，导致十多年时间里一直称霸浏览器内核界，在IExplorer 4+中被使用。\n\n\n# 渲染过程\n\n要了解浏览器页面的渲染过程，首先得知道关键渲染路径。关键渲染路径指浏览器从最初接收请求得到 HTML、CSS、JS 等资源，然后解析、构建、渲染、布局、绘制、合成，到最后呈现在用户眼前界面的整个过程。\n\n 1. 解析文件\n\n * 将 html 文件转换为 DOM 树\n * 将 css 文件转换为 CSSOM 树\n * 将 DOM 树和 CSSOM 树合并生成渲染树\n\nHTML 文档描述一个页面的结构，浏览器通过HTML解析器将 HTML 解析成 DOM 树结构。HTML 文档中所有内容皆为节点，各节点间拥有层级关系，彼此相连，构成 DOM 树。构建DOM树的过程：读取 HTML 文档的字节(Bytes)，将字节转换成字符(Chars)，依据字符确定标签(Tokens)，将标签转换成节点(Nodes)，以节点为基准构建 DOM 树。\n\nCSS 文档描述一个页面的表现，浏览器通过 CSS 解析器将 CSS 解析成 CSSOM 树结构，与 DOM 树结构比较像。CSS 文档中所有内容皆为节点，与 HTML 文档中的节点一一对应，各节点间拥有层级关系，彼此相连，构成 CSSOM 树。构建 CSSOM 树的过程：读取 CSS 文档的字节(Bytes)，将字节转换成字符(Chars)，依据字符确定标签(Tokens)，将标签转换成节点(Nodes)，以节点为基准构建 CSSOM 树。与 DOM 树的构建过程完全一致。\n\n 2. 绘制图层\n\n * 根据渲染树生成布局渲染树(回流)\n * 根据布局渲染树生成绘制渲染树(重绘)\n\n 3. 合成图层：根据绘制渲染树合成图层显示在屏幕上\n\n\n# 解析文件\n\nHTML文档描述一个页面的结构，浏览器通过HTML解析器将HTML解析成DOM树结构。HTML文档中所有内容皆为节点，各节点间拥有层级关系，彼此相连，构成DOM树。构建DOM树的过程：读取HTML文档的字节(Bytes)，将字节转换成字符(Chars)批注：在计算机屏幕上看到的是实体化的文字，而在计算机存储介质中存放的实际是二进制的比特流。 那么在这两者之间的转换规则就需要一个统一的标准，各种字符集标准就出现了，依据字符确定标签(Tokens)，将标签转换成节点(Nodes)，以节点为基准构建DOM树。\n\n在构建DOM树的过程中，当HTML解析器遇到<script>时会立即阻塞DOM树的构建，将控制权移交给浏览器的JS引擎，等到JS引擎运行完毕，浏览器才会从中断的地方恢复DOM树的构建。<script>的脚本加载完毕，JS引擎通过DOM API和CSSOM API操作DOM树和CSSOM树。为何会产生渲染阻塞呢？其根本原因在于：JS操作DOM后，浏览器无法预测未来DOM的具体内容，为了防止无效操作和节省资源，只能阻塞DOM树的构建。\n\n// TODO:script异步加载：\n\n\n\n浏览器的渲染引擎将DOM树和CSSOM树合并生成渲染树，只渲染需显示的节点及其样式。DOM树、CSSOM树和渲染树三者的构建并无先后条件和先后顺序，并非完全独立而是会有交叉并行构建的情况。因此会形成一边加载，一边解析，一边渲染的工作现象。\n\n\n# 绘制图层\n\n进入绘制阶段，遍历渲染树，调用渲染器的paint()在屏幕上绘制内容。根据渲染树布局计算样式，即每个节点在页面中的布局、尺寸等几何属性。HTML默认是流式布局，CSS和JS会打破这种布局，改变DOM的几何属性和外观属性。在绘制过程中，根据渲染树布局，再根据布局绘制，这就是常听常说的回流重绘。\n\n在此涉及到两个核心概念：回流、重绘。笔者用两句精简的话分别概括它们。\n\n * 回流：几何属性需改变的渲染\n * 重绘：更改外观属性而不影响几何属性的渲染\n\n当生成渲染树后，至少会渲染一次。在后续交互过程中，还会不断地重新渲染。这时只会回流重绘或只有重绘。因此引出一个定向法则：回流必定引发重绘，重绘不一定引发回流。\n\n在下一章中，笔者会安排整章篇幅讲述回流重绘以及如何让回流重绘的影响最小化。相信下一章提及的属性排序应该较少同学了解过或使用过，敬请期待。\n\n\n# 合成图层\n\n兼容性又名网站兼容性或网页兼容性，指网页在各种浏览器上的显示效果可能不同而产生浏览器和网页间的兼容问题。\n\n说到兼容性，就不得不推荐一个专门为前端开发者定制可查询CSS/JS特性在各种浏览器中兼容性的网站Caniuse，它可很好地保障网页在不同浏览器间的兼容性。有了这个工具可快速地了解使用到的代码在各个浏览器中的效果。所以后续使用VScode编码的过程中都会顺带使用Caniuse查看CSS属性与选择器的兼容性。\n\n产生浏览器间的兼容问题，正是上述谈到的渲染引擎而导致的。在网站的设计和开发中，做好浏览器兼容才能让网站在不同浏览器间都能显示正常。浏览器对标准的更好兼容能够给用户带来更好的使用体验，当然无法奢求浏览器厂商能统一所有浏览器标准，所以前端开发者只能自己着手解决。\n\n以下聊聊处理CSS兼容性的三种方式，相对处理JS兼容性来说简单到不得了，这也是普遍前端开发者认为CSS简单的原因之一。\n\n# 磨平浏览器默认样式\n\n每个浏览器的CSS默认样式不尽相同，所以最简单最有效的方式就是对其默认样式初始化。以下贴一个各位同学都会的初始化代码。简单暴力但不明确，*通配符可是有执行性能问题的。\n\n* {\n    margin: 0;\n    padding: 0;\n}\n\n\n以下推荐两种磨平浏览器默认样式的方式，在接入其他css文件前将其导入，天下太平，大家都不能拼爹了，都是在同一起跑线上，IExplorer同学你可别抢跑哇，大家都盯着你呢！\n\n * normalize.css：懒人必备的浏览器默认样式库，接近40k的Star，说明大部分人都是懒人\n * reset.css：其实就是笔者自定义的默认样式，各位同学也可自行为项目撰写一份默认样式\n\n在项目入口文件的其他css文件前导入，若使用burce-cli，可能发现在index.js里已经提前导入了reset.css。\n\nimport "path/to/normalize.css";\n// 或\nimport "path/to/reset.css";\n\n\n# 插入浏览器私有属性\n\n通常编写CSS都会在一些CSS3属性前加入-webkit-、-moz-、-ms-或-o-，这些奇形怪状写到手软的东西就是浏览器私有属性。样式少还好，样式多那就欲哭无泪了😂。\n\n出现这些私有属性，是因为制定CSS标准的W3C其动作就像蜗牛一样慢，量产一个属性是需走一个很严格很复杂的流程。一个成熟且被大众肯定的属性，浏览器厂商会加大其支持力度而铺路，但为了避免日后W3C公布标准时有所变更，就加入一个本厂商的私有属性提前支持该属性，待W3C公布该属性标准后，再让新版浏览器支持标准属性。\n\n对于编写私有属性的顺序需特别注意：兼容性写法放到前面，标准写法放到最后。在浏览器解析CSS过程中，若标准属性无法使用则使用当前浏览器对应的私有属性。\n\n/* Chrome、Safari、New Opera、New Edge */\n-webkit-transform: translate(10px, 10px);\n/* Firefox */\n-moz-transform: translate(10px, 10px);\n/* IExplorer、Old Edge */\n-ms-transform: translate(10px, 10px);\n/* Old Opera */\n-o-transform: translate(10px, 10px);\n/* 标准 */\ntransform: translate(10px, 10px);\n\n\n当然不是所有的CSS3属性都需补齐-webkit-、-moz-、-ms-或-o-，上述Demo只是一个示例，真正的transform私有属性只有-webkit-和-ms-。这些需查看Caniuse确保正确的编写，若想偷懒也可全部写上。\n\n每个CSS3属性都编写这么一堆兼容性代码，无疑是对生命最大的浪费。在使用Webpack打包项目代码的过程中，可接入postcss-loader和postcss-preset-env，postcss-preset-env内置了autoprefixer，它会依据Caniuse所提供的数据对代码里的CSS3属性批量添加私有属性。\n\n若使用bruce-cli，那么也无需关注CSS私有属性的插入，因为其内置了postcss-loader和postcss-preset-env。自动化工具的好处就是为了解决一些重复而无趣的工作。\n\n# CSS Hack\n\nCSS Hack指针对不同浏览器编写不同CSS，让它能够同时兼容不同浏览器，在不同浏览器中渲染想要的效果。当然也可反过来利用CSS Hack为不同版本的浏览器定制不同效果。\n\n在一些老旧网站的html文件或css文件里可能会看到以下代码，没错，这就是CSS Hack。现在可能很多同学都不会遇到这种写法，毕竟很多公司的产品都放弃了IExplorer 8以下的兼容，这些痕迹都已经成为历史。很多同学没想过5年到10年前的前端开发者是多么苦逼的，光兼容IExplorer就已经够烦了，还连续兼容几个版本。\n\n<head>\n    \x3c!--[if IE]>\n    <style>\n    .elem {\n        background-color: #f66;\n    }\n    </style>\n    <![endif]--\x3e\n</head>\n.elem {\n    background-color: #f66; /* IExplorer 8+ */\n    *background-color: #f66; /* IExplorer 7 */\n    _background-color: #f66; /* IExplorer 6 */\n}\n\n\n所以现在也不会推荐去学习这些CSS Hack，有一个基本的了解即可。上述CSS Hack写法只是最简单的几行代码，其实还存在一些更难的表达式。当然也不推荐这种写法，毕竟不符合大名鼎鼎的雅虎军规的Avoid CSS Expressions。',normalizedContent:'# 渲染引擎\n\n渲染引擎又名浏览器内核，指负责对网页语法解析并渲染成一张可视化页面的解析器。它是浏览器最核心最重要的部位，不同内核对网页语法的解析也有不同，因此同一网页语法在不同内核的浏览器中的渲染效果也可能不同，这就是常说的浏览器差异性。\n\n上述提到的世界五大浏览器，在自身的发展过程中都使用了一种或多种浏览器内核作为自身的渲染引擎。\n\n * google chrome：webkit(前期)、blink(后期)\n * apple safari：webkit\n * mozilla firefox：gecko\n * asa opera：presto(前期)、blink(后期)\n * microsoft iexplorer：trident\n * microsoft edge：trident(前期)、blink(后期)\n\niexplorer和edge同是微软公司开发的浏览器产品，鉴于iexplorer存在很多为人诟病的问题，在后续的系统升级中逐渐使用edge取代iexplorer在windows上的位置\n\n\n因此20多年的浏览器发展史里，被大规模使用的浏览器内核也就这五个。\n\n * blink内核：由谷歌公司和欧朋公司合作自研的内核，同时谷歌公司也将其作为开源内核架构chromium的一部分发布，在chrome 28+和opear 15+中被使用。\n * webkit内核：由苹果公司自研的内核，同时也是blink内核的原型，在chrome 1 ~ 28和safari 1+中被使用。\n * gecko内核：由网景公司自研的内核，先期在navigator中使用，后期推广到firefox上，在firefox 1+中被使用。\n * presto内核：由欧朋公司自研的内核，其渲染性能达到极致但牺牲了兼容性，目前已经废弃，在opear 7 ~ 14中被使用。\n * trident内核：由微软公司自研的内核，由于其被包含在全世界使用率最高的windows操作系统中，导致十多年时间里一直称霸浏览器内核界，在iexplorer 4+中被使用。\n\n\n# 渲染过程\n\n要了解浏览器页面的渲染过程，首先得知道关键渲染路径。关键渲染路径指浏览器从最初接收请求得到 html、css、js 等资源，然后解析、构建、渲染、布局、绘制、合成，到最后呈现在用户眼前界面的整个过程。\n\n 1. 解析文件\n\n * 将 html 文件转换为 dom 树\n * 将 css 文件转换为 cssom 树\n * 将 dom 树和 cssom 树合并生成渲染树\n\nhtml 文档描述一个页面的结构，浏览器通过html解析器将 html 解析成 dom 树结构。html 文档中所有内容皆为节点，各节点间拥有层级关系，彼此相连，构成 dom 树。构建dom树的过程：读取 html 文档的字节(bytes)，将字节转换成字符(chars)，依据字符确定标签(tokens)，将标签转换成节点(nodes)，以节点为基准构建 dom 树。\n\ncss 文档描述一个页面的表现，浏览器通过 css 解析器将 css 解析成 cssom 树结构，与 dom 树结构比较像。css 文档中所有内容皆为节点，与 html 文档中的节点一一对应，各节点间拥有层级关系，彼此相连，构成 cssom 树。构建 cssom 树的过程：读取 css 文档的字节(bytes)，将字节转换成字符(chars)，依据字符确定标签(tokens)，将标签转换成节点(nodes)，以节点为基准构建 cssom 树。与 dom 树的构建过程完全一致。\n\n 2. 绘制图层\n\n * 根据渲染树生成布局渲染树(回流)\n * 根据布局渲染树生成绘制渲染树(重绘)\n\n 3. 合成图层：根据绘制渲染树合成图层显示在屏幕上\n\n\n# 解析文件\n\nhtml文档描述一个页面的结构，浏览器通过html解析器将html解析成dom树结构。html文档中所有内容皆为节点，各节点间拥有层级关系，彼此相连，构成dom树。构建dom树的过程：读取html文档的字节(bytes)，将字节转换成字符(chars)批注：在计算机屏幕上看到的是实体化的文字，而在计算机存储介质中存放的实际是二进制的比特流。 那么在这两者之间的转换规则就需要一个统一的标准，各种字符集标准就出现了，依据字符确定标签(tokens)，将标签转换成节点(nodes)，以节点为基准构建dom树。\n\n在构建dom树的过程中，当html解析器遇到<script>时会立即阻塞dom树的构建，将控制权移交给浏览器的js引擎，等到js引擎运行完毕，浏览器才会从中断的地方恢复dom树的构建。<script>的脚本加载完毕，js引擎通过dom api和cssom api操作dom树和cssom树。为何会产生渲染阻塞呢？其根本原因在于：js操作dom后，浏览器无法预测未来dom的具体内容，为了防止无效操作和节省资源，只能阻塞dom树的构建。\n\n// todo:script异步加载：\n\n\n\n浏览器的渲染引擎将dom树和cssom树合并生成渲染树，只渲染需显示的节点及其样式。dom树、cssom树和渲染树三者的构建并无先后条件和先后顺序，并非完全独立而是会有交叉并行构建的情况。因此会形成一边加载，一边解析，一边渲染的工作现象。\n\n\n# 绘制图层\n\n进入绘制阶段，遍历渲染树，调用渲染器的paint()在屏幕上绘制内容。根据渲染树布局计算样式，即每个节点在页面中的布局、尺寸等几何属性。html默认是流式布局，css和js会打破这种布局，改变dom的几何属性和外观属性。在绘制过程中，根据渲染树布局，再根据布局绘制，这就是常听常说的回流重绘。\n\n在此涉及到两个核心概念：回流、重绘。笔者用两句精简的话分别概括它们。\n\n * 回流：几何属性需改变的渲染\n * 重绘：更改外观属性而不影响几何属性的渲染\n\n当生成渲染树后，至少会渲染一次。在后续交互过程中，还会不断地重新渲染。这时只会回流重绘或只有重绘。因此引出一个定向法则：回流必定引发重绘，重绘不一定引发回流。\n\n在下一章中，笔者会安排整章篇幅讲述回流重绘以及如何让回流重绘的影响最小化。相信下一章提及的属性排序应该较少同学了解过或使用过，敬请期待。\n\n\n# 合成图层\n\n兼容性又名网站兼容性或网页兼容性，指网页在各种浏览器上的显示效果可能不同而产生浏览器和网页间的兼容问题。\n\n说到兼容性，就不得不推荐一个专门为前端开发者定制可查询css/js特性在各种浏览器中兼容性的网站caniuse，它可很好地保障网页在不同浏览器间的兼容性。有了这个工具可快速地了解使用到的代码在各个浏览器中的效果。所以后续使用vscode编码的过程中都会顺带使用caniuse查看css属性与选择器的兼容性。\n\n产生浏览器间的兼容问题，正是上述谈到的渲染引擎而导致的。在网站的设计和开发中，做好浏览器兼容才能让网站在不同浏览器间都能显示正常。浏览器对标准的更好兼容能够给用户带来更好的使用体验，当然无法奢求浏览器厂商能统一所有浏览器标准，所以前端开发者只能自己着手解决。\n\n以下聊聊处理css兼容性的三种方式，相对处理js兼容性来说简单到不得了，这也是普遍前端开发者认为css简单的原因之一。\n\n# 磨平浏览器默认样式\n\n每个浏览器的css默认样式不尽相同，所以最简单最有效的方式就是对其默认样式初始化。以下贴一个各位同学都会的初始化代码。简单暴力但不明确，*通配符可是有执行性能问题的。\n\n* {\n    margin: 0;\n    padding: 0;\n}\n\n\n以下推荐两种磨平浏览器默认样式的方式，在接入其他css文件前将其导入，天下太平，大家都不能拼爹了，都是在同一起跑线上，iexplorer同学你可别抢跑哇，大家都盯着你呢！\n\n * normalize.css：懒人必备的浏览器默认样式库，接近40k的star，说明大部分人都是懒人\n * reset.css：其实就是笔者自定义的默认样式，各位同学也可自行为项目撰写一份默认样式\n\n在项目入口文件的其他css文件前导入，若使用burce-cli，可能发现在index.js里已经提前导入了reset.css。\n\nimport "path/to/normalize.css";\n// 或\nimport "path/to/reset.css";\n\n\n# 插入浏览器私有属性\n\n通常编写css都会在一些css3属性前加入-webkit-、-moz-、-ms-或-o-，这些奇形怪状写到手软的东西就是浏览器私有属性。样式少还好，样式多那就欲哭无泪了😂。\n\n出现这些私有属性，是因为制定css标准的w3c其动作就像蜗牛一样慢，量产一个属性是需走一个很严格很复杂的流程。一个成熟且被大众肯定的属性，浏览器厂商会加大其支持力度而铺路，但为了避免日后w3c公布标准时有所变更，就加入一个本厂商的私有属性提前支持该属性，待w3c公布该属性标准后，再让新版浏览器支持标准属性。\n\n对于编写私有属性的顺序需特别注意：兼容性写法放到前面，标准写法放到最后。在浏览器解析css过程中，若标准属性无法使用则使用当前浏览器对应的私有属性。\n\n/* chrome、safari、new opera、new edge */\n-webkit-transform: translate(10px, 10px);\n/* firefox */\n-moz-transform: translate(10px, 10px);\n/* iexplorer、old edge */\n-ms-transform: translate(10px, 10px);\n/* old opera */\n-o-transform: translate(10px, 10px);\n/* 标准 */\ntransform: translate(10px, 10px);\n\n\n当然不是所有的css3属性都需补齐-webkit-、-moz-、-ms-或-o-，上述demo只是一个示例，真正的transform私有属性只有-webkit-和-ms-。这些需查看caniuse确保正确的编写，若想偷懒也可全部写上。\n\n每个css3属性都编写这么一堆兼容性代码，无疑是对生命最大的浪费。在使用webpack打包项目代码的过程中，可接入postcss-loader和postcss-preset-env，postcss-preset-env内置了autoprefixer，它会依据caniuse所提供的数据对代码里的css3属性批量添加私有属性。\n\n若使用bruce-cli，那么也无需关注css私有属性的插入，因为其内置了postcss-loader和postcss-preset-env。自动化工具的好处就是为了解决一些重复而无趣的工作。\n\n# css hack\n\ncss hack指针对不同浏览器编写不同css，让它能够同时兼容不同浏览器，在不同浏览器中渲染想要的效果。当然也可反过来利用css hack为不同版本的浏览器定制不同效果。\n\n在一些老旧网站的html文件或css文件里可能会看到以下代码，没错，这就是css hack。现在可能很多同学都不会遇到这种写法，毕竟很多公司的产品都放弃了iexplorer 8以下的兼容，这些痕迹都已经成为历史。很多同学没想过5年到10年前的前端开发者是多么苦逼的，光兼容iexplorer就已经够烦了，还连续兼容几个版本。\n\n<head>\n    \x3c!--[if ie]>\n    <style>\n    .elem {\n        background-color: #f66;\n    }\n    </style>\n    <![endif]--\x3e\n</head>\n.elem {\n    background-color: #f66; /* iexplorer 8+ */\n    *background-color: #f66; /* iexplorer 7 */\n    _background-color: #f66; /* iexplorer 6 */\n}\n\n\n所以现在也不会推荐去学习这些css hack，有一个基本的了解即可。上述css hack写法只是最简单的几行代码，其实还存在一些更难的表达式。当然也不推荐这种写法，毕竟不符合大名鼎鼎的雅虎军规的avoid css expressions。',charsets:{cjk:!0},lastUpdated:"2022年06月11日",lastUpdatedTimestamp:1654956222e3},{title:"Html",frontmatter:{title:"Html",sidebar:"auto",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Html.html",relativePath:"前端开发/Html.md",key:"v-619cc960",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Html.html",headers:[{level:2,title:"html5(Hyper Text Markup Language)骨架",slug:"html5-hyper-text-markup-language-骨架",normalizedTitle:"html5(hyper text markup language)骨架",charIndex:2},{level:3,title:"<!DOCTYPE html>的重要性",slug:"doctype-html-的重要性",normalizedTitle:"<!doctype html>的重要性",charIndex:500},{level:2,title:"字符集",slug:"字符集",normalizedTitle:"字符集",charIndex:875},{level:2,title:"title,关键词及页面描述",slug:"title-关键词及页面描述",normalizedTitle:"title,关键词及页面描述",charIndex:1264},{level:3,title:"title 的用途",slug:"title-的用途",normalizedTitle:"title 的用途",charIndex:1283},{level:3,title:"网页关键词和页面描述",slug:"网页关键词和页面描述",normalizedTitle:"网页关键词和页面描述",charIndex:1382},{level:2,title:"标题和段落标签",slug:"标题和段落标签",normalizedTitle:"标题和段落标签",charIndex:1715},{level:2,title:"div 标签",slug:"div-标签",normalizedTitle:"div 标签",charIndex:1914},{level:2,title:"HTML5 特性",slug:"html5-特性",normalizedTitle:"html5 特性",charIndex:1955},{level:3,title:"空白折叠现象",slug:"空白折叠现象",normalizedTitle:"空白折叠现象",charIndex:1968},{level:3,title:"转义字符",slug:"转义字符",normalizedTitle:"转义字符",charIndex:2032},{level:2,title:"列表标签",slug:"列表标签",normalizedTitle:"列表标签",charIndex:2135},{level:3,title:"有序列表 ol",slug:"有序列表-ol",normalizedTitle:"有序列表 ol",charIndex:2315},{level:3,title:"定义列表 dl",slug:"定义列表-dl",normalizedTitle:"定义列表 dl",charIndex:2680},{level:2,title:"多媒体标签",slug:"多媒体标签",normalizedTitle:"多媒体标签",charIndex:3251},{level:3,title:"img 标签",slug:"img-标签",normalizedTitle:"img 标签",charIndex:3261},{level:3,title:"a 标签",slug:"a-标签",normalizedTitle:"a 标签",charIndex:1699},{level:3,title:"audio 标签",slug:"audio-标签",normalizedTitle:"audio 标签",charIndex:3706},{level:3,title:"video 标签",slug:"video-标签",normalizedTitle:"video 标签",charIndex:3859},{level:2,title:"语义化标签",slug:"语义化标签",normalizedTitle:"语义化标签",charIndex:3894},{level:3,title:"语义化标签的优势",slug:"语义化标签的优势",normalizedTitle:"语义化标签的优势",charIndex:4014},{level:3,title:"常见的语义化标签",slug:"常见的语义化标签",normalizedTitle:"常见的语义化标签",charIndex:4290},{level:2,title:"表格标签",slug:"表格标签",normalizedTitle:"表格标签",charIndex:6441},{level:3,title:"单元格的合并",slug:"单元格的合并",normalizedTitle:"单元格的合并",charIndex:7352},{level:3,title:"表格的其他特征",slug:"表格的其他特征",normalizedTitle:"表格的其他特征",charIndex:7426},{level:2,title:"表单标签",slug:"表单标签",normalizedTitle:"表单标签",charIndex:7938},{level:3,title:"表单的创建",slug:"表单的创建",normalizedTitle:"表单的创建",charIndex:7947},{level:3,title:"单行文本框",slug:"单行文本框",normalizedTitle:"单行文本框",charIndex:8164},{level:3,title:"单选按钮",slug:"单选按钮",normalizedTitle:"单选按钮",charIndex:8388},{level:3,title:"label 标签",slug:"label-标签",normalizedTitle:"label 标签",charIndex:4166},{level:3,title:"复选框",slug:"复选框",normalizedTitle:"复选框",charIndex:8789},{level:3,title:"密码框",slug:"密码框",normalizedTitle:"密码框",charIndex:9064},{level:3,title:"下拉菜单",slug:"下拉菜单",normalizedTitle:"下拉菜单",charIndex:9112},{level:3,title:"多行文本框",slug:"多行文本框",normalizedTitle:"多行文本框",charIndex:9335},{level:3,title:"三种按钮",slug:"三种按钮",normalizedTitle:"三种按钮",charIndex:9403},{level:3,title:"datalist 控件",slug:"datalist-控件",normalizedTitle:"datalist 控件",charIndex:9589}],headersStr:"html5(Hyper Text Markup Language)骨架 <!DOCTYPE html>的重要性 字符集 title,关键词及页面描述 title 的用途 网页关键词和页面描述 标题和段落标签 div 标签 HTML5 特性 空白折叠现象 转义字符 列表标签 有序列表 ol 定义列表 dl 多媒体标签 img 标签 a 标签 audio 标签 video 标签 语义化标签 语义化标签的优势 常见的语义化标签 表格标签 单元格的合并 表格的其他特征 表单标签 表单的创建 单行文本框 单选按钮 label 标签 复选框 密码框 下拉菜单 多行文本框 三种按钮 datalist 控件",content:'# html5(Hyper Text Markup Language)骨架\n\n注意\n\n请始终向 HTML 文档添加 <!DOCTYPE> 声明，这样浏览器才能获知文档类型。\n\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>文档的标题</title>\n    </head>\n\n    <body>\n        文档的内容......\n    </body>\n</html>\n\n\n * <!DOCTYPE>声明必须是 HTML文档的第一行，位于 html标签之前。\n * <!DOCTYPE>声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。\n * 在 HTML 4.01中，<!DOCTYPE>声明引用 DTD，因为 HTML 4.01基于SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。\n * HTML5不基于SGML，所以不需要引用DTD，在 HTML 4.01 中有三种 <!DOCTYPE> 声明。在 HTML5 中只有一种：<!DOCTYPE html>\n\n\n# <!DOCTYPE html>的重要性\n\n声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式\n\ndocument.compatMode：\n\n * BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。\n * CSS1Compat：标准模式，浏览器使用 W3C 的标准解析渲染页面。\n\n这个属性会被浏览器识别并使用，但是如果你的页面没有<!DOCTYPE>的声明，那么compatMode默认就是BackCompat,\n\n浏览器按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式。\n\n如果你的页面添加了<!DOCTYPE html>那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。\n\n\n# 字符集\n\n注意\n\n无论使用哪种字符集，一定要在Vscode编辑器中将文件也设置为相同字符集，否则会岀现乱码，然后更改meta标签\n\n字符集           涵盖字符                                  一个汉字字节数   适用场景\nUTF-8         涵盖全球所有国家、民族的文字和大量图形字符                 3         制作有非汉字文字的网页\nGb2312(gbk)   收录所有汉字字符（包括简体、繁体)和英语、少量韩文、日语和少量图形字符   2         制作只有汉语和英语的网页 由于 1 个汉字仅占 2 字节，网页文件尺寸明显减少\n\n\x3c!-- meta：元标签，表示网页的基本配置 --\x3e\n\x3c!-- charset：字符集 --\x3e\n<meta charset="UTF-8" />\n\n\n\n# title,关键词及页面描述\n\n\n# title 的用途\n\n 1. title标签用来设置网页的标题，文字会显示在浏览器的签栏上\n 2. title也是搜索引擎收录网站时显示的标题，为了吸引用户点击，合理设置title是必要的\n\n\n# 网页关键词和页面描述\n\n 1. 合理设置网页的网页的关键词和页面描述，也是SEO的重要手段\n\nSEO（ Search Engine Optimization，搜索引擎优化）利用搜索引擎的规则提高网站在有关搜索引擎內的自然排名,让网站在搜索引擎的结果中占据领先地位，获得品牌收益\n\n 2. 使用meta标签设置网页关键词和描述，name属性非常关键,用来设置meta的具体功能\n\n<meta name="keywords" content="前端,JavaScript,Vue,React" />\n<meta name="description" content="一个前端学习博客" />\n\n\n 3. 其他 meta:HTML meta 标签 看这篇就够了\n\n\n# 标题和段落标签\n\n<h1>\n    ~\n    <h6></h6>\n</h1>\n\n\n * 搜索引擎非常看重h1标签的内容，应该将重点内容放到h1中，比如网页的logo等\n\n * h1标签一般只能放置一个\n\n<p>this is a p</p>\n\n\n * 任何段落都要放到p标签中，因为HTML中即使代码换行了，页面显示效果也不会换行\n\n * p元素嵌套任何块级元素都一定会被浏览器错误解析\n\n\n# div 标签\n\ndiv像是一个容器，什么都可以容纳，因此一般被称呼为盒子\n\n\n# HTML5 特性\n\n\n# 空白折叠现象\n\n 1. 文字和文字之间的多个空格、换行会被折叠成一个空格\n 2. 标签“内壁”和文字之间的空格会被忽略\n\n\n# 转义字符\n\n\x3c!-- //小于号 --\x3e\n&lt;\n\x3c!-- //大于号 --\x3e\n&gt;\n\x3c!-- //空格（不会被折叠） --\x3e\n&nbsp;\n\x3c!--  //版权符号 --\x3e\n&copy;\n\n\n\n# 列表标签\n\n\x3c!-- 无序列表 --\x3e\n<ul></ul>\n\x3c!-- 有序列表 --\x3e\n<ol></ol>\n\x3c!-- 定义列表 --\x3e\n<dl>\n    <dt></dt>\n    <dd></dd>\n</dl>\n\n\n注意：\n\n * li标签是不能单独使用的，它必须放到ul或ol中\n * ul和ol的子标签只能是li\n * li标签中可以放任何标签\n\n\n# 有序列表 ol\n\n# ol 标签的 type 属性\n\nTYPE 属性值   意义\na          表示小写英文字母编号\nA          表示大写英文字母编号\n¡          表示小写罗马数字编号\nⅠ          表示大写罗马数字编号\n1          表示数字编号（默认）\n\n# ol 标签的 start 属性\n\n1.start属性值必须是一个整数，指定了列表编号的起始值\n\n 2. 此属性的值应为阿拉伯数字，尽管列表条目的编号类型type属性可能指定为了罗马数字编号等其他类型的编号\n\n# ol 标签的 reversed 属性\n\n 1. reversed属性指定列表中的条目是否是倒序排列的\n\n 2. reversed属性不需要值，只需要写reversed单词即可，这是HTML5的全新特性\n\n\n# 定义列表 dl\n\n * 需要逐条给出定义描述的列表就是定义列表\n * 只要语义上有“解释说明”含义的文字，且为列表形态，应该使用定义列表。\n\n\x3c!-- 定义列表 --\x3e\n<dl>\n    \x3c!-- 数据项  --\x3e\n    <dt></dt>\n    \x3c!--数据定义  --\x3e\n    <dd></dd>\n</dl>\n\n\n * 一个例子:\n\n\x3c!-- <dl>是定义列表标签，内容交替出现<dt>、<dd>标签 --\x3e\n<dl>\n    <dt>手机</dt>\n    <dd>iphone</dd>\n    <dd>xiaomi</dd>\n    <dd>huawei</dd>\n    <dt>电脑</dt>\n    <dd>联想</dd>\n    <dd>HP</dd>\n    <dd>DELL</dd>\n</dl>\n\x3c!-- 也允许dt和dd不交替出现，而是分别处于不同的定义列表中 --\x3e\n<dl>\n    <dt>手机</dt>\n    <dd>iphone</dd>\n    <dd>xiaomi</dd>\n    <dd>huawei</dd>\n    <dt>电脑</dt>\n</dl>\n<dl>\n    <dd>联想</dd>\n    <dd>HP</dd>\n    <dd>DELL</dd>\n</dl>\n\n\n\n# 多媒体标签\n\n\n# img 标签\n\n提示\n\n如果需要回退层级，使用../这样的写法,./是当前目录\n\n 1. alt属性：由于某种原因无法加载图像，浏览器会在页面上显示alt属性中的备用文本\n 2. 相对路径：描述从网页出发，如何找到图片\n 3. 绝对路径：描述图片精准地址\n\n\n# a 标签\n\n注意\n\na元素嵌套a 元素会导致所有浏览器解析错误,但a 元素可以嵌套其他的内联元素(比如:img)\n\n 1. href属性：规定链接的目标地址,支持相对路径和绝对路径\n\n 2. title属性：用于设置鼠标的悬停文本\n\n 3. 在新窗口打开网页：将target属性设置为blank\n\n 4. 给图片设置超级链接：用 a 标签包裹 img 标签\n\n 5. 页面内锚点：较长的页面，可以适当的给 h 系列标签添加 id属性，它将成为页面的“锚点”;当网址后面添加#时，页面将自动滚动到锚点所在位置;其他页面的超级链接，可以链接到指定锚点\n\n<a href="1.html#baoji">baoji</a>\n\n\n\n# audio 标签\n\n<audio controls src="音频地址"></audio>\n\n\n 1. autoplay属性：声明 autopaly 会自动播放音乐\n 2. loop属性：声明 loop 属性会循环播放音频\n 3. controls属性: 显示控制面板\n 4. muted: 静音\n\n\n# video 标签\n\n使用方法，属性和audio类似，不赘述。\n\n\n# 语义化标签\n\n语义化的标签，旨在让标签有自己的含义\n\n<p>一行文字</p>\n<span>一行文字</span>\n\n\n如上代码，p 标签与 span 标签都区别之一就是，p 标签的含义是：段落。而 span 标签责没有独特的含义。\n\n\n# 语义化标签的优势\n\n * 代码结构: 使页面没有 css的情况下，也能够呈现出很好的内容结构\n\n * 有利于 SEO: 爬虫依赖标签来确定关键字的权重，因此可以和搜索引擎建立良好的沟通，帮助爬虫抓取更多的有效信息\n\n * 提升用户体验： 例如 title、alt 可以用于解释名称或者解释图片信息，以及 label 标签的灵活运用。\n\n * 便于团队开发和维护: 语义化使得代码更具有可读性，让其他开发人员更加理解你的 html 结构，减少差异化。\n\n * 方便其他设备解析: 如屏幕阅读器、盲人阅读器、移动设备等，以有意义的方式来渲染网页。\n\n\n# 常见的语义化标签\n\n\n\n# h1~h6 元素\n\n定义页面的标题，h1 元素具有最高等级，h6元素具有最低的等级\n\n# header 标签\n\n用于定义页面的介绍展示区域，通常包括网站 logo、主导航、全站链接以及搜索框。也适合对页面内部一组介绍性或导航性内容进行标记。\n\n<header>\n    <h1>HTML Reference</h1>\n    <nav>\n        <a>Home</a>\n        <a>About</a>\n        <a>Contact</a>\n    </nav>\n</header>\n\n\n# nav 标签\n\n定义导航链接的部分\n\n<nav>\n    <a>Home</a>\n    <a>About</a>\n    <a>Contact</a>\n</nav>\n\n\n# article 标签\n\n标签定义外部的内容。\n\n外部内容可以是来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文本，或者是来自论坛的文本。亦或是来自其他外部源内容。\n\n<article>\n    <header>\n        <h3>\n            <a href="">My blog</a>\n        </h3>\n    </header>\n    <section>\n        <p>这是我的个人博客地址</p>\n    </section>\n    <footer>\n        <small>\n            Posted on\n            <time datetime="2021-011-20T19:00">Apr 20</time> in\n            <a href="https://www.zfhblog.top">点我访问</a>\n        </small>\n    </footer>\n</article>\n\n\n# main 标签\n\n定义页面的主要内容，一个页面只能使用一次.\n\n注意\n\n在一个文档中，不能出现一个以上的 <main> 元素。<main> 元素不能是以下元素的后代：<article>、<aside>、<footer>、<header> 或 <nav>。\n\n<main>\n    <h1>My blog test</h1>\n    <p>\n        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec viverra\n        nec nulla vitae mollis.\n    </p>\n    <p>etc.</p>\n</main>\n\n\n# section 标签\n\nsection 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。\n\n<section>\n    <h2>Section title</h2>\n    <p>\n        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec viverra\n        nec nulla vitae mollis.\n    </p>\n</section>\n\n\n# aside 标签\n\n定义与主要内容相关的内容块。通常显示为侧边栏。\n\n# footer 标签\n\n定义文档的底部区域，通常包含文档的作者，著作权信息，链接的使用条款，联系信息等\n\n# small 标签\n\n为较不重要的内容定义小字体。如果被包围的字体已经是字体模型所支持的最小字号，那么small 标签将不起任何作用。\n\n# strong 标签\n\n把文本定义为语气更强的强调的内容，以表示内容的重要性。\n\n# em 标签\n\n标记内容着重点（大量用于提升段落文本语义），通常呈现为斜体文字。\n\n# blockquote 标签\n\n定义块引用，浏览器会在 blockquote 元素前后添加换行，并增加外边距。cite 属性可用来规定引用的来源\n\n<blockquote cite="https://en.wikiquote.org/wiki/Marie_Curie">\n    Here is a long quotation here is a long quotation here is a long quotation\n    here is a long quotation here is a long quotation here is a long quotation\n    here is a long quotation here is a long quotation here is a long quotation.\n</blockquote>\n\n\n# abbr 标签\n\n解释缩写词。使用 title 属性可提供全称，只在第一次出现时使用就 ok。\n\nThe <abbr title="People\'s Republic of China">PRC</abbr> was founded in 1949.\n\n\n\n# 表格标签\n\n⛔️\n\ntable作为块级元素，其在没有指定宽度的情况并不会继承父元素的宽度，其默认的宽度是根据表格中填写的数据所控制的\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>Document</title>\n    </head>\n    <body>\n        \x3c!-- 这种写法已被废弃 --\x3e\n        <table border="1">\n            \x3c!-- 表格的标题 --\x3e\n            <caption>\n                数字表\n            </caption>\n            <tr>\n                \x3c!-- 标题单元格 --\x3e\n                <th>1</th>\n                <th>2</th>\n                <th>3</th>\n            </tr>\n            <tr>\n                <td>4</td>\n                <td>5</td>\n                <td>6</td>\n            </tr>\n            <tr>\n                <td>5</td>\n                <td>8</td>\n                <td>9</td>\n            </tr>\n        </table>\n    </body>\n</html>\n\n\n\n# 单元格的合并\n\n * colspan属性:用来设置 td 或 th 的列跨度\n * rowspan属性:用来设置 td 或 th 的行跨度\n\n\n# 表格的其他特征\n\n * < thead >标签定义表头\n * < tbody >标签定义表核心内容\n * < tfoot >标签定义表脚，通常是汇总行\n\n<table border="1">\n    <thead>\n        <tr>\n            <th>Month</th>\n            <th>Savings</th>\n        </tr>\n    </thead>\n\n    <tbody>\n        <tr>\n            <td>January</td>\n            <td>$100</td>\n        </tr>\n        <tr>\n            <td>February</td>\n            <td>$80</td>\n        </tr>\n    </tbody>\n\n    <tfoot>\n        <tr>\n            <td>Sum</td>\n            <td>$180</td>\n        </tr>\n    </tfoot>\n</table>\n\n\n\n# 表单标签\n\n\n# 表单的创建\n\n表单用来收集信息，比如注册、登录、发送评论反馈、购买商品等等\n\n * action属性表示表单要提交到的后台程序的网址(现在基本用不到了)\n * method属性表示表单提交的方式，有 get 或 post(现在基本用不到了)\n * onsubmit:onsubmit 事件在表单提交时触发\n\n<form action="" method="" onsubmit="myFunction()"></form>\n\n\n\n# 单行文本框\n\n * value属性表示已经填写好的值\n\n<input type="text" value="zfh" />\n\n\n * placeholder属性表示提示文本，将以浅色文字写在文本框中，并不是文本框中的值\n\n<input type="text" placeholder="请输入姓名" />\n\n\n * disabled 属性表示用户不能与元素交互，即“锁死"\n\n<input type="text" disabled />\n\n\n\n# 单选按钮\n\n * 互斥的单选按钮应该设置它们的name为相同值\n * 单选按钮要有value属性值，向服务器提交的就是 value 值\n * 单选按钮如果加上了checked属性，表示默认被选中\n\n男<input type="radio" name="sex" value="男" /> 女<input\n    type="radio"\n    name="sex"\n    value="女"\n    checked\n/>\n\n\n\n# label 标签\n\nlabel标签用来将文字和单选按钮进行绑定，用户单击文字的时候也视为点击了单选按钮\n\n<label> 男<input type="radio" name="sex" value="男" /> </label>\n\n<label> 女<input type="radio" name="sex" value="女" /> </label>\n\n\n\n# 复选框\n\n * 同组复选框应该设置它们的name为相同值\n * 复选框要有 value属性值，向服务器提交的就是 value 值\n * 多选按钮如果加上了 checked属性，表示默认被选中\n\n<input type="checkbox" name="province" value="sx" />陕西\n<input type="checkbox" name="province" value="sc" />四川\n<input type="checkbox" name="province" value="hb" checked />湖北\n\n\n\n# 密码框\n\n使用type属性值被设置为password的 input 元素可以创建密码框\n\n\n# 下拉菜单\n\n * <select>标签表示下拉菜单，<option>是它内部的选项\n * value是提交到服务器的值\n * selected表示默认被选中\n\n<select>\n    <option value="alipay">支付宝</option>\n    <option value="vx">微信</option>\n    <option value="dy" selected>抖音</option>\n</select>\n\n\n\n# 多行文本框\n\n<textarea></textarea>表示多行文本框；rows和cols属性，用于定义多行文本框的行数和列数\n\n\n# 三种按钮\n\n// 普通按钮 ，可以简写为<button></button>\n// value代表按钮上的文字\n<input type="button" value="普通按钮" />\n// 重置按钮\n<input type="reset" value="重置按钮" />\n// 提交按钮\n<input type="submit" value="提交按钮" />\n\n\n\n# datalist 控件\n\ndatalist控件可以为输入框提供一些备选项，当用户输入的内容与备选项文字相同时，将会显示智能感应\n\n<input type="text" list="province-list" />\n<datalist id="province-list">\n    <option value="山东"></option>\n    <option value="陕西"></option>\n    <option value="云南"></option>\n    <option value="贵州"></option>\n</datalist>\n',normalizedContent:'# html5(hyper text markup language)骨架\n\n注意\n\n请始终向 html 文档添加 <!doctype> 声明，这样浏览器才能获知文档类型。\n\n<!doctype html>\n<html>\n    <head>\n        <title>文档的标题</title>\n    </head>\n\n    <body>\n        文档的内容......\n    </body>\n</html>\n\n\n * <!doctype>声明必须是 html文档的第一行，位于 html标签之前。\n * <!doctype>声明不是 html 标签；它是指示 web 浏览器关于页面使用哪个 html 版本进行编写的指令。\n * 在 html 4.01中，<!doctype>声明引用 dtd，因为 html 4.01基于sgml。dtd 规定了标记语言的规则，这样浏览器才能正确地呈现内容。\n * html5不基于sgml，所以不需要引用dtd，在 html 4.01 中有三种 <!doctype> 声明。在 html5 中只有一种：<!doctype html>\n\n\n# <!doctype html>的重要性\n\n声明文档的解析类型(document.compatmode)，避免浏览器的怪异模式\n\ndocument.compatmode：\n\n * backcompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。\n * css1compat：标准模式，浏览器使用 w3c 的标准解析渲染页面。\n\n这个属性会被浏览器识别并使用，但是如果你的页面没有<!doctype>的声明，那么compatmode默认就是backcompat,\n\n浏览器按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式。\n\n如果你的页面添加了<!doctype html>那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照w3c的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。\n\n\n# 字符集\n\n注意\n\n无论使用哪种字符集，一定要在vscode编辑器中将文件也设置为相同字符集，否则会岀现乱码，然后更改meta标签\n\n字符集           涵盖字符                                  一个汉字字节数   适用场景\nutf-8         涵盖全球所有国家、民族的文字和大量图形字符                 3         制作有非汉字文字的网页\ngb2312(gbk)   收录所有汉字字符（包括简体、繁体)和英语、少量韩文、日语和少量图形字符   2         制作只有汉语和英语的网页 由于 1 个汉字仅占 2 字节，网页文件尺寸明显减少\n\n\x3c!-- meta：元标签，表示网页的基本配置 --\x3e\n\x3c!-- charset：字符集 --\x3e\n<meta charset="utf-8" />\n\n\n\n# title,关键词及页面描述\n\n\n# title 的用途\n\n 1. title标签用来设置网页的标题，文字会显示在浏览器的签栏上\n 2. title也是搜索引擎收录网站时显示的标题，为了吸引用户点击，合理设置title是必要的\n\n\n# 网页关键词和页面描述\n\n 1. 合理设置网页的网页的关键词和页面描述，也是seo的重要手段\n\nseo（ search engine optimization，搜索引擎优化）利用搜索引擎的规则提高网站在有关搜索引擎內的自然排名,让网站在搜索引擎的结果中占据领先地位，获得品牌收益\n\n 2. 使用meta标签设置网页关键词和描述，name属性非常关键,用来设置meta的具体功能\n\n<meta name="keywords" content="前端,javascript,vue,react" />\n<meta name="description" content="一个前端学习博客" />\n\n\n 3. 其他 meta:html meta 标签 看这篇就够了\n\n\n# 标题和段落标签\n\n<h1>\n    ~\n    <h6></h6>\n</h1>\n\n\n * 搜索引擎非常看重h1标签的内容，应该将重点内容放到h1中，比如网页的logo等\n\n * h1标签一般只能放置一个\n\n<p>this is a p</p>\n\n\n * 任何段落都要放到p标签中，因为html中即使代码换行了，页面显示效果也不会换行\n\n * p元素嵌套任何块级元素都一定会被浏览器错误解析\n\n\n# div 标签\n\ndiv像是一个容器，什么都可以容纳，因此一般被称呼为盒子\n\n\n# html5 特性\n\n\n# 空白折叠现象\n\n 1. 文字和文字之间的多个空格、换行会被折叠成一个空格\n 2. 标签“内壁”和文字之间的空格会被忽略\n\n\n# 转义字符\n\n\x3c!-- //小于号 --\x3e\n&lt;\n\x3c!-- //大于号 --\x3e\n&gt;\n\x3c!-- //空格（不会被折叠） --\x3e\n&nbsp;\n\x3c!--  //版权符号 --\x3e\n&copy;\n\n\n\n# 列表标签\n\n\x3c!-- 无序列表 --\x3e\n<ul></ul>\n\x3c!-- 有序列表 --\x3e\n<ol></ol>\n\x3c!-- 定义列表 --\x3e\n<dl>\n    <dt></dt>\n    <dd></dd>\n</dl>\n\n\n注意：\n\n * li标签是不能单独使用的，它必须放到ul或ol中\n * ul和ol的子标签只能是li\n * li标签中可以放任何标签\n\n\n# 有序列表 ol\n\n# ol 标签的 type 属性\n\ntype 属性值   意义\na          表示小写英文字母编号\na          表示大写英文字母编号\n¡          表示小写罗马数字编号\nⅰ          表示大写罗马数字编号\n1          表示数字编号（默认）\n\n# ol 标签的 start 属性\n\n1.start属性值必须是一个整数，指定了列表编号的起始值\n\n 2. 此属性的值应为阿拉伯数字，尽管列表条目的编号类型type属性可能指定为了罗马数字编号等其他类型的编号\n\n# ol 标签的 reversed 属性\n\n 1. reversed属性指定列表中的条目是否是倒序排列的\n\n 2. reversed属性不需要值，只需要写reversed单词即可，这是html5的全新特性\n\n\n# 定义列表 dl\n\n * 需要逐条给出定义描述的列表就是定义列表\n * 只要语义上有“解释说明”含义的文字，且为列表形态，应该使用定义列表。\n\n\x3c!-- 定义列表 --\x3e\n<dl>\n    \x3c!-- 数据项  --\x3e\n    <dt></dt>\n    \x3c!--数据定义  --\x3e\n    <dd></dd>\n</dl>\n\n\n * 一个例子:\n\n\x3c!-- <dl>是定义列表标签，内容交替出现<dt>、<dd>标签 --\x3e\n<dl>\n    <dt>手机</dt>\n    <dd>iphone</dd>\n    <dd>xiaomi</dd>\n    <dd>huawei</dd>\n    <dt>电脑</dt>\n    <dd>联想</dd>\n    <dd>hp</dd>\n    <dd>dell</dd>\n</dl>\n\x3c!-- 也允许dt和dd不交替出现，而是分别处于不同的定义列表中 --\x3e\n<dl>\n    <dt>手机</dt>\n    <dd>iphone</dd>\n    <dd>xiaomi</dd>\n    <dd>huawei</dd>\n    <dt>电脑</dt>\n</dl>\n<dl>\n    <dd>联想</dd>\n    <dd>hp</dd>\n    <dd>dell</dd>\n</dl>\n\n\n\n# 多媒体标签\n\n\n# img 标签\n\n提示\n\n如果需要回退层级，使用../这样的写法,./是当前目录\n\n 1. alt属性：由于某种原因无法加载图像，浏览器会在页面上显示alt属性中的备用文本\n 2. 相对路径：描述从网页出发，如何找到图片\n 3. 绝对路径：描述图片精准地址\n\n\n# a 标签\n\n注意\n\na元素嵌套a 元素会导致所有浏览器解析错误,但a 元素可以嵌套其他的内联元素(比如:img)\n\n 1. href属性：规定链接的目标地址,支持相对路径和绝对路径\n\n 2. title属性：用于设置鼠标的悬停文本\n\n 3. 在新窗口打开网页：将target属性设置为blank\n\n 4. 给图片设置超级链接：用 a 标签包裹 img 标签\n\n 5. 页面内锚点：较长的页面，可以适当的给 h 系列标签添加 id属性，它将成为页面的“锚点”;当网址后面添加#时，页面将自动滚动到锚点所在位置;其他页面的超级链接，可以链接到指定锚点\n\n<a href="1.html#baoji">baoji</a>\n\n\n\n# audio 标签\n\n<audio controls src="音频地址"></audio>\n\n\n 1. autoplay属性：声明 autopaly 会自动播放音乐\n 2. loop属性：声明 loop 属性会循环播放音频\n 3. controls属性: 显示控制面板\n 4. muted: 静音\n\n\n# video 标签\n\n使用方法，属性和audio类似，不赘述。\n\n\n# 语义化标签\n\n语义化的标签，旨在让标签有自己的含义\n\n<p>一行文字</p>\n<span>一行文字</span>\n\n\n如上代码，p 标签与 span 标签都区别之一就是，p 标签的含义是：段落。而 span 标签责没有独特的含义。\n\n\n# 语义化标签的优势\n\n * 代码结构: 使页面没有 css的情况下，也能够呈现出很好的内容结构\n\n * 有利于 seo: 爬虫依赖标签来确定关键字的权重，因此可以和搜索引擎建立良好的沟通，帮助爬虫抓取更多的有效信息\n\n * 提升用户体验： 例如 title、alt 可以用于解释名称或者解释图片信息，以及 label 标签的灵活运用。\n\n * 便于团队开发和维护: 语义化使得代码更具有可读性，让其他开发人员更加理解你的 html 结构，减少差异化。\n\n * 方便其他设备解析: 如屏幕阅读器、盲人阅读器、移动设备等，以有意义的方式来渲染网页。\n\n\n# 常见的语义化标签\n\n\n\n# h1~h6 元素\n\n定义页面的标题，h1 元素具有最高等级，h6元素具有最低的等级\n\n# header 标签\n\n用于定义页面的介绍展示区域，通常包括网站 logo、主导航、全站链接以及搜索框。也适合对页面内部一组介绍性或导航性内容进行标记。\n\n<header>\n    <h1>html reference</h1>\n    <nav>\n        <a>home</a>\n        <a>about</a>\n        <a>contact</a>\n    </nav>\n</header>\n\n\n# nav 标签\n\n定义导航链接的部分\n\n<nav>\n    <a>home</a>\n    <a>about</a>\n    <a>contact</a>\n</nav>\n\n\n# article 标签\n\n标签定义外部的内容。\n\n外部内容可以是来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文本，或者是来自论坛的文本。亦或是来自其他外部源内容。\n\n<article>\n    <header>\n        <h3>\n            <a href="">my blog</a>\n        </h3>\n    </header>\n    <section>\n        <p>这是我的个人博客地址</p>\n    </section>\n    <footer>\n        <small>\n            posted on\n            <time datetime="2021-011-20t19:00">apr 20</time> in\n            <a href="https://www.zfhblog.top">点我访问</a>\n        </small>\n    </footer>\n</article>\n\n\n# main 标签\n\n定义页面的主要内容，一个页面只能使用一次.\n\n注意\n\n在一个文档中，不能出现一个以上的 <main> 元素。<main> 元素不能是以下元素的后代：<article>、<aside>、<footer>、<header> 或 <nav>。\n\n<main>\n    <h1>my blog test</h1>\n    <p>\n        lorem ipsum dolor sit amet, consectetur adipiscing elit. donec viverra\n        nec nulla vitae mollis.\n    </p>\n    <p>etc.</p>\n</main>\n\n\n# section 标签\n\nsection 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。\n\n<section>\n    <h2>section title</h2>\n    <p>\n        lorem ipsum dolor sit amet, consectetur adipiscing elit. donec viverra\n        nec nulla vitae mollis.\n    </p>\n</section>\n\n\n# aside 标签\n\n定义与主要内容相关的内容块。通常显示为侧边栏。\n\n# footer 标签\n\n定义文档的底部区域，通常包含文档的作者，著作权信息，链接的使用条款，联系信息等\n\n# small 标签\n\n为较不重要的内容定义小字体。如果被包围的字体已经是字体模型所支持的最小字号，那么small 标签将不起任何作用。\n\n# strong 标签\n\n把文本定义为语气更强的强调的内容，以表示内容的重要性。\n\n# em 标签\n\n标记内容着重点（大量用于提升段落文本语义），通常呈现为斜体文字。\n\n# blockquote 标签\n\n定义块引用，浏览器会在 blockquote 元素前后添加换行，并增加外边距。cite 属性可用来规定引用的来源\n\n<blockquote cite="https://en.wikiquote.org/wiki/marie_curie">\n    here is a long quotation here is a long quotation here is a long quotation\n    here is a long quotation here is a long quotation here is a long quotation\n    here is a long quotation here is a long quotation here is a long quotation.\n</blockquote>\n\n\n# abbr 标签\n\n解释缩写词。使用 title 属性可提供全称，只在第一次出现时使用就 ok。\n\nthe <abbr title="people\'s republic of china">prc</abbr> was founded in 1949.\n\n\n\n# 表格标签\n\n⛔️\n\ntable作为块级元素，其在没有指定宽度的情况并不会继承父元素的宽度，其默认的宽度是根据表格中填写的数据所控制的\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta http-equiv="x-ua-compatible" content="ie=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>document</title>\n    </head>\n    <body>\n        \x3c!-- 这种写法已被废弃 --\x3e\n        <table border="1">\n            \x3c!-- 表格的标题 --\x3e\n            <caption>\n                数字表\n            </caption>\n            <tr>\n                \x3c!-- 标题单元格 --\x3e\n                <th>1</th>\n                <th>2</th>\n                <th>3</th>\n            </tr>\n            <tr>\n                <td>4</td>\n                <td>5</td>\n                <td>6</td>\n            </tr>\n            <tr>\n                <td>5</td>\n                <td>8</td>\n                <td>9</td>\n            </tr>\n        </table>\n    </body>\n</html>\n\n\n\n# 单元格的合并\n\n * colspan属性:用来设置 td 或 th 的列跨度\n * rowspan属性:用来设置 td 或 th 的行跨度\n\n\n# 表格的其他特征\n\n * < thead >标签定义表头\n * < tbody >标签定义表核心内容\n * < tfoot >标签定义表脚，通常是汇总行\n\n<table border="1">\n    <thead>\n        <tr>\n            <th>month</th>\n            <th>savings</th>\n        </tr>\n    </thead>\n\n    <tbody>\n        <tr>\n            <td>january</td>\n            <td>$100</td>\n        </tr>\n        <tr>\n            <td>february</td>\n            <td>$80</td>\n        </tr>\n    </tbody>\n\n    <tfoot>\n        <tr>\n            <td>sum</td>\n            <td>$180</td>\n        </tr>\n    </tfoot>\n</table>\n\n\n\n# 表单标签\n\n\n# 表单的创建\n\n表单用来收集信息，比如注册、登录、发送评论反馈、购买商品等等\n\n * action属性表示表单要提交到的后台程序的网址(现在基本用不到了)\n * method属性表示表单提交的方式，有 get 或 post(现在基本用不到了)\n * onsubmit:onsubmit 事件在表单提交时触发\n\n<form action="" method="" onsubmit="myfunction()"></form>\n\n\n\n# 单行文本框\n\n * value属性表示已经填写好的值\n\n<input type="text" value="zfh" />\n\n\n * placeholder属性表示提示文本，将以浅色文字写在文本框中，并不是文本框中的值\n\n<input type="text" placeholder="请输入姓名" />\n\n\n * disabled 属性表示用户不能与元素交互，即“锁死"\n\n<input type="text" disabled />\n\n\n\n# 单选按钮\n\n * 互斥的单选按钮应该设置它们的name为相同值\n * 单选按钮要有value属性值，向服务器提交的就是 value 值\n * 单选按钮如果加上了checked属性，表示默认被选中\n\n男<input type="radio" name="sex" value="男" /> 女<input\n    type="radio"\n    name="sex"\n    value="女"\n    checked\n/>\n\n\n\n# label 标签\n\nlabel标签用来将文字和单选按钮进行绑定，用户单击文字的时候也视为点击了单选按钮\n\n<label> 男<input type="radio" name="sex" value="男" /> </label>\n\n<label> 女<input type="radio" name="sex" value="女" /> </label>\n\n\n\n# 复选框\n\n * 同组复选框应该设置它们的name为相同值\n * 复选框要有 value属性值，向服务器提交的就是 value 值\n * 多选按钮如果加上了 checked属性，表示默认被选中\n\n<input type="checkbox" name="province" value="sx" />陕西\n<input type="checkbox" name="province" value="sc" />四川\n<input type="checkbox" name="province" value="hb" checked />湖北\n\n\n\n# 密码框\n\n使用type属性值被设置为password的 input 元素可以创建密码框\n\n\n# 下拉菜单\n\n * <select>标签表示下拉菜单，<option>是它内部的选项\n * value是提交到服务器的值\n * selected表示默认被选中\n\n<select>\n    <option value="alipay">支付宝</option>\n    <option value="vx">微信</option>\n    <option value="dy" selected>抖音</option>\n</select>\n\n\n\n# 多行文本框\n\n<textarea></textarea>表示多行文本框；rows和cols属性，用于定义多行文本框的行数和列数\n\n\n# 三种按钮\n\n// 普通按钮 ，可以简写为<button></button>\n// value代表按钮上的文字\n<input type="button" value="普通按钮" />\n// 重置按钮\n<input type="reset" value="重置按钮" />\n// 提交按钮\n<input type="submit" value="提交按钮" />\n\n\n\n# datalist 控件\n\ndatalist控件可以为输入框提供一些备选项，当用户输入的内容与备选项文字相同时，将会显示智能感应\n\n<input type="text" list="province-list" />\n<datalist id="province-list">\n    <option value="山东"></option>\n    <option value="陕西"></option>\n    <option value="云南"></option>\n    <option value="贵州"></option>\n</datalist>\n',charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"Class类",frontmatter:{title:"Class类",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Class%E7%B1%BB.html",relativePath:"前端开发/JavaScript/ES6/Class类.md",key:"v-cbef54ee",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Class%E7%B1%BB.html",headers:[{level:2,title:"Class 基本用法",slug:"class-基本用法",normalizedTitle:"class 基本用法",charIndex:43},{level:2,title:"属性与方法",slug:"属性与方法",normalizedTitle:"属性与方法",charIndex:232},{level:3,title:"实例属性、静态方法和静态属性",slug:"实例属性、静态方法和静态属性",normalizedTitle:"实例属性、静态方法和静态属性",charIndex:242},{level:3,title:"私有属性和方法",slug:"私有属性和方法",normalizedTitle:"私有属性和方法",charIndex:882},{level:2,title:"存取器",slug:"存取器",normalizedTitle:"存取器",charIndex:1960},{level:2,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:2277},{level:3,title:"extends",slug:"extends",normalizedTitle:"extends",charIndex:2284},{level:3,title:"super",slug:"super",normalizedTitle:"super",charIndex:2353}],headersStr:"Class 基本用法 属性与方法 实例属性、静态方法和静态属性 私有属性和方法 存取器 继承 extends super",content:"// TODO: 2022.5.23 基于ES6入门 class章节重新梳理\n\n\n# Class 基本用法\n\n类名一般首字母大写\n\nclass Person {\n    constructor(name, age) {\n        // 实例化时执行构造方法\n        this.name = name\n        this.age = age\n    }\n    // 各实例共享的方法(在原型上定义)\n    speak() {}\n}\n\n\n\n# 属性与方法\n\n\n# 实例属性、静态方法和静态属性\n\n 1. 实例属性\n\nclass Person {\n    // 实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层\n    age = 0\n    sex = 'male'\n    //方法就是值为函数的特殊属性\n    getSex = function () {\n        return this.sex\n    }\n\n    constructor(name, sex) {\n        this.name = name\n        this.sex = sex || this.sex\n    }\n    speak() {\n        console.log('啊这')\n    }\n}\nconst p = new Person('Alex')\np.speak()\nconsole.log(p)\nconsole.log(p.getSex())\n\n\n 2. 静态方法(类的方法)\n\nstatic speak(){\n  // this指向类\n    console.log('人类可以说话')\n}\n\n\n 3. 静态属性(类的属性)\n\n// 这是一个最近添加到 JavaScript 的特性,可以在最近的 Chrome 工作\nstatic version='1.0'\n// 推荐 将属性变成方法\nstatic getVersion(){\n    return '1.0'\n}\n\n\n\n# 私有属性和方法\n\n新提案\n\n这是一个最近添加到 JavaScript 的特性，它为私有属性和方法提供语言级支持。\n\n私有属性和方法应该以 # 开头。它们只在类的内部可被访问：\n\nclass Foo {\n  // 必须声明，否则会报错：‘Private field '#a' must be declared in an enclosing class’ 普通属性无需这样做\n  #a;\n  #b;\n  constructor(a, b) {\n    this.#a = a;\n    this.#b = b;\n  }\n  #sum() {\n    return this.#a + this.#b;\n  }\n  printSum() {\n    console.log(this.#sum());\n  }\n}\n\n\n上面代码中，#a,#b为私有属性（必须在类中声明），#sum()就是一个私有方法。\n\n私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。\n\n模拟私有属性和方法：_开头表示私有，属性或方法名用下划线开头（业界规定这样的属性或方法表示私有，不应该随意改动，但不具备很强的约束力）\n\nclass Person {\n    constructor(name) {\n        this._name = name\n    }\n    getName() {\n        return this._name\n    }\n}\n\nconst p = new Person('alex')\nconsole.log(p.getName())\n\n\n将私有属性和方法移出类,从根本上解决问题\n\n;(function () {\n    let name = ''\n    class Person {\n        constructor(username) {\n            name = username\n        }\n        getName() {\n            return name\n        }\n    }\n    // 将Person类暴露到全局\n    window.Person = Person\n})()\n\nconst p = new Person('alex')\nconsole.log(p.name)\n// 只能通过暴露出的方法访问属性\nconsole.log(p.getName())\n\n\n\n# 存取器\n\n使用 getter 和 setter 可以改变属性的赋值和读取行为：\n\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  get name() {\n    return 'Jack';\n  }\n  set name(value) {\n    console.log('setter: ' + value);\n  }\n}\n\nlet a = new Animal('Kitty'); // setter: Kitty\na.name = 'Tom'; // setter: Tom\nconsole.log(a.name); // Jack\n\n\n\n# 继承\n\n\n# extends\n\n注意\n\n在 class 方法中，继承是使用 extends 关键字来实现的。子类必须在 constructor()调用 super()方法，否则新建实例时会报错\n\n报错的原因是：子类是没有自己的 this对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super()就是将父类中的this 对象继承给子类的。没有 super，子类就得不到 this对象。\n\n但是 子类中不写 constructor 可以不写 super\n\nclass Person {\n    constructor(name, sex) {\n        this.name = name\n        this.sex = sex\n        this.say = function () {\n            console.log('say')\n        }\n    }\n    speak() {\n        console.log('speak')\n    }\n  // 静态属性和方法是可被继承的\n    static speak() {\n        console.log('staic')\n    }\n}\nPerson.version = '1.0'\nclass Programmer extends Person {\n    //实现继承的关键语句\n    constructor(name, sex, feature) {\n        // this 操作不能放在 super 前面\n        super(name, sex) //实现继承的关键语句\n        this.feature = feature\n    }\n\n    // 子类可以定义属于自己的特有方法\n    hi() {\n        console.log('hi')\n    }\n\n    // 子类如果定义同名函数，就会覆盖父类的函数\n    speak() {\n        console.log('Programmer speak')\n    }\n}\n\nconst zs = new Programmer('zs', '男', '秃头')\n\n// 继承的父类的方法和属性\nconsole.log(zs.name)\nconsole.log(zs.sex)\nzs.say()\nProgrammer.speak()\nconsole.log(Programmer.version)\n\n// 子类独有的方法和属性\nconsole.log(zs.feature)\nzs.speak()\nzs.hi()\n\n\n\n# super\n\n# 作为函数调用\n\n * super 可以作为函数调用，形式是 super(参数 1, 参数 2, ...)\n * 代表父类的构造方法，只能用在子类的构造方法中，用在其他地方就会报错\n * super 虽然代表了父类的构造方法，但是内部的 this 指向子类的实例\n\n# 作为对象使用\n\nsuper 还可以作为对象调用，形式是 super.函数名()\n\n(1) 在构造方法中使用或在一般方法中使用\n\n * super 代表父类的原型对象 Person.prototype\n * 定义在父类 constructor 上的方法或属性，是无法通过 super 调用的\n * 通过super调用父类的方法时,方法内部的this 指向当前的子类实例\n\nclass Person {\n    constructor(name, sex) {\n        this.name = name\n        this.sex = sex\n    }\n    speak() {\n        console.log(this.name + 'speak')\n    }\n}\nclass Programmer extends Person {\n    constructor(name, sex) {\n        super(name, sex)\n        super.speak()\n    }\n}\nconst p = new Programmer('frank', 'male')\n\n\n(2) 在静态方法中使用\n\n * super 代表的是父类，而不是父类的原型对象\n * 通过 super 调用父类的方法时，父类静态方法内部的 this 指向当前的子类，而不是子类的实例\n\nclass Person {\n    constructor(name, sex) {\n        this.name = name\n    }\n    static speak() {\n        console.log('person speak')\n    }\n}\nclass Programmer extends Person {\n    constructor(name, sex) {\n        super(name, sex)\n    }\n    static speak() {\n        super.speak()\n        console.log('p speak')\n    }\n}\nProgrammer.speak()\n",normalizedContent:"// todo: 2022.5.23 基于es6入门 class章节重新梳理\n\n\n# class 基本用法\n\n类名一般首字母大写\n\nclass person {\n    constructor(name, age) {\n        // 实例化时执行构造方法\n        this.name = name\n        this.age = age\n    }\n    // 各实例共享的方法(在原型上定义)\n    speak() {}\n}\n\n\n\n# 属性与方法\n\n\n# 实例属性、静态方法和静态属性\n\n 1. 实例属性\n\nclass person {\n    // 实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层\n    age = 0\n    sex = 'male'\n    //方法就是值为函数的特殊属性\n    getsex = function () {\n        return this.sex\n    }\n\n    constructor(name, sex) {\n        this.name = name\n        this.sex = sex || this.sex\n    }\n    speak() {\n        console.log('啊这')\n    }\n}\nconst p = new person('alex')\np.speak()\nconsole.log(p)\nconsole.log(p.getsex())\n\n\n 2. 静态方法(类的方法)\n\nstatic speak(){\n  // this指向类\n    console.log('人类可以说话')\n}\n\n\n 3. 静态属性(类的属性)\n\n// 这是一个最近添加到 javascript 的特性,可以在最近的 chrome 工作\nstatic version='1.0'\n// 推荐 将属性变成方法\nstatic getversion(){\n    return '1.0'\n}\n\n\n\n# 私有属性和方法\n\n新提案\n\n这是一个最近添加到 javascript 的特性，它为私有属性和方法提供语言级支持。\n\n私有属性和方法应该以 # 开头。它们只在类的内部可被访问：\n\nclass foo {\n  // 必须声明，否则会报错：‘private field '#a' must be declared in an enclosing class’ 普通属性无需这样做\n  #a;\n  #b;\n  constructor(a, b) {\n    this.#a = a;\n    this.#b = b;\n  }\n  #sum() {\n    return this.#a + this.#b;\n  }\n  printsum() {\n    console.log(this.#sum());\n  }\n}\n\n\n上面代码中，#a,#b为私有属性（必须在类中声明），#sum()就是一个私有方法。\n\n私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 es6 不提供，只能通过变通方法模拟实现。\n\n模拟私有属性和方法：_开头表示私有，属性或方法名用下划线开头（业界规定这样的属性或方法表示私有，不应该随意改动，但不具备很强的约束力）\n\nclass person {\n    constructor(name) {\n        this._name = name\n    }\n    getname() {\n        return this._name\n    }\n}\n\nconst p = new person('alex')\nconsole.log(p.getname())\n\n\n将私有属性和方法移出类,从根本上解决问题\n\n;(function () {\n    let name = ''\n    class person {\n        constructor(username) {\n            name = username\n        }\n        getname() {\n            return name\n        }\n    }\n    // 将person类暴露到全局\n    window.person = person\n})()\n\nconst p = new person('alex')\nconsole.log(p.name)\n// 只能通过暴露出的方法访问属性\nconsole.log(p.getname())\n\n\n\n# 存取器\n\n使用 getter 和 setter 可以改变属性的赋值和读取行为：\n\nclass animal {\n  constructor(name) {\n    this.name = name;\n  }\n  get name() {\n    return 'jack';\n  }\n  set name(value) {\n    console.log('setter: ' + value);\n  }\n}\n\nlet a = new animal('kitty'); // setter: kitty\na.name = 'tom'; // setter: tom\nconsole.log(a.name); // jack\n\n\n\n# 继承\n\n\n# extends\n\n注意\n\n在 class 方法中，继承是使用 extends 关键字来实现的。子类必须在 constructor()调用 super()方法，否则新建实例时会报错\n\n报错的原因是：子类是没有自己的 this对象的，它只能继承自父类的 this 对象，然后对其进行加工，而super()就是将父类中的this 对象继承给子类的。没有 super，子类就得不到 this对象。\n\n但是 子类中不写 constructor 可以不写 super\n\nclass person {\n    constructor(name, sex) {\n        this.name = name\n        this.sex = sex\n        this.say = function () {\n            console.log('say')\n        }\n    }\n    speak() {\n        console.log('speak')\n    }\n  // 静态属性和方法是可被继承的\n    static speak() {\n        console.log('staic')\n    }\n}\nperson.version = '1.0'\nclass programmer extends person {\n    //实现继承的关键语句\n    constructor(name, sex, feature) {\n        // this 操作不能放在 super 前面\n        super(name, sex) //实现继承的关键语句\n        this.feature = feature\n    }\n\n    // 子类可以定义属于自己的特有方法\n    hi() {\n        console.log('hi')\n    }\n\n    // 子类如果定义同名函数，就会覆盖父类的函数\n    speak() {\n        console.log('programmer speak')\n    }\n}\n\nconst zs = new programmer('zs', '男', '秃头')\n\n// 继承的父类的方法和属性\nconsole.log(zs.name)\nconsole.log(zs.sex)\nzs.say()\nprogrammer.speak()\nconsole.log(programmer.version)\n\n// 子类独有的方法和属性\nconsole.log(zs.feature)\nzs.speak()\nzs.hi()\n\n\n\n# super\n\n# 作为函数调用\n\n * super 可以作为函数调用，形式是 super(参数 1, 参数 2, ...)\n * 代表父类的构造方法，只能用在子类的构造方法中，用在其他地方就会报错\n * super 虽然代表了父类的构造方法，但是内部的 this 指向子类的实例\n\n# 作为对象使用\n\nsuper 还可以作为对象调用，形式是 super.函数名()\n\n(1) 在构造方法中使用或在一般方法中使用\n\n * super 代表父类的原型对象 person.prototype\n * 定义在父类 constructor 上的方法或属性，是无法通过 super 调用的\n * 通过super调用父类的方法时,方法内部的this 指向当前的子类实例\n\nclass person {\n    constructor(name, sex) {\n        this.name = name\n        this.sex = sex\n    }\n    speak() {\n        console.log(this.name + 'speak')\n    }\n}\nclass programmer extends person {\n    constructor(name, sex) {\n        super(name, sex)\n        super.speak()\n    }\n}\nconst p = new programmer('frank', 'male')\n\n\n(2) 在静态方法中使用\n\n * super 代表的是父类，而不是父类的原型对象\n * 通过 super 调用父类的方法时，父类静态方法内部的 this 指向当前的子类，而不是子类的实例\n\nclass person {\n    constructor(name, sex) {\n        this.name = name\n    }\n    static speak() {\n        console.log('person speak')\n    }\n}\nclass programmer extends person {\n    constructor(name, sex) {\n        super(name, sex)\n    }\n    static speak() {\n        super.speak()\n        console.log('p speak')\n    }\n}\nprogrammer.speak()\n",charsets:{cjk:!0},lastUpdated:"2022年05月24日",lastUpdatedTimestamp:1653404643e3},{title:"ES6 的新增方法",frontmatter:{title:"ES6 的新增方法",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/ES6%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.html",relativePath:"前端开发/JavaScript/ES6/ES6的新增方法.md",key:"v-7bee9c99",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/ES6%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.html",headers:[{level:2,title:"字符串新增方法",slug:"字符串新增方法",normalizedTitle:"字符串新增方法",charIndex:2},{level:3,title:"includes()",slug:"includes",normalizedTitle:"includes()",charIndex:14},{level:3,title:"padStart()和padEnd()",slug:"padstart-和padend",normalizedTitle:"padstart()和padend()",charIndex:1253},{level:3,title:"trimStart()和trimEnd()",slug:"trimstart-和trimend",normalizedTitle:"trimstart()和trimend()",charIndex:1609},{level:3,title:"replaceAll()",slug:"replaceall",normalizedTitle:"replaceall()",charIndex:2221},{level:2,title:"数组的新增方法",slug:"数组的新增方法",normalizedTitle:"数组的新增方法",charIndex:2385},{level:3,title:"includes()",slug:"includes-2",normalizedTitle:"includes()",charIndex:14},{level:3,title:"Array.from()",slug:"array-from",normalizedTitle:"array.from()",charIndex:2489},{level:3,title:"find()和findIndex()",slug:"find-和findindex",normalizedTitle:"find()和findindex()",charIndex:2937},{level:2,title:"对象的新增方法",slug:"对象的新增方法",normalizedTitle:"对象的新增方法",charIndex:3168},{level:3,title:"Object.assign()",slug:"object-assign",normalizedTitle:"object.assign()",charIndex:3180},{level:3,title:"Object.keys()、Object.values()和Object.entries()",slug:"object-keys-、object-values-和object-entries",normalizedTitle:"object.keys()、object.values()和object.entries()",charIndex:4118}],headersStr:"字符串新增方法 includes() padStart()和padEnd() trimStart()和trimEnd() replaceAll() 数组的新增方法 includes() Array.from() find()和findIndex() 对象的新增方法 Object.assign() Object.keys()、Object.values()和Object.entries()",content:"# 字符串新增方法\n\n\n# includes()\n\n * 判断字符串中是否含有某些字符 1.基本用法\n\nconsole.log('abc'.includes('a')) // true\n\n\n 2. 第二个参数\n\n表示开始搜索的位置，默认为0\n\n    console.log('abc'.includes('a',1))\n\n\n 3. 应用:query的拼接\n\n\x3c!-- query的拼接 --\x3e\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n   <meta charset=\"UTF-8\">\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n   <title>Document</title>\n</head>\n<body>\n   <script>\n      let url = 'https://www.imooc.com/course/list?';\n      let url1 ='https://www.imooc.com/course/list?username=xm&';\n      let url2 ='https://www.imooc.com/course/list?username=xm';\n        const addURL=(url,name,value)=>{\n                if(url.includes(\"?\")){\n                    if(url.substr(url.length-1,1)=='?'|| url.substr(url.length-1,1)=='&'  ){\n                        url+=''\n                    }else{\n                        url+='&'\n                    }\n                 }else{\n                     url+='?'\n                 }\n                 url+=`${name}=${value}`\n                 return url\n        }\n  \n    console.log(addURL(url,'password','admin'));\n    console.log(addURL(url1,'password','admin'));\n    console.log(addURL(url2,'password','admin'));\n                                                 \n   <\/script>\n</body>\n</html>\n\n\n\n\n# padStart()和padEnd()\n\n 1. 基本用法\n\n补全字符串\n\n        console.log('xxx'.padStart(4,'a')); // axxx\n        console.log('xxx'.padEnd(4,'a')); // xxxa\n\n\n 2. 注意事项\n\n * 原字符串的长度，等于或大于最大长度，不会消减原字符串，字符串补全不生效，返回原字符串\n * 用来补全的字符串与原字符串长度之和超过了最大长度，截去超出位数的补全字符串，原字符串不动\n * 如果省略第二个参数，默认使用空格补全长度\n\n 3. 应用\n\n显示日期格式\n\n2021-1-1\n2021-10-12\n\n保持日期格式统一，一位数前面补零=》'1'.padStart(2,'0') // 01\n\n\n# trimStart()和trimEnd()\n\n 1. 基本用法\n    清除字符串的首或尾空格，中间的空格不会清除\n\n  console.log('                        xxxxx'.trimStart());\n\n\n 2. 应用\n    清除表单非法数据\n\n<body>\n    <input type=\"text\" id=\"username\"> \n    <input type=\"submit\" value=\"提交\" id='btn'>\n    <script>\n        const username=document.getElementById('username')\n        const btn=document.getElementById('btn')\n      \n        btn.onclick=()=>{\n        // trim()去除字符串的头尾空格\n            if(username.value.trim()!==''){\n            console.log('可以提交');\n        }else{\n            console.log('不可以提交');\n        }\n        }\n    <\/script>\n</body>\n\n\n> 备注： trim()同时清除两边的空格\n\n\n# replaceAll()\n\n相比于replace方法，可以在不使用正则的情况下，一次性替换掉所有的匹配\n\n    const str = 'aabbcc'\n    const str2=str.replaceAll('b','-')    \n    console.log(str2)   // aa--cc    \n\n\n\n# 数组的新增方法\n\n\n# includes()\n\n 1. 基本用法\n    ncludes() 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。\n 2. 应用：数组去重\n\n\n# Array.from()\n\nArray.from()\n\n 1. 基本用法\n    将其他数据类型转换成数组\n\n 2. 哪些可以通过 Array.from()转换成数组\n\n * 所有可遍历的：数组、字符串、set、map、 nodeList、 arguments\n * 拥有 length属性的任意对象\n\n     const obj={\n             '0':'a',\n             '1':'b',\n             length:2\n         }\n         console.log(Array.from(obj));\n\n\n 3. 第二个参数\n    作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组\n\nconsole.log(\n         Array.from('12',v=>v*2)\n     );\n\n\n 4. 第三个参数\n    \n    指定回调函数中的this指向，大坑：箭头函数无法修改\n\n\n# find()和findIndex()\n\n 1. 基本用法\n\n * find():找到满足条件的一个立即返回\n * findIndex():找到满足条件的一个，立即返回其索引\n\n  const arr=[1,2,3,4,5]\n        \n console.log(arr.find(function(value,index,arr){\n            return value>2\n        }));\n \n\n\n 2. 应用\n\n筛选数据\n\n\n# 对象的新增方法\n\n\n# Object.assign()\n\n 1. 基本用法\n\n     const apple={\n            color:\"black\",\n            shape:'圆柱形',\n            taste:'甜'\n        }\n        const pen={\n            color:'red',\n            shape:'球形',\n            use:'write'\n        }\n        console.log(Object.assign(apple,pen) );\n\n\n直接合并到了第一个参数中，返回的就是合并后的对象(修改后的第一个对象是同一个引用)。\n如果像创建一个新对象可以这样写\n\n console.log(Object.assign({},apple,pen) )\n\n\n\n可以合并多个对象\n\n 2. 注意事项\n\n * 基本数据类型作为源对象：与对象的展开类似，先转换成对象，再合并\n\n\n    console.log(Object.assign({},'str'));\n\n\nObject.assign(目标对象，源对象，....)\n\n\n * 同名属性的替换 ：后面的直接覆盖前面的，如果属性值为引用数据类型，也是直接覆盖，不用考虑那么多\n\n 3. 应用\n    合并默认参数和用户参数\n\n   const logUser=useroptions=>{\n             const Defaults={\n                 username:'zhangsan',\n                 password:'123'\n             }\n             const options=Object.assign({},Defaults,useroptions)\n             console.log(options);\n         }\n         logUser(\n             {\n                 \n             }\n         )\n\n\n\n# Object.keys()、Object.values()和Object.entries()\n\n 1. 基本用法\n\n   const person = {\n        name: \"zhangsan\",\n        age: 18,\n        sex: \"male\",\n      };\n      console.log(Object.keys(person));\n      console.log(Object.values(person));\n      console.log(Object.entries(person));\n\n\n 2. 与数组类似方法的区别\n\n1、调用方法不同，对于数组来说是实例的方法，对象是构造函数的方法\n\n2、返回值不同，数组的方法返回的是数组的可遍历对象，对象的方法返回的是数组\n\n 3. 使用对象的 Object.keys()、Object.values()、Object.entries() ，才能让对象使用 for...of 循环遍历对象\n\nconst apple={\n            color:\"black\",\n            shape:'圆柱形',\n            taste:'甜'\n        }\n        for(const [key,value] of Object.entries(apple)){\n            console.log(key,value);\n        }\n\n\n 4. 但是，Object.keys()/values()/entires() 并不能保证顺序一定是看到的样子，这一点和 for in 是一样的=>属性是数字，在使用Object.keys()、Object.values()、Object.entries()方法时，顺序是按照属性的大小来定的\n\n const person = {\n      100: \"p\",\n      2: \"e\",\n      5: \"r\",\n      30: \"s\",\n      15: \"o\",\n      75: \"n\"\n    };\n    console.log(Object.keys(person))\n    console.log(Object.values(person))\n    console.log(Object.entries(person)\n",normalizedContent:"# 字符串新增方法\n\n\n# includes()\n\n * 判断字符串中是否含有某些字符 1.基本用法\n\nconsole.log('abc'.includes('a')) // true\n\n\n 2. 第二个参数\n\n表示开始搜索的位置，默认为0\n\n    console.log('abc'.includes('a',1))\n\n\n 3. 应用:query的拼接\n\n\x3c!-- query的拼接 --\x3e\n<!doctype html>\n<html lang=\"en\">\n<head>\n   <meta charset=\"utf-8\">\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n   <title>document</title>\n</head>\n<body>\n   <script>\n      let url = 'https://www.imooc.com/course/list?';\n      let url1 ='https://www.imooc.com/course/list?username=xm&';\n      let url2 ='https://www.imooc.com/course/list?username=xm';\n        const addurl=(url,name,value)=>{\n                if(url.includes(\"?\")){\n                    if(url.substr(url.length-1,1)=='?'|| url.substr(url.length-1,1)=='&'  ){\n                        url+=''\n                    }else{\n                        url+='&'\n                    }\n                 }else{\n                     url+='?'\n                 }\n                 url+=`${name}=${value}`\n                 return url\n        }\n  \n    console.log(addurl(url,'password','admin'));\n    console.log(addurl(url1,'password','admin'));\n    console.log(addurl(url2,'password','admin'));\n                                                 \n   <\/script>\n</body>\n</html>\n\n\n\n\n# padstart()和padend()\n\n 1. 基本用法\n\n补全字符串\n\n        console.log('xxx'.padstart(4,'a')); // axxx\n        console.log('xxx'.padend(4,'a')); // xxxa\n\n\n 2. 注意事项\n\n * 原字符串的长度，等于或大于最大长度，不会消减原字符串，字符串补全不生效，返回原字符串\n * 用来补全的字符串与原字符串长度之和超过了最大长度，截去超出位数的补全字符串，原字符串不动\n * 如果省略第二个参数，默认使用空格补全长度\n\n 3. 应用\n\n显示日期格式\n\n2021-1-1\n2021-10-12\n\n保持日期格式统一，一位数前面补零=》'1'.padstart(2,'0') // 01\n\n\n# trimstart()和trimend()\n\n 1. 基本用法\n    清除字符串的首或尾空格，中间的空格不会清除\n\n  console.log('                        xxxxx'.trimstart());\n\n\n 2. 应用\n    清除表单非法数据\n\n<body>\n    <input type=\"text\" id=\"username\"> \n    <input type=\"submit\" value=\"提交\" id='btn'>\n    <script>\n        const username=document.getelementbyid('username')\n        const btn=document.getelementbyid('btn')\n      \n        btn.onclick=()=>{\n        // trim()去除字符串的头尾空格\n            if(username.value.trim()!==''){\n            console.log('可以提交');\n        }else{\n            console.log('不可以提交');\n        }\n        }\n    <\/script>\n</body>\n\n\n> 备注： trim()同时清除两边的空格\n\n\n# replaceall()\n\n相比于replace方法，可以在不使用正则的情况下，一次性替换掉所有的匹配\n\n    const str = 'aabbcc'\n    const str2=str.replaceall('b','-')    \n    console.log(str2)   // aa--cc    \n\n\n\n# 数组的新增方法\n\n\n# includes()\n\n 1. 基本用法\n    ncludes() 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。\n 2. 应用：数组去重\n\n\n# array.from()\n\narray.from()\n\n 1. 基本用法\n    将其他数据类型转换成数组\n\n 2. 哪些可以通过 array.from()转换成数组\n\n * 所有可遍历的：数组、字符串、set、map、 nodelist、 arguments\n * 拥有 length属性的任意对象\n\n     const obj={\n             '0':'a',\n             '1':'b',\n             length:2\n         }\n         console.log(array.from(obj));\n\n\n 3. 第二个参数\n    作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组\n\nconsole.log(\n         array.from('12',v=>v*2)\n     );\n\n\n 4. 第三个参数\n    \n    指定回调函数中的this指向，大坑：箭头函数无法修改\n\n\n# find()和findindex()\n\n 1. 基本用法\n\n * find():找到满足条件的一个立即返回\n * findindex():找到满足条件的一个，立即返回其索引\n\n  const arr=[1,2,3,4,5]\n        \n console.log(arr.find(function(value,index,arr){\n            return value>2\n        }));\n \n\n\n 2. 应用\n\n筛选数据\n\n\n# 对象的新增方法\n\n\n# object.assign()\n\n 1. 基本用法\n\n     const apple={\n            color:\"black\",\n            shape:'圆柱形',\n            taste:'甜'\n        }\n        const pen={\n            color:'red',\n            shape:'球形',\n            use:'write'\n        }\n        console.log(object.assign(apple,pen) );\n\n\n直接合并到了第一个参数中，返回的就是合并后的对象(修改后的第一个对象是同一个引用)。\n如果像创建一个新对象可以这样写\n\n console.log(object.assign({},apple,pen) )\n\n\n\n可以合并多个对象\n\n 2. 注意事项\n\n * 基本数据类型作为源对象：与对象的展开类似，先转换成对象，再合并\n\n\n    console.log(object.assign({},'str'));\n\n\nobject.assign(目标对象，源对象，....)\n\n\n * 同名属性的替换 ：后面的直接覆盖前面的，如果属性值为引用数据类型，也是直接覆盖，不用考虑那么多\n\n 3. 应用\n    合并默认参数和用户参数\n\n   const loguser=useroptions=>{\n             const defaults={\n                 username:'zhangsan',\n                 password:'123'\n             }\n             const options=object.assign({},defaults,useroptions)\n             console.log(options);\n         }\n         loguser(\n             {\n                 \n             }\n         )\n\n\n\n# object.keys()、object.values()和object.entries()\n\n 1. 基本用法\n\n   const person = {\n        name: \"zhangsan\",\n        age: 18,\n        sex: \"male\",\n      };\n      console.log(object.keys(person));\n      console.log(object.values(person));\n      console.log(object.entries(person));\n\n\n 2. 与数组类似方法的区别\n\n1、调用方法不同，对于数组来说是实例的方法，对象是构造函数的方法\n\n2、返回值不同，数组的方法返回的是数组的可遍历对象，对象的方法返回的是数组\n\n 3. 使用对象的 object.keys()、object.values()、object.entries() ，才能让对象使用 for...of 循环遍历对象\n\nconst apple={\n            color:\"black\",\n            shape:'圆柱形',\n            taste:'甜'\n        }\n        for(const [key,value] of object.entries(apple)){\n            console.log(key,value);\n        }\n\n\n 4. 但是，object.keys()/values()/entires() 并不能保证顺序一定是看到的样子，这一点和 for in 是一样的=>属性是数字，在使用object.keys()、object.values()、object.entries()方法时，顺序是按照属性的大小来定的\n\n const person = {\n      100: \"p\",\n      2: \"e\",\n      5: \"r\",\n      30: \"s\",\n      15: \"o\",\n      75: \"n\"\n    };\n    console.log(object.keys(person))\n    console.log(object.values(person))\n    console.log(object.entries(person)\n",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"Generator",frontmatter:{title:"Generator",date:"2022/06/03 22:59:51",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Generator.html",relativePath:"前端开发/JavaScript/ES6/Generator.md",key:"v-54a8f500",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Generator.html",headersStr:null,content:"Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\n\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n\n形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。\n\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloWorldGenerator();\n\n\n⚠️\n\n待学习......",normalizedContent:"generator 函数是 es6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。\n\ngenerator 函数有多种理解角度。语法上，首先可以把它理解成，generator 函数是一个状态机，封装了多个内部状态。\n\n执行 generator 函数会返回一个遍历器对象，也就是说，generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 generator 函数内部的每一个状态。\n\n形式上，generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。\n\nfunction* helloworldgenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloworldgenerator();\n\n\n⚠️\n\n待学习......",charsets:{cjk:!0},lastUpdated:"2022年06月04日",lastUpdatedTimestamp:1654357652e3},{title:"Module模块",frontmatter:{title:"Module模块",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Module%E6%A8%A1%E5%9D%97.html",relativePath:"前端开发/JavaScript/ES6/Module模块.md",key:"v-b6571256",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Module%E6%A8%A1%E5%9D%97.html",headers:[{level:2,title:"Module 模块介绍",slug:"module-模块介绍",normalizedTitle:"module 模块介绍",charIndex:12},{level:2,title:"导入与导出",slug:"导入与导出",normalizedTitle:"导入与导出",charIndex:307},{level:3,title:"export default 和对应的 import",slug:"export-default-和对应的-import",normalizedTitle:"export default 和对应的 import",charIndex:410},{level:3,title:"export 和对应的 import",slug:"export-和对应的-import",normalizedTitle:"export 和对应的 import",charIndex:897},{level:3,title:"整体导入",slug:"整体导入",normalizedTitle:"整体导入",charIndex:1240},{level:3,title:"同时导入",slug:"同时导入",normalizedTitle:"同时导入",charIndex:1330}],headersStr:"Module 模块介绍 导入与导出 export default 和对应的 import export 和对应的 import 整体导入 同时导入",content:"details\n\n\n# Module 模块介绍\n\n * Module模块:一个一个的局部作用域的代码块\n * Module 解决的问题：\n\n(1) 模块化的问题\n\n(2) 消除全局变量\n\n(3) 管理加载顺序\n\n * 使用 script标签加载模块:只要用到 import 或 export，在使用 script 标签加载的时候，就要加上 type=\"module\"\n\n<script src=\"./xxx.js\" type=\"module\"><\/script>\n \x3c!--以下写法和👆的写法等价--\x3e\n<script type=\"module\">\nimport \"xxx.js\"\n<\/script>\n\n\n\n# 导入与导出\n\n如果一个模块没有导出，也可以进行导入，被导入的代码都会执行一遍，也仅仅会执行一遍\n\n<script type=\"module\">\nimport \"xxx.js\"\n<\/script>\n\n\n\n# export default 和对应的 import\n\n为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。\n\n本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字,正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句\n\n一个模块只能有一个 export default\n\n// 导出\nconst age =123\nexport default age\n// 导入\nimport age from './module.js'\n// 导入,可以随意命名,但不建议这样使用\nimport xxx from './module.js'\n//--------------------------------------\n// 导出匿名函数\nexport default ()=>{\n\tconsole.log('123')\n}\n// 导出具名函数，在模块外部是无效的。加载的时候，视同匿名函数加载\n\n\n\n# export 和对应的 import\n\n 1. 单个导出\n\n// 两种导出\n// 第一种\nexport const age = 18\n// 第二种\nconst age = 18\nexport { age }\n// 导入\nimport { age } from './module.js'\n\n\n 2. 多个导出\n\n// 导出\nexport { Person, age }\n// 导入\nimport { Person, age } from './module.js'\n\n\n 3. 导出或导入时起别名\n\n// 导出\nexport { Person as ren, age }\n// 导入\nimport { ren, age as sui } from './module.js'\n\n\n\n# 整体导入\n\n整体导入中包括了export 导出 和 export default导出 的所有内容\n\nimport * as obj from './module.js'\n\n\n\n# 同时导入\n\n注意\n\nexport default 导出的内容必须写在最前面\n\n同时导入export dafault和export\n\nimport age2, { func, age } from './module.js'\n",normalizedContent:"details\n\n\n# module 模块介绍\n\n * module模块:一个一个的局部作用域的代码块\n * module 解决的问题：\n\n(1) 模块化的问题\n\n(2) 消除全局变量\n\n(3) 管理加载顺序\n\n * 使用 script标签加载模块:只要用到 import 或 export，在使用 script 标签加载的时候，就要加上 type=\"module\"\n\n<script src=\"./xxx.js\" type=\"module\"><\/script>\n \x3c!--以下写法和👆的写法等价--\x3e\n<script type=\"module\">\nimport \"xxx.js\"\n<\/script>\n\n\n\n# 导入与导出\n\n如果一个模块没有导出，也可以进行导入，被导入的代码都会执行一遍，也仅仅会执行一遍\n\n<script type=\"module\">\nimport \"xxx.js\"\n<\/script>\n\n\n\n# export default 和对应的 import\n\n为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。\n\n本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字,正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句\n\n一个模块只能有一个 export default\n\n// 导出\nconst age =123\nexport default age\n// 导入\nimport age from './module.js'\n// 导入,可以随意命名,但不建议这样使用\nimport xxx from './module.js'\n//--------------------------------------\n// 导出匿名函数\nexport default ()=>{\n\tconsole.log('123')\n}\n// 导出具名函数，在模块外部是无效的。加载的时候，视同匿名函数加载\n\n\n\n# export 和对应的 import\n\n 1. 单个导出\n\n// 两种导出\n// 第一种\nexport const age = 18\n// 第二种\nconst age = 18\nexport { age }\n// 导入\nimport { age } from './module.js'\n\n\n 2. 多个导出\n\n// 导出\nexport { person, age }\n// 导入\nimport { person, age } from './module.js'\n\n\n 3. 导出或导入时起别名\n\n// 导出\nexport { person as ren, age }\n// 导入\nimport { ren, age as sui } from './module.js'\n\n\n\n# 整体导入\n\n整体导入中包括了export 导出 和 export default导出 的所有内容\n\nimport * as obj from './module.js'\n\n\n\n# 同时导入\n\n注意\n\nexport default 导出的内容必须写在最前面\n\n同时导入export dafault和export\n\nimport age2, { func, age } from './module.js'\n",charsets:{cjk:!0},lastUpdated:"2022年07月06日",lastUpdatedTimestamp:1657123865e3},{title:"Promise",frontmatter:{title:"Promise",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Promise.html",relativePath:"前端开发/JavaScript/ES6/Promise.md",key:"v-1af69640",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Promise.html",headers:[{level:2,title:"初识 Promise",slug:"初识-promise",normalizedTitle:"初识 promise",charIndex:2},{level:2,title:"为什么要使用 Promise?",slug:"为什么要使用-promise",normalizedTitle:"为什么要使用 promise?",charIndex:124},{level:2,title:"Promise 的基本流程",slug:"promise-的基本流程",normalizedTitle:"promise 的基本流程",charIndex:787},{level:2,title:"Promise 的基本用法",slug:"promise-的基本用法",normalizedTitle:"promise 的基本用法",charIndex:807},{level:2,title:"实例方法",slug:"实例方法",normalizedTitle:"实例方法",charIndex:1529},{level:3,title:"Promise.prototype.then()",slug:"promise-prototype-then",normalizedTitle:"promise.prototype.then()",charIndex:1538},{level:3,title:"Promise.prototype.catch()",slug:"promise-prototype-catch",normalizedTitle:"promise.prototype.catch()",charIndex:3343},{level:3,title:"Promise.prototype.finally()",slug:"promise-prototype-finally",normalizedTitle:"promise.prototype.finally()",charIndex:3719},{level:2,title:"构造函数方法",slug:"构造函数方法",normalizedTitle:"构造函数方法",charIndex:3929},{level:3,title:"Promise.resolve()",slug:"promise-resolve",normalizedTitle:"promise.resolve()",charIndex:3940},{level:3,title:"Promise.reject()",slug:"promise-reject",normalizedTitle:"promise.reject()",charIndex:4452},{level:3,title:"Promise.all()",slug:"promise-all",normalizedTitle:"promise.all()",charIndex:4719},{level:3,title:"Promise.race()和 Promise.allSettled()",slug:"promise-race-和-promise-allsettled",normalizedTitle:"promise.race()和 promise.allsettled()",charIndex:5462},{level:3,title:"Promise.any()",slug:"promise-any",normalizedTitle:"promise.any()",charIndex:6745},{level:2,title:"Promise 的关键问题",slug:"promise-的关键问题",normalizedTitle:"promise 的关键问题",charIndex:8507},{level:2,title:"Promise 的应用",slug:"promise-的应用",normalizedTitle:"promise 的应用",charIndex:9777},{level:2,title:"手写 Promise",slug:"手写-promise",normalizedTitle:"手写 promise",charIndex:11173}],headersStr:"初识 Promise 为什么要使用 Promise? Promise 的基本流程 Promise 的基本用法 实例方法 Promise.prototype.then() Promise.prototype.catch() Promise.prototype.finally() 构造函数方法 Promise.resolve() Promise.reject() Promise.all() Promise.race()和 Promise.allSettled() Promise.any() Promise 的关键问题 Promise 的应用 手写 Promise",content:"# 初识 Promise\n\npromise是es6进行异步编程的新解决方案--- 旧方案指的是回调函数\n\n从语法上来说，Promise 是一个构造函数\n\n从功能上来说，Promise 对象用来封装一个异步操作并可以获取其成功或失败的结果值\n\n\n# 为什么要使用 Promise?\n\n 1. 指定回调函数的方式更加灵活：\n\n * 旧的：必须在启动异步任务前指定\n * promise：启动异步任务 → 返回 promise 对象 → 给 promise 对象绑定回调函数（甚至可以在异步任务结束后指定多个）\n\n// 一个promise指定多个回调如下\nlet p2 = new Promise((resolve, reject) => {\n    resolve(1)\n})\np2.then(value => {\n    console.log('第一个', value)\n})\np2.then(value => {\n    console.log('第二个', value)\n})\n// 不止成功的promise会如此，失败的promise亦是如此，如下：\nlet p3 = new Promise((resolve, reject) => {\n    reject(2)\n})\np3.then(\n    () => {},\n    value => {\n        console.log('第一个', value)\n    }\n)\np3.then(\n    () => {},\n    value => {\n        console.log('第二个', value)\n    }\n)\n\n\n 2. 支持链式调用，Promise 可以用来解决回调地狱(外部回调函数异步执行的结果是嵌套的回调执行的条件)的问题\n\n回调地狱不方便阅读，也不便于异常处理\n\n\n\n\n# Promise 的基本流程\n\n\n\n\n# Promise 的基本用法\n\n 1. 实例化构造函数生成实例对象\n\nconst p = new Promise(executor)\n\n\n(1). executor函数： 执行器(resolve,reject)=>{}\n\n(2). resolve函数：内部定义成功时调用的函数\n\n(3).reject函数：内部定义失败时调用的函数\n\n注意\n\nexecutor 会在 promise 内部立即同步调用，异步操作在执行器中执行\n\n 2. Promise 对象状态属性:PromiseState\n\n（1）一开始声明后不进行任何操作，就是 pending,未完成\n\n（2）执行 resolve函数，变成fulfilled，已成功\n\n（3）执行reject函数，变成 rejected，已失败\n\n（4）Promise 函数的两个参数可以任意命名，但是功能并不会改变\n\n（5）Promise 的状态一旦发生变化，就不会再改变，即Promise 函数里的 resolve 或是 reject 只执行第一个\n\nconst p = new Promise((resolve, reject) => {\n    // pending->fulfilled\n    // resolve();     //可以传递参数，在then()方法的第一个回调函数中接收\n    // pending->rejected\n    //reject();        //可以传递参数，在then()方法的第二个回调函数中接收\n})\n\n\n 3. Promise 对象结果值属性：PromiseResult\n\n保存对象成功（resolve）或者失败（reject）的结果\n\n\n# 实例方法\n\n\n# Promise.prototype.then()\n\n 1. 什么时候执行？\n\n（1）resolve():状态 pending->fulfilled 的时候，执行 then 方法的第一个回调函数\n\n（2）reject():状态 pending->rejected 的时候，执行 then 方法的第二个回调函数\n\nconst p = new Promise((resolve, reject) => {\n    // resolve 和 reject 函数的参数\n    // resolve('success');  //传的是字符串\n    // resolve({ username: 'frank' });  //传的是对象\n    reject(new Error('reason')) //传的是错误对象\n})\np.then(\n    data => {\n        //data接收的是成功状态下，resolve函数传递的参数\n        console.log('success', data)\n    },\n    err => {\n        //err接收的是失败状态下，reject函数传递的参数\n        console.log('error', err)\n    }\n)\n\n\n 2. 执行后返回的值也是一个 promise 对象，then 方法可以连续调用，并且每次调用后都会返回一个新的 Promise 对象。\n\nconst p = new Promise((resolve, reject) => {\n    resolve() //改变状态为fulfilled\n})\np.then(\n    () => {},\n    () => {}\n)\n    .then()\n    .then()\n\n\n 3. then 方法返回的 Promise 对象的状态\n\n由 then()指定的回调函数执行的结果决定\n\n① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常\n\nconst p = new Promise((resolve, reject) => {\n    resolve('frank')\n})\np.then(value => {\n    console.log(value)\n    // throw '错啦!'\n}).then(\n    a => {\n        // 没有返回值相当于return undefined,即return一个成功状态的promise\n        console.log(a) // undefined\n        console.log('成功了!')\n    },\n    err => {\n        console.log(err)\n    }\n)\n\n\n② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值\n\n提示\n\n没有返回值相当于 return undefined,即 return 一个成功状态的 promise,结果为 undefined\n\nconst p = new Promise((resolve, reject) => {\n    resolve('frank')\n})\np.then(value => {\n    console.log(value)\n    return 456\n}).then(value => {\n    console.log(value) // 456\n})\n\n\n③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果\n\nconst p = new Promise((resolve, reject) => {\n    resolve('frank')\n})\np.then(value => {\n    console.log(value)\n    return new Promise((resolve, reject) => {\n        resolve('123')\n    })\n}).then(value => {\n    console.log(value) // 123\n})\n\n\n\n# Promise.prototype.catch()\n\n 1. 有什么用\n\n * catch 专门用来处理 rejected 状态\n * catch 本质是 then 的特例,即它只能指定失败的回调,不能指定成功的回调\n\n 2. 基本用法 一般总是建议，Promise 对象后面要跟 catch 方法，这样可以处理 Promise 内部发生的错误\n\nconst p = new Promise((resolve, reject) => {\n    reject('err')\n})\n    .catch(err => {\n        console.log(err)\n        return 123\n    })\n    .then(data => {\n        console.log(data) // 123\n    })\n\n\n\n# Promise.prototype.finally()\n\nfinally()方法返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是rejected，都会执行指定的回调函数。这为在 Promise 是否成功完成后都需要执行的代码提供了一种方式。\n\np.finally(function () {\n    // 返回状态为(resolved 或 rejected)\n})\n\n\n\n# 构造函数方法\n\n\n# Promise.resolve()\n\nPromise.resolve()， 返回一个成功/失败的 Promise 对象的一种简写形式\n\nnew Promise(resolve => resolve('foo'))\n// 简写\nPromise.resolve('foo')\n\n\n * 参数\n\n 1. 一般参数(非 Promise 对象),返回的结果为成功 Promise 对象\n\nPromise.resolve('foo').then(data => {\n    console.log(data)\n})\n\n\n 2. 以 Promise 对象当做参数\n\n如果传入的参数是 Promise 对象，则参数的结果决定了Promise.resolve()的结果\n\nconst p = Promise.resolve(\n    new Promise((resolve, reject) => {\n        reject(123)\n    })\n)\nconsole.log(p) // Promise {<rejected>: 123}\np.catch(err => {\n    console.log(err)\n})\n\n\n\n# Promise.reject()\n\nPromise.reject()，返回一个失败状态 Promise 对象的一种简写形式\n\nnew Promise((resolve, reject) => {\n    reject('reason')\n})\n\n// 等价于\nPromise.reject('reason')\n\n\n与 Promise.resolve()不同，Promise.reject()不管什么参数,它返回的结果永远都是失败的，而且传入什么参数，失败的结果就是什么(传入 promise,失败的结果也是 promise)\n\n\n# Promise.all()\n\n关注多个 Promise 对象的状态变化，可以传入多个 Promise 实例，包装成一个新的 Promise 实例返回\n\nPromise.all() 的状态变化与所有传入的 Promise 实例对象状态有关,所有状态都变成 resolved，最终的状态才会变成 resolved,只要有一个变成 rejected，最终的状态就变成 rejected\n\n基本用法\n\nconst delay = ms => {\n    return new Promise(resolve => {\n        setTimeout(resolve, ms)\n    })\n}\n\nconst p1 = delay(1000).then(() => {\n    console.log('p1 完成了')\n\n    return 'p1'\n    // return Promise.reject('reason1');\n})\n\nconst p2 = delay(2000).then(() => {\n    console.log('p2 完成了')\n\n    return 'p2'\n    // return Promise.reject('reason2');\n})\n\nconst p = Promise.all([p1, p2])\np.then(\n    data => {\n        console.log(data) //[\"p1\", \"p2\"]\n    },\n    err => {\n        console.log(err) //如果p1失败，会立即输出reason，不会等到p2执行完 ,控制台打印reason1\n    }\n)\n\n\n\n# Promise.race()和 Promise.allSettled()\n\n 1. Promise.race()\n    关注多个 Promise 对象的状态变化，最终状态取决于第一个 Promise 对象的状态。\n    如果第一个成功了，那最终的就成功；如果第一个失败了，那最终的就失败\n\nconst delay = ms => {\n    return new Promise(resolve => {\n        setTimeout(resolve, ms)\n    })\n}\n\nconst p1 = delay(1000).then(() => {\n    console.log('p1 完成了')\n\n    return 'p1'\n    //   return Promise.reject('reason1');\n})\n\nconst p2 = delay(2000).then(() => {\n    console.log('p2 完成了')\n\n    return 'p2'\n    // return Promise.reject('reason2');\n})\n\nconst r = Promise.race([p1, p2])\nr.then(\n    data => {\n        console.log(data) //\n    },\n    err => {\n        console.log(err)\n    }\n)\n\n\n 2. Promise.allSettled() 只会真实记录下各个 Promise 的表现，最终状态永远都是成功的\n\nconst delay = ms => {\n    return new Promise(resolve => {\n        setTimeout(resolve, ms)\n    })\n}\n\nconst p1 = delay(1000).then(() => {\n    console.log('p1 完成了')\n\n    return 'p1'\n    // return Promise.reject('reason');\n})\n\nconst p2 = delay(2000).then(() => {\n    console.log('p2 完成了')\n\n    //   return 'p2';\n    return Promise.reject('reason')\n})\n\nconst allSettledPromise = Promise.allSettled([p1, p2])\nallSettledPromise.then(data => {\n    console.log(data)\n    //   [\n    //     { status: 'fulfilled', value: 'p1' },\n    //   { status: 'rejected', reason: 'reason' }\n    //   ]\n})\n\n\n\n# Promise.any()\n\n传入的参数是一组 Promise 实例，当所有 Promise 实例都变成 rejected 状态，返回的 Promise 才会变成 rejected 状态，参数中只要有一个 Promise 改变为成功状态，则返回的 Promise 状态就是成功的状态。\n\n# 示例\n\n（1）参数中只有一个成功状态的 Promise 实例\n\n// 失败\nconst p1 = new Promise((resolve, reject) => {\n    reject()\n})\n// 失败\nconst p2 = new Promise((resolve, reject) => {\n    reject()\n})\n// 成功\nconst p3 = new Promise(resolve => {\n    resolve()\n})\nconst res = Promise.any([p1, p3, p2])\nconsole.log(res) // 返回成功状态的Promise\n\n\n传入的一组 Promise 实例参数中，虽然 p1、p2 这两个是失败状态，但其中的 p3 是成功状态，所以 Promise.any()最终返回结果是成功状态的 Promise\n\n（2）参数中全部是失败状态的 Promise 实例\n\n// 失败\nconst p1 = new Promise((resolve, reject) => {\n    reject()\n})\n// 失败\nconst p2 = new Promise((resolve, reject) => {\n    reject()\n})\n// 失败\nconst p3 = new Promise((resolve, reject) => {\n    reject()\n})\nconst res = Promise.any([p1, p3, p2])\nconsole.log(res) // 返回失败状态的Promise\n\n\n由于参数中的 p1、p2、p3 这个三个 Promise 实例都是失败状态的，所以 Promise.any()返回一个失败状态的 Promise 实例\n\n⭐ 特别注意 ⭐:Promise.any()不会因为某个 Promise 实例变成失败状态而结束，这个方法用于返回第一个成功的 promise。只要有一个 Promise 成功此方法就会终止，它不会等待其他的 Promise 全部完成\n\nconst p1 = new Promise((resolve, reject) => {\n    reject('失败')\n})\n\nconst p2 = new Promise((resolve, reject) => {\n    setTimeout(resolve, 500, '最后完成')\n})\n\nconst p3 = new Promise((resolve, reject) => {\n    setTimeout(resolve, 100, '第一个完成')\n})\n\nconst res = Promise.any([p1, p2, p3])\nres.then(value => {\n    console.log(value)\n})\n\n\n上面这段代码中，p1 是失败状态，但 Promise.any()方法并没有结束，而是返回第一个成功的 Promise， 即 p3，当有一个 Promise 成功后，就会终止，所以最终输出结果只有“第一个完成”，并没有“最后完成”内容。\n\n⭐⭐ 总结 ⭐⭐\n\nall 且逻辑，全部成功才会成功，一个失败，即失败，其余参数还继续执行。\n\nrace，只关心第一个执行，第一个成功或失败，即执行成功或失败，其余参数还继续执行。\n\nallStated 只关心全部执行，不管参数是否成功或失败，最后只会执行成功，记录参数执行的状态。\n\nany 或逻辑 有一个成功即成功，立刻执行成功，其余参数不执行。如果全部失败，执行失败。\n\n# 实际应用场景\n\n实际开发中，可能会有这样的需求：一次性加载多张图片，哪一张先加载出来就显示哪一张。那么此时就可以使用 Promise.any()方法实现效果。\n\n\n# Promise 的关键问题\n\n1. Promise.all()/race()/allSettled()的参数，如果传的不是 Promise 数组，那么将自动转化成 Promise 数组\n\nPromise.all([1, 2, 3]).then(data => {\n    console.log(data) //[1, 2, 3]\n})\n// 等价于\n\nPromise.all([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]).then(\n    data => {\n        console.log(data) //[1, 2, 3]\n    }\n)\n\n\n提示\n\n不只是数组，任何可遍历的都可以作为参数\n\n2. Promise.all/race/allSettled 的错误处理\n\n（1）错误既可以在每个 Promise 中单独处理\n\n（2）也可以在 Promise.all/race/allSettled 中统一处理\n\n（3）错误一旦被处理，就不会在其他地方再处理一遍\n\n3. 如何改变 promise 的状态\n\n(1) resolve(value): 如果当前是 pending 就会变为 resolved\n\n(2) reject(reason): 如果当前是 pending 就会变为 rejected\n\n(3) 抛出异常: throw \"出问题了\",如果当前是 pending 就会变为 rejected\n\n4. 一个 promise 指定多个成功/失败回调函数, 都会调用吗?\n\n当 promise 改变为对应状态时都会调用\n\n5. 改变 promise 状态和指定回调函数谁先谁后?\n\n(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调\n\n(2) 如何先改状态再指定回调?\n\n① 在执行器中直接调用 resolve()/reject()\n\n② 延迟更长时间才调用 then()\n\n(3) 什么时候才能得到数据?\n\n① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据\n\n② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据\n\n6. promise 如何串连多个操作任务?\n\npromise 的 then()返回一个新的 promise, 通过 then 的链式调用串连多个同步/异步任务\n\n7. promise 异常传透?\n\n(1) 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调\n\n(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理\n\n8. 中断 promise 链?\n\n(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数\n\n(2) 有且只有一种办法: 在回调函数中返回一个 pending 状态的 promise 对象=>return new Promise(()=>{})\n\n\n# Promise 的应用\n\n * 异步加载图片\n\nconst loadImgAsync = url => {\n    return new Promise((resolve, reject) => {\n        const img = new Image()\n\n        img.onload = () => {\n            resolve(img)\n        }\n\n        img.onerror = () => {\n            reject(new Error(`Could not load image at ${url}`))\n        }\n\n        img.src = url\n    })\n}\n\nconst imgDOM = document.getElementById('img')\nloadImgAsync('图片地址')\n    .then(img => {\n        console.log(img.src)\n        setTimeout(() => {\n            imgDOM.src = img.src\n        }, 1000)\n    })\n    .catch(err => {\n        console.log(err)\n    })\n\n\n * AJAX 请求\n\n/**\n * 封装一个函数 sendAJAX 发送 GET AJAX 请求\n * 参数   URL\n * 返回结果 Promise 对象\n */\nfunction sendAJAX(url) {\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest()\n        xhr.responseType = 'json'\n        xhr.open('GET', url)\n        xhr.send()\n        //处理结果\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === 4) {\n                //判断成功\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    //成功的结果\n                    resolve(xhr.response)\n                } else {\n                    reject(xhr.status)\n                }\n            }\n        }\n    })\n}\n\nsendAJAX('https://api.apiopen.top/getJoke').then(\n    value => {\n        console.log(value)\n    },\n    reason => {\n        console.warn(reason)\n    }\n)\n\n\n\n# 手写 Promise\n\n//声明构造函数\nfunction Promise(executor) {\n    //添加属性\n    this.PromiseState = 'pending'\n    this.PromiseResult = null\n    //声明属性\n    this.callbacks = []\n    //保存实例对象的 this 的值\n    const self = this // self _this that\n    //resolve 函数\n    function resolve(data) {\n        //判断状态\n        if (self.PromiseState !== 'pending') return\n        //1. 修改对象的状态 (promiseState)\n        self.PromiseState = 'fulfilled' // resolved\n        //2. 设置对象结果值 (promiseResult)\n        self.PromiseResult = data\n        //调用成功的回调函数\n        setTimeout(() => {\n            self.callbacks.forEach(item => {\n                item.onResolved(data)\n            })\n        })\n    }\n    //reject 函数\n    function reject(data) {\n        //判断状态\n        if (self.PromiseState !== 'pending') return\n        //1. 修改对象的状态 (promiseState)\n        self.PromiseState = 'rejected' //\n        //2. 设置对象结果值 (promiseResult)\n        self.PromiseResult = data\n        //执行失败的回调\n        setTimeout(() => {\n            self.callbacks.forEach(item => {\n                item.onRejected(data)\n            })\n        })\n    }\n    try {\n        //同步调用『执行器函数』\n        executor(resolve, reject)\n    } catch (e) {\n        //修改 promise 对象状态为『失败』\n        reject(e)\n    }\n}\n\n//添加 then 方法\nPromise.prototype.then = function (onResolved, onRejected) {\n    const self = this\n    //判断回调函数参数\n    if (typeof onRejected !== 'function') {\n        onRejected = reason => {\n            throw reason\n        }\n    }\n    if (typeof onResolved !== 'function') {\n        onResolved = value => value\n        //value => { return value};\n    }\n    return new Promise((resolve, reject) => {\n        //封装函数\n        function callback(type) {\n            try {\n                //获取回调函数的执行结果\n                let result = type(self.PromiseResult)\n                //判断\n                if (result instanceof Promise) {\n                    //如果是 Promise 类型的对象\n                    result.then(\n                        v => {\n                            resolve(v)\n                        },\n                        r => {\n                            reject(r)\n                        }\n                    )\n                } else {\n                    //结果的对象状态为『成功』\n                    resolve(result)\n                }\n            } catch (e) {\n                reject(e)\n            }\n        }\n        //调用回调函数  PromiseState\n        if (this.PromiseState === 'fulfilled') {\n            setTimeout(() => {\n                callback(onResolved)\n            })\n        }\n        if (this.PromiseState === 'rejected') {\n            setTimeout(() => {\n                callback(onRejected)\n            })\n        }\n        //判断 pending 状态\n        if (this.PromiseState === 'pending') {\n            //保存回调函数\n            this.callbacks.push({\n                onResolved: function () {\n                    callback(onResolved)\n                },\n                onRejected: function () {\n                    callback(onRejected)\n                },\n            })\n        }\n    })\n}\n\n//添加 catch 方法\nPromise.prototype.catch = function (onRejected) {\n    return this.then(undefined, onRejected)\n}\n\n//添加 resolve 方法\nPromise.resolve = function (value) {\n    //返回promise对象\n    return new Promise((resolve, reject) => {\n        if (value instanceof Promise) {\n            value.then(\n                v => {\n                    resolve(v)\n                },\n                r => {\n                    reject(r)\n                }\n            )\n        } else {\n            //状态设置为成功\n            resolve(value)\n        }\n    })\n}\n\n//添加 reject 方法\nPromise.reject = function (reason) {\n    return new Promise((resolve, reject) => {\n        reject(reason)\n    })\n}\n\n//添加 all 方法\nPromise.all = function (promises) {\n    //返回结果为promise对象\n    return new Promise((resolve, reject) => {\n        //声明变量\n        let count = 0\n        let arr = []\n        //遍历\n        for (let i = 0; i < promises.length; i++) {\n            //\n            promises[i].then(\n                v => {\n                    //得知对象的状态是成功\n                    //每个promise对象 都成功\n                    count++\n                    //将当前promise对象成功的结果 存入到数组中\n                    arr[i] = v\n                    //判断\n                    if (count === promises.length) {\n                        //修改状态\n                        resolve(arr)\n                    }\n                },\n                r => {\n                    reject(r)\n                }\n            )\n        }\n    })\n}\n\n//添加 race 方法\nPromise.race = function (promises) {\n    return new Promise((resolve, reject) => {\n        for (let i = 0; i < promises.length; i++) {\n            promises[i].then(\n                v => {\n                    //修改返回对象的状态为 『成功』\n                    resolve(v)\n                },\n                r => {\n                    //修改返回对象的状态为 『失败』\n                    reject(r)\n                }\n            )\n        }\n    })\n}\n",normalizedContent:"# 初识 promise\n\npromise是es6进行异步编程的新解决方案--- 旧方案指的是回调函数\n\n从语法上来说，promise 是一个构造函数\n\n从功能上来说，promise 对象用来封装一个异步操作并可以获取其成功或失败的结果值\n\n\n# 为什么要使用 promise?\n\n 1. 指定回调函数的方式更加灵活：\n\n * 旧的：必须在启动异步任务前指定\n * promise：启动异步任务 → 返回 promise 对象 → 给 promise 对象绑定回调函数（甚至可以在异步任务结束后指定多个）\n\n// 一个promise指定多个回调如下\nlet p2 = new promise((resolve, reject) => {\n    resolve(1)\n})\np2.then(value => {\n    console.log('第一个', value)\n})\np2.then(value => {\n    console.log('第二个', value)\n})\n// 不止成功的promise会如此，失败的promise亦是如此，如下：\nlet p3 = new promise((resolve, reject) => {\n    reject(2)\n})\np3.then(\n    () => {},\n    value => {\n        console.log('第一个', value)\n    }\n)\np3.then(\n    () => {},\n    value => {\n        console.log('第二个', value)\n    }\n)\n\n\n 2. 支持链式调用，promise 可以用来解决回调地狱(外部回调函数异步执行的结果是嵌套的回调执行的条件)的问题\n\n回调地狱不方便阅读，也不便于异常处理\n\n\n\n\n# promise 的基本流程\n\n\n\n\n# promise 的基本用法\n\n 1. 实例化构造函数生成实例对象\n\nconst p = new promise(executor)\n\n\n(1). executor函数： 执行器(resolve,reject)=>{}\n\n(2). resolve函数：内部定义成功时调用的函数\n\n(3).reject函数：内部定义失败时调用的函数\n\n注意\n\nexecutor 会在 promise 内部立即同步调用，异步操作在执行器中执行\n\n 2. promise 对象状态属性:promisestate\n\n（1）一开始声明后不进行任何操作，就是 pending,未完成\n\n（2）执行 resolve函数，变成fulfilled，已成功\n\n（3）执行reject函数，变成 rejected，已失败\n\n（4）promise 函数的两个参数可以任意命名，但是功能并不会改变\n\n（5）promise 的状态一旦发生变化，就不会再改变，即promise 函数里的 resolve 或是 reject 只执行第一个\n\nconst p = new promise((resolve, reject) => {\n    // pending->fulfilled\n    // resolve();     //可以传递参数，在then()方法的第一个回调函数中接收\n    // pending->rejected\n    //reject();        //可以传递参数，在then()方法的第二个回调函数中接收\n})\n\n\n 3. promise 对象结果值属性：promiseresult\n\n保存对象成功（resolve）或者失败（reject）的结果\n\n\n# 实例方法\n\n\n# promise.prototype.then()\n\n 1. 什么时候执行？\n\n（1）resolve():状态 pending->fulfilled 的时候，执行 then 方法的第一个回调函数\n\n（2）reject():状态 pending->rejected 的时候，执行 then 方法的第二个回调函数\n\nconst p = new promise((resolve, reject) => {\n    // resolve 和 reject 函数的参数\n    // resolve('success');  //传的是字符串\n    // resolve({ username: 'frank' });  //传的是对象\n    reject(new error('reason')) //传的是错误对象\n})\np.then(\n    data => {\n        //data接收的是成功状态下，resolve函数传递的参数\n        console.log('success', data)\n    },\n    err => {\n        //err接收的是失败状态下，reject函数传递的参数\n        console.log('error', err)\n    }\n)\n\n\n 2. 执行后返回的值也是一个 promise 对象，then 方法可以连续调用，并且每次调用后都会返回一个新的 promise 对象。\n\nconst p = new promise((resolve, reject) => {\n    resolve() //改变状态为fulfilled\n})\np.then(\n    () => {},\n    () => {}\n)\n    .then()\n    .then()\n\n\n 3. then 方法返回的 promise 对象的状态\n\n由 then()指定的回调函数执行的结果决定\n\n① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常\n\nconst p = new promise((resolve, reject) => {\n    resolve('frank')\n})\np.then(value => {\n    console.log(value)\n    // throw '错啦!'\n}).then(\n    a => {\n        // 没有返回值相当于return undefined,即return一个成功状态的promise\n        console.log(a) // undefined\n        console.log('成功了!')\n    },\n    err => {\n        console.log(err)\n    }\n)\n\n\n② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值\n\n提示\n\n没有返回值相当于 return undefined,即 return 一个成功状态的 promise,结果为 undefined\n\nconst p = new promise((resolve, reject) => {\n    resolve('frank')\n})\np.then(value => {\n    console.log(value)\n    return 456\n}).then(value => {\n    console.log(value) // 456\n})\n\n\n③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果\n\nconst p = new promise((resolve, reject) => {\n    resolve('frank')\n})\np.then(value => {\n    console.log(value)\n    return new promise((resolve, reject) => {\n        resolve('123')\n    })\n}).then(value => {\n    console.log(value) // 123\n})\n\n\n\n# promise.prototype.catch()\n\n 1. 有什么用\n\n * catch 专门用来处理 rejected 状态\n * catch 本质是 then 的特例,即它只能指定失败的回调,不能指定成功的回调\n\n 2. 基本用法 一般总是建议，promise 对象后面要跟 catch 方法，这样可以处理 promise 内部发生的错误\n\nconst p = new promise((resolve, reject) => {\n    reject('err')\n})\n    .catch(err => {\n        console.log(err)\n        return 123\n    })\n    .then(data => {\n        console.log(data) // 123\n    })\n\n\n\n# promise.prototype.finally()\n\nfinally()方法返回一个 promise。在 promise 结束时，无论结果是 fulfilled 或者是rejected，都会执行指定的回调函数。这为在 promise 是否成功完成后都需要执行的代码提供了一种方式。\n\np.finally(function () {\n    // 返回状态为(resolved 或 rejected)\n})\n\n\n\n# 构造函数方法\n\n\n# promise.resolve()\n\npromise.resolve()， 返回一个成功/失败的 promise 对象的一种简写形式\n\nnew promise(resolve => resolve('foo'))\n// 简写\npromise.resolve('foo')\n\n\n * 参数\n\n 1. 一般参数(非 promise 对象),返回的结果为成功 promise 对象\n\npromise.resolve('foo').then(data => {\n    console.log(data)\n})\n\n\n 2. 以 promise 对象当做参数\n\n如果传入的参数是 promise 对象，则参数的结果决定了promise.resolve()的结果\n\nconst p = promise.resolve(\n    new promise((resolve, reject) => {\n        reject(123)\n    })\n)\nconsole.log(p) // promise {<rejected>: 123}\np.catch(err => {\n    console.log(err)\n})\n\n\n\n# promise.reject()\n\npromise.reject()，返回一个失败状态 promise 对象的一种简写形式\n\nnew promise((resolve, reject) => {\n    reject('reason')\n})\n\n// 等价于\npromise.reject('reason')\n\n\n与 promise.resolve()不同，promise.reject()不管什么参数,它返回的结果永远都是失败的，而且传入什么参数，失败的结果就是什么(传入 promise,失败的结果也是 promise)\n\n\n# promise.all()\n\n关注多个 promise 对象的状态变化，可以传入多个 promise 实例，包装成一个新的 promise 实例返回\n\npromise.all() 的状态变化与所有传入的 promise 实例对象状态有关,所有状态都变成 resolved，最终的状态才会变成 resolved,只要有一个变成 rejected，最终的状态就变成 rejected\n\n基本用法\n\nconst delay = ms => {\n    return new promise(resolve => {\n        settimeout(resolve, ms)\n    })\n}\n\nconst p1 = delay(1000).then(() => {\n    console.log('p1 完成了')\n\n    return 'p1'\n    // return promise.reject('reason1');\n})\n\nconst p2 = delay(2000).then(() => {\n    console.log('p2 完成了')\n\n    return 'p2'\n    // return promise.reject('reason2');\n})\n\nconst p = promise.all([p1, p2])\np.then(\n    data => {\n        console.log(data) //[\"p1\", \"p2\"]\n    },\n    err => {\n        console.log(err) //如果p1失败，会立即输出reason，不会等到p2执行完 ,控制台打印reason1\n    }\n)\n\n\n\n# promise.race()和 promise.allsettled()\n\n 1. promise.race()\n    关注多个 promise 对象的状态变化，最终状态取决于第一个 promise 对象的状态。\n    如果第一个成功了，那最终的就成功；如果第一个失败了，那最终的就失败\n\nconst delay = ms => {\n    return new promise(resolve => {\n        settimeout(resolve, ms)\n    })\n}\n\nconst p1 = delay(1000).then(() => {\n    console.log('p1 完成了')\n\n    return 'p1'\n    //   return promise.reject('reason1');\n})\n\nconst p2 = delay(2000).then(() => {\n    console.log('p2 完成了')\n\n    return 'p2'\n    // return promise.reject('reason2');\n})\n\nconst r = promise.race([p1, p2])\nr.then(\n    data => {\n        console.log(data) //\n    },\n    err => {\n        console.log(err)\n    }\n)\n\n\n 2. promise.allsettled() 只会真实记录下各个 promise 的表现，最终状态永远都是成功的\n\nconst delay = ms => {\n    return new promise(resolve => {\n        settimeout(resolve, ms)\n    })\n}\n\nconst p1 = delay(1000).then(() => {\n    console.log('p1 完成了')\n\n    return 'p1'\n    // return promise.reject('reason');\n})\n\nconst p2 = delay(2000).then(() => {\n    console.log('p2 完成了')\n\n    //   return 'p2';\n    return promise.reject('reason')\n})\n\nconst allsettledpromise = promise.allsettled([p1, p2])\nallsettledpromise.then(data => {\n    console.log(data)\n    //   [\n    //     { status: 'fulfilled', value: 'p1' },\n    //   { status: 'rejected', reason: 'reason' }\n    //   ]\n})\n\n\n\n# promise.any()\n\n传入的参数是一组 promise 实例，当所有 promise 实例都变成 rejected 状态，返回的 promise 才会变成 rejected 状态，参数中只要有一个 promise 改变为成功状态，则返回的 promise 状态就是成功的状态。\n\n# 示例\n\n（1）参数中只有一个成功状态的 promise 实例\n\n// 失败\nconst p1 = new promise((resolve, reject) => {\n    reject()\n})\n// 失败\nconst p2 = new promise((resolve, reject) => {\n    reject()\n})\n// 成功\nconst p3 = new promise(resolve => {\n    resolve()\n})\nconst res = promise.any([p1, p3, p2])\nconsole.log(res) // 返回成功状态的promise\n\n\n传入的一组 promise 实例参数中，虽然 p1、p2 这两个是失败状态，但其中的 p3 是成功状态，所以 promise.any()最终返回结果是成功状态的 promise\n\n（2）参数中全部是失败状态的 promise 实例\n\n// 失败\nconst p1 = new promise((resolve, reject) => {\n    reject()\n})\n// 失败\nconst p2 = new promise((resolve, reject) => {\n    reject()\n})\n// 失败\nconst p3 = new promise((resolve, reject) => {\n    reject()\n})\nconst res = promise.any([p1, p3, p2])\nconsole.log(res) // 返回失败状态的promise\n\n\n由于参数中的 p1、p2、p3 这个三个 promise 实例都是失败状态的，所以 promise.any()返回一个失败状态的 promise 实例\n\n⭐ 特别注意 ⭐:promise.any()不会因为某个 promise 实例变成失败状态而结束，这个方法用于返回第一个成功的 promise。只要有一个 promise 成功此方法就会终止，它不会等待其他的 promise 全部完成\n\nconst p1 = new promise((resolve, reject) => {\n    reject('失败')\n})\n\nconst p2 = new promise((resolve, reject) => {\n    settimeout(resolve, 500, '最后完成')\n})\n\nconst p3 = new promise((resolve, reject) => {\n    settimeout(resolve, 100, '第一个完成')\n})\n\nconst res = promise.any([p1, p2, p3])\nres.then(value => {\n    console.log(value)\n})\n\n\n上面这段代码中，p1 是失败状态，但 promise.any()方法并没有结束，而是返回第一个成功的 promise， 即 p3，当有一个 promise 成功后，就会终止，所以最终输出结果只有“第一个完成”，并没有“最后完成”内容。\n\n⭐⭐ 总结 ⭐⭐\n\nall 且逻辑，全部成功才会成功，一个失败，即失败，其余参数还继续执行。\n\nrace，只关心第一个执行，第一个成功或失败，即执行成功或失败，其余参数还继续执行。\n\nallstated 只关心全部执行，不管参数是否成功或失败，最后只会执行成功，记录参数执行的状态。\n\nany 或逻辑 有一个成功即成功，立刻执行成功，其余参数不执行。如果全部失败，执行失败。\n\n# 实际应用场景\n\n实际开发中，可能会有这样的需求：一次性加载多张图片，哪一张先加载出来就显示哪一张。那么此时就可以使用 promise.any()方法实现效果。\n\n\n# promise 的关键问题\n\n1. promise.all()/race()/allsettled()的参数，如果传的不是 promise 数组，那么将自动转化成 promise 数组\n\npromise.all([1, 2, 3]).then(data => {\n    console.log(data) //[1, 2, 3]\n})\n// 等价于\n\npromise.all([promise.resolve(1), promise.resolve(2), promise.resolve(3)]).then(\n    data => {\n        console.log(data) //[1, 2, 3]\n    }\n)\n\n\n提示\n\n不只是数组，任何可遍历的都可以作为参数\n\n2. promise.all/race/allsettled 的错误处理\n\n（1）错误既可以在每个 promise 中单独处理\n\n（2）也可以在 promise.all/race/allsettled 中统一处理\n\n（3）错误一旦被处理，就不会在其他地方再处理一遍\n\n3. 如何改变 promise 的状态\n\n(1) resolve(value): 如果当前是 pending 就会变为 resolved\n\n(2) reject(reason): 如果当前是 pending 就会变为 rejected\n\n(3) 抛出异常: throw \"出问题了\",如果当前是 pending 就会变为 rejected\n\n4. 一个 promise 指定多个成功/失败回调函数, 都会调用吗?\n\n当 promise 改变为对应状态时都会调用\n\n5. 改变 promise 状态和指定回调函数谁先谁后?\n\n(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调\n\n(2) 如何先改状态再指定回调?\n\n① 在执行器中直接调用 resolve()/reject()\n\n② 延迟更长时间才调用 then()\n\n(3) 什么时候才能得到数据?\n\n① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据\n\n② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据\n\n6. promise 如何串连多个操作任务?\n\npromise 的 then()返回一个新的 promise, 通过 then 的链式调用串连多个同步/异步任务\n\n7. promise 异常传透?\n\n(1) 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调\n\n(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理\n\n8. 中断 promise 链?\n\n(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数\n\n(2) 有且只有一种办法: 在回调函数中返回一个 pending 状态的 promise 对象=>return new promise(()=>{})\n\n\n# promise 的应用\n\n * 异步加载图片\n\nconst loadimgasync = url => {\n    return new promise((resolve, reject) => {\n        const img = new image()\n\n        img.onload = () => {\n            resolve(img)\n        }\n\n        img.onerror = () => {\n            reject(new error(`could not load image at ${url}`))\n        }\n\n        img.src = url\n    })\n}\n\nconst imgdom = document.getelementbyid('img')\nloadimgasync('图片地址')\n    .then(img => {\n        console.log(img.src)\n        settimeout(() => {\n            imgdom.src = img.src\n        }, 1000)\n    })\n    .catch(err => {\n        console.log(err)\n    })\n\n\n * ajax 请求\n\n/**\n * 封装一个函数 sendajax 发送 get ajax 请求\n * 参数   url\n * 返回结果 promise 对象\n */\nfunction sendajax(url) {\n    return new promise((resolve, reject) => {\n        const xhr = new xmlhttprequest()\n        xhr.responsetype = 'json'\n        xhr.open('get', url)\n        xhr.send()\n        //处理结果\n        xhr.onreadystatechange = function () {\n            if (xhr.readystate === 4) {\n                //判断成功\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    //成功的结果\n                    resolve(xhr.response)\n                } else {\n                    reject(xhr.status)\n                }\n            }\n        }\n    })\n}\n\nsendajax('https://api.apiopen.top/getjoke').then(\n    value => {\n        console.log(value)\n    },\n    reason => {\n        console.warn(reason)\n    }\n)\n\n\n\n# 手写 promise\n\n//声明构造函数\nfunction promise(executor) {\n    //添加属性\n    this.promisestate = 'pending'\n    this.promiseresult = null\n    //声明属性\n    this.callbacks = []\n    //保存实例对象的 this 的值\n    const self = this // self _this that\n    //resolve 函数\n    function resolve(data) {\n        //判断状态\n        if (self.promisestate !== 'pending') return\n        //1. 修改对象的状态 (promisestate)\n        self.promisestate = 'fulfilled' // resolved\n        //2. 设置对象结果值 (promiseresult)\n        self.promiseresult = data\n        //调用成功的回调函数\n        settimeout(() => {\n            self.callbacks.foreach(item => {\n                item.onresolved(data)\n            })\n        })\n    }\n    //reject 函数\n    function reject(data) {\n        //判断状态\n        if (self.promisestate !== 'pending') return\n        //1. 修改对象的状态 (promisestate)\n        self.promisestate = 'rejected' //\n        //2. 设置对象结果值 (promiseresult)\n        self.promiseresult = data\n        //执行失败的回调\n        settimeout(() => {\n            self.callbacks.foreach(item => {\n                item.onrejected(data)\n            })\n        })\n    }\n    try {\n        //同步调用『执行器函数』\n        executor(resolve, reject)\n    } catch (e) {\n        //修改 promise 对象状态为『失败』\n        reject(e)\n    }\n}\n\n//添加 then 方法\npromise.prototype.then = function (onresolved, onrejected) {\n    const self = this\n    //判断回调函数参数\n    if (typeof onrejected !== 'function') {\n        onrejected = reason => {\n            throw reason\n        }\n    }\n    if (typeof onresolved !== 'function') {\n        onresolved = value => value\n        //value => { return value};\n    }\n    return new promise((resolve, reject) => {\n        //封装函数\n        function callback(type) {\n            try {\n                //获取回调函数的执行结果\n                let result = type(self.promiseresult)\n                //判断\n                if (result instanceof promise) {\n                    //如果是 promise 类型的对象\n                    result.then(\n                        v => {\n                            resolve(v)\n                        },\n                        r => {\n                            reject(r)\n                        }\n                    )\n                } else {\n                    //结果的对象状态为『成功』\n                    resolve(result)\n                }\n            } catch (e) {\n                reject(e)\n            }\n        }\n        //调用回调函数  promisestate\n        if (this.promisestate === 'fulfilled') {\n            settimeout(() => {\n                callback(onresolved)\n            })\n        }\n        if (this.promisestate === 'rejected') {\n            settimeout(() => {\n                callback(onrejected)\n            })\n        }\n        //判断 pending 状态\n        if (this.promisestate === 'pending') {\n            //保存回调函数\n            this.callbacks.push({\n                onresolved: function () {\n                    callback(onresolved)\n                },\n                onrejected: function () {\n                    callback(onrejected)\n                },\n            })\n        }\n    })\n}\n\n//添加 catch 方法\npromise.prototype.catch = function (onrejected) {\n    return this.then(undefined, onrejected)\n}\n\n//添加 resolve 方法\npromise.resolve = function (value) {\n    //返回promise对象\n    return new promise((resolve, reject) => {\n        if (value instanceof promise) {\n            value.then(\n                v => {\n                    resolve(v)\n                },\n                r => {\n                    reject(r)\n                }\n            )\n        } else {\n            //状态设置为成功\n            resolve(value)\n        }\n    })\n}\n\n//添加 reject 方法\npromise.reject = function (reason) {\n    return new promise((resolve, reject) => {\n        reject(reason)\n    })\n}\n\n//添加 all 方法\npromise.all = function (promises) {\n    //返回结果为promise对象\n    return new promise((resolve, reject) => {\n        //声明变量\n        let count = 0\n        let arr = []\n        //遍历\n        for (let i = 0; i < promises.length; i++) {\n            //\n            promises[i].then(\n                v => {\n                    //得知对象的状态是成功\n                    //每个promise对象 都成功\n                    count++\n                    //将当前promise对象成功的结果 存入到数组中\n                    arr[i] = v\n                    //判断\n                    if (count === promises.length) {\n                        //修改状态\n                        resolve(arr)\n                    }\n                },\n                r => {\n                    reject(r)\n                }\n            )\n        }\n    })\n}\n\n//添加 race 方法\npromise.race = function (promises) {\n    return new promise((resolve, reject) => {\n        for (let i = 0; i < promises.length; i++) {\n            promises[i].then(\n                v => {\n                    //修改返回对象的状态为 『成功』\n                    resolve(v)\n                },\n                r => {\n                    //修改返回对象的状态为 『失败』\n                    reject(r)\n                }\n            )\n        }\n    })\n}\n",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"Set和Map数据结构",frontmatter:{title:"Set和Map数据结构",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",relativePath:"前端开发/JavaScript/ES6/Set和Map数据结构.md",key:"v-e7f7dee2",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",headers:[{level:2,title:"Set",slug:"set",normalizedTitle:"set",charIndex:2},{level:3,title:"set 是什么",slug:"set-是什么",normalizedTitle:"set 是什么",charIndex:10},{level:3,title:"set 实例的方法和属性",slug:"set-实例的方法和属性",normalizedTitle:"set 实例的方法和属性",charIndex:215},{level:3,title:"Set 构造函数的参数",slug:"set-构造函数的参数",normalizedTitle:"set 构造函数的参数",charIndex:800},{level:3,title:"Set 的注意事项",slug:"set-的注意事项",normalizedTitle:"set 的注意事项",charIndex:1147},{level:3,title:"Set 的应用",slug:"set-的应用",normalizedTitle:"set 的应用",charIndex:1344},{level:2,title:"Map",slug:"map",normalizedTitle:"map",charIndex:1767},{level:3,title:"Map 是什么",slug:"map-是什么",normalizedTitle:"map 是什么",charIndex:1775},{level:3,title:"Map 实例的属性和方法",slug:"map-实例的属性和方法",normalizedTitle:"map 实例的属性和方法",charIndex:1978},{level:3,title:"Map 构造函数的参数",slug:"map-构造函数的参数",normalizedTitle:"map 构造函数的参数",charIndex:2886},{level:3,title:"Map 的注意事项",slug:"map-的注意事项",normalizedTitle:"map 的注意事项",charIndex:3220},{level:3,title:"Map 的应用",slug:"map-的应用",normalizedTitle:"map 的应用",charIndex:3391}],headersStr:"Set set 是什么 set 实例的方法和属性 Set 构造函数的参数 Set 的注意事项 Set 的应用 Map Map 是什么 Map 实例的属性和方法 Map 构造函数的参数 Map 的注意事项 Map 的应用",content:"# Set\n\n\n# set 是什么\n\n 1. 什么是 Set\n    Set 是一系列无序、没有重复值的数据集合\n 2. 理解 Set\n\n * set 中不能有重复的成员\n * Set没有下标去标示每一个值，所以 Set 是无序的，也不能像数组那样通过下标去访问 Set 的成员\n\nconst s = new Set()\ns.add(1)\ns.add(2)\nconsole.log(s) // Set { 1, 2 }\n\n\n\n# set 实例的方法和属性\n\n 1. 方法\n\n * add\n\n返回值：Set对象本身\n\nconst s = new Set()\ns.add(1).add(2)\n\n\n * has\n\nconst s = new Set()\ns.add(1).add(2)\nconsole.log(s.has(1)) // true\n\n\n * delete\n   使用 delete 删除不存在的成员，什么都不会发生，也不会报错\n\nconst s = new Set()\ns.add(1).add(2)\ns.delete(1) // true\n\n\n * clear:清空 set\n\nconst s = new Set()\ns.add(1)\ns.add(2)\ns.clear()\nconsole.log(s) // Set {}\n\n\n * forEach(数组,set map 都有这个方法)\n\nconst s = new Set()\ns.add(1)\n    .add(2)\n    .add(3)\ns.forEach(function(v, k, set) {\n    // set中v=k\n    console.log(v, k, set)\n    console.log(this) // window\n}, 这里修改this执向)\n\n\n 1. 属性\n\nsize:返回成员个数\n\n\n# Set 构造函数的参数\n\n 1. 数组\n\nconst s = new Set([1, 2, 1])\nconsole.log(s) // Set(2) { 1, 2 }\n\n\n 2. 字符串、arguments、Nodelist、Set 等\n\n// 字符串组作为Set构造函数的参数\nconst s = new Set('hello')\nconsole.log(s) // Set(4) { 'h', 'e', 'l', 'o' }\n\n\n// Set作为Set构造函数的参数\nconst s = new Set()\ns.add(1).add(2)\n// 相当于复制了了一个全新的Set\nconst b = new Set(s)\nconsole.log(b) //Set { 1, 2 }\n\n\n\n# Set 的注意事项\n\n 1. 判断重复的方式\n    set 对重复值的判断基本遵循严格相等,但是对于 NaN 的判断与（===）不同，Set 中 NaN 等于 NaN\n 2. 什么时候使用 Set\n\n * 数组或字符串去重时\n * 不需要通过下标访问，只需要遍历时\n * 为了使用 Set 提供的方法和属性时（add delete clear has forEach size 等）\n\n\n# Set 的应用\n\n 1. 数组去重\n\n// Set也可以使用`展开运算符`展开\nconsole.log([...new Set([1, 2, 1, 2, 1])])\n\n\n 2. 字符串去重\n\nconsole.log([...new Set('aabbccd')].join(''))\n\n\n 3. 存放 DOM 元素\n\n<body>\n    <p>1</p>\n    <p>2</p>\n    <p>3</p>\n    <script>\n        // nodelist 作为Set构造函数的参数\n        const s = new Set(document.querySelectorAll('p'))\n        s.forEach(function(e) {\n            e.style.backgroundColor = 'red'\n        })\n    <\/script>\n</body>\n\n\n\n# Map\n\n\n# Map 是什么\n\n 1. Map 和对象都是键值对的集合\n\nkey->value\n\nconst m = new Map()\nm.set('name', 'alex')\n\n\n 2. Map 和对象的区别\n\n * 对象一般用字符串当作键\n * 基本数据类型：数字、字符串、布尔值、 undefined、null,引用数据类型：对象（［］、｛｝、函数、Set、Map 等），以上都可以作为 Map 的键\n\n\n# Map 实例的属性和方法\n\n 1. 方法\n\n * set\n   使用 set 添加的新成员，键如果已经存在，后添加的键值对覆盖已有的,返回值为该 map 对象\n\nconst m = new Map()\nm.set('age', 18)\n    .set('name', 'alex')\n    .set('age', 111)\n\n\n * get\n   get 获取不存在的成员，返回 undefined\n\nconst m=new Map()\nm.set('age',18).set('name','alex').set('age',111)\nconsole.log(m.get('name') // 'alex'\n\n\n * has\n\nconst m = new Map()\nm.set('age', 18)\n    .set('name', 'alex')\n    .set('age', 111)\nconsole.log(m.has('name')) // true\n\n\n * delete\n   使用 delete 删除不存在的成员，什么都不会发生，也不会报错\n\nconst m = new Map()\nm.set('age', 18)\n    .set('name', 'alex')\n    .set('age', 111)\nm.delete('name') // true\n\n\n * clear\n\nconst m = new Map()\nm.set('age', 18)\n    .set('name', 'alex')\n    .set('age', 111)\nm.clear()\n\n\n * forEach\n\nconst m = new Map()\nm.set('age', 18)\n    .set('name', 'alex')\n    .set('age', 111)\nm.forEach(function(value, key, map) {\n    console.log(value, key, map)\n}, 这里修改this指向)\n\n\n 2. 属性\n\nsize：对象没有类似属性\n\n\n# Map 构造函数的参数\n\n 1. 数组 只能传二维数组，而且必须体现出键和值\n\nconst m = new Map([\n    ['name', 'alex'],\n    ['age', 18],\n])\nconsole.log(m)\n\n\n 2. Set Map\n\n * Set 中也必须体现出键和值，和二维数组类似\n\nconst s = new Set([\n    ['age', 123],\n    ['name', 'frank'],\n])\nconst m = new Map(s)\nconsole.log(m) // Map { 'age' => 123, 'name' => 'frank' }\n\n\n * 传入 Map 相当于复制了一个全新的 Map\n\n\n# Map 的注意事项\n\n 1. 判断重复的方式(后添加的新成员，键如果已经存在，后添加的键值对覆盖已有的) 基本遵循严格相等，例外 Map 中 NaN 等于 NaN\n 2. 什么时候使用 Map\n    如果只是需要 key->value的结构，或者需要字符串以外的值做键，使用 Map 更合适\n\n只有模拟现实世界的实体时，才使用对象\n\n\n# Map 的应用\n\n<body>\n    <p>1</p>\n    <p>2</p>\n    <p>3</p>\n    <script>\n        const [p1, p2, p3] = document.querySelectorAll('p')\n        const creatMap = (color, backgroundColor, fontSize) => {\n            const m = new Map([\n                ['color', color],\n                ['backgroundColor', backgroundColor],\n                ['fontSize', fontSize],\n            ])\n            return m\n        }\n        const newm = new Map([\n            // 调用creatMap函数返回的是一个map\n            [p1, creatMap('red', 'green', '34px')],\n            [p2, creatMap('black', 'blue', '30px')],\n            [p3, creatMap('green', 'orange', '15px')],\n        ])\n        newm.forEach(function(resultmap, elem) {\n            resultmap.forEach((value, k) => (elem.style[k] = value))\n        })\n    <\/script>\n</body>\n",normalizedContent:"# set\n\n\n# set 是什么\n\n 1. 什么是 set\n    set 是一系列无序、没有重复值的数据集合\n 2. 理解 set\n\n * set 中不能有重复的成员\n * set没有下标去标示每一个值，所以 set 是无序的，也不能像数组那样通过下标去访问 set 的成员\n\nconst s = new set()\ns.add(1)\ns.add(2)\nconsole.log(s) // set { 1, 2 }\n\n\n\n# set 实例的方法和属性\n\n 1. 方法\n\n * add\n\n返回值：set对象本身\n\nconst s = new set()\ns.add(1).add(2)\n\n\n * has\n\nconst s = new set()\ns.add(1).add(2)\nconsole.log(s.has(1)) // true\n\n\n * delete\n   使用 delete 删除不存在的成员，什么都不会发生，也不会报错\n\nconst s = new set()\ns.add(1).add(2)\ns.delete(1) // true\n\n\n * clear:清空 set\n\nconst s = new set()\ns.add(1)\ns.add(2)\ns.clear()\nconsole.log(s) // set {}\n\n\n * foreach(数组,set map 都有这个方法)\n\nconst s = new set()\ns.add(1)\n    .add(2)\n    .add(3)\ns.foreach(function(v, k, set) {\n    // set中v=k\n    console.log(v, k, set)\n    console.log(this) // window\n}, 这里修改this执向)\n\n\n 1. 属性\n\nsize:返回成员个数\n\n\n# set 构造函数的参数\n\n 1. 数组\n\nconst s = new set([1, 2, 1])\nconsole.log(s) // set(2) { 1, 2 }\n\n\n 2. 字符串、arguments、nodelist、set 等\n\n// 字符串组作为set构造函数的参数\nconst s = new set('hello')\nconsole.log(s) // set(4) { 'h', 'e', 'l', 'o' }\n\n\n// set作为set构造函数的参数\nconst s = new set()\ns.add(1).add(2)\n// 相当于复制了了一个全新的set\nconst b = new set(s)\nconsole.log(b) //set { 1, 2 }\n\n\n\n# set 的注意事项\n\n 1. 判断重复的方式\n    set 对重复值的判断基本遵循严格相等,但是对于 nan 的判断与（===）不同，set 中 nan 等于 nan\n 2. 什么时候使用 set\n\n * 数组或字符串去重时\n * 不需要通过下标访问，只需要遍历时\n * 为了使用 set 提供的方法和属性时（add delete clear has foreach size 等）\n\n\n# set 的应用\n\n 1. 数组去重\n\n// set也可以使用`展开运算符`展开\nconsole.log([...new set([1, 2, 1, 2, 1])])\n\n\n 2. 字符串去重\n\nconsole.log([...new set('aabbccd')].join(''))\n\n\n 3. 存放 dom 元素\n\n<body>\n    <p>1</p>\n    <p>2</p>\n    <p>3</p>\n    <script>\n        // nodelist 作为set构造函数的参数\n        const s = new set(document.queryselectorall('p'))\n        s.foreach(function(e) {\n            e.style.backgroundcolor = 'red'\n        })\n    <\/script>\n</body>\n\n\n\n# map\n\n\n# map 是什么\n\n 1. map 和对象都是键值对的集合\n\nkey->value\n\nconst m = new map()\nm.set('name', 'alex')\n\n\n 2. map 和对象的区别\n\n * 对象一般用字符串当作键\n * 基本数据类型：数字、字符串、布尔值、 undefined、null,引用数据类型：对象（［］、｛｝、函数、set、map 等），以上都可以作为 map 的键\n\n\n# map 实例的属性和方法\n\n 1. 方法\n\n * set\n   使用 set 添加的新成员，键如果已经存在，后添加的键值对覆盖已有的,返回值为该 map 对象\n\nconst m = new map()\nm.set('age', 18)\n    .set('name', 'alex')\n    .set('age', 111)\n\n\n * get\n   get 获取不存在的成员，返回 undefined\n\nconst m=new map()\nm.set('age',18).set('name','alex').set('age',111)\nconsole.log(m.get('name') // 'alex'\n\n\n * has\n\nconst m = new map()\nm.set('age', 18)\n    .set('name', 'alex')\n    .set('age', 111)\nconsole.log(m.has('name')) // true\n\n\n * delete\n   使用 delete 删除不存在的成员，什么都不会发生，也不会报错\n\nconst m = new map()\nm.set('age', 18)\n    .set('name', 'alex')\n    .set('age', 111)\nm.delete('name') // true\n\n\n * clear\n\nconst m = new map()\nm.set('age', 18)\n    .set('name', 'alex')\n    .set('age', 111)\nm.clear()\n\n\n * foreach\n\nconst m = new map()\nm.set('age', 18)\n    .set('name', 'alex')\n    .set('age', 111)\nm.foreach(function(value, key, map) {\n    console.log(value, key, map)\n}, 这里修改this指向)\n\n\n 2. 属性\n\nsize：对象没有类似属性\n\n\n# map 构造函数的参数\n\n 1. 数组 只能传二维数组，而且必须体现出键和值\n\nconst m = new map([\n    ['name', 'alex'],\n    ['age', 18],\n])\nconsole.log(m)\n\n\n 2. set map\n\n * set 中也必须体现出键和值，和二维数组类似\n\nconst s = new set([\n    ['age', 123],\n    ['name', 'frank'],\n])\nconst m = new map(s)\nconsole.log(m) // map { 'age' => 123, 'name' => 'frank' }\n\n\n * 传入 map 相当于复制了一个全新的 map\n\n\n# map 的注意事项\n\n 1. 判断重复的方式(后添加的新成员，键如果已经存在，后添加的键值对覆盖已有的) 基本遵循严格相等，例外 map 中 nan 等于 nan\n 2. 什么时候使用 map\n    如果只是需要 key->value的结构，或者需要字符串以外的值做键，使用 map 更合适\n\n只有模拟现实世界的实体时，才使用对象\n\n\n# map 的应用\n\n<body>\n    <p>1</p>\n    <p>2</p>\n    <p>3</p>\n    <script>\n        const [p1, p2, p3] = document.queryselectorall('p')\n        const creatmap = (color, backgroundcolor, fontsize) => {\n            const m = new map([\n                ['color', color],\n                ['backgroundcolor', backgroundcolor],\n                ['fontsize', fontsize],\n            ])\n            return m\n        }\n        const newm = new map([\n            // 调用creatmap函数返回的是一个map\n            [p1, creatmap('red', 'green', '34px')],\n            [p2, creatmap('black', 'blue', '30px')],\n            [p3, creatmap('green', 'orange', '15px')],\n        ])\n        newm.foreach(function(resultmap, elem) {\n            resultmap.foreach((value, k) => (elem.style[k] = value))\n        })\n    <\/script>\n</body>\n",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"let和const",frontmatter:{title:"let和const",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/let%E5%92%8Cconst.html",relativePath:"前端开发/JavaScript/ES6/let和const.md",key:"v-7381bf8a",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/let%E5%92%8Cconst.html",headers:[{level:2,title:"let 和 const",slug:"let-和-const",normalizedTitle:"let 和 const",charIndex:27},{level:2,title:"const",slug:"const",normalizedTitle:"const",charIndex:33},{level:2,title:"声明最佳实践",slug:"声明最佳实践",normalizedTitle:"声明最佳实践",charIndex:1784},{level:2,title:"let,const 与 var 的区别",slug:"let-const-与-var-的区别",normalizedTitle:"let,const 与 var 的区别",charIndex:1860},{level:3,title:"重复声明",slug:"重复声明",normalizedTitle:"重复声明",charIndex:1077},{level:3,title:"变量提升",slug:"变量提升",normalizedTitle:"变量提升",charIndex:2072},{level:3,title:"修改声明的变量",slug:"修改声明的变量",normalizedTitle:"修改声明的变量",charIndex:2271},{level:3,title:"暂时性锁区",slug:"暂时性锁区",normalizedTitle:"暂时性锁区",charIndex:2352},{level:3,title:"window 对象的属性和方法",slug:"window-对象的属性和方法",normalizedTitle:"window 对象的属性和方法",charIndex:2686},{level:3,title:"块级作用域",slug:"块级作用域",normalizedTitle:"块级作用域",charIndex:2361},{level:2,title:"let,const 的应用",slug:"let-const-的应用",normalizedTitle:"let,const 的应用",charIndex:3240}],headersStr:"let 和 const const 声明最佳实践 let,const 与 var 的区别 重复声明 变量提升 修改声明的变量 暂时性锁区 window 对象的属性和方法 块级作用域 let,const 的应用",content:'ES6 圣经\n\nECMAScipt 6 入门\n\n\n# let 和 const\n\nlet 声明变量,const 声明常量。\n\n{\n    var username = \'Frank\'\n    let age = 18\n    const sex = \'male\'\n}\nconsole.log(username) //  Frank\nconsole.log(age) // 报错\nconsole.log(sex) // 报错\n\n\n * var,let 声明的是变量，变量一旦初始化以后，还可以重新赋值。\n * const声明的是常量，常量一旦初始化，就不能重新赋值了，否则会报错。\n * let,const所声明的变量/常量，只在自身所在的代码块内有效。\n\nfor 循环的计数器，就很适合使用 let 命令\n\nvar a = []\nfor (let i = 0; i < 10; i++) {\n    a[i] = function() {\n        console.log(i)\n    }\n}\na[6]() // 6\n\n\n上面代码中，变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是 6。你可能会问，如果每一轮循环的变量 i 都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行计算。\n\n如果是 var 声明的 i 呢？所有的输出都是 10，变量 i 是 var 命令声明的，在全局范围内都有效，所以全局只有一个变量 i。每一次循环，变量 i 的值都会发生改变，而循环内被赋给数组 a 的函数内部的 console.log(i)，里面的 i 指向的就是全局的 i。也就是说，所有数组 a 的成员里面的 i，指向的都是同一个 i，导致运行时输出的是最后一轮的 i 的值，也就是 10。\n\n需要注意的是， for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\n\nfor (let i = 0; i < 3; i++) {\n    let i = \'abc\'\n    console.log(i)\n}\n// abc\n// abc\n// abc\n\n\n上面代码正确运行，输出了 3 次 abc。这表明函数内部的变量 i 与循环变量 i 不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 let 重复声明同一个变量）。\n\n\n# const\n\n使用 const 声明一个只读的常量，一旦声明，就必须立即初始化，不能留到最后赋值。\n\nconst 声明的常量，允许在不重新赋值的情况下修改它的值：\n\n 1. 基本类型数据类型是做不到的\n 2. 引用数据类型可以\n\nconst person = { username: \'bob\' }\nperson.username = \'zhang\'\n\n\n原因\n\nconst 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了,所以可以在不重新赋值的情况下修改 const 声明的引用数据类型。\n\n如果真的想将对象冻结，应该使用 Object.freeze 方法,那如果对象的属性也是对象呢？\n\nconst constantize = obj => {\n    Object.freeze(obj)\n    Object.keys(obj).forEach(key => {\n        if (typeof obj[key] === \'object\') {\n            Object.freeze(obj[key])\n            console.log(i)\n        }\n    })\n}\n\n\n\n# 声明最佳实践\n\n 1. 简单一看能用 let 的场景就用 let,比如 for 循环中的循环变量\n 2. 判断不了就用 const,报错好修改\n\n\n# let,const 与 var 的区别\n\n\n# 重复声明\n\nvar 允许重复声明，let,const 不允许不允许在相同作用域内，重复声明同一个变量。\n\nvar a = 1\nvar a = 2\nconsole.log(a) //2\nlet b = 2\nlet b = 3\nconsole.log(b) //SyntaxError: Identifier \'b\' has already been declared\n\n\n\n# 变量提升\n\nvar 会提升变量的声明到当前作用域的顶部，let，const 不存在变量提升,所声明的变量/常量一定要在声明后使用，否则报错。\n\nconsole.log(a) // undefined\nvar a = 2\nconsole.log(b) // ReferenceError: Cannot access \'b\' before initialization\nlet b = 2\n\n\n\n# 修改声明的变量\n\nvar 和 let 可以修改\n\nconst 声明一个只读的常量。一旦声明，常量的值就不能改变。并且 const 声明时，必须立即初始化\n\n\n# 暂时性锁区\n\n只要块级作用域内存在 let,const 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。\n\nconst a = 100\n\nfunction fun() {\n    console.log(a) // 报错Cannot access \'a\' before initialization（在初始化之前无法访问“a”）\n    const a = 1\n}\nfun()\n\n\n上面代码中，在 const 命令声明变量 a 之前，属于变量 a 的“死区”\n\n在代码块内，使用 let、const 命令声明变量或常量之前，该变量或常量都是不可用的。这在语法上，称为暂时性死区(temporal dead zone，简称 TDZ)\n\n\n# window 对象的属性和方法\n\n全局作用域中，var 声明的变量和通过 function 声明的函数，会自动变成 window 对象的属性或方法，let、 const 不会。\n\n\n# 块级作用域\n\nlet，const会形成块级作用域，var 没有块级作用域。\n\n没有块级作用域会导致两个问题：\n\n内层变量可能会覆盖外层变量:\n\nvar tmp = new Date()\n\nfunction f() {\n    console.log(tmp)\n    if (false) {\n        var tmp = \'hello world\'\n    }\n}\n\nf() // undefined\n\n\n用来计数的循环变量泄露为全局变量:\n\nfor (var i = 0; i < 3; i++) {\n    console.log(i) // 0,1,2\n}\nconsole.log(i) // 3\n\n\nES6 允许块级作用域的任意嵌套，内层作用域可以定义外层作用域的同名变量，块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。\n\n有哪些块级作用域?\n\n{}\nfor(){}\nwhile(){}\ndo{}while()\nif(){}\nswitch(){}\n\n\n\n# let,const 的应用\n\n场景：点击那个按钮弹出按钮上的数字\n\nes6 之前(利用闭包解决)：\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <meta http-equiv="X-UA-Compatible" content="ie=edge" />\n        <title>let 和 const 的应用</title>\n        <style>\n            body {\n                padding: 50px 0 0 150px;\n            }\n\n            .btn {\n                width: 100px;\n                height: 100px;\n                margin-right: 20px;\n                font-size: 80px;\n                cursor: pointer;\n            }\n        </style>\n    </head>\n    <body>\n        <button class="btn">0</button>\n        <button class="btn">1</button>\n        <button class="btn">2</button>\n\n        <script>\n            // var\n            // var btns = document.querySelectorAll(\'.btn\');\n\n            // for (var i = 0; i < btns.length; i++) {\n            //   btns[i].addEventListener(\n            //     \'click\',\n            //     function () {\n            //       console.log(i); // 永远都是3！\n            //     },\n            //     false\n            //   );\n            // }\n\n            // 利用闭包解决\n            var btns = document.querySelectorAll(\'.btn\')\n\n            for (var i = 0; i < btns.length; i++) {\n                ;(function(index) {\n                    btns[index].addEventListener(\n                        \'click\',\n                        function() {\n                            console.log(index)\n                        },\n                        false\n                    )\n                })(i)\n            }\n        <\/script>\n    </body>\n</html>\n\n\nes6 写法：\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <meta http-equiv="X-UA-Compatible" content="ie=edge" />\n        <title>let 和 const 的应用</title>\n        <style>\n            body {\n                padding: 50px 0 0 150px;\n            }\n\n            .btn {\n                width: 100px;\n                height: 100px;\n                margin-right: 20px;\n                font-size: 80px;\n                cursor: pointer;\n            }\n        </style>\n    </head>\n    <body>\n        <button class="btn">0</button>\n        <button class="btn">1</button>\n        <button class="btn">2</button>\n\n        <script>\n            let btns = document.querySelectorAll(\'.btn\')\n\n            for (let i = 0; i < btns.length; i++) {\n                btns[i].addEventListener(\n                    \'click\',\n                    function() {\n                        console.log(i)\n                    },\n                    false\n                )\n            }\n        <\/script>\n    </body>\n</html>\n',normalizedContent:'es6 圣经\n\necmascipt 6 入门\n\n\n# let 和 const\n\nlet 声明变量,const 声明常量。\n\n{\n    var username = \'frank\'\n    let age = 18\n    const sex = \'male\'\n}\nconsole.log(username) //  frank\nconsole.log(age) // 报错\nconsole.log(sex) // 报错\n\n\n * var,let 声明的是变量，变量一旦初始化以后，还可以重新赋值。\n * const声明的是常量，常量一旦初始化，就不能重新赋值了，否则会报错。\n * let,const所声明的变量/常量，只在自身所在的代码块内有效。\n\nfor 循环的计数器，就很适合使用 let 命令\n\nvar a = []\nfor (let i = 0; i < 10; i++) {\n    a[i] = function() {\n        console.log(i)\n    }\n}\na[6]() // 6\n\n\n上面代码中，变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是 6。你可能会问，如果每一轮循环的变量 i 都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 javascript 引擎内部会记住上一轮循环的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行计算。\n\n如果是 var 声明的 i 呢？所有的输出都是 10，变量 i 是 var 命令声明的，在全局范围内都有效，所以全局只有一个变量 i。每一次循环，变量 i 的值都会发生改变，而循环内被赋给数组 a 的函数内部的 console.log(i)，里面的 i 指向的就是全局的 i。也就是说，所有数组 a 的成员里面的 i，指向的都是同一个 i，导致运行时输出的是最后一轮的 i 的值，也就是 10。\n\n需要注意的是， for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\n\nfor (let i = 0; i < 3; i++) {\n    let i = \'abc\'\n    console.log(i)\n}\n// abc\n// abc\n// abc\n\n\n上面代码正确运行，输出了 3 次 abc。这表明函数内部的变量 i 与循环变量 i 不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 let 重复声明同一个变量）。\n\n\n# const\n\n使用 const 声明一个只读的常量，一旦声明，就必须立即初始化，不能留到最后赋值。\n\nconst 声明的常量，允许在不重新赋值的情况下修改它的值：\n\n 1. 基本类型数据类型是做不到的\n 2. 引用数据类型可以\n\nconst person = { username: \'bob\' }\nperson.username = \'zhang\'\n\n\n原因\n\nconst 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了,所以可以在不重新赋值的情况下修改 const 声明的引用数据类型。\n\n如果真的想将对象冻结，应该使用 object.freeze 方法,那如果对象的属性也是对象呢？\n\nconst constantize = obj => {\n    object.freeze(obj)\n    object.keys(obj).foreach(key => {\n        if (typeof obj[key] === \'object\') {\n            object.freeze(obj[key])\n            console.log(i)\n        }\n    })\n}\n\n\n\n# 声明最佳实践\n\n 1. 简单一看能用 let 的场景就用 let,比如 for 循环中的循环变量\n 2. 判断不了就用 const,报错好修改\n\n\n# let,const 与 var 的区别\n\n\n# 重复声明\n\nvar 允许重复声明，let,const 不允许不允许在相同作用域内，重复声明同一个变量。\n\nvar a = 1\nvar a = 2\nconsole.log(a) //2\nlet b = 2\nlet b = 3\nconsole.log(b) //syntaxerror: identifier \'b\' has already been declared\n\n\n\n# 变量提升\n\nvar 会提升变量的声明到当前作用域的顶部，let，const 不存在变量提升,所声明的变量/常量一定要在声明后使用，否则报错。\n\nconsole.log(a) // undefined\nvar a = 2\nconsole.log(b) // referenceerror: cannot access \'b\' before initialization\nlet b = 2\n\n\n\n# 修改声明的变量\n\nvar 和 let 可以修改\n\nconst 声明一个只读的常量。一旦声明，常量的值就不能改变。并且 const 声明时，必须立即初始化\n\n\n# 暂时性锁区\n\n只要块级作用域内存在 let,const 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。\n\nconst a = 100\n\nfunction fun() {\n    console.log(a) // 报错cannot access \'a\' before initialization（在初始化之前无法访问“a”）\n    const a = 1\n}\nfun()\n\n\n上面代码中，在 const 命令声明变量 a 之前，属于变量 a 的“死区”\n\n在代码块内，使用 let、const 命令声明变量或常量之前，该变量或常量都是不可用的。这在语法上，称为暂时性死区(temporal dead zone，简称 tdz)\n\n\n# window 对象的属性和方法\n\n全局作用域中，var 声明的变量和通过 function 声明的函数，会自动变成 window 对象的属性或方法，let、 const 不会。\n\n\n# 块级作用域\n\nlet，const会形成块级作用域，var 没有块级作用域。\n\n没有块级作用域会导致两个问题：\n\n内层变量可能会覆盖外层变量:\n\nvar tmp = new date()\n\nfunction f() {\n    console.log(tmp)\n    if (false) {\n        var tmp = \'hello world\'\n    }\n}\n\nf() // undefined\n\n\n用来计数的循环变量泄露为全局变量:\n\nfor (var i = 0; i < 3; i++) {\n    console.log(i) // 0,1,2\n}\nconsole.log(i) // 3\n\n\nes6 允许块级作用域的任意嵌套，内层作用域可以定义外层作用域的同名变量，块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 iife）不再必要了。\n\n有哪些块级作用域?\n\n{}\nfor(){}\nwhile(){}\ndo{}while()\nif(){}\nswitch(){}\n\n\n\n# let,const 的应用\n\n场景：点击那个按钮弹出按钮上的数字\n\nes6 之前(利用闭包解决)：\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <meta http-equiv="x-ua-compatible" content="ie=edge" />\n        <title>let 和 const 的应用</title>\n        <style>\n            body {\n                padding: 50px 0 0 150px;\n            }\n\n            .btn {\n                width: 100px;\n                height: 100px;\n                margin-right: 20px;\n                font-size: 80px;\n                cursor: pointer;\n            }\n        </style>\n    </head>\n    <body>\n        <button class="btn">0</button>\n        <button class="btn">1</button>\n        <button class="btn">2</button>\n\n        <script>\n            // var\n            // var btns = document.queryselectorall(\'.btn\');\n\n            // for (var i = 0; i < btns.length; i++) {\n            //   btns[i].addeventlistener(\n            //     \'click\',\n            //     function () {\n            //       console.log(i); // 永远都是3！\n            //     },\n            //     false\n            //   );\n            // }\n\n            // 利用闭包解决\n            var btns = document.queryselectorall(\'.btn\')\n\n            for (var i = 0; i < btns.length; i++) {\n                ;(function(index) {\n                    btns[index].addeventlistener(\n                        \'click\',\n                        function() {\n                            console.log(index)\n                        },\n                        false\n                    )\n                })(i)\n            }\n        <\/script>\n    </body>\n</html>\n\n\nes6 写法：\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <meta http-equiv="x-ua-compatible" content="ie=edge" />\n        <title>let 和 const 的应用</title>\n        <style>\n            body {\n                padding: 50px 0 0 150px;\n            }\n\n            .btn {\n                width: 100px;\n                height: 100px;\n                margin-right: 20px;\n                font-size: 80px;\n                cursor: pointer;\n            }\n        </style>\n    </head>\n    <body>\n        <button class="btn">0</button>\n        <button class="btn">1</button>\n        <button class="btn">2</button>\n\n        <script>\n            let btns = document.queryselectorall(\'.btn\')\n\n            for (let i = 0; i < btns.length; i++) {\n                btns[i].addeventlistener(\n                    \'click\',\n                    function() {\n                        console.log(i)\n                    },\n                    false\n                )\n            }\n        <\/script>\n    </body>\n</html>\n',charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"剩余参数与展开运算符",frontmatter:{title:"剩余参数与展开运算符",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E4%B8%8E%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6.html",relativePath:"前端开发/JavaScript/ES6/剩余参数与展开运算符.md",key:"v-3a0007c8",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E4%B8%8E%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6.html",headers:[{level:2,title:"剩余参数",slug:"剩余参数",normalizedTitle:"剩余参数",charIndex:2},{level:3,title:"剩余参数是什么",slug:"剩余参数是什么",normalizedTitle:"剩余参数是什么",charIndex:11},{level:3,title:"剩余参数的注意事项",slug:"剩余参数的注意事项",normalizedTitle:"剩余参数的注意事项",charIndex:152},{level:3,title:"与解构赋值结合使用",slug:"与解构赋值结合使用",normalizedTitle:"与解构赋值结合使用",charIndex:354},{level:2,title:"数组的展开运算符",slug:"数组的展开运算符",normalizedTitle:"数组的展开运算符",charIndex:647},{level:3,title:"数组的展开运算符的基本用法",slug:"数组的展开运算符的基本用法",normalizedTitle:"数组的展开运算符的基本用法",charIndex:660},{level:3,title:"区分剩余参数和展开运算符",slug:"区分剩余参数和展开运算符",normalizedTitle:"区分剩余参数和展开运算符",charIndex:781},{level:3,title:"数组展开运算符的应用",slug:"数组展开运算符的应用",normalizedTitle:"数组展开运算符的应用",charIndex:1026},{level:2,title:"对象的展开运算符",slug:"对象的展开运算符",normalizedTitle:"对象的展开运算符",charIndex:1401},{level:3,title:"对象展开运算符的基本用法",slug:"对象展开运算符的基本用法",normalizedTitle:"对象展开运算符的基本用法",charIndex:1414},{level:3,title:"对象的展开运算符的注意事项",slug:"对象的展开运算符的注意事项",normalizedTitle:"对象的展开运算符的注意事项",charIndex:1815},{level:3,title:"对象展开运算符的应用",slug:"对象展开运算符的应用",normalizedTitle:"对象展开运算符的应用",charIndex:2351}],headersStr:"剩余参数 剩余参数是什么 剩余参数的注意事项 与解构赋值结合使用 数组的展开运算符 数组的展开运算符的基本用法 区分剩余参数和展开运算符 数组展开运算符的应用 对象的展开运算符 对象展开运算符的基本用法 对象的展开运算符的注意事项 对象展开运算符的应用",content:"# 剩余参数\n\n\n# 剩余参数是什么\n\n剩余参数永远是个数组，即使没有值，也是空数组\n\nconst add = (x, y, z, ...args) => {\n    console.log(x, y, z, args) // 1 2 3 [4,5]\n}\nadd(1, 2, 3, 4, 5)\n\n\n\n# 剩余参数的注意事项\n\n 1. 箭头函数的剩余参数\n\n箭头函数的参数部分即使只有剩余参数，也不能省略圆括号\n\nconst add = (...args) => {\n    console.log(args)\n}\nadd(1, 2)\n\n\n 2. 箭头函数可以使用剩余参数替代 arguments 获取实际参数\n\n 3. 剩余参数的位置：剩余参数只能是最后一个参数，之后不能再有其他参数，否则会报错。\n\n\n# 与解构赋值结合使用\n\n剩余参数不一定非要作为函数参数使用：\n\n * 与数组的解构赋值\n\n// 必须是最后一个\n// 这里称作 剩余元素 合适一些\nconst [num, ...args] = [1, 2, 3, 4]\n\n\n * 与对象的解构赋值\n\n// 必须是最后一个\n// 这里称作 剩余元素 合适一些\n// 对象作为函数参数时的解构赋值\nconst func = ({ x, y, ...z }) => {\n    console.log(x, y, z) // 1 2 { a: 3, b: 4 }\n}\nfunc({ a: 3, x: 1, y: 2, b: 4 })\n\n\n\n# 数组的展开运算符\n\n\n# 数组的展开运算符的基本用法\n\neg:求数组中的最小值\n\n// Math.min()要求参数必须是“罗列出来”，而不能是数组，所以要展开\nconsole.log(Math.min(...[1, 2, 3, 44445, 0.1]))\n\n\n\n# 区分剩余参数和展开运算符\n\n// 剩余参数\nconst add = (a, ...args) => {\n    console.log(args)\n    // 展开运算符\n    console.log(1, ...args)\n}\nadd(1, 23, 4, 5)\n\n\n根本区别：\n\n// 展开运算符\n[3,1,2]->3,1,2\n// 剩余参数\n3,1,2->[3,1,2]\n\n\ntest:下图中标注的三处代码，分别表示什么？\n\n\n\n1 剩余元素、2 剩余参数、3 展开运算符\n\n\n# 数组展开运算符的应用\n\n 1. 复制数组\n\n// 浅拷贝\nconst a = [1, 2]\nconst c = [...a]\n\n\n 2. 合并数组\n\nconst a = [1, 2]\nconst b = [3]\nconst c = [12, 321]\nconsole.log([1, ...a, ...b, ...c])\n\n\n 3. 字符串转为数组\n\n字符串可以按照数组的形式展开\n\nconsole.log([...'alex'])\n\n\n 4. 常见的类数组转化为数组\n\n * arguments\n\nfunction func() {\n    console.log([...arguments])\n}\n\n\n * NodeList\n\nconsole.log([...document.querySelectAll('p')], push)\n\n\n\n# 对象的展开运算符\n\n\n# 对象展开运算符的基本用法\n\n 1. 展开对象\n    对象不能直接展开，必须在{}中展开\n    对象的展开：把属性罗列出来，用顿号分隔，放到一个{}中，构成新对象\n\nconst apple = {\n    color: 'black',\n    shape: '圆柱形',\n    taste: '甜',\n}\nconsole.log({ ...apple })\n\n\n 2. 合并对象\n    新对象拥有全部属性，相同属性，后者覆盖前者。\n\nconst apple = {\n    color: 'black',\n    shape: '圆柱形',\n    taste: '甜',\n}\nconst pen = {\n    color: 'red',\n    shape: '球形',\n    use: 'write',\n}\nconsole.log({ ...apple, ...pen })\n\n\n\n# 对象的展开运算符的注意事项\n\n 1. 空对象的展开\n    如果展开一个空对象，则没有任何效果\n\nconsole.log({ ...{}, ...{ a: 1 } }) //{ a: 1 }\n\n\n 2. 非对象的展开\n\n * 如果展开的不是对象，则会自动将其转为对象，再将属性罗列出来\n\n// 自身转换为对象中没有属性 所有返回空对象\nconsole.log({ ...1 }) //{}\n\n\n * 如果展开运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象\n\nconsole.log({ ...'alex' }) // { '0': 'a', '1': 'l', '2': 'e', '3': 'x' }\n//  数组在对象中展开\nconsole.log({ ...[1, 2, 3] }) // { '0': 1, '1': 2, '2': 3 }\n\n\n 3. 不会展开对象中的对象属性\n\nconst obj = {\n    a: {\n        b: 2,\n    },\n    c: 2,\n}\nconst obj2 = { ...obj }\nconsole.log(obj2) // { a: { b: 2 }, c: 2 }\n\n\n\n# 对象展开运算符的应用\n\n 1. 复制对象\n\n// 浅拷贝\nconst a = { x: 1, y: 2 }\nconst c = { ...a }\n\n\n 2. 用户参数和默认参数\n\nconst logUser = userParam => {\n    const defaultParam = {\n        username: 'zhangsan',\n        age: 0,\n        sex: 'male',\n    }\n    const { username, age, sex } = { ...defaultParam, ...userParam }\n    console.log(username, age, sex)\n}\nlogUser({\n    username: 'zhangsan',\n    age: 0,\n})\n",normalizedContent:"# 剩余参数\n\n\n# 剩余参数是什么\n\n剩余参数永远是个数组，即使没有值，也是空数组\n\nconst add = (x, y, z, ...args) => {\n    console.log(x, y, z, args) // 1 2 3 [4,5]\n}\nadd(1, 2, 3, 4, 5)\n\n\n\n# 剩余参数的注意事项\n\n 1. 箭头函数的剩余参数\n\n箭头函数的参数部分即使只有剩余参数，也不能省略圆括号\n\nconst add = (...args) => {\n    console.log(args)\n}\nadd(1, 2)\n\n\n 2. 箭头函数可以使用剩余参数替代 arguments 获取实际参数\n\n 3. 剩余参数的位置：剩余参数只能是最后一个参数，之后不能再有其他参数，否则会报错。\n\n\n# 与解构赋值结合使用\n\n剩余参数不一定非要作为函数参数使用：\n\n * 与数组的解构赋值\n\n// 必须是最后一个\n// 这里称作 剩余元素 合适一些\nconst [num, ...args] = [1, 2, 3, 4]\n\n\n * 与对象的解构赋值\n\n// 必须是最后一个\n// 这里称作 剩余元素 合适一些\n// 对象作为函数参数时的解构赋值\nconst func = ({ x, y, ...z }) => {\n    console.log(x, y, z) // 1 2 { a: 3, b: 4 }\n}\nfunc({ a: 3, x: 1, y: 2, b: 4 })\n\n\n\n# 数组的展开运算符\n\n\n# 数组的展开运算符的基本用法\n\neg:求数组中的最小值\n\n// math.min()要求参数必须是“罗列出来”，而不能是数组，所以要展开\nconsole.log(math.min(...[1, 2, 3, 44445, 0.1]))\n\n\n\n# 区分剩余参数和展开运算符\n\n// 剩余参数\nconst add = (a, ...args) => {\n    console.log(args)\n    // 展开运算符\n    console.log(1, ...args)\n}\nadd(1, 23, 4, 5)\n\n\n根本区别：\n\n// 展开运算符\n[3,1,2]->3,1,2\n// 剩余参数\n3,1,2->[3,1,2]\n\n\ntest:下图中标注的三处代码，分别表示什么？\n\n\n\n1 剩余元素、2 剩余参数、3 展开运算符\n\n\n# 数组展开运算符的应用\n\n 1. 复制数组\n\n// 浅拷贝\nconst a = [1, 2]\nconst c = [...a]\n\n\n 2. 合并数组\n\nconst a = [1, 2]\nconst b = [3]\nconst c = [12, 321]\nconsole.log([1, ...a, ...b, ...c])\n\n\n 3. 字符串转为数组\n\n字符串可以按照数组的形式展开\n\nconsole.log([...'alex'])\n\n\n 4. 常见的类数组转化为数组\n\n * arguments\n\nfunction func() {\n    console.log([...arguments])\n}\n\n\n * nodelist\n\nconsole.log([...document.queryselectall('p')], push)\n\n\n\n# 对象的展开运算符\n\n\n# 对象展开运算符的基本用法\n\n 1. 展开对象\n    对象不能直接展开，必须在{}中展开\n    对象的展开：把属性罗列出来，用顿号分隔，放到一个{}中，构成新对象\n\nconst apple = {\n    color: 'black',\n    shape: '圆柱形',\n    taste: '甜',\n}\nconsole.log({ ...apple })\n\n\n 2. 合并对象\n    新对象拥有全部属性，相同属性，后者覆盖前者。\n\nconst apple = {\n    color: 'black',\n    shape: '圆柱形',\n    taste: '甜',\n}\nconst pen = {\n    color: 'red',\n    shape: '球形',\n    use: 'write',\n}\nconsole.log({ ...apple, ...pen })\n\n\n\n# 对象的展开运算符的注意事项\n\n 1. 空对象的展开\n    如果展开一个空对象，则没有任何效果\n\nconsole.log({ ...{}, ...{ a: 1 } }) //{ a: 1 }\n\n\n 2. 非对象的展开\n\n * 如果展开的不是对象，则会自动将其转为对象，再将属性罗列出来\n\n// 自身转换为对象中没有属性 所有返回空对象\nconsole.log({ ...1 }) //{}\n\n\n * 如果展开运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象\n\nconsole.log({ ...'alex' }) // { '0': 'a', '1': 'l', '2': 'e', '3': 'x' }\n//  数组在对象中展开\nconsole.log({ ...[1, 2, 3] }) // { '0': 1, '1': 2, '2': 3 }\n\n\n 3. 不会展开对象中的对象属性\n\nconst obj = {\n    a: {\n        b: 2,\n    },\n    c: 2,\n}\nconst obj2 = { ...obj }\nconsole.log(obj2) // { a: { b: 2 }, c: 2 }\n\n\n\n# 对象展开运算符的应用\n\n 1. 复制对象\n\n// 浅拷贝\nconst a = { x: 1, y: 2 }\nconst c = { ...a }\n\n\n 2. 用户参数和默认参数\n\nconst loguser = userparam => {\n    const defaultparam = {\n        username: 'zhangsan',\n        age: 0,\n        sex: 'male',\n    }\n    const { username, age, sex } = { ...defaultparam, ...userparam }\n    console.log(username, age, sex)\n}\nloguser({\n    username: 'zhangsan',\n    age: 0,\n})\n",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"模板字符串与箭头函数",frontmatter:{title:"模板字符串与箭头函数",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0.html",relativePath:"前端开发/JavaScript/ES6/模板字符串与箭头函数.md",key:"v-1a83c4d8",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0.html",headers:[{level:2,title:"模板字符串",slug:"模板字符串",normalizedTitle:"模板字符串",charIndex:2},{level:3,title:"什么是模板字符串？",slug:"什么是模板字符串",normalizedTitle:"什么是模板字符串？",charIndex:12},{level:3,title:"模板字符串和一般字符串的区别",slug:"模板字符串和一般字符串的区别",normalizedTitle:"模板字符串和一般字符串的区别",charIndex:36},{level:3,title:"模板字符串的注意事项",slug:"模板字符串的注意事项",normalizedTitle:"模板字符串的注意事项",charIndex:348},{level:3,title:"模板字符串的应用",slug:"模板字符串的应用",normalizedTitle:"模板字符串的应用",charIndex:896},{level:2,title:"箭头函数",slug:"箭头函数",normalizedTitle:"箭头函数",charIndex:2215},{level:3,title:"箭头函数是什么？",slug:"箭头函数是什么",normalizedTitle:"箭头函数是什么？",charIndex:2224},{level:3,title:"箭头函数的注意事项",slug:"箭头函数的注意事项",normalizedTitle:"箭头函数的注意事项",charIndex:2332},{level:3,title:"箭头函数中的 this 指向",slug:"箭头函数中的-this-指向",normalizedTitle:"箭头函数中的 this 指向",charIndex:2750},{level:3,title:"不适用箭头函数的场景",slug:"不适用箭头函数的场景",normalizedTitle:"不适用箭头函数的场景",charIndex:3126},{level:3,title:"箭头函数的应用",slug:"箭头函数的应用",normalizedTitle:"箭头函数的应用",charIndex:3219}],headersStr:"模板字符串 什么是模板字符串？ 模板字符串和一般字符串的区别 模板字符串的注意事项 模板字符串的应用 箭头函数 箭头函数是什么？ 箭头函数的注意事项 箭头函数中的 this 指向 不适用箭头函数的场景 箭头函数的应用",content:"# 模板字符串\n\n\n# 什么是模板字符串？\n\n;`alex`\n\n\n\n# 模板字符串和一般字符串的区别\n\nconst person = {\n    username: 'alex',\n    sex: 'male',\n    age: 18,\n}\n//  一般字符串\n//  const info='我的名字是：'+person.username+',性别：'+person.sex+',今年'+person.age+'岁了'\n// 模板字符串\nconst info = `我的名字是：${person.username},性别：${person.sex},今年${person.age}岁了`\nconsole.log(info)\n\n\n和其他东西一起使用的时候，使用模板字符串，方便注入。\n\n\n# 模板字符串的注意事项\n\n 1. 输出多行字符串\n\n// 一般字符串\nconst info = '第一行\\n第二行'\nconsole.log(info)\n\n\n// 模板字符串\nconst info = `第一行\n           第二行`\nconsole.log(info)\n\n\n模板字符串中，所有的空格，换行或缩进都会被保留正在输出之中。（怎么写就怎么输出）\n\n 2. 输出`和\\等特殊字符\n\n使用转义字符\n\nconst info = `\\\\`\nconsole.log(info)\nconst info = `\\``\nconsole.log(info)\n\n\n 3. 模板字符串的注入\n\n${} 只要最终能得到一个值的就能放在花括号里面！\n\nconst username = 'alex'\nconst person = { age: 17, sex: 'male' }\nconst getSex = function (sex) {\n    return sex === 'male' ? '男' : '女'\n}\nconst info = `${username},${person.age + 2},${getSex(person.sex)}`\nconsole.log(info)\n\n\n\n# 模板字符串的应用\n\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>学生信息表</title>\n    </head>\n    <body>\n        <p>学生信息表</p>\n        <ul id=\"list\">\n            <li style=\"list-style-type:none;\">信息加载中……</li>\n        </ul>\n\n        <script>\n            // 数据\n            const students = [\n                {\n                    username: 'Alex',\n                    age: 18,\n                    sex: 'male',\n                },\n                {\n                    username: 'ZhangSan',\n                    age: 28,\n                    sex: 'male',\n                },\n                {\n                    username: 'LiSi',\n                    age: 20,\n                    sex: 'female',\n                },\n            ]\n            const list = document.getElementById('list')\n            let html = ''\n            for (let i = 0; i < students.length; i++) {\n                html += `<li>我的名字是：${students[i].username},${students[i].sex},${students[i].age}</li>`\n            }\n            //  延迟两秒加载数据\n            setTimeout(function () {\n                list.innerHTML = html\n            }, 2000)\n        <\/script>\n    </body>\n</html>\n\n\n\n# 箭头函数\n\n\n# 箭头函数是什么？\n\n * 认识箭头函数\n\nconst add = (x, y) => {\n    return x + y\n}\n\n\n * 箭头函数的结构\n\nconst/let 函数名 = 参数 => 函数体\n\n\n# 箭头函数的注意事项\n\n * 单个参数可以省略圆括号\n\nconst add = x => {\n    return x + 1\n}\n\n\n * 无参数或多个参数不能省略圆括号\n\nconst add()=>{\n    return 1+1\n}\n\n\n * 单行函数体可以同时省略{}和 return ，多行函数体不能再化简了\n\nconst add = (x, y) => x + y\n\n\n * 如果箭头函数返回单行对象，可以在{}外面加上()，让浏览器不再认为那是函数体的花括号。\n\n// 完整写法\n// const add=(x,y)=>{\n//   return {\n//     value:x+y\n//   }\n// }\n// const add=(x,y)=>{value:x+y} js会把{}认为是函数的花括号而不是对象的，所以会报错！\nconst add = (x, y) => ({ value: x + y })\n\n\n\n# 箭头函数中的 this 指向\n\n箭头函数没有自己的 this,而是根据外层作用域来决定 this\n\neg1:\n\nconst calc = {\n    add: () => {\n        console.log(this) //作用链查找，对象没有作用域,找到全局作用域中的this,指向window\n    },\n}\ncalc.add()\n\n\neg2:\n\nconst calc ={\n    add:function (){\n        const adder=()=>{\n            console.log(this) // calc\n        }\n    }\n    adder()\n}\ncalc.add()\nconst addFn=calc.add\naddFn() // undefined->window\n\n\n\n# 不适用箭头函数的场景\n\n * 作为构造函数：因为箭头函数没有 this\n\n * 需要 this 指向调用对象的时候：如事件处理函数\n\n * 需要使用 arguments 的时候\n\n\n# 箭头函数的应用\n\n我们需要 setInterval 中的 this 指向 timer。es6 之前使用普通函数，setInterval 中的 this 指向 window，可以采用备份上下文的方法：\n\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>箭头函数的应用</title>\n    </head>\n    <body>\n        <button id=\"btn\">开始</button>\n        <span id=\"result\">0</span>\n\n        <script>\n            var btn = document.getElementById('btn')\n            var result = document.getElementById('result')\n            var timer = {\n                time: 0,\n                start: function () {\n                    var that = this\n                    btn.addEventListener(\n                        'click',\n                        function () {\n                            setInterval(function () {\n                                that.time++\n                                result.innerHTML = that.time\n                            }, 1000)\n                        },\n                        false\n                    )\n                },\n            }\n\n            timer.start()\n        <\/script>\n    </body>\n</html>\n\n\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>箭头函数的应用</title>\n    </head>\n    <body>\n        <button id=\"btn\">开始</button>\n        <span id=\"result\">0</span>\n\n        <script>\n            const btn = document.getElementById('btn')\n            const result = document.getElementById('result')\n            const timer = {\n                time: 0,\n                start: function () {\n                    //this\n                    btn.addEventListener(\n                        'click',\n                        () => {\n                            setInterval(() => {\n                                this.time++\n                                result.innerHTML = this.time\n                            }, 1000)\n                        },\n                        false\n                    )\n                },\n            }\n\n            timer.start()\n        <\/script>\n    </body>\n</html>\n",normalizedContent:"# 模板字符串\n\n\n# 什么是模板字符串？\n\n;`alex`\n\n\n\n# 模板字符串和一般字符串的区别\n\nconst person = {\n    username: 'alex',\n    sex: 'male',\n    age: 18,\n}\n//  一般字符串\n//  const info='我的名字是：'+person.username+',性别：'+person.sex+',今年'+person.age+'岁了'\n// 模板字符串\nconst info = `我的名字是：${person.username},性别：${person.sex},今年${person.age}岁了`\nconsole.log(info)\n\n\n和其他东西一起使用的时候，使用模板字符串，方便注入。\n\n\n# 模板字符串的注意事项\n\n 1. 输出多行字符串\n\n// 一般字符串\nconst info = '第一行\\n第二行'\nconsole.log(info)\n\n\n// 模板字符串\nconst info = `第一行\n           第二行`\nconsole.log(info)\n\n\n模板字符串中，所有的空格，换行或缩进都会被保留正在输出之中。（怎么写就怎么输出）\n\n 2. 输出`和\\等特殊字符\n\n使用转义字符\n\nconst info = `\\\\`\nconsole.log(info)\nconst info = `\\``\nconsole.log(info)\n\n\n 3. 模板字符串的注入\n\n${} 只要最终能得到一个值的就能放在花括号里面！\n\nconst username = 'alex'\nconst person = { age: 17, sex: 'male' }\nconst getsex = function (sex) {\n    return sex === 'male' ? '男' : '女'\n}\nconst info = `${username},${person.age + 2},${getsex(person.sex)}`\nconsole.log(info)\n\n\n\n# 模板字符串的应用\n\n<!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>学生信息表</title>\n    </head>\n    <body>\n        <p>学生信息表</p>\n        <ul id=\"list\">\n            <li style=\"list-style-type:none;\">信息加载中……</li>\n        </ul>\n\n        <script>\n            // 数据\n            const students = [\n                {\n                    username: 'alex',\n                    age: 18,\n                    sex: 'male',\n                },\n                {\n                    username: 'zhangsan',\n                    age: 28,\n                    sex: 'male',\n                },\n                {\n                    username: 'lisi',\n                    age: 20,\n                    sex: 'female',\n                },\n            ]\n            const list = document.getelementbyid('list')\n            let html = ''\n            for (let i = 0; i < students.length; i++) {\n                html += `<li>我的名字是：${students[i].username},${students[i].sex},${students[i].age}</li>`\n            }\n            //  延迟两秒加载数据\n            settimeout(function () {\n                list.innerhtml = html\n            }, 2000)\n        <\/script>\n    </body>\n</html>\n\n\n\n# 箭头函数\n\n\n# 箭头函数是什么？\n\n * 认识箭头函数\n\nconst add = (x, y) => {\n    return x + y\n}\n\n\n * 箭头函数的结构\n\nconst/let 函数名 = 参数 => 函数体\n\n\n# 箭头函数的注意事项\n\n * 单个参数可以省略圆括号\n\nconst add = x => {\n    return x + 1\n}\n\n\n * 无参数或多个参数不能省略圆括号\n\nconst add()=>{\n    return 1+1\n}\n\n\n * 单行函数体可以同时省略{}和 return ，多行函数体不能再化简了\n\nconst add = (x, y) => x + y\n\n\n * 如果箭头函数返回单行对象，可以在{}外面加上()，让浏览器不再认为那是函数体的花括号。\n\n// 完整写法\n// const add=(x,y)=>{\n//   return {\n//     value:x+y\n//   }\n// }\n// const add=(x,y)=>{value:x+y} js会把{}认为是函数的花括号而不是对象的，所以会报错！\nconst add = (x, y) => ({ value: x + y })\n\n\n\n# 箭头函数中的 this 指向\n\n箭头函数没有自己的 this,而是根据外层作用域来决定 this\n\neg1:\n\nconst calc = {\n    add: () => {\n        console.log(this) //作用链查找，对象没有作用域,找到全局作用域中的this,指向window\n    },\n}\ncalc.add()\n\n\neg2:\n\nconst calc ={\n    add:function (){\n        const adder=()=>{\n            console.log(this) // calc\n        }\n    }\n    adder()\n}\ncalc.add()\nconst addfn=calc.add\naddfn() // undefined->window\n\n\n\n# 不适用箭头函数的场景\n\n * 作为构造函数：因为箭头函数没有 this\n\n * 需要 this 指向调用对象的时候：如事件处理函数\n\n * 需要使用 arguments 的时候\n\n\n# 箭头函数的应用\n\n我们需要 setinterval 中的 this 指向 timer。es6 之前使用普通函数，setinterval 中的 this 指向 window，可以采用备份上下文的方法：\n\n<!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>箭头函数的应用</title>\n    </head>\n    <body>\n        <button id=\"btn\">开始</button>\n        <span id=\"result\">0</span>\n\n        <script>\n            var btn = document.getelementbyid('btn')\n            var result = document.getelementbyid('result')\n            var timer = {\n                time: 0,\n                start: function () {\n                    var that = this\n                    btn.addeventlistener(\n                        'click',\n                        function () {\n                            setinterval(function () {\n                                that.time++\n                                result.innerhtml = that.time\n                            }, 1000)\n                        },\n                        false\n                    )\n                },\n            }\n\n            timer.start()\n        <\/script>\n    </body>\n</html>\n\n\n<!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>箭头函数的应用</title>\n    </head>\n    <body>\n        <button id=\"btn\">开始</button>\n        <span id=\"result\">0</span>\n\n        <script>\n            const btn = document.getelementbyid('btn')\n            const result = document.getelementbyid('result')\n            const timer = {\n                time: 0,\n                start: function () {\n                    //this\n                    btn.addeventlistener(\n                        'click',\n                        () => {\n                            setinterval(() => {\n                                this.time++\n                                result.innerhtml = this.time\n                            }, 1000)\n                        },\n                        false\n                    )\n                },\n            }\n\n            timer.start()\n        <\/script>\n    </body>\n</html>\n",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"对象字面量的增强与函数参数的默认值",frontmatter:{title:"对象字面量的增强与函数参数的默认值",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E5%A2%9E%E5%BC%BA%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC.html",relativePath:"前端开发/JavaScript/ES6/对象字面量的增强与函数参数的默认值.md",key:"v-01a65d50",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E5%A2%9E%E5%BC%BA%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC.html",headers:[{level:2,title:"对象字面量的增强",slug:"对象字面量的增强",normalizedTitle:"对象字面量的增强",charIndex:2},{level:3,title:"属性和方法的简介表示法",slug:"属性和方法的简介表示法",normalizedTitle:"属性和方法的简介表示法",charIndex:15},{level:3,title:"方括号语法",slug:"方括号语法",normalizedTitle:"方括号语法",charIndex:423},{level:2,title:"函数参数的默认值",slug:"函数参数的默认值",normalizedTitle:"函数参数的默认值",charIndex:1015},{level:3,title:"函数参数的默认值是什么？",slug:"函数参数的默认值是什么",normalizedTitle:"函数参数的默认值是什么？",charIndex:1028},{level:3,title:"函数参数默认值的注意事项",slug:"函数参数默认值的注意事项",normalizedTitle:"函数参数默认值的注意事项",charIndex:1143},{level:3,title:"函数参数默认值的应用",slug:"函数参数默认值的应用",normalizedTitle:"函数参数默认值的应用",charIndex:1406}],headersStr:"对象字面量的增强 属性和方法的简介表示法 方括号语法 函数参数的默认值 函数参数的默认值是什么？ 函数参数默认值的注意事项 函数参数默认值的应用",content:"# 对象字面量的增强\n\n\n# 属性和方法的简介表示法\n\n 1. 对象字面量是什么？\n\n// 对象字面量\nconst person = {\n    age: 18,\n    speak: function() {},\n}\n\n\n还可以通过实例化构造函数生成对象：\n\n// 实例化构造函数生成对象\nconst person= new Object()\nperson.age=18\nperson.speak=function()\n\n\n 2. 属性的简洁表示法\n    键名和变量或常量一样的时候，可以只写一个\n\nconst age = 18\nconst person = {\n    // age:age\n    age,\n}\n\n\n3.方法的简介表示法\n方法可以省略冒号和 function 关键字,但不能使用箭头函数\n\nconst person = {\n    // speak:function(){}\n    speak() {},\n}\n\n\n\n# 方括号语法\n\n 1. 方括号语法的用法\n\n增强：方括号语法可以写在对象字面量中\n\nconst prop = 'age'\nconst person = {}\n// person.prop=18 x\n// person[prop]=18\n// 增强\nconst person = {\n    [prop]: 18,\n}\n\n\n 2. 方括号中可以放什么\n    值或通过计算可以得到值的（表达式）\n\nconst prop='age'\nconst func=()=>\"age\"\nconst person={\n    [prop]:18,\n    [func()]:18\n    ['sex']:'male'\n}\n\n\n 3. 方括号语法和点语法的区别\n\nconst person = {}\nperson.age等价于person['age']\n\n\n * 属性名是合法标识符时，使用点语法和方括号语法都是可以的，属性名不是合法标识符时，只能使用方括号语法\n * 使用变量或者常量保存属性名时，只能使用方括号语法，不能使用点语法。\n\n> 同一个属性不可以同时使用简洁表达式(键名和变量或常量一样的时候，可以只写一个)和方括号语法\n\nconst age='18'\nconst name='frank'\nconst person={\n    [age]  ❌\n    [\"name\"]❌\n}\n\n\n\n# 函数参数的默认值\n\n\n# 函数参数的默认值是什么？\n\n1.认识\n调用函数的时候传参了，就用传递的参数；如果没传参，就用默认值\n\n 2. 函数参数默认值的基本用法\n\nconst multiply = (x = 1, y = 1) => x * y\n\n\n\n# 函数参数默认值的注意事项\n\n 1. 默认值的生效条件\n    不传参数，或者明确的传递 undefined 作为参数，只有这两种情况下，默认值才会生效\n 2. 默认值表达式\n    如果默认是表达式，默认表达式是惰性求值的\n 3. 设置默认值的小技巧\n    函数参数的默认值，最好从参数列表的右边开始设置\n\nconst multiply = (x = 1, y) => x * y、\n// 不可以省略undefined(从右边设置可以省略)\nconsole.log(multiply(undefined, 1))\n\n\n\n# 函数参数默认值的应用\n\n接收很多参数的时候,可以接收一个对象作为参数\n\n// 无需记忆参数的顺序\n// 解构赋值，解构赋值的默认值，函数参数的默认值混用\nconst logUser = ({ username = 'wuming', age = '0', sex = '0' } = {}) => {\n    console.log(username, age, sex)\n}\n// logUser(\n//     {username:'a',\n//     age:16,\n//     sex:'male'}\n// )\n// logUser({})\nlogUser()\n",normalizedContent:"# 对象字面量的增强\n\n\n# 属性和方法的简介表示法\n\n 1. 对象字面量是什么？\n\n// 对象字面量\nconst person = {\n    age: 18,\n    speak: function() {},\n}\n\n\n还可以通过实例化构造函数生成对象：\n\n// 实例化构造函数生成对象\nconst person= new object()\nperson.age=18\nperson.speak=function()\n\n\n 2. 属性的简洁表示法\n    键名和变量或常量一样的时候，可以只写一个\n\nconst age = 18\nconst person = {\n    // age:age\n    age,\n}\n\n\n3.方法的简介表示法\n方法可以省略冒号和 function 关键字,但不能使用箭头函数\n\nconst person = {\n    // speak:function(){}\n    speak() {},\n}\n\n\n\n# 方括号语法\n\n 1. 方括号语法的用法\n\n增强：方括号语法可以写在对象字面量中\n\nconst prop = 'age'\nconst person = {}\n// person.prop=18 x\n// person[prop]=18\n// 增强\nconst person = {\n    [prop]: 18,\n}\n\n\n 2. 方括号中可以放什么\n    值或通过计算可以得到值的（表达式）\n\nconst prop='age'\nconst func=()=>\"age\"\nconst person={\n    [prop]:18,\n    [func()]:18\n    ['sex']:'male'\n}\n\n\n 3. 方括号语法和点语法的区别\n\nconst person = {}\nperson.age等价于person['age']\n\n\n * 属性名是合法标识符时，使用点语法和方括号语法都是可以的，属性名不是合法标识符时，只能使用方括号语法\n * 使用变量或者常量保存属性名时，只能使用方括号语法，不能使用点语法。\n\n> 同一个属性不可以同时使用简洁表达式(键名和变量或常量一样的时候，可以只写一个)和方括号语法\n\nconst age='18'\nconst name='frank'\nconst person={\n    [age]  ❌\n    [\"name\"]❌\n}\n\n\n\n# 函数参数的默认值\n\n\n# 函数参数的默认值是什么？\n\n1.认识\n调用函数的时候传参了，就用传递的参数；如果没传参，就用默认值\n\n 2. 函数参数默认值的基本用法\n\nconst multiply = (x = 1, y = 1) => x * y\n\n\n\n# 函数参数默认值的注意事项\n\n 1. 默认值的生效条件\n    不传参数，或者明确的传递 undefined 作为参数，只有这两种情况下，默认值才会生效\n 2. 默认值表达式\n    如果默认是表达式，默认表达式是惰性求值的\n 3. 设置默认值的小技巧\n    函数参数的默认值，最好从参数列表的右边开始设置\n\nconst multiply = (x = 1, y) => x * y、\n// 不可以省略undefined(从右边设置可以省略)\nconsole.log(multiply(undefined, 1))\n\n\n\n# 函数参数默认值的应用\n\n接收很多参数的时候,可以接收一个对象作为参数\n\n// 无需记忆参数的顺序\n// 解构赋值，解构赋值的默认值，函数参数的默认值混用\nconst loguser = ({ username = 'wuming', age = '0', sex = '0' } = {}) => {\n    console.log(username, age, sex)\n}\n// loguser(\n//     {username:'a',\n//     age:16,\n//     sex:'male'}\n// )\n// loguser({})\nloguser()\n",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"解构赋值",frontmatter:{title:"解构赋值",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html",relativePath:"前端开发/JavaScript/ES6/解构赋值.md",key:"v-0c0f2fc9",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html",headers:[{level:2,title:"数组的解构赋值",slug:"数组的解构赋值",normalizedTitle:"数组的解构赋值",charIndex:2},{level:3,title:"解构赋值是什么？",slug:"解构赋值是什么",normalizedTitle:"解构赋值是什么？",charIndex:14},{level:3,title:"数组解构赋值的原理",slug:"数组解构赋值的原理",normalizedTitle:"数组解构赋值的原理",charIndex:112},{level:3,title:"数组解构赋值的默认值",slug:"数组解构赋值的默认值",normalizedTitle:"数组解构赋值的默认值",charIndex:263},{level:3,title:"数组解构赋值的应用",slug:"数组解构赋值的应用",normalizedTitle:"数组解构赋值的应用",charIndex:592},{level:2,title:"对象的解构赋值",slug:"对象的解构赋值",normalizedTitle:"对象的解构赋值",charIndex:1127},{level:3,title:"对象的解构赋值的原理",slug:"对象的解构赋值的原理",normalizedTitle:"对象的解构赋值的原理",charIndex:1139},{level:3,title:"对象的解构赋值的注意事项",slug:"对象的解构赋值的注意事项",normalizedTitle:"对象的解构赋值的注意事项",charIndex:1520},{level:3,title:"对象的解构赋值的应用",slug:"对象的解构赋值的应用",normalizedTitle:"对象的解构赋值的应用",charIndex:1889},{level:2,title:"其它数据类型的解构赋值",slug:"其它数据类型的解构赋值",normalizedTitle:"其它数据类型的解构赋值",charIndex:2253},{level:3,title:"字符串的解构赋值",slug:"字符串的解构赋值",normalizedTitle:"字符串的解构赋值",charIndex:2269},{level:3,title:"数值和布尔值的解构赋值",slug:"数值和布尔值的解构赋值",normalizedTitle:"数值和布尔值的解构赋值",charIndex:2433},{level:3,title:"undefined和null的解构赋值",slug:"undefined和null的解构赋值",normalizedTitle:"undefined和null的解构赋值",charIndex:2568},{level:2,title:"解构赋值常见的应用场景",slug:"解构赋值常见的应用场景",normalizedTitle:"解构赋值常见的应用场景",charIndex:2634},{level:3,title:"交换变量的值",slug:"交换变量的值",normalizedTitle:"交换变量的值",charIndex:972},{level:3,title:"从函数返回多个值",slug:"从函数返回多个值",normalizedTitle:"从函数返回多个值",charIndex:2789},{level:3,title:"函数参数的定义",slug:"函数参数的定义",normalizedTitle:"函数参数的定义",charIndex:3098},{level:3,title:"指定函数参数的默认值",slug:"指定函数参数的默认值",normalizedTitle:"指定函数参数的默认值",charIndex:3399},{level:3,title:"遍历Map解构",slug:"遍历map解构",normalizedTitle:"遍历map解构",charIndex:3570},{level:3,title:"加载模块",slug:"加载模块",normalizedTitle:"加载模块",charIndex:3738},{level:3,title:"提取JSON数据",slug:"提取json数据",normalizedTitle:"提取json数据",charIndex:3800}],headersStr:"数组的解构赋值 解构赋值是什么？ 数组解构赋值的原理 数组解构赋值的默认值 数组解构赋值的应用 对象的解构赋值 对象的解构赋值的原理 对象的解构赋值的注意事项 对象的解构赋值的应用 其它数据类型的解构赋值 字符串的解构赋值 数值和布尔值的解构赋值 undefined和null的解构赋值 解构赋值常见的应用场景 交换变量的值 从函数返回多个值 函数参数的定义 指定函数参数的默认值 遍历Map解构 加载模块 提取JSON数据",content:"# 数组的解构赋值\n\n\n# 解构赋值是什么？\n\n解析某一数据的结构，将我们想要的东西提取出来，赋值给变量或常量\n\nconst [a,b,c]=[1,2,3]\nconsole.log(a,b,c) // 1,2,3\n\n\n\n# 数组解构赋值的原理\n\n * 模式（结构）匹配\n\nconst [a,b,c]=[1,2,3] // 等号左右结构相同\n\n\n\n * 索引值相同的完成赋值\n\n * 不取的，可以直接用逗号跳过\n\neg:我们要取3\n\nconst [,,c]=[1,2,3] \nconsole.log(c) // 3\n\n\n\n\n# 数组解构赋值的默认值\n\nconst[a=1,b=2]=[]\n\n\n * 默认值的生效条件\n   只有当一个数组成员严格等于（===）undefined时，对应的默认值才会生效\n\nconst [a=1,b=2] = [3,null] \nconsole.log(a,b) // 3,null\nconst [a=1,b=2]=[3]\nconsole.log(a,b) // 1,2 \n\n\n * 默认值表达式\n   如果默认值是表达式，默认表达式是惰性求值的\n\nconst func = ()=>{\n   console.log('我被执行了')\n   return 2\n}\nconst [x=fun()]=[1]\nconsole.log(x) // 1 \n\n\n\n# 数组解构赋值的应用\n\n 1. 常见的类数组的解构赋值\n\n * arguments\n\nfunction func(){\n   const [a,b]=arguments;  \n    console.log(a,b);\n   }\n   func(1,2);\n\n\n * nodeList\n\n<body>\n    <p>1</p>\n    <p>2</p>\n    <p>3</p>\n<script>\n    const [p1,p2,p3]=document.querySelectorAll('p')\n    console.log(p1,p2,p3);\n<\/script>\n</body>\n\n\n 2. 函数参数的解构赋值\n\nconst arr=[1,2]\nconst add=([x,y])=>x+y\nconsole.log(add(arr));\n\n\n 3. 交换变量的值\n\nes6之前需要引入中间变量:\n\nlet x=1\nlet y=2\nlet temp=x\nx=y\ny=temp\nconsole.log(x,y) //2,1\n\n\n\nes6:\n\nlet x=1;\nlet y=2;\n[x,y]=[y,x];\nconsole.log(x,y); // 2,1\n\n\n\n# 对象的解构赋值\n\n\n# 对象的解构赋值的原理\n\n 1. 模式（结构）匹配\n\n{}={}\n\n\n 2. 属性名相同的完成赋值\n\n  const{age,username}={username:\"alex\",age:18}\n    console.log(age,username); // 18 \"alex\"\n    // 完整写法\n    // const{'age':age,'username':username}= {username:\"alex\",age:18}\n    // 取别名\n    //   const{age:age,username:uname}={username:\"alex\",age:18}\n    console.log(age,uname); // 18 \"alex\"\n\n\n> 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。\n\n\n# 对象的解构赋值的注意事项\n\n 1. 默认值的生效条件\n    对象的属性值严格等于undefined时，对应的默认值才会生效。\n\nconst {username='alex',age=0}={username:'alex'}\n   console.log(username,age); // 'alex', 0 \n\n\n 2. 默认值表达式\n\n如果默认值是表达式，默认值表达式是惰性求值的\n\n 3. 将一个已经声明的变量用于解构赋值\n\nlet x=2;\n// let{x}={x:1} ❌\n// {x}={x:1} ❌\n({x}={x:1}) \nconsole.log(x);  \n\n\n 4. 可以取到继承的属性\n\nconst{toString}={} \nconsole.log(toString); //继承自Object()\n\n\n\n# 对象的解构赋值的应用\n\n1.函数参数的解构赋值\n\n  const logPersonInfo=({age=1,username='alex'})=>{\n    console.log(age,username) // 18 , 'alex'\n  }\n  logPersonInfo({age:18}) \n\n\n 2. 复杂的嵌套\n\n   const obj={\n      x:1,\n      y:[2,3,4],\n      z:{\n          a:5,\n          b:4\n      }\n  }\n//   const{x,y,z}=obj \n//   console.log(x,y,z);\nconst{y:[,yy],y,z:{a:a1}}=obj\nconsole.log(y,yy,a1);\n\n\n\n# 其它数据类型的解构赋值\n\n\n# 字符串的解构赋值\n\n 1. 数组形式的解构赋值\n\nconst [a,b,,,c]='hello'\nconsole.log(a,b,c) //  h e o\n\n\n 2. 对象形式的解构赋值\n\nconst {0:a,1:b,length}='hello'\nconsole.log(a,b,length) // h e 5\n\n\n\n# 数值和布尔值的解构赋值\n\njs会先将等号右边的值转为对象\n\nconst{a=1,toString}=123 \nconsole.log(a,toString)\n\nconst{b=1,toString}=true \nconsole.log(b,toString)\n\n\n\n# undefined和null的解构赋值\n\n由于 undefined和null无法转为对象，所以对它们进行解构赋值，都会报错\n\n\n# 解构赋值常见的应用场景\n\n\n# 交换变量的值\n\nlet x = 1;\nlet y = 2;\n[x, y] = [y, x]; // tips：x 和 y 已经声明了，这里就不用再添加 let 等关键字声明了\nconsole.log(x, y) // 2 1\n\n\n交换后 x 的值为 2，y 的值为 1\n\n\n# 从函数返回多个值\n\n函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回，可以使用解构赋值，非常方便的取出这些值。\n\n 1. 返回一个数组\n\nfunction fun(){\n    return [1,2,3]\n}\nlet[a,b,c]=fun()\nconsole.log(a,b,c) // 1 2 3 \n\n\n 2. 返回一个对象\n\nfunction fun(){\n    return {\n        name:'frank',\n        age:18\n    }\n}\nlet{name,age}=fun()\nconsole.log(name,age) // frank 18\n\n\n\n# 函数参数的定义\n\n可以方便地将一组参数与变量名对应起来\n\n（1）参数是一组有次序的值\n\n function f([x, y, z]) {\n    console.log(x, y, z)\n}\nf([1, 2, 3])\n\n\n传入函数的参数是数组时，可以对参数进行解构，获取数组中每一项的值\n\n（2）参数是一组无次序的值\n\nfunction f({\n    x,\n    y,\n    z\n}) {\n    console.log(x, y, z)\n}\nf({\n    z: 1,\n    x: 2,\n    y: 3\n})\n\n\n传入函数的参数是对象时，可以对参数进行解构，获取对象中对应的属性值\n\n\n# 指定函数参数的默认值\n\n指定参数的默认值，就避免了在函数体内部再去判断传入的参数是否有值了\n\nfunction foo({x, y = 5}) {\n    console.log(x, y);\n}\nfoo({}) // undefined 5\nfoo({x: 1}) // 1 5\nfoo({x: 1, y: 2}) // 1 2\n\n\n\n# 遍历Map解构\n\n解构赋值，获取键名和键值就非常方便\n\nvar map = new Map();\nmap.set('李四', '18');\nmap.set('张三', '20');\nfor (let [key, value] of map) {\n    console.log(`${key}今年${value}岁`);\n}\n\n\n\n# 加载模块\n\n这里也是用到了解构，可以让你引入的部分更加明确\n\nimport {x, y} from 'xxx';\n\n\n\n# 提取JSON数据\n\n解构赋值可以快速提取JSON数据的值\n\nvar jsonData = {\n    \"name\": \"小慕\",\n    \"age\": \"18\",\n    \"data\": [1, 2, 3, 4],\n    \"status\": \"OK\"\n}\nlet {\n    name,\n    age,\n    data,\n    status\n} = jsonData\nconsole.log(name, age, data, status);\n",normalizedContent:"# 数组的解构赋值\n\n\n# 解构赋值是什么？\n\n解析某一数据的结构，将我们想要的东西提取出来，赋值给变量或常量\n\nconst [a,b,c]=[1,2,3]\nconsole.log(a,b,c) // 1,2,3\n\n\n\n# 数组解构赋值的原理\n\n * 模式（结构）匹配\n\nconst [a,b,c]=[1,2,3] // 等号左右结构相同\n\n\n\n * 索引值相同的完成赋值\n\n * 不取的，可以直接用逗号跳过\n\neg:我们要取3\n\nconst [,,c]=[1,2,3] \nconsole.log(c) // 3\n\n\n\n\n# 数组解构赋值的默认值\n\nconst[a=1,b=2]=[]\n\n\n * 默认值的生效条件\n   只有当一个数组成员严格等于（===）undefined时，对应的默认值才会生效\n\nconst [a=1,b=2] = [3,null] \nconsole.log(a,b) // 3,null\nconst [a=1,b=2]=[3]\nconsole.log(a,b) // 1,2 \n\n\n * 默认值表达式\n   如果默认值是表达式，默认表达式是惰性求值的\n\nconst func = ()=>{\n   console.log('我被执行了')\n   return 2\n}\nconst [x=fun()]=[1]\nconsole.log(x) // 1 \n\n\n\n# 数组解构赋值的应用\n\n 1. 常见的类数组的解构赋值\n\n * arguments\n\nfunction func(){\n   const [a,b]=arguments;  \n    console.log(a,b);\n   }\n   func(1,2);\n\n\n * nodelist\n\n<body>\n    <p>1</p>\n    <p>2</p>\n    <p>3</p>\n<script>\n    const [p1,p2,p3]=document.queryselectorall('p')\n    console.log(p1,p2,p3);\n<\/script>\n</body>\n\n\n 2. 函数参数的解构赋值\n\nconst arr=[1,2]\nconst add=([x,y])=>x+y\nconsole.log(add(arr));\n\n\n 3. 交换变量的值\n\nes6之前需要引入中间变量:\n\nlet x=1\nlet y=2\nlet temp=x\nx=y\ny=temp\nconsole.log(x,y) //2,1\n\n\n\nes6:\n\nlet x=1;\nlet y=2;\n[x,y]=[y,x];\nconsole.log(x,y); // 2,1\n\n\n\n# 对象的解构赋值\n\n\n# 对象的解构赋值的原理\n\n 1. 模式（结构）匹配\n\n{}={}\n\n\n 2. 属性名相同的完成赋值\n\n  const{age,username}={username:\"alex\",age:18}\n    console.log(age,username); // 18 \"alex\"\n    // 完整写法\n    // const{'age':age,'username':username}= {username:\"alex\",age:18}\n    // 取别名\n    //   const{age:age,username:uname}={username:\"alex\",age:18}\n    console.log(age,uname); // 18 \"alex\"\n\n\n> 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。\n\n\n# 对象的解构赋值的注意事项\n\n 1. 默认值的生效条件\n    对象的属性值严格等于undefined时，对应的默认值才会生效。\n\nconst {username='alex',age=0}={username:'alex'}\n   console.log(username,age); // 'alex', 0 \n\n\n 2. 默认值表达式\n\n如果默认值是表达式，默认值表达式是惰性求值的\n\n 3. 将一个已经声明的变量用于解构赋值\n\nlet x=2;\n// let{x}={x:1} ❌\n// {x}={x:1} ❌\n({x}={x:1}) \nconsole.log(x);  \n\n\n 4. 可以取到继承的属性\n\nconst{tostring}={} \nconsole.log(tostring); //继承自object()\n\n\n\n# 对象的解构赋值的应用\n\n1.函数参数的解构赋值\n\n  const logpersoninfo=({age=1,username='alex'})=>{\n    console.log(age,username) // 18 , 'alex'\n  }\n  logpersoninfo({age:18}) \n\n\n 2. 复杂的嵌套\n\n   const obj={\n      x:1,\n      y:[2,3,4],\n      z:{\n          a:5,\n          b:4\n      }\n  }\n//   const{x,y,z}=obj \n//   console.log(x,y,z);\nconst{y:[,yy],y,z:{a:a1}}=obj\nconsole.log(y,yy,a1);\n\n\n\n# 其它数据类型的解构赋值\n\n\n# 字符串的解构赋值\n\n 1. 数组形式的解构赋值\n\nconst [a,b,,,c]='hello'\nconsole.log(a,b,c) //  h e o\n\n\n 2. 对象形式的解构赋值\n\nconst {0:a,1:b,length}='hello'\nconsole.log(a,b,length) // h e 5\n\n\n\n# 数值和布尔值的解构赋值\n\njs会先将等号右边的值转为对象\n\nconst{a=1,tostring}=123 \nconsole.log(a,tostring)\n\nconst{b=1,tostring}=true \nconsole.log(b,tostring)\n\n\n\n# undefined和null的解构赋值\n\n由于 undefined和null无法转为对象，所以对它们进行解构赋值，都会报错\n\n\n# 解构赋值常见的应用场景\n\n\n# 交换变量的值\n\nlet x = 1;\nlet y = 2;\n[x, y] = [y, x]; // tips：x 和 y 已经声明了，这里就不用再添加 let 等关键字声明了\nconsole.log(x, y) // 2 1\n\n\n交换后 x 的值为 2，y 的值为 1\n\n\n# 从函数返回多个值\n\n函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回，可以使用解构赋值，非常方便的取出这些值。\n\n 1. 返回一个数组\n\nfunction fun(){\n    return [1,2,3]\n}\nlet[a,b,c]=fun()\nconsole.log(a,b,c) // 1 2 3 \n\n\n 2. 返回一个对象\n\nfunction fun(){\n    return {\n        name:'frank',\n        age:18\n    }\n}\nlet{name,age}=fun()\nconsole.log(name,age) // frank 18\n\n\n\n# 函数参数的定义\n\n可以方便地将一组参数与变量名对应起来\n\n（1）参数是一组有次序的值\n\n function f([x, y, z]) {\n    console.log(x, y, z)\n}\nf([1, 2, 3])\n\n\n传入函数的参数是数组时，可以对参数进行解构，获取数组中每一项的值\n\n（2）参数是一组无次序的值\n\nfunction f({\n    x,\n    y,\n    z\n}) {\n    console.log(x, y, z)\n}\nf({\n    z: 1,\n    x: 2,\n    y: 3\n})\n\n\n传入函数的参数是对象时，可以对参数进行解构，获取对象中对应的属性值\n\n\n# 指定函数参数的默认值\n\n指定参数的默认值，就避免了在函数体内部再去判断传入的参数是否有值了\n\nfunction foo({x, y = 5}) {\n    console.log(x, y);\n}\nfoo({}) // undefined 5\nfoo({x: 1}) // 1 5\nfoo({x: 1, y: 2}) // 1 2\n\n\n\n# 遍历map解构\n\n解构赋值，获取键名和键值就非常方便\n\nvar map = new map();\nmap.set('李四', '18');\nmap.set('张三', '20');\nfor (let [key, value] of map) {\n    console.log(`${key}今年${value}岁`);\n}\n\n\n\n# 加载模块\n\n这里也是用到了解构，可以让你引入的部分更加明确\n\nimport {x, y} from 'xxx';\n\n\n\n# 提取json数据\n\n解构赋值可以快速提取json数据的值\n\nvar jsondata = {\n    \"name\": \"小慕\",\n    \"age\": \"18\",\n    \"data\": [1, 2, 3, 4],\n    \"status\": \"ok\"\n}\nlet {\n    name,\n    age,\n    data,\n    status\n} = jsondata\nconsole.log(name, age, data, status);\n",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"遍历器与for...of循环",frontmatter:{title:"遍历器与for...of循环",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E9%81%8D%E5%8E%86%E5%99%A8%E4%B8%8Efor...of%E5%BE%AA%E7%8E%AF.html",relativePath:"前端开发/JavaScript/ES6/遍历器与for...of循环.md",key:"v-30659e0a",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ES6/%E9%81%8D%E5%8E%86%E5%99%A8%E4%B8%8Efor...of%E5%BE%AA%E7%8E%AF.html",headers:[{level:2,title:"Iterator 是什么",slug:"iterator-是什么",normalizedTitle:"iterator 是什么",charIndex:2},{level:2,title:"Symbol 详解",slug:"symbol-详解",normalizedTitle:"symbol 详解",charIndex:333},{level:3,title:"基础语法",slug:"基础语法",normalizedTitle:"基础语法",charIndex:480},{level:3,title:"Symbol 属性的遍历",slug:"symbol-属性的遍历",normalizedTitle:"symbol 属性的遍历",charIndex:983},{level:3,title:"Symbol.for()，Symbol.keyFor()",slug:"symbol-for-symbol-keyfor",normalizedTitle:"symbol.for()，symbol.keyfor()",charIndex:1278},{level:3,title:"Symbol 的作用",slug:"symbol-的作用",normalizedTitle:"symbol 的作用",charIndex:1701},{level:3,title:"常用内置的 Symbol 值：Symbol.iterator",slug:"常用内置的-symbol-值-symbol-iterator",normalizedTitle:"常用内置的 symbol 值：symbol.iterator",charIndex:2110},{level:3,title:"Symbol 与基本数据类型转换",slug:"symbol-与基本数据类型转换",normalizedTitle:"symbol 与基本数据类型转换",charIndex:2302},{level:2,title:"Iterator 解惑",slug:"iterator-解惑",normalizedTitle:"iterator 解惑",charIndex:2633},{level:2,title:"for...of 的用法",slug:"for-of-的用法",normalizedTitle:"for...of 的用法",charIndex:2695},{level:2,title:"原生可遍历与非原生可遍历",slug:"原生可遍历与非原生可遍历",normalizedTitle:"原生可遍历与非原生可遍历",charIndex:3332},{level:2,title:"使用了 Iterator 的场合",slug:"使用了-iterator-的场合",normalizedTitle:"使用了 iterator 的场合",charIndex:3512},{level:2,title:"遍历总结",slug:"遍历总结",normalizedTitle:"遍历总结",charIndex:3639},{level:3,title:"for",slug:"for",normalizedTitle:"for",charIndex:1028},{level:3,title:"forEach",slug:"foreach",normalizedTitle:"foreach",charIndex:3724},{level:3,title:"for in",slug:"for-in",normalizedTitle:"for in",charIndex:3917},{level:3,title:"for of",slug:"for-of",normalizedTitle:"for of",charIndex:4073}],headersStr:"Iterator 是什么 Symbol 详解 基础语法 Symbol 属性的遍历 Symbol.for()，Symbol.keyFor() Symbol 的作用 常用内置的 Symbol 值：Symbol.iterator Symbol 与基本数据类型转换 Iterator 解惑 for...of 的用法 原生可遍历与非原生可遍历 使用了 Iterator 的场合 遍历总结 for forEach for in for of",content:"# Iterator 是什么\n\n 1. Iterator(遍历器)的作用:它是用来遍历的\n 2. 使用 Iterator\n\nconst it = [1, 2][Symbol.iterator]()\nconsole.log(it.next())\nconsole.log(it.next())\nconsole.log(it.next())\n\n\n * it:可遍历对象\n * Symbol.iterator：可遍历对象的生成方法\n\n 3. 什么是 Iterator Symbol.iterator（可遍历对象的生成方法）->it（可遍历对象）-> it.next() ->it. next()->…(直到 done 为 true) 这个过程被称为Iterator\n\n\n# Symbol 详解\n\nSymbol 是 ES6 中引入的一种新的基本数据类型，用于表示一个独一无二的值。它是 JavaScript 中的第七种数据类型，与 undefined、null、Number（数值）、String（字符串）、Boolean（布尔值）、Object（对象）并列。\n\n\n# 基础语法\n\n创建一个 Symbol 值的方式如下：\n\nconst a = Symbol()\nconst b = Symbol()\nconsole.log(a) //Symbol()\nconsole.log(b) //Symbol()\nconsole.log(typeof a) // 类型是：Symbol\nconsole.log(a === b) // false 可以知道Symbol的值是唯一的\n\n\n如果同时定义两个 Symbol 值，它们打印的结果都是：Symbol(),为此，我们可以在调用 Symbol 的时候传入一个字符串作为对当前 Symbol 变量的描述：\n\nlet a = Symbol('symbol1')\nlet b = Symbol('symbol2')\nconsole.log(a) //Symbol(\"symbol1\")\nconsole.log(b) //Symbol(\"symbol2\")\n\n\n注意： 调用 Symbol 时不可以使用 new 关键字\n\n//报错，Symbol is not a constructor\nconst a = new Symbol()\n\n\n\n# Symbol 属性的遍历\n\n以 Symbol 类型的变量作为对象属性时，该属性不会出现在 for … in、for … of 循环中 举个例子：\n\nlet s1 = Symbol('a')\nlet s2 = Symbol('b')\n// 由于 s1 和 s2 是一个变量，而不是字符串，因此需要使用中括号括起来（否则它会被当做字符串使用）\nlet a = {\n    name: '夕山雨',\n    [s1]: 24,\n    [s2]: function () {},\n}\n\n\nfor…in 方式遍历 obj 对象时，Symbol 类型的属性没有输出，只输出了 name 属性\n\n\n# Symbol.for()，Symbol.keyFor()\n\n(1)Symbol.for()：Symbol 提供的一种可以创建相同 Symbol 的机制，就是使用 Symbol.for()方法进行注册。示例：\n\nlet a = Symbol.for('imooc') //全局注册了以\"imooc\"为描述符的 Symbol\n//由于描述符\"imooc\"已被注册到全局，因此这里创建的 Symbol 与上面是同一个\nlet b = Symbol.for('imooc')\nconsole.log(a === b) // true\n\n\n(2)Symbol.keyFor()：返回一个全局注册的 Symbol 的描述符\n\nlet a = Symbol.for('imooc')\n// 返回结果是已经注册过的变量 a 的描述符 imooc\nlet res = Symbol.keyFor(a)\nconsole.log(res) // imooc\n\n\n\n# Symbol 的作用\n\n由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。\n\nlet s1 = Symbol()\nlet s2 = Symbol()\nconst obj = {\n    age: 16,\n    age: 19,\n    [s1]: 'Hello!',\n    [s2]: 'world',\n}\nconsole.log(obj)\n\n\n由于 age 是字符串类型的，同名属性会被覆盖，所以 obj 对象中只会有一个 age 属性，而 Symbol 值是唯一的，即使控制台中输出结果看起来是一样的，但他们并不表示同一个值，所以 obj 中 s1 和 s2 都被添加到 obj 对象中\n\n注： 为了方便区分，可以给 Symbol 值添加描述\n\n\n# 常用内置的 Symbol 值：Symbol.iterator\n\n对象的 [Symbol.iterator] 属性，指向该对象的默认遍历器方法 ，凡是具有[Symbol(Symbol.iterator)]属性的对象都是可遍历的，可以使用 for … of 循环依次输出对象的每个属性\n\n数组和类数组，以及 ES6 新增的 Map、Set 等都原生部署了该方法，因此它们都可遍历\n\n\n# Symbol 与基本数据类型转换\n\n（1）Symbol 不能转成数字。示例：\n\nlet s1 = Symbol('1')\n// 报错\nconsole.log(Number(s1))\n\n\n(2) 可以转成布尔值和字符串\n\n// Symbol 值可以通过 String 转成字符串形式，通过 Boolean 转成布尔值\nlet s1 = Symbol('1')\nconsole.log(typeof s1) // symbol\nlet str = String(s1)\nconsole.log(typeof str) // string\nlet bool = Boolean(s1)\nconsole.log(typeof bool) // boolean\n\n\n\n# Iterator 解惑\n\nIterator 是一个统一的遍历方式, 我们一般不会直接使用 Iterator 去遍历\n\n\n# for...of 的用法\n\nmdn文档\n\n1.认识 for...of：Iterator 的封装\n\nconst arr = [1, 2, 3, 4]\nfor (const item of arr) {\n    console.log(item)\n}\n\n\n 2. 与 break,continue 一起使用\n\nconst arr = [1, 2, 3, 4]\nfor (const item of arr) {\n    if (item === 2) {\n        break\n        // continue\n    }\n    console.log(item)\n}\n\n\n 3. 在 for...of 中取得数组的索引\n\n * keys()得到的是索引的可遍历对象，可以遍历出索引值\n\nconst arr = [1, 2, 3, 4]\nfor (const key of arr.keys()) {\n    console.log(key)\n}\n\n\n * values()得到的是值的可遍历对象，可以遍历出值，多此一举，和直接使用 for...of 方法效果一样\n\n * entries()得到的是索引+值组成的数组的可遍历对象\n\nconst arr = [11, 21, 31, 4]\n// 解构赋值\nfor (const [key, value] of arr.entries()) {\n    console.log(key, value)\n}\n\n\n\n# 原生可遍历与非原生可遍历\n\n 1. 什么是可遍历\n\n只要有 [Symbol.iterator] 方法，就是可遍历的，只要可遍历，就可以使用 for...of 循环来统一遍历\n\n 2. 原生可遍历的有哪些？\n\n * 数组\n * 字符串\n * Set\n * Map\n * arguments\n * NodeList\n\n 3. 非原生可遍历的有哪些？ 对象\n\n\n# 使用了 Iterator 的场合\n\n 1. 数组的展开运算符\n\n 2. 数组的解构赋值\n\nconst [a, b] = 'hi'\nconst [a, b] = new Set([3, 4])\n\n\n只要是原生可遍历的就可以按照数组的方式展开，解构\n\n\n# 遍历总结\n\n\n# for\n\n * 用于遍历数组,字符串,类数组对象(NodeList,arguments)\n\n * 可以使用 break,continue 语句\n\n\n# forEach\n\nforEach 方法对数组的每个元素执行一次给定的函数\n\n * 用于遍历数组, Set和Map数据结构\n\n * 可以通过回调函数参数传入value,key 和自身,同时可以改变 this 指向(回调函数为非箭头函数时)\n\n * 不能使用 break 和 continue 语句\n\nmap 和 forEach:数组中 forEach() 和 map() 的区别\n\n\n# for in\n\nJavaScript for...in 循环出来的对象属性顺序到底是什么规律？\n\n * 用于遍历数组(不推荐，for...in 不应该用于迭代一个关注索引顺序的 Array),对象,字符串\n * 只能获得 key,没有 value\n * 可以使用 break 和 continue 语句\n\n\n# for of\n\n * 用于遍历数组,字符串,Set,Map,NodeList,arguments(原生可遍历),不能直接遍历对象\n * 默认获得 value,但可以通过 keys(),values(),entries()获得对应可遍历对象\n * 可以使用 break 和 continue 语句",normalizedContent:"# iterator 是什么\n\n 1. iterator(遍历器)的作用:它是用来遍历的\n 2. 使用 iterator\n\nconst it = [1, 2][symbol.iterator]()\nconsole.log(it.next())\nconsole.log(it.next())\nconsole.log(it.next())\n\n\n * it:可遍历对象\n * symbol.iterator：可遍历对象的生成方法\n\n 3. 什么是 iterator symbol.iterator（可遍历对象的生成方法）->it（可遍历对象）-> it.next() ->it. next()->…(直到 done 为 true) 这个过程被称为iterator\n\n\n# symbol 详解\n\nsymbol 是 es6 中引入的一种新的基本数据类型，用于表示一个独一无二的值。它是 javascript 中的第七种数据类型，与 undefined、null、number（数值）、string（字符串）、boolean（布尔值）、object（对象）并列。\n\n\n# 基础语法\n\n创建一个 symbol 值的方式如下：\n\nconst a = symbol()\nconst b = symbol()\nconsole.log(a) //symbol()\nconsole.log(b) //symbol()\nconsole.log(typeof a) // 类型是：symbol\nconsole.log(a === b) // false 可以知道symbol的值是唯一的\n\n\n如果同时定义两个 symbol 值，它们打印的结果都是：symbol(),为此，我们可以在调用 symbol 的时候传入一个字符串作为对当前 symbol 变量的描述：\n\nlet a = symbol('symbol1')\nlet b = symbol('symbol2')\nconsole.log(a) //symbol(\"symbol1\")\nconsole.log(b) //symbol(\"symbol2\")\n\n\n注意： 调用 symbol 时不可以使用 new 关键字\n\n//报错，symbol is not a constructor\nconst a = new symbol()\n\n\n\n# symbol 属性的遍历\n\n以 symbol 类型的变量作为对象属性时，该属性不会出现在 for … in、for … of 循环中 举个例子：\n\nlet s1 = symbol('a')\nlet s2 = symbol('b')\n// 由于 s1 和 s2 是一个变量，而不是字符串，因此需要使用中括号括起来（否则它会被当做字符串使用）\nlet a = {\n    name: '夕山雨',\n    [s1]: 24,\n    [s2]: function () {},\n}\n\n\nfor…in 方式遍历 obj 对象时，symbol 类型的属性没有输出，只输出了 name 属性\n\n\n# symbol.for()，symbol.keyfor()\n\n(1)symbol.for()：symbol 提供的一种可以创建相同 symbol 的机制，就是使用 symbol.for()方法进行注册。示例：\n\nlet a = symbol.for('imooc') //全局注册了以\"imooc\"为描述符的 symbol\n//由于描述符\"imooc\"已被注册到全局，因此这里创建的 symbol 与上面是同一个\nlet b = symbol.for('imooc')\nconsole.log(a === b) // true\n\n\n(2)symbol.keyfor()：返回一个全局注册的 symbol 的描述符\n\nlet a = symbol.for('imooc')\n// 返回结果是已经注册过的变量 a 的描述符 imooc\nlet res = symbol.keyfor(a)\nconsole.log(res) // imooc\n\n\n\n# symbol 的作用\n\n由于每一个 symbol 值都是不相等的，这意味着 symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。\n\nlet s1 = symbol()\nlet s2 = symbol()\nconst obj = {\n    age: 16,\n    age: 19,\n    [s1]: 'hello!',\n    [s2]: 'world',\n}\nconsole.log(obj)\n\n\n由于 age 是字符串类型的，同名属性会被覆盖，所以 obj 对象中只会有一个 age 属性，而 symbol 值是唯一的，即使控制台中输出结果看起来是一样的，但他们并不表示同一个值，所以 obj 中 s1 和 s2 都被添加到 obj 对象中\n\n注： 为了方便区分，可以给 symbol 值添加描述\n\n\n# 常用内置的 symbol 值：symbol.iterator\n\n对象的 [symbol.iterator] 属性，指向该对象的默认遍历器方法 ，凡是具有[symbol(symbol.iterator)]属性的对象都是可遍历的，可以使用 for … of 循环依次输出对象的每个属性\n\n数组和类数组，以及 es6 新增的 map、set 等都原生部署了该方法，因此它们都可遍历\n\n\n# symbol 与基本数据类型转换\n\n（1）symbol 不能转成数字。示例：\n\nlet s1 = symbol('1')\n// 报错\nconsole.log(number(s1))\n\n\n(2) 可以转成布尔值和字符串\n\n// symbol 值可以通过 string 转成字符串形式，通过 boolean 转成布尔值\nlet s1 = symbol('1')\nconsole.log(typeof s1) // symbol\nlet str = string(s1)\nconsole.log(typeof str) // string\nlet bool = boolean(s1)\nconsole.log(typeof bool) // boolean\n\n\n\n# iterator 解惑\n\niterator 是一个统一的遍历方式, 我们一般不会直接使用 iterator 去遍历\n\n\n# for...of 的用法\n\nmdn文档\n\n1.认识 for...of：iterator 的封装\n\nconst arr = [1, 2, 3, 4]\nfor (const item of arr) {\n    console.log(item)\n}\n\n\n 2. 与 break,continue 一起使用\n\nconst arr = [1, 2, 3, 4]\nfor (const item of arr) {\n    if (item === 2) {\n        break\n        // continue\n    }\n    console.log(item)\n}\n\n\n 3. 在 for...of 中取得数组的索引\n\n * keys()得到的是索引的可遍历对象，可以遍历出索引值\n\nconst arr = [1, 2, 3, 4]\nfor (const key of arr.keys()) {\n    console.log(key)\n}\n\n\n * values()得到的是值的可遍历对象，可以遍历出值，多此一举，和直接使用 for...of 方法效果一样\n\n * entries()得到的是索引+值组成的数组的可遍历对象\n\nconst arr = [11, 21, 31, 4]\n// 解构赋值\nfor (const [key, value] of arr.entries()) {\n    console.log(key, value)\n}\n\n\n\n# 原生可遍历与非原生可遍历\n\n 1. 什么是可遍历\n\n只要有 [symbol.iterator] 方法，就是可遍历的，只要可遍历，就可以使用 for...of 循环来统一遍历\n\n 2. 原生可遍历的有哪些？\n\n * 数组\n * 字符串\n * set\n * map\n * arguments\n * nodelist\n\n 3. 非原生可遍历的有哪些？ 对象\n\n\n# 使用了 iterator 的场合\n\n 1. 数组的展开运算符\n\n 2. 数组的解构赋值\n\nconst [a, b] = 'hi'\nconst [a, b] = new set([3, 4])\n\n\n只要是原生可遍历的就可以按照数组的方式展开，解构\n\n\n# 遍历总结\n\n\n# for\n\n * 用于遍历数组,字符串,类数组对象(nodelist,arguments)\n\n * 可以使用 break,continue 语句\n\n\n# foreach\n\nforeach 方法对数组的每个元素执行一次给定的函数\n\n * 用于遍历数组, set和map数据结构\n\n * 可以通过回调函数参数传入value,key 和自身,同时可以改变 this 指向(回调函数为非箭头函数时)\n\n * 不能使用 break 和 continue 语句\n\nmap 和 foreach:数组中 foreach() 和 map() 的区别\n\n\n# for in\n\njavascript for...in 循环出来的对象属性顺序到底是什么规律？\n\n * 用于遍历数组(不推荐，for...in 不应该用于迭代一个关注索引顺序的 array),对象,字符串\n * 只能获得 key,没有 value\n * 可以使用 break 和 continue 语句\n\n\n# for of\n\n * 用于遍历数组,字符串,set,map,nodelist,arguments(原生可遍历),不能直接遍历对象\n * 默认获得 value,但可以通过 keys(),values(),entries()获得对应可遍历对象\n * 可以使用 break 和 continue 语句",charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"BOM",frontmatter:{title:"BOM",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/BOM.html",relativePath:"前端开发/JavaScript/JS基础/BOM.md",key:"v-76290fb8",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/BOM.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"window 对象",slug:"window-对象",normalizedTitle:"window 对象",charIndex:61},{level:3,title:"全局变量是 window 的属性",slug:"全局变量是-window-的属性",normalizedTitle:"全局变量是 window 的属性",charIndex:220},{level:3,title:"内置函数普遍是 window 的方法",slug:"内置函数普遍是-window-的方法",normalizedTitle:"内置函数普遍是 window 的方法",charIndex:282},{level:3,title:"窗口尺寸相关属性",slug:"窗口尺寸相关属性",normalizedTitle:"窗口尺寸相关属性",charIndex:307},{level:3,title:"resize 事件",slug:"resize-事件",normalizedTitle:"resize 事件",charIndex:401},{level:3,title:"已卷动高度",slug:"已卷动高度",normalizedTitle:"已卷动高度",charIndex:496},{level:3,title:"scroll 事件",slug:"scroll-事件",normalizedTitle:"scroll 事件",charIndex:741},{level:2,title:"Navigator 对象",slug:"navigator-对象",normalizedTitle:"navigator 对象",charIndex:838},{level:3,title:"识别用户浏览器品牌",slug:"识别用户浏览器品牌",normalizedTitle:"识别用户浏览器品牌",charIndex:919},{level:2,title:"History 对象",slug:"history-对象",normalizedTitle:"history 对象",charIndex:972},{level:2,title:"Location 对象",slug:"location-对象",normalizedTitle:"location 对象",charIndex:1090},{level:3,title:"重新加载当前页面",slug:"重新加载当前页面",normalizedTitle:"重新加载当前页面",charIndex:1157},{level:3,title:"GET 请求查询参数",slug:"get-请求查询参数",normalizedTitle:"get 请求查询参数",charIndex:1258},{level:2,title:"BOM 特效",slug:"bom-特效",normalizedTitle:"bom 特效",charIndex:1321},{level:3,title:"返回顶部",slug:"返回顶部",normalizedTitle:"返回顶部",charIndex:1332},{level:3,title:"楼层导航",slug:"楼层导航",normalizedTitle:"楼层导航",charIndex:1656}],headersStr:"简介 window 对象 全局变量是 window 的属性 内置函数普遍是 window 的方法 窗口尺寸相关属性 resize 事件 已卷动高度 scroll 事件 Navigator 对象 识别用户浏览器品牌 History 对象 Location 对象 重新加载当前页面 GET 请求查询参数 BOM 特效 返回顶部 楼层导航",content:'# 简介\n\nBOM（ Browser Object Model，浏览器对象模型）是 Js 与浏览器窗口交互的接口\n\n\n# window 对象\n\nwindow 对象是当前 JS 脚本运行所处的窗口，而这个窗口中包含 DOM 结构， window.document 属性就是 document 对象\n\n在有标签页功能的浏览器中，每个标签都拥有自己的 window 对象；也就是说，同一个窗口的标签页之间不会共享一个 window 对象\n\n\n# 全局变量是 window 的属性\n\n\n\n这就意味着，多个 js 文件之间是共享全局作用域的，即 s 文件没有作用域\n\n\n# 内置函数普遍是 window 的方法\n\n\n\n\n# 窗口尺寸相关属性\n\n\n\n> document.documentElement 是一个会返回文档对象（document）的根元素的只读属性（如 HTML 文档的 html 元素）。\n\n\n# resize 事件\n\n在窗口大小改变之后，就会触发 resize 事件，可以使用 window.onresize window.addEventListener 来绑定事件处理函数\n\n\n# 已卷动高度\n\n * window.scrollY 属性表示在垂直方向已滚动的像素值\n\n\n\n * document.documentElement.scrollTop 属性也表示窗口卷动高度\n\nvar scrollTop = window.scrollY || document.documentElement.scrollTop\n// 浏览器兼容性考虑\n\n\ndocument.documentElement.scrollTop不是只读的，而 window.scrollY 是只读的\n\n\n# scroll 事件\n\n在窗口被卷动之后，就会触发 scroll 事件，可以使用 window.onscroll 或者 window.addEventListener 来绑定事件处理函数\n\n\n# Navigator 对象\n\nwindow.navigator 属性可以检索 navigator 对象，它内部含有用户此次活动的浏览器的相关属性和标识\n\n\n\n\n# 识别用户浏览器品牌\n\n识别用户浏览器品牌通常使用 naviator.userAgent 属性\n\n\n\n\n# History 对象\n\nwindow.history 对象提供了操作浏览器会话历史的接口\n\n模拟浏览器回退按钮\n\nhistory.back() //等同于浏览器的后退按钮\nhistory.go(-1) //等同于back()\n\n\n\n# Location 对象\n\nwindow.location 标识当前所在网址，可以通过给这个属性赋值命令浏览器进行页面跳转\n\n\n\n\n# 重新加载当前页面\n\n可以调用 location 的 reload 方法以重新加载当前页面，参数 true 表示强制从服务器强制加载\n\nwindow.location.reload(true)\n\n\n\n# GET 请求查询参数\n\nwindow.location.search 属性即为当前浏览器的 GET 请求查询参数\n\n\n\n\n# BOM 特效\n\n\n# 返回顶部\n\n固定定位 定时器\n\nvar box = document.getElementById(\'box\')\nvar timer\nbox.onclick = function () {\n    clearInterval(timer)\n    timer = setInterval(function () {\n        document.documentElement.scrollTop -= 100\n        if (document.documentElement.scrollTop <= 0) {\n            clearInterval(timer)\n        }\n    }, 50)\n}\n\n\n\n# 楼层导航\n\n * DOM 元素都有offsetTop属性(HTMLElement.offsetTop)，表示此元素到定位祖先元素的垂直距离\n * 定位祖先元素：在祖先中，离自己最近的且拥有定位属性的元素，若祖先都不符合条件，offsetParent 为body\n * 利用 scrollTo 实现 smooth(平滑滚动)\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>Document</title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            html,\n            body {\n                height: 100%;\n            }\n            #list {\n                position: fixed;\n                right: 50px;\n                top: 50%;\n                transform: translateY(-50%);\n                list-style: none;\n            }\n            li {\n                background-color: #fd9c4c88;\n                height: 40px;\n                line-height: 40px;\n                text-align: center;\n                width: 100px;\n                color: #fff;\n                border-radius: 20px;\n                margin-bottom: 10px;\n            }\n            .contentPart {\n                width: 100%;\n                height: 100%;\n                font-size: 400px;\n                text-align: center;\n                line-height: 1024px;\n                margin-bottom: 1px;\n                background-color: black;\n                color: #fff;\n            }\n            /* 自定义属性修改css样式 */\n            /* .contentPart[data-n=\'one\']{\n           background-image:url(./1.jpg) ;\n           background-size:cover;\n        }\n        .contentPart[data-n=\'two\']{\n           background-image:url(./2.jpg) ;\n           background-size:cover;\n        }\n        .contentPart[data-n=\'three\']{\n           background-image:url(./3.jpg) ;\n           background-size:cover;\n        }\n        .contentPart[data-n=\'four\']{\n           background-image:url(./4.jpg) ;\n           background-size:cover;\n        } */\n            li.current {\n                color: yellow;\n            }\n        </style>\n    </head>\n    <body>\n        <ul id="list">\n            <li data-n="one" class="current">one</li>\n            <li data-n="two">two</li>\n            <li data-n="three">three</li>\n            <li data-n="four">four</li>\n        </ul>\n\n        <section class="contentPart" data-n="one">1</section>\n        <section class="contentPart" data-n="two">2</section>\n        <section class="contentPart" data-n="three">3</section>\n        <section class="contentPart" data-n="four">4</section>\n\n        <script>\n            // 楼层导航逻辑\n            var list = document.getElementById(\'list\')\n            var lis = document.querySelectorAll(\'#list li\')\n            var contentParts = document.querySelectorAll(\'.contentPart\')\n            list.onclick = function (e) {\n                if (e.target.tagName.toLowerCase() == \'li\') {\n                    var n = e.target.getAttribute(\'data-n\')\n                    var contentPart = document.querySelector(\n                        \'.contentPart[data-n=\' + n + \']\'\n                    )\n                    // 利用scrollTo实现smooth(平滑滚动)\n                    window.scrollTo({\n                        top: contentPart.offsetTop,\n                        behavior: \'smooth\',\n                    })\n                }\n            }\n            // 导航切换\n            var offsetTopArr = []\n            var nowFloor = 0\n            for (var i = 0; i < contentParts.length; i++) {\n                offsetTopArr.push(contentParts[i].offsetTop)\n            }\n            offsetTopArr.push(Infinity)\n            console.log(offsetTopArr)\n            window.onscroll = function () {\n                var s = document.documentElement.scrollTop\n                for (var i = 0; i < offsetTopArr.length; i++) {\n                    if (s >= offsetTopArr[i] && s < offsetTopArr[i + 1]) {\n                        break\n                    }\n                }\n                if (i != nowFloor) {\n                    nowFloor = i\n                    for (var j = 0; j < lis.length; j++) {\n                        if (j == i) {\n                            lis[j].className = \'current\'\n                        } else {\n                            lis[j].className = \'none\'\n                        }\n                    }\n                }\n            }\n        <\/script>\n    </body>\n</html>\n',normalizedContent:'# 简介\n\nbom（ browser object model，浏览器对象模型）是 js 与浏览器窗口交互的接口\n\n\n# window 对象\n\nwindow 对象是当前 js 脚本运行所处的窗口，而这个窗口中包含 dom 结构， window.document 属性就是 document 对象\n\n在有标签页功能的浏览器中，每个标签都拥有自己的 window 对象；也就是说，同一个窗口的标签页之间不会共享一个 window 对象\n\n\n# 全局变量是 window 的属性\n\n\n\n这就意味着，多个 js 文件之间是共享全局作用域的，即 s 文件没有作用域\n\n\n# 内置函数普遍是 window 的方法\n\n\n\n\n# 窗口尺寸相关属性\n\n\n\n> document.documentelement 是一个会返回文档对象（document）的根元素的只读属性（如 html 文档的 html 元素）。\n\n\n# resize 事件\n\n在窗口大小改变之后，就会触发 resize 事件，可以使用 window.onresize window.addeventlistener 来绑定事件处理函数\n\n\n# 已卷动高度\n\n * window.scrolly 属性表示在垂直方向已滚动的像素值\n\n\n\n * document.documentelement.scrolltop 属性也表示窗口卷动高度\n\nvar scrolltop = window.scrolly || document.documentelement.scrolltop\n// 浏览器兼容性考虑\n\n\ndocument.documentelement.scrolltop不是只读的，而 window.scrolly 是只读的\n\n\n# scroll 事件\n\n在窗口被卷动之后，就会触发 scroll 事件，可以使用 window.onscroll 或者 window.addeventlistener 来绑定事件处理函数\n\n\n# navigator 对象\n\nwindow.navigator 属性可以检索 navigator 对象，它内部含有用户此次活动的浏览器的相关属性和标识\n\n\n\n\n# 识别用户浏览器品牌\n\n识别用户浏览器品牌通常使用 naviator.useragent 属性\n\n\n\n\n# history 对象\n\nwindow.history 对象提供了操作浏览器会话历史的接口\n\n模拟浏览器回退按钮\n\nhistory.back() //等同于浏览器的后退按钮\nhistory.go(-1) //等同于back()\n\n\n\n# location 对象\n\nwindow.location 标识当前所在网址，可以通过给这个属性赋值命令浏览器进行页面跳转\n\n\n\n\n# 重新加载当前页面\n\n可以调用 location 的 reload 方法以重新加载当前页面，参数 true 表示强制从服务器强制加载\n\nwindow.location.reload(true)\n\n\n\n# get 请求查询参数\n\nwindow.location.search 属性即为当前浏览器的 get 请求查询参数\n\n\n\n\n# bom 特效\n\n\n# 返回顶部\n\n固定定位 定时器\n\nvar box = document.getelementbyid(\'box\')\nvar timer\nbox.onclick = function () {\n    clearinterval(timer)\n    timer = setinterval(function () {\n        document.documentelement.scrolltop -= 100\n        if (document.documentelement.scrolltop <= 0) {\n            clearinterval(timer)\n        }\n    }, 50)\n}\n\n\n\n# 楼层导航\n\n * dom 元素都有offsettop属性(htmlelement.offsettop)，表示此元素到定位祖先元素的垂直距离\n * 定位祖先元素：在祖先中，离自己最近的且拥有定位属性的元素，若祖先都不符合条件，offsetparent 为body\n * 利用 scrollto 实现 smooth(平滑滚动)\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta http-equiv="x-ua-compatible" content="ie=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>document</title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            html,\n            body {\n                height: 100%;\n            }\n            #list {\n                position: fixed;\n                right: 50px;\n                top: 50%;\n                transform: translatey(-50%);\n                list-style: none;\n            }\n            li {\n                background-color: #fd9c4c88;\n                height: 40px;\n                line-height: 40px;\n                text-align: center;\n                width: 100px;\n                color: #fff;\n                border-radius: 20px;\n                margin-bottom: 10px;\n            }\n            .contentpart {\n                width: 100%;\n                height: 100%;\n                font-size: 400px;\n                text-align: center;\n                line-height: 1024px;\n                margin-bottom: 1px;\n                background-color: black;\n                color: #fff;\n            }\n            /* 自定义属性修改css样式 */\n            /* .contentpart[data-n=\'one\']{\n           background-image:url(./1.jpg) ;\n           background-size:cover;\n        }\n        .contentpart[data-n=\'two\']{\n           background-image:url(./2.jpg) ;\n           background-size:cover;\n        }\n        .contentpart[data-n=\'three\']{\n           background-image:url(./3.jpg) ;\n           background-size:cover;\n        }\n        .contentpart[data-n=\'four\']{\n           background-image:url(./4.jpg) ;\n           background-size:cover;\n        } */\n            li.current {\n                color: yellow;\n            }\n        </style>\n    </head>\n    <body>\n        <ul id="list">\n            <li data-n="one" class="current">one</li>\n            <li data-n="two">two</li>\n            <li data-n="three">three</li>\n            <li data-n="four">four</li>\n        </ul>\n\n        <section class="contentpart" data-n="one">1</section>\n        <section class="contentpart" data-n="two">2</section>\n        <section class="contentpart" data-n="three">3</section>\n        <section class="contentpart" data-n="four">4</section>\n\n        <script>\n            // 楼层导航逻辑\n            var list = document.getelementbyid(\'list\')\n            var lis = document.queryselectorall(\'#list li\')\n            var contentparts = document.queryselectorall(\'.contentpart\')\n            list.onclick = function (e) {\n                if (e.target.tagname.tolowercase() == \'li\') {\n                    var n = e.target.getattribute(\'data-n\')\n                    var contentpart = document.queryselector(\n                        \'.contentpart[data-n=\' + n + \']\'\n                    )\n                    // 利用scrollto实现smooth(平滑滚动)\n                    window.scrollto({\n                        top: contentpart.offsettop,\n                        behavior: \'smooth\',\n                    })\n                }\n            }\n            // 导航切换\n            var offsettoparr = []\n            var nowfloor = 0\n            for (var i = 0; i < contentparts.length; i++) {\n                offsettoparr.push(contentparts[i].offsettop)\n            }\n            offsettoparr.push(infinity)\n            console.log(offsettoparr)\n            window.onscroll = function () {\n                var s = document.documentelement.scrolltop\n                for (var i = 0; i < offsettoparr.length; i++) {\n                    if (s >= offsettoparr[i] && s < offsettoparr[i + 1]) {\n                        break\n                    }\n                }\n                if (i != nowfloor) {\n                    nowfloor = i\n                    for (var j = 0; j < lis.length; j++) {\n                        if (j == i) {\n                            lis[j].classname = \'current\'\n                        } else {\n                            lis[j].classname = \'none\'\n                        }\n                    }\n                }\n            }\n        <\/script>\n    </body>\n</html>\n',charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"DOM",frontmatter:{title:"DOM",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/DOM.html",relativePath:"前端开发/JavaScript/JS基础/DOM.md",key:"v-542bb398",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/DOM.html",headers:[{level:2,title:"DOM 简介",slug:"dom-简介",normalizedTitle:"dom 简介",charIndex:41},{level:2,title:"访问元素节点",slug:"访问元素节点",normalizedTitle:"访问元素节点",charIndex:214},{level:3,title:"document 对象",slug:"document-对象",normalizedTitle:"document 对象",charIndex:225},{level:3,title:"访问元素节点的常用方法",slug:"访问元素节点的常用方法",normalizedTitle:"访问元素节点的常用方法",charIndex:378},{level:2,title:"节点的关系",slug:"节点的关系",normalizedTitle:"节点的关系",charIndex:1627},{level:3,title:"文本节点也属于节点",slug:"文本节点也属于节点",normalizedTitle:"文本节点也属于节点",charIndex:1641},{level:3,title:"排除文本节点的干扰",slug:"排除文本节点的干扰",normalizedTitle:"排除文本节点的干扰",charIndex:1761},{level:3,title:"书写常见的节点关系函数",slug:"书写常见的节点关系函数",normalizedTitle:"书写常见的节点关系函数",charIndex:1803},{level:2,title:"节点操作",slug:"节点操作",normalizedTitle:"节点操作",charIndex:4919},{level:3,title:"改变元素节点中的内容",slug:"改变元素节点中的内容",normalizedTitle:"改变元素节点中的内容",charIndex:4928},{level:3,title:"改变元素节点的 css 样式",slug:"改变元素节点的-css-样式",normalizedTitle:"改变元素节点的 css 样式",charIndex:5033},{level:3,title:"改变元素节点的 HTML 属性",slug:"改变元素节点的-html-属性",normalizedTitle:"改变元素节点的 html 属性",charIndex:5079},{level:3,title:"节点的创建",slug:"节点的创建",normalizedTitle:"节点的创建",charIndex:10289},{level:3,title:"移动节点",slug:"移动节点",normalizedTitle:"移动节点",charIndex:10747},{level:3,title:"删除节点",slug:"删除节点",normalizedTitle:"删除节点",charIndex:10920},{level:3,title:"克隆节点",slug:"克隆节点",normalizedTitle:"克隆节点",charIndex:10988},{level:2,title:"DOM 事件",slug:"dom-事件",normalizedTitle:"dom 事件",charIndex:11169},{level:3,title:"事件监听",slug:"事件监听",normalizedTitle:"事件监听",charIndex:11180},{level:3,title:"事件传播",slug:"事件传播",normalizedTitle:"事件传播",charIndex:11251},{level:3,title:"事件对象",slug:"事件对象",normalizedTitle:"事件对象",charIndex:11457},{level:3,title:"事件委托",slug:"事件委托",normalizedTitle:"事件委托",charIndex:16037},{level:3,title:"使用事件委托时需要注意的事项",slug:"使用事件委托时需要注意的事项",normalizedTitle:"使用事件委托时需要注意的事项",charIndex:17472},{level:2,title:"定时器和延时器",slug:"定时器和延时器",normalizedTitle:"定时器和延时器",charIndex:17705},{level:3,title:"定时器",slug:"定时器",normalizedTitle:"定时器",charIndex:17705},{level:3,title:"延时器",slug:"延时器",normalizedTitle:"延时器",charIndex:17709},{level:3,title:"函数节流",slug:"函数节流",normalizedTitle:"函数节流",charIndex:17984},{level:2,title:"动画效果开发",slug:"动画效果开发",normalizedTitle:"动画效果开发",charIndex:18085},{level:3,title:"无缝连续滚动特效",slug:"无缝连续滚动特效",normalizedTitle:"无缝连续滚动特效",charIndex:18096},{level:3,title:"轮播图特效",slug:"轮播图特效",normalizedTitle:"轮播图特效",charIndex:20499},{level:3,title:"呼吸轮播图",slug:"呼吸轮播图",normalizedTitle:"呼吸轮播图",charIndex:25172}],headersStr:"DOM 简介 访问元素节点 document 对象 访问元素节点的常用方法 节点的关系 文本节点也属于节点 排除文本节点的干扰 书写常见的节点关系函数 节点操作 改变元素节点中的内容 改变元素节点的 css 样式 改变元素节点的 HTML 属性 节点的创建 移动节点 删除节点 克隆节点 DOM 事件 事件监听 事件传播 事件对象 事件委托 使用事件委托时需要注意的事项 定时器和延时器 定时器 延时器 函数节流 动画效果开发 无缝连续滚动特效 轮播图特效 呼吸轮播图",content:'DOM 接口\n\n"DOM 是 JS 操控 HTML 和 CSS 的桥梁"\n\n\n# DOM 简介\n\n * DOM（ Document Object Model，文档对象模型）是 JavaScript 操作 HTML 文档的接口，使文档操作变得非常优雅、简便\n\n * DOM 最大的特点就是将文档表示为节点树\n\n\n\n\n\n * DOM 的继承关系图解\n\n\n\n * 节点的 nodeType 属性可以显示这个节点具体的类型\n\n\n\n\n# 访问元素节点\n\n\n# document 对象\n\n * document 对象是 DOM 中最重要的东西，几乎所有 DOM 的功能都封装在了 document 对象中\n\n * document 对象也表示整个 HTML 文档，它是 DOM 节点树的根\n\n * document.body 返回当前文档中的 body 元素\n\n\n# 访问元素节点的常用方法\n\n\n\n# getElementById()\n\ndocument.getElementById()功能是通过id得到元素节点\n\n\n\n * 如果页面上有相同 id 的元素，则只能得到第一个(一个页面一个 id 命名一般只能出现一次)\n * 括号里面不要写#\n * 通过 ID 获取元素的上下文只能是 document\n   \n   > 原因：拿 div 举例子，div 是 HTMLDivElement 类的一个实例，document 是 HTMLDocument 的实例。 他们的继承关系： HTMLDivElement > HTMLElement > Element > Node > EventTarget;;;;;;;; HTMLDocument > Document > Node > EventTarget 我们都知道子类继承父类，子类就可以使用父类的属性和方法。 他们相同的继承关系是 Node 和 EventTarget，也就是说他们都可以使用 Node 和 EventTarget 上的方法。 如 Node 上的 nodeName、parentNode 等，和 EventTarget 上的 addEventListener 等。 getElementById 只在 Document 类的原型上，HTMLDivElement 没有继承 Document 类，所以 div 不能使用 getElementById 方法。\n\n# getElementsByTagName()\n\ngetElementsByTagName()方法的功能是通过标签名得到节点数组\n\n\n\n * 数组方便遍历，从而可以批量操控元素节点\n * 即使页面上只有一个指定标签名的节点，也将得到长度为 1 的数组\n * 任何一个节点元素也可以调用 getElementsByTagName()方法，从而得到其内部的某种类的元素节点\n\n# getElementsByClassName()\n\ngetElementsByClassName()方法的功能是通过类名得到节点数组\n\n\n\n * 即使页面上只有一个指定类名的节点，也将得到长度为 1 的数组\n * 某个节点元素也可以调用 getElementsByClassName()方法，从而得到其内部的某类名的元素节点\n\n# querySelector()\n\nquerySelector()方法的功能是通过选择器得到元素\n\n\n\n * querySelector()方法只能得到页面上一个元素，如果有多个元素符合条件，则只能得到第一个元素\n\n * 上下文可以是 document，也可以是一个元素\n\n# querySelectorAll()\n\nquerySelectorAll()方法的功能是通过选择器得到元素数组\n\n * 即使页面上只有一个符合选择器的节点，也将得到长度为 1 的数组\n\n * 上下文可以是 document，也可以是一个元素\n\n\n# 节点的关系\n\n\n\n\n\n\n# 文本节点也属于节点\n\n * DOM 中，文本节点也属于节点，在使用节点的关系时一定要注意\n\n * 在标准的 W3C 规范中，空白文本节点也应该算作节点，但是在 IE8 及以前的浏览器中会有一定的兼容问题，它们不把空文本节点当做节点\n\n\n# 排除文本节点的干扰\n\n从 IE9 开始支持一些“只考虑元素节点”的属性\n\n\n\n\n# 书写常见的节点关系函数\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>Document</title>\n    </head>\n\n    <body>\n        <div id="box">\n            <p>我是段落</p>\n            <p>我是段落</p>\n            <p>我是段落</p>\n            <p id="fpara">我是段落fpara</p>\n            我是文本\n            \x3c!-- 我是注释 --\x3e\n            <p id="para">\n                我是段落para\n                <span>1</span>\n                <span>2</span>\n                <span>3</span>\n            </p>\n            <p>我是段落</p>\n            <p>我是段落</p>\n            <p>我是段落</p>\n        </div>\n\n        <script>\n            var box = document.getElementById(\'box\')\n            var para = document.getElementById(\'para\')\n            var fpara = document.getElementById(\'fpara\')\n\n            // 封装一个函数，这个函数可以返回元素的所有子元素节点（兼容到IE6），类似children的功能\n            function getChildren(node) {\n                // 结果数组\n                var children = []\n                // 遍历node这个节点的所有子节点，判断每一个子节点的nodeType属性是不是1\n                // 如果是1，就推入结果数组\n                for (var i = 0; i < node.childNodes.length; i++) {\n                    if (node.childNodes[i].nodeType == 1) {\n                        children.push(node.childNodes[i])\n                    }\n                }\n                return children\n            }\n\n            console.log(getChildren(box))\n            console.log(getChildren(para))\n\n            // 封装一个函数，这个函数可以返回元素的前一个元素兄弟节点（兼容到IE6），类似previousElementSibling的功能\n            function getElementPrevSibling(node) {\n                var o = node\n                // 使用while语句\n                while (o.previousSibling != null) {\n                    if (o.previousSibling.nodeType == 1) {\n                        // 结束循环，找到了\n                        return o.previousSibling\n                    }\n\n                    // 让o成为它的前一个节点，就有点“递归”的感觉\n                    o = o.previousSibling\n                }\n                return null\n            }\n\n            console.log(getElementPrevSibling(para))\n            console.log(getElementPrevSibling(fpara))\n\n            // 封装第三个函数，这个函数可以返回元素的所有元素兄弟节点\n            function getAllElementSibling(node) {\n                // 前面的元素兄弟节点\n                var prevs = []\n                // 后面的元素兄弟节点\n                var nexts = []\n\n                var o = node\n                // 遍历node的前面的节点\n                while (o.previousSibling != null) {\n                    if (o.previousSibling.nodeType == 1) {\n                        prevs.unshift(o.previousSibling)\n                    }\n                    o = o.previousSibling\n                }\n\n                o = node\n\n                // 遍历node的后面的节点\n                while (o.nextSibling != null) {\n                    if (o.nextSibling.nodeType == 1) {\n                        nexts.push(o.nextSibling)\n                    }\n                    o = o.nextSibling\n                }\n\n                // 将两个数组进行合并，然后返回\n                return prevs.concat(nexts)\n            }\n\n            console.log(getAllElementSibling(para))\n        <\/script>\n    </body>\n</html>\n\n\n\n# 节点操作\n\n\n# 改变元素节点中的内容\n\n改变元素节点中的内容可以使用两个相关属性\n\n * innerHTML 属性能以 HTML 语法设置节点中的内容\n * innerText 属性只能以纯文本的形式设置节点中的内容\n\n\n# 改变元素节点的 css 样式\n\n改变元素节点的 CSS 样式需要使用这样的语句\n\n\n\n\n# 改变元素节点的 HTML 属性\n\n * 标准 W3C 属性，如 src、href 等等，只需要直接打点进行更改即可\n\noImg.src = \'images/2.png\'\n\n\n# class 属性\n\nclass 属性需要通过 className 属性 获取和修改，而不是直接使用 el.class,修改该值将直接覆盖之前所有的类名\n\n# classList 属性\n\ndocument.getElementById(\'myDIV\').classList.add(\'mystyle\')\n\n\nclassList 属性返回元素的类名，作为 DOMTokenList 对象。\n\n该属性用于在元素中添加，移除及切换 CSS 类\n\nclassList 属性是只读的，但你可以使用 add() 和 remove() 方法修改它。\n\n * 不符合 W3C 标准的属性，要使用 setAttribute()和 getAttribute()来设置、读取\n\noBox.setAttribute(data - n, 10)\nvar n = oBox.getAttribute(data - n)\nalert(n)\n\n\n# 自定义属性 data\n\n在 HTML5 中添加了 data-*的方式来自定义属性，所谓 data-*实际上就是 data-前缀加上自定义的属性名，使用这样的结构可以进行数据存放。使用 data-*可以解决自定义属性混乱无管理 的现状。\n\n 1. 设置自定义属性的 2 种方式：\n\n（1）第一种方式是可以直接在 HTML 标签上面书写：\n\n<h2 data-weather="rain">今天下雨啦</h2>\n\n\n上面 data-weather 就是一个自定义属性，值为 rain。\n\n> 注意：如果设置的自定义属性是多个单词的组合的话，需要用中横线（-）链接，比如：\n\n<h2 data-birth-date="20201128">今天下雨啦</h2>\n\n\n（2）第二种方式是通过 js 的 dataset 属性来设置：\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <title>Document</title>\n    </head>\n    <body>\n        <h2>今天下雨啦</h2>\n        <script>\n            var h2 = document.querySelector(\'h2\')\n            h2.dataset.weather = \'rain\'\n        <\/script>\n    </body>\n</html>\n\n\n这样也是设置了一个 data-weater 的自定义属性，值为 rain，HTML5 中元素都会有一个 dataset 的属性，这是一个 DOMStringMap 类型的键值对集合。\n\n> 注意：如果设置的是多个单词的组合的话，需要使用驼峰命名法来书写，如下：\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <title>Document</title>\n    </head>\n    <body>\n        <h2>今天下雨啦</h2>\n        <script>\n            var h2 = document.querySelector(\'h2\')\n            h2.dataset.birthDate = \'20201128\'\n        <\/script>\n    </body>\n</html>\n\n\n 2. js 读取自定义属性\n\n读取的时候通过 dataset 属性，使用" . "来获取自定义属性，需要去掉 data- 前缀，连字符需要转化为驼峰命名，如下：\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <title>Document</title>\n    </head>\n    <body>\n        <h2 data-weather="rain" data-birth-date="20201128">今天下雨啦</h2>\n        <script>\n            var h2 = document.querySelector(\'h2\')\n            console.log(h2.dataset.weather) // rain\n            console.log(h2.dataset.birthDate) // 20201128\n        <\/script>\n    </body>\n</html>\n\n\n 3. CSS 也可以通过自定义属性来书写样式，如下：\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <title>Document</title>\n        <style>\n            h2[data-birth-date=\'20201128\'] {\n                color: red;\n            }\n        </style>\n    </head>\n    <body>\n        <h2 data-birth-date="20201128">今天下雨啦</h2>\n    </body>\n</html>\n\n\n 4. 自定义属性 data 一个不错的 demo\n\n> 当然也可以使用 setAttribute()和 getAttribute()来设置、读取\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <meta http-equiv="X-UA-Compatible" content="ie=edge" />\n        <title>Document</title>\n        <style>\n            div {\n                width: 300px;\n                height: 200px;\n                display: none;\n                text-align: center;\n                border: 1px solid #ccc;\n            }\n            div.php {\n                background: red;\n            }\n            div.javascript {\n                background: blue;\n            }\n            div.html {\n                background: green;\n            }\n            div.linux {\n                background: yellow;\n            }\n        </style>\n        <script>\n            window.onload = function () {\n                var aInput = document.querySelectorAll(\'input\')\n                var aDiv = document.querySelectorAll(\'div\')\n                aInput.forEach(function (val, key) {\n                    val.onclick = function () {\n                        for (var i = 0, len = aInput.length; i < len; i++) {\n                            aInput[i].style.background = \'\'\n                            aDiv[i].style.display = \'none\'\n                        }\n                        val.style.background = \'red\'\n                        // val.dataset.target 获取val元素的自定义target属性，因为自定属性里前有一个#号，所以去掉#，就变成了val.dataset.target.substring(1)\n                        // 对应的div元素Id刚好是 val 的自定义索引data-target属性去掉# 号，所以可以按照如下方法获取元素，然后进行显示\n                        document.getElementById(\n                            val.dataset.target.substring(1)\n                        ).style.display = \'block\'\n                    }\n                })\n            }\n        <\/script>\n    </head>\n    <body>\n        <input\n            type="button"\n            value="点击1"\n            data-index="1"\n            data-target="#php"\n            style="background:red;"\n        />\n        <input\n            type="button"\n            value="点击2"\n            data-index="2"\n            data-target="#javascript"\n        />\n        <input type="button" value="点击3" data-index="3" data-target="#html" />\n        <input\n            type="button"\n            value="点击4"\n            data-index="4"\n            data-target="#linux"\n        />\n        <div id="php" style="display:block" class="php">\n            php 是一门强大的后端脚本语言\n        </div>\n        <div id="javascript" class="javascript">\n            javascript 是一门强大的前端脚本语言\n        </div>\n        <div id="html" class="html">html 是一门浏览器语言</div>\n        <div id="linux" class="linux">linux 是一门强大的服务器脚本语言</div>\n    </body>\n</html>\n\n\n\n# 节点的创建\n\ndocument.createElement()方法用于创建一个指定 tagName 的 HTML 元素\n\nvar oDiv = document.createElement(\'div\')\n\n\n# “孤儿节点"\n\n * 新创建出的节点是"孤儿节点”，这意味着它并没有被挂载到 DOM 树上，我们无法看见它\n\n * 必须继续使用 appendChild() 或 insertBefore() 方法将孤儿节点插入到 DOM 树上\n\n# appendChild()\n\n任何已经在 DOM 树上的节点，都可以调用 appendChild()法，它可以将孤儿节点挂载到它的内部，成为它的最后一个节点\n\n父节点.appendChild(孤儿节点)\n\n\n# insertBefore()\n\n任何已经在 DOM 树上的节点，都可以调用 insertBefore() 方法，它可以将孤儿节点挂载到它的内部，成为它的**“标杆子节点”之前的节点**\n\n父节点.insertBefore(孤儿节点, 标杆子节点)\n\n\n\n# 移动节点\n\n * 如果将已经挂载到 DOM 树上的节点成为 appendChild()或者 insertBefore()的参数，这个节点将会被移动\n\n新父节点.appendChild(已经有父亲的节点)\n\n新父节点.insertBefore(已经有父亲的节点, 标杆子节点)\n\n\n * 这意味着一个节点不能同时位于 DOM 树的两个位置\n\n\n# 删除节点\n\n * removeChild()方法从 DOM 中删除一个子节点\n\n * 节点不能主动删除自己，必须由父节点删除它\n\n\n# 克隆节点\n\n * cloneNode() 方法可以克隆节点，克隆出的节点是 "孤儿节点“\n\nvar 孤儿节点 = 老节点.cloneNode()\n\nvar 孤儿节点 = 老节点.cloneNode(true)\n\n\n * 参数是一个布尔值，表示是否采用深度克隆：如果为 true，则该节点的所有后代节点也都会被克隆，如果为 false，则只克隆该节点本身\n\n\n# DOM 事件\n\n\n# 事件监听\n\n\n\n# 常见的鼠标事件监听\n\n\n\n# 常见的键盘事件监听\n\n\n\n# 常见的表单事件监听\n\n\n\n# 常见的页面事件监听\n\n\n\n\n# 事件传播\n\n# 当盒子嵌套时事件监听的执行顺序\n\n事件的传播是：先从外到内，然后再从内到外\n\n\n\n * onXXX 这样的写法只能监听冒泡阶段\n\n\n\n# addEventListener()方法\n\n\n\n * 最内部元素不再区分捕获和冒泡阶段，会先执行写在前面的监听，然后执行后写的监听\n * 如果给元素设置相同的两个或多个同名事件，则 DOM0 级写法后面写的会覆盖先写的;而 D0M2 级会按顺序执行\n\n\n# 事件对象\n\n * 事件处理函数提供一个形式参数，它是一个对象，封裝了本次事件的细节\n * 这个参数通常用单词 event 或字母 e 表示\n\n# 鼠标位置\n\n\n\ndemo\n\n当鼠标移入红色区域便会显示该位置的坐标（相对于事件源元素）\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>Document</title>\n        <style>\n            #root {\n                width: 500px;\n                height: 500px;\n                background-color: red;\n            }\n        </style>\n    </head>\n    <body>\n        <div id="root"></div>\n        <div id="x"></div>\n        <div id="y"></div>\n        <script>\n            var odiv = document.getElementById(\'root\')\n            var ox = document.getElementById(\'x\')\n            var oy = document.getElementById(\'y\')\n            odiv.onmousemove = function (e) {\n                x.innerText = `x：${e.offsetX}`\n                y.innerText = `y：${e.offsetY}`\n            }\n        <\/script>\n    </body>\n</html>\n\n\n# e.charCode 和 e.keyCode 属性\n\n * e.charCode 属性通常用于 onkeypress 事件中，表示用户输入的字符的“字符码”\n\n\n\n * e.keyCode 属性通常用于 onkeydown 事件和 onkeyup 中，表示用户按下的按键的“键码“\n\n\n\n * eg 按方向键可以控制页面上的盒子移动\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>Document</title>\n        <style>\n            #root {\n                width: 200px;\n                height: 200px;\n                position: absolute;\n                top: 200px;\n                left: 200px;\n                background-color: #f1f1f1;\n            }\n        </style>\n    </head>\n    <body>\n        <div id="root"></div>\n        <script>\n            var t = 200\n            var l = 200\n            var oroot = document.getElementById(\'root\')\n            document.onkeydown = function (e) {\n                switch (e.keyCode) {\n                    case 37:\n                        l -= 3\n                        break\n                    case 38:\n                        t -= 3\n                        break\n                    case 39:\n                        l += 3\n                        break\n                    case 40:\n                        t += 3\n                        break\n                }\n                oroot.style.top = t + \'px\'\n                oroot.style.left = l + \'px\'\n            }\n        <\/script>\n    </body>\n</html>\n\n\n# e.preventDefault()方法\n\n * e.preventDefault()方法用来阻止事件产生的”默认动作“\n\n * 一些特殊的业务需求，需要阻止事件的“默认动作”\n\neg:制作一个文本框，只能让用户在其中输入小写字母和数字，其他字符输入没有效果。\n\n<body>\n    <form>\n        <div id="message"></div>\n        <input type="text" name="name" id="text_id" />\n        <input type="password" id="password" />\n    </form>\n    <script>\n        var text_id = document.getElementById(\'text_id\')\n        text_id.onkeypress = function (e) {\n            if (\n                !(\n                    (e.charCode >= 48 && e.charCode <= 57) ||\n                    (e.charCode >= 97 && e.charCode <= 122)\n                )\n            )\n                e.preventDefault()\n        }\n    <\/script>\n</body>\n\n\n# e.stopPropagation()方法\n\n用来阻止事件继续传播\n\neg: 制作一个弹出层：点击按钮显示弹出层，点击网页任意地方，弹出层关闭\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>Document</title>\n        <style>\n            #button {\n                z-index: -1;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n            }\n            .mask {\n                display: none;\n                position: absolute;\n                top: 0;\n                left: 0;\n                bottom: 0;\n                right: 0;\n                background-color: rgba(0, 0, 0, 0.445);\n            }\n        </style>\n    </head>\n    <body>\n        <div class="mask"></div>\n        <button id="button">按我打开弹出层</button>\n        <script>\n            var obutton = document.getElementById(\'button\')\n            var mask = document.getElementsByClassName(\'mask\')[0]\n            obutton.onclick = function (e) {\n                mask.style.display = \'block\'\n                e.stopPropagation()\n                console.log(\'点击了按钮\')\n            }\n            document.onclick = function () {\n                mask.style.display = \'none\'\n                console.log(\'点击了网页\')\n            }\n        <\/script>\n    </body>\n</html>\n\n\n\n# 事件委托\n\n# 批量添加事件监听\n\n页面上有一个无序列表 ul，它内部共有 20 个 li 元素，请批量给它们添加点击事件监听，实现效果：点击哪个 li 元素，哪个 li 元素就变红\n\n# 批量添加事件监听的性能问题\n\n * 每一个事件监听注册都会消耗一定的系统内存，而批量添加事件会导致监听数量太多，内存消耗会非常大\n\n * 实际上，每个 li 的事件处理函数都是不同的函数，这些函数本身也会占用内存\n\n# 新增元素动态绑定事件\n\n页面上有一个无序列表 ul，它内部没有 1i 元素，请制作一个按钮，点击这个按钮就能增加一个 1i 元素。并且要求每个增加的 li 元素也要有点击事件监听，实现效果点击哪个 li 元素，哪个 1i 元素就变红\n\n# 动态绑定事件的问题\n\n * 新增元素必须分别添加事件监听，不能自动获得事件监听\n * 大量事件监听、大量事件处理函数都会产生大量消耗内存\n\n# 解决方案--事件委托\n\n * 利用事件冒泡机制，将后代元素事件委托给祖先元素\n\n\n\n * 事件委托通常需要结合使用 e.target 属性\n\n\n\neg：在下面的例子中，点击事件中，每个 li 元素就是事件源元素，而 list 就是e.currentTarget\n\n# 动态绑定事件 demo\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>Document</title>\n    </head>\n    <body>\n        <button id="btn">点击我添加列表项</button>\n        <ul id="list"></ul>\n        <script>\n            var btn = document.getElementById(\'btn\')\n            var list = document.getElementById(\'list\')\n            btn.onclick = function () {\n                var li = document.createElement(\'li\')\n                li.innerText = \'我是新来的\'\n                list.appendChild(li)\n            }\n            list.onclick = function (e) {\n                e.target.style.color = \'red\'\n            }\n        <\/script>\n    </body>\n</html>\n\n\n# 事件委托的使用场景\n\n * 当有大量类似元素需要批量添加事件监听时，使用事件委托可以减少内存开销\n\n * 当有动态元素节点上树时，使用事件委托可以让新上树的元素具有事件监听\n\n\n# 使用事件委托时需要注意的事项\n\n * 使用事件委托时要注意：不能委托不冒泡的事件给祖先元素,比如：\n\nonmouseenter 和 onmouseover 都表示“鼠标进入”, onmouseenter 不冒泡, onmouseover 冒泡。\n\nonmouseenter 这个属性天生就是“不冒泡”的，相当于你事件处理函数附加给了哪个 DOM 节点就是哪个 D0M 节点自己触发的事件，没有冒泡过程\n\n * 最内层元素不能再有额外的内层元素了，比如：\n\n\n\n\n# 定时器和延时器\n\n\n# 定时器\n\n * setInterval()函数可以重复调用一个函数，在每次调用之间具有固定的时间间隔\n\n\n\n * setInterval()函数可以接收第 3、4…个参数，它们将按顺序传入函数\n\n\n\n * 具名函数也可以传入 setInterval()\n\n\n\n# 清除定时器\n\nClearInterval()函数可以清除一个定时器\n\n\n\n\n# 延时器\n\nsetTimeout()函数可以设置一个延时器，当指定时间到了之后，会执行函数一次，不再重复执行。\n\n\n\n# 清除延时器\n\nclearTimeout()函数可以清除延时器\n\n\n# 函数节流\n\n7 分钟理解 JS 的节流、防抖及使用场景\n\n节流的意思是让函数有节制地执行，而不是毫无节制的触发一次就执行一次。什么叫有节制呢？第一次执行之后，在设定的时间之后才执行第二次。\n\n\n\n\n# 动画效果开发\n\n\n# 无缝连续滚动特效\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>Document</title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n\n            .box {\n                width: 1000px;\n                height: 130px;\n                border: 1px solid #000;\n                margin: 50px auto;\n                overflow: hidden;\n            }\n\n            .box ul {\n                list-style: none;\n                /* 设置大一点，这样li才能浮动 */\n                width: 5000px;\n                position: relative;\n            }\n\n            .box ul li {\n                float: left;\n                margin-right: 10px;\n            }\n        </style>\n    </head>\n\n    <body>\n        <div id="box" class="box">\n            <ul id="list">\n                <li><img src="images/number/0.png" alt="" /></li>\n                <li><img src="images/number/1.png" alt="" /></li>\n                <li><img src="images/number/2.png" alt="" /></li>\n                <li><img src="images/number/3.png" alt="" /></li>\n                <li><img src="images/number/4.png" alt="" /></li>\n                <li><img src="images/number/5.png" alt="" /></li>\n            </ul>\n        </div>\n        <script>\n            var box = document.getElementById(\'box\')\n            var list = document.getElementById(\'list\')\n\n            // 复制多一遍所有的li\n            list.innerHTML += list.innerHTML\n\n            // 全局变量，表示当前list的left值\n            var left = 0\n\n            // 定时器，全局变量\n            var timer\n\n            move()\n\n            // 动画封装成函数\n            function move() {\n                // 设表先关，防止动画积累\n                clearInterval(timer)\n\n                timer = setInterval(function () {\n                    left -= 4\n                    // 验收\n                    if (left <= -1260) {\n                        left = 0\n                    }\n                    list.style.left = left + \'px\'\n                }, 20)\n            }\n\n            // 鼠标进入停止定时器\n            box.onmouseenter = function () {\n                clearInterval(timer)\n            }\n\n            // 鼠标离开继续定时器\n            box.onmouseleave = function () {\n                move()\n            }\n        <\/script>\n    </body>\n</html>\n\n\ntips\n\n * timer 延时器必须是全局变量，后面鼠标移入盒子需要清楚延时器。\n * 开启延时器之前要清除延时器，防止动画积累：’设表先关‘\n\n\n# 轮播图特效\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>Document</title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            .carousel {\n                width: 650px;\n                height: 360px;\n                border: 1px solid #000;\n                margin: 50px auto;\n                position: relative;\n                overflow: hidden;\n            }\n            .carousel ul {\n                list-style: none;\n                width: 6000px;\n                position: relative;\n                left: 0px;\n                transition: left 0.5s ease 0s;\n            }\n            .carousel ul li {\n                float: left;\n            }\n            .carousel .leftbtn {\n                position: absolute;\n                left: 20px;\n                top: 50%;\n                margin-top: -25px;\n                width: 50px;\n                height: 50px;\n                background-color: rgb(28, 180, 226);\n                border-radius: 50%;\n            }\n            .carousel .rightbtn {\n                position: absolute;\n                right: 20px;\n                top: 50%;\n                margin-top: -25px;\n                width: 50px;\n                height: 50px;\n                background-color: rgb(28, 180, 226);\n                border-radius: 50%;\n            }\n        </style>\n    </head>\n    <body>\n        <div class="carousel">\n            <ul id="list">\n                <li><img src="images/beijing/0.jpg" alt="" /></li>\n                <li><img src="images/beijing/1.jpg" alt="" /></li>\n                <li><img src="images/beijing/2.jpg" alt="" /></li>\n                <li><img src="images/beijing/3.jpg" alt="" /></li>\n                <li><img src="images/beijing/4.jpg" alt="" /></li>\n            </ul>\n            <a href="javascript:;" class="leftbtn" id="leftbtn"></a>\n            <a href="javascript:;" class="rightbtn" id="rightbtn"></a>\n        </div>\n        <script>\n            // 得到按钮和ul，ul整体进行运动\n            var leftbtn = document.getElementById(\'leftbtn\')\n            var rightbtn = document.getElementById(\'rightbtn\')\n            var list = document.getElementById(\'list\')\n            // 克隆第一张图片\n            var cloneli = list.firstElementChild.cloneNode(true)\n            list.appendChild(cloneli)\n            // 当前ul显示到第几张了，从0开始数\n            var idx = 0\n            // 节流锁\n            var lock = true\n            // 右边按钮监听\n            rightbtn.onclick = function () {\n                // 判断锁的状态\n                if (!lock) return\n                lock = false\n                // 给list加过渡，为什么要加？？css中不是已经加了么？？这是因为最后一张图片会把过渡去掉\n                list.style.transition = \'left .5s ease 0s\'\n                idx++\n                if (idx > 4) {\n                    // 设置一个延时器，延时器的功能就是将ul瞬间拉回0的位置，延时器的目的就是让过渡动画结束之后\n                    setTimeout(function () {\n                        // 取消掉过渡，因为要的是瞬间移动，不是“咕噜”回去\n                        list.style.transition = \'none\'\n                        list.style.left = 0\n                        idx = 0\n                    }, 500)\n                }\n                list.style.left = -idx * 650 + \'px\'\n                // 函数节流\n                setTimeout(function () {\n                    lock = true\n                }, 500)\n            }\n            // 左边按钮监听\n            leftbtn.onclick = function () {\n                if (!lock) return\n                lock = false\n                // 判断是不是第0张，如果是，就要瞬间用假的替换真的\n                if (idx == 0) {\n                    // 取消掉过渡，因为要的是瞬间移动，不是“咕噜”过去\n                    list.style.transition = \'none\'\n                    // 直接瞬间移动到最后的假图片上\n                    list.style.left = -5 * 650 + \'px\'\n                    // 设置一个延时器，这个延时器的延时时间可以是0毫秒，虽然是0毫秒，但是可以让我们过渡先是瞬间取消，然后再加上\n                    setTimeout(function () {\n                        // 加过渡\n                        list.style.transition = \'left .5s ease 0s\'\n                        // idx改为真正的最后一张\n                        idx = 4\n                        list.style.left = -idx * 650 + \'px\'\n                    }, 0)\n                } else {\n                    idx--\n                    list.style.left = -idx * 650 + \'px\'\n                }\n                // 函数节流\n                setTimeout(function () {\n                    lock = true\n                }, 500)\n            }\n        <\/script>\n    </body>\n</html>\n\n\ntips\n\n * 获取元素的第一个子节点使用 element.firstElementChild\n * 关于 setTimeout(function(),0):同步代码转异步代码，很常用的技巧。这是为了手动调配优先级不高的代码靠后执行\n * 函数节流的用法，第一次执行之后，在设定的时间之后才执行第二次，重点就是开关锁\n * 左右按钮的写法不一样，尤其注意是否采用if...else写法！\n\n\n# 呼吸轮播图\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>Document</title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n\n            .carousel {\n                width: 650px;\n                height: 360px;\n                border: 1px solid #000;\n                margin: 50px auto;\n                position: relative;\n            }\n\n            .carousel ul {\n                list-style: none;\n            }\n\n            .carousel ul li {\n                position: absolute;\n                top: 0;\n                left: 0;\n                /* 透明度都是0 */\n                opacity: 0;\n                transition: opacity 1s ease 0s;\n            }\n\n            /* 只有第一张透明度是1 */\n            .carousel ul li:first-child {\n                opacity: 1;\n            }\n\n            .carousel .leftbtn {\n                position: absolute;\n                left: 20px;\n                top: 50%;\n                margin-top: -25px;\n                width: 50px;\n                height: 50px;\n                background-color: rgb(28, 180, 226);\n                border-radius: 50%;\n            }\n\n            .carousel .rightbtn {\n                position: absolute;\n                right: 20px;\n                top: 50%;\n                margin-top: -25px;\n                width: 50px;\n                height: 50px;\n                background-color: rgb(28, 180, 226);\n                border-radius: 50%;\n            }\n        </style>\n    </head>\n\n    <body>\n        <div class="carousel">\n            <ul id="list">\n                <li><img src="images/beijing/0.jpg" alt="" /></li>\n                <li><img src="images/beijing/1.jpg" alt="" /></li>\n                <li><img src="images/beijing/2.jpg" alt="" /></li>\n                <li><img src="images/beijing/3.jpg" alt="" /></li>\n                <li><img src="images/beijing/4.jpg" alt="" /></li>\n            </ul>\n            <a href="javascript:;" class="leftbtn" id="leftbtn"></a>\n            <a href="javascript:;" class="rightbtn" id="rightbtn"></a>\n        </div>\n        <script>\n            // 得到按钮和ul，ul整体进行运动\n            var leftbtn = document.getElementById(\'leftbtn\')\n            var rightbtn = document.getElementById(\'rightbtn\')\n            var list = document.getElementById(\'list\')\n            var lis = list.getElementsByTagName(\'li\')\n\n            // 当前是第几张图显示\n            var idx = 0\n\n            // 节流\n            var lock = true\n\n            // 右按钮\n            rightbtn.onclick = function () {\n                // 判断节流\n                if (!lock) return\n\n                lock = false\n\n                // 还没有改idx，此时的idx这个图片就是老图，老图淡出\n                lis[idx].style.opacity = 0\n                idx++\n                if (idx > 4) idx = 0\n                // 改了idx，此时的idx这个图片就是新图，新图淡入\n                lis[idx].style.opacity = 1\n\n                // 动画结束之后，开锁\n                setTimeout(function () {\n                    lock = true\n                }, 1000)\n            }\n\n            // 左按钮\n            leftbtn.onclick = function () {\n                // 判断节流\n                if (!lock) return\n\n                lock = false\n\n                // 还没有改idx，此时的idx这个图片就是老图，老图淡出\n                lis[idx].style.opacity = 0\n                idx--\n                if (idx < 0) idx = 4\n                // 改了idx，此时的idx这个图片就是新图，新图淡入\n                lis[idx].style.opacity = 1\n\n                // 动画结束之后，开锁\n                setTimeout(function () {\n                    lock = true\n                }, 1000)\n            }\n        <\/script>\n    </body>\n</html>\n',normalizedContent:'dom 接口\n\n"dom 是 js 操控 html 和 css 的桥梁"\n\n\n# dom 简介\n\n * dom（ document object model，文档对象模型）是 javascript 操作 html 文档的接口，使文档操作变得非常优雅、简便\n\n * dom 最大的特点就是将文档表示为节点树\n\n\n\n\n\n * dom 的继承关系图解\n\n\n\n * 节点的 nodetype 属性可以显示这个节点具体的类型\n\n\n\n\n# 访问元素节点\n\n\n# document 对象\n\n * document 对象是 dom 中最重要的东西，几乎所有 dom 的功能都封装在了 document 对象中\n\n * document 对象也表示整个 html 文档，它是 dom 节点树的根\n\n * document.body 返回当前文档中的 body 元素\n\n\n# 访问元素节点的常用方法\n\n\n\n# getelementbyid()\n\ndocument.getelementbyid()功能是通过id得到元素节点\n\n\n\n * 如果页面上有相同 id 的元素，则只能得到第一个(一个页面一个 id 命名一般只能出现一次)\n * 括号里面不要写#\n * 通过 id 获取元素的上下文只能是 document\n   \n   > 原因：拿 div 举例子，div 是 htmldivelement 类的一个实例，document 是 htmldocument 的实例。 他们的继承关系： htmldivelement > htmlelement > element > node > eventtarget;;;;;;;; htmldocument > document > node > eventtarget 我们都知道子类继承父类，子类就可以使用父类的属性和方法。 他们相同的继承关系是 node 和 eventtarget，也就是说他们都可以使用 node 和 eventtarget 上的方法。 如 node 上的 nodename、parentnode 等，和 eventtarget 上的 addeventlistener 等。 getelementbyid 只在 document 类的原型上，htmldivelement 没有继承 document 类，所以 div 不能使用 getelementbyid 方法。\n\n# getelementsbytagname()\n\ngetelementsbytagname()方法的功能是通过标签名得到节点数组\n\n\n\n * 数组方便遍历，从而可以批量操控元素节点\n * 即使页面上只有一个指定标签名的节点，也将得到长度为 1 的数组\n * 任何一个节点元素也可以调用 getelementsbytagname()方法，从而得到其内部的某种类的元素节点\n\n# getelementsbyclassname()\n\ngetelementsbyclassname()方法的功能是通过类名得到节点数组\n\n\n\n * 即使页面上只有一个指定类名的节点，也将得到长度为 1 的数组\n * 某个节点元素也可以调用 getelementsbyclassname()方法，从而得到其内部的某类名的元素节点\n\n# queryselector()\n\nqueryselector()方法的功能是通过选择器得到元素\n\n\n\n * queryselector()方法只能得到页面上一个元素，如果有多个元素符合条件，则只能得到第一个元素\n\n * 上下文可以是 document，也可以是一个元素\n\n# queryselectorall()\n\nqueryselectorall()方法的功能是通过选择器得到元素数组\n\n * 即使页面上只有一个符合选择器的节点，也将得到长度为 1 的数组\n\n * 上下文可以是 document，也可以是一个元素\n\n\n# 节点的关系\n\n\n\n\n\n\n# 文本节点也属于节点\n\n * dom 中，文本节点也属于节点，在使用节点的关系时一定要注意\n\n * 在标准的 w3c 规范中，空白文本节点也应该算作节点，但是在 ie8 及以前的浏览器中会有一定的兼容问题，它们不把空文本节点当做节点\n\n\n# 排除文本节点的干扰\n\n从 ie9 开始支持一些“只考虑元素节点”的属性\n\n\n\n\n# 书写常见的节点关系函数\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>document</title>\n    </head>\n\n    <body>\n        <div id="box">\n            <p>我是段落</p>\n            <p>我是段落</p>\n            <p>我是段落</p>\n            <p id="fpara">我是段落fpara</p>\n            我是文本\n            \x3c!-- 我是注释 --\x3e\n            <p id="para">\n                我是段落para\n                <span>1</span>\n                <span>2</span>\n                <span>3</span>\n            </p>\n            <p>我是段落</p>\n            <p>我是段落</p>\n            <p>我是段落</p>\n        </div>\n\n        <script>\n            var box = document.getelementbyid(\'box\')\n            var para = document.getelementbyid(\'para\')\n            var fpara = document.getelementbyid(\'fpara\')\n\n            // 封装一个函数，这个函数可以返回元素的所有子元素节点（兼容到ie6），类似children的功能\n            function getchildren(node) {\n                // 结果数组\n                var children = []\n                // 遍历node这个节点的所有子节点，判断每一个子节点的nodetype属性是不是1\n                // 如果是1，就推入结果数组\n                for (var i = 0; i < node.childnodes.length; i++) {\n                    if (node.childnodes[i].nodetype == 1) {\n                        children.push(node.childnodes[i])\n                    }\n                }\n                return children\n            }\n\n            console.log(getchildren(box))\n            console.log(getchildren(para))\n\n            // 封装一个函数，这个函数可以返回元素的前一个元素兄弟节点（兼容到ie6），类似previouselementsibling的功能\n            function getelementprevsibling(node) {\n                var o = node\n                // 使用while语句\n                while (o.previoussibling != null) {\n                    if (o.previoussibling.nodetype == 1) {\n                        // 结束循环，找到了\n                        return o.previoussibling\n                    }\n\n                    // 让o成为它的前一个节点，就有点“递归”的感觉\n                    o = o.previoussibling\n                }\n                return null\n            }\n\n            console.log(getelementprevsibling(para))\n            console.log(getelementprevsibling(fpara))\n\n            // 封装第三个函数，这个函数可以返回元素的所有元素兄弟节点\n            function getallelementsibling(node) {\n                // 前面的元素兄弟节点\n                var prevs = []\n                // 后面的元素兄弟节点\n                var nexts = []\n\n                var o = node\n                // 遍历node的前面的节点\n                while (o.previoussibling != null) {\n                    if (o.previoussibling.nodetype == 1) {\n                        prevs.unshift(o.previoussibling)\n                    }\n                    o = o.previoussibling\n                }\n\n                o = node\n\n                // 遍历node的后面的节点\n                while (o.nextsibling != null) {\n                    if (o.nextsibling.nodetype == 1) {\n                        nexts.push(o.nextsibling)\n                    }\n                    o = o.nextsibling\n                }\n\n                // 将两个数组进行合并，然后返回\n                return prevs.concat(nexts)\n            }\n\n            console.log(getallelementsibling(para))\n        <\/script>\n    </body>\n</html>\n\n\n\n# 节点操作\n\n\n# 改变元素节点中的内容\n\n改变元素节点中的内容可以使用两个相关属性\n\n * innerhtml 属性能以 html 语法设置节点中的内容\n * innertext 属性只能以纯文本的形式设置节点中的内容\n\n\n# 改变元素节点的 css 样式\n\n改变元素节点的 css 样式需要使用这样的语句\n\n\n\n\n# 改变元素节点的 html 属性\n\n * 标准 w3c 属性，如 src、href 等等，只需要直接打点进行更改即可\n\noimg.src = \'images/2.png\'\n\n\n# class 属性\n\nclass 属性需要通过 classname 属性 获取和修改，而不是直接使用 el.class,修改该值将直接覆盖之前所有的类名\n\n# classlist 属性\n\ndocument.getelementbyid(\'mydiv\').classlist.add(\'mystyle\')\n\n\nclasslist 属性返回元素的类名，作为 domtokenlist 对象。\n\n该属性用于在元素中添加，移除及切换 css 类\n\nclasslist 属性是只读的，但你可以使用 add() 和 remove() 方法修改它。\n\n * 不符合 w3c 标准的属性，要使用 setattribute()和 getattribute()来设置、读取\n\nobox.setattribute(data - n, 10)\nvar n = obox.getattribute(data - n)\nalert(n)\n\n\n# 自定义属性 data\n\n在 html5 中添加了 data-*的方式来自定义属性，所谓 data-*实际上就是 data-前缀加上自定义的属性名，使用这样的结构可以进行数据存放。使用 data-*可以解决自定义属性混乱无管理 的现状。\n\n 1. 设置自定义属性的 2 种方式：\n\n（1）第一种方式是可以直接在 html 标签上面书写：\n\n<h2 data-weather="rain">今天下雨啦</h2>\n\n\n上面 data-weather 就是一个自定义属性，值为 rain。\n\n> 注意：如果设置的自定义属性是多个单词的组合的话，需要用中横线（-）链接，比如：\n\n<h2 data-birth-date="20201128">今天下雨啦</h2>\n\n\n（2）第二种方式是通过 js 的 dataset 属性来设置：\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <title>document</title>\n    </head>\n    <body>\n        <h2>今天下雨啦</h2>\n        <script>\n            var h2 = document.queryselector(\'h2\')\n            h2.dataset.weather = \'rain\'\n        <\/script>\n    </body>\n</html>\n\n\n这样也是设置了一个 data-weater 的自定义属性，值为 rain，html5 中元素都会有一个 dataset 的属性，这是一个 domstringmap 类型的键值对集合。\n\n> 注意：如果设置的是多个单词的组合的话，需要使用驼峰命名法来书写，如下：\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <title>document</title>\n    </head>\n    <body>\n        <h2>今天下雨啦</h2>\n        <script>\n            var h2 = document.queryselector(\'h2\')\n            h2.dataset.birthdate = \'20201128\'\n        <\/script>\n    </body>\n</html>\n\n\n 2. js 读取自定义属性\n\n读取的时候通过 dataset 属性，使用" . "来获取自定义属性，需要去掉 data- 前缀，连字符需要转化为驼峰命名，如下：\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <title>document</title>\n    </head>\n    <body>\n        <h2 data-weather="rain" data-birth-date="20201128">今天下雨啦</h2>\n        <script>\n            var h2 = document.queryselector(\'h2\')\n            console.log(h2.dataset.weather) // rain\n            console.log(h2.dataset.birthdate) // 20201128\n        <\/script>\n    </body>\n</html>\n\n\n 3. css 也可以通过自定义属性来书写样式，如下：\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <title>document</title>\n        <style>\n            h2[data-birth-date=\'20201128\'] {\n                color: red;\n            }\n        </style>\n    </head>\n    <body>\n        <h2 data-birth-date="20201128">今天下雨啦</h2>\n    </body>\n</html>\n\n\n 4. 自定义属性 data 一个不错的 demo\n\n> 当然也可以使用 setattribute()和 getattribute()来设置、读取\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <meta http-equiv="x-ua-compatible" content="ie=edge" />\n        <title>document</title>\n        <style>\n            div {\n                width: 300px;\n                height: 200px;\n                display: none;\n                text-align: center;\n                border: 1px solid #ccc;\n            }\n            div.php {\n                background: red;\n            }\n            div.javascript {\n                background: blue;\n            }\n            div.html {\n                background: green;\n            }\n            div.linux {\n                background: yellow;\n            }\n        </style>\n        <script>\n            window.onload = function () {\n                var ainput = document.queryselectorall(\'input\')\n                var adiv = document.queryselectorall(\'div\')\n                ainput.foreach(function (val, key) {\n                    val.onclick = function () {\n                        for (var i = 0, len = ainput.length; i < len; i++) {\n                            ainput[i].style.background = \'\'\n                            adiv[i].style.display = \'none\'\n                        }\n                        val.style.background = \'red\'\n                        // val.dataset.target 获取val元素的自定义target属性，因为自定属性里前有一个#号，所以去掉#，就变成了val.dataset.target.substring(1)\n                        // 对应的div元素id刚好是 val 的自定义索引data-target属性去掉# 号，所以可以按照如下方法获取元素，然后进行显示\n                        document.getelementbyid(\n                            val.dataset.target.substring(1)\n                        ).style.display = \'block\'\n                    }\n                })\n            }\n        <\/script>\n    </head>\n    <body>\n        <input\n            type="button"\n            value="点击1"\n            data-index="1"\n            data-target="#php"\n            style="background:red;"\n        />\n        <input\n            type="button"\n            value="点击2"\n            data-index="2"\n            data-target="#javascript"\n        />\n        <input type="button" value="点击3" data-index="3" data-target="#html" />\n        <input\n            type="button"\n            value="点击4"\n            data-index="4"\n            data-target="#linux"\n        />\n        <div id="php" style="display:block" class="php">\n            php 是一门强大的后端脚本语言\n        </div>\n        <div id="javascript" class="javascript">\n            javascript 是一门强大的前端脚本语言\n        </div>\n        <div id="html" class="html">html 是一门浏览器语言</div>\n        <div id="linux" class="linux">linux 是一门强大的服务器脚本语言</div>\n    </body>\n</html>\n\n\n\n# 节点的创建\n\ndocument.createelement()方法用于创建一个指定 tagname 的 html 元素\n\nvar odiv = document.createelement(\'div\')\n\n\n# “孤儿节点"\n\n * 新创建出的节点是"孤儿节点”，这意味着它并没有被挂载到 dom 树上，我们无法看见它\n\n * 必须继续使用 appendchild() 或 insertbefore() 方法将孤儿节点插入到 dom 树上\n\n# appendchild()\n\n任何已经在 dom 树上的节点，都可以调用 appendchild()法，它可以将孤儿节点挂载到它的内部，成为它的最后一个节点\n\n父节点.appendchild(孤儿节点)\n\n\n# insertbefore()\n\n任何已经在 dom 树上的节点，都可以调用 insertbefore() 方法，它可以将孤儿节点挂载到它的内部，成为它的**“标杆子节点”之前的节点**\n\n父节点.insertbefore(孤儿节点, 标杆子节点)\n\n\n\n# 移动节点\n\n * 如果将已经挂载到 dom 树上的节点成为 appendchild()或者 insertbefore()的参数，这个节点将会被移动\n\n新父节点.appendchild(已经有父亲的节点)\n\n新父节点.insertbefore(已经有父亲的节点, 标杆子节点)\n\n\n * 这意味着一个节点不能同时位于 dom 树的两个位置\n\n\n# 删除节点\n\n * removechild()方法从 dom 中删除一个子节点\n\n * 节点不能主动删除自己，必须由父节点删除它\n\n\n# 克隆节点\n\n * clonenode() 方法可以克隆节点，克隆出的节点是 "孤儿节点“\n\nvar 孤儿节点 = 老节点.clonenode()\n\nvar 孤儿节点 = 老节点.clonenode(true)\n\n\n * 参数是一个布尔值，表示是否采用深度克隆：如果为 true，则该节点的所有后代节点也都会被克隆，如果为 false，则只克隆该节点本身\n\n\n# dom 事件\n\n\n# 事件监听\n\n\n\n# 常见的鼠标事件监听\n\n\n\n# 常见的键盘事件监听\n\n\n\n# 常见的表单事件监听\n\n\n\n# 常见的页面事件监听\n\n\n\n\n# 事件传播\n\n# 当盒子嵌套时事件监听的执行顺序\n\n事件的传播是：先从外到内，然后再从内到外\n\n\n\n * onxxx 这样的写法只能监听冒泡阶段\n\n\n\n# addeventlistener()方法\n\n\n\n * 最内部元素不再区分捕获和冒泡阶段，会先执行写在前面的监听，然后执行后写的监听\n * 如果给元素设置相同的两个或多个同名事件，则 dom0 级写法后面写的会覆盖先写的;而 d0m2 级会按顺序执行\n\n\n# 事件对象\n\n * 事件处理函数提供一个形式参数，它是一个对象，封裝了本次事件的细节\n * 这个参数通常用单词 event 或字母 e 表示\n\n# 鼠标位置\n\n\n\ndemo\n\n当鼠标移入红色区域便会显示该位置的坐标（相对于事件源元素）\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta http-equiv="x-ua-compatible" content="ie=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>document</title>\n        <style>\n            #root {\n                width: 500px;\n                height: 500px;\n                background-color: red;\n            }\n        </style>\n    </head>\n    <body>\n        <div id="root"></div>\n        <div id="x"></div>\n        <div id="y"></div>\n        <script>\n            var odiv = document.getelementbyid(\'root\')\n            var ox = document.getelementbyid(\'x\')\n            var oy = document.getelementbyid(\'y\')\n            odiv.onmousemove = function (e) {\n                x.innertext = `x：${e.offsetx}`\n                y.innertext = `y：${e.offsety}`\n            }\n        <\/script>\n    </body>\n</html>\n\n\n# e.charcode 和 e.keycode 属性\n\n * e.charcode 属性通常用于 onkeypress 事件中，表示用户输入的字符的“字符码”\n\n\n\n * e.keycode 属性通常用于 onkeydown 事件和 onkeyup 中，表示用户按下的按键的“键码“\n\n\n\n * eg 按方向键可以控制页面上的盒子移动\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta http-equiv="x-ua-compatible" content="ie=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>document</title>\n        <style>\n            #root {\n                width: 200px;\n                height: 200px;\n                position: absolute;\n                top: 200px;\n                left: 200px;\n                background-color: #f1f1f1;\n            }\n        </style>\n    </head>\n    <body>\n        <div id="root"></div>\n        <script>\n            var t = 200\n            var l = 200\n            var oroot = document.getelementbyid(\'root\')\n            document.onkeydown = function (e) {\n                switch (e.keycode) {\n                    case 37:\n                        l -= 3\n                        break\n                    case 38:\n                        t -= 3\n                        break\n                    case 39:\n                        l += 3\n                        break\n                    case 40:\n                        t += 3\n                        break\n                }\n                oroot.style.top = t + \'px\'\n                oroot.style.left = l + \'px\'\n            }\n        <\/script>\n    </body>\n</html>\n\n\n# e.preventdefault()方法\n\n * e.preventdefault()方法用来阻止事件产生的”默认动作“\n\n * 一些特殊的业务需求，需要阻止事件的“默认动作”\n\neg:制作一个文本框，只能让用户在其中输入小写字母和数字，其他字符输入没有效果。\n\n<body>\n    <form>\n        <div id="message"></div>\n        <input type="text" name="name" id="text_id" />\n        <input type="password" id="password" />\n    </form>\n    <script>\n        var text_id = document.getelementbyid(\'text_id\')\n        text_id.onkeypress = function (e) {\n            if (\n                !(\n                    (e.charcode >= 48 && e.charcode <= 57) ||\n                    (e.charcode >= 97 && e.charcode <= 122)\n                )\n            )\n                e.preventdefault()\n        }\n    <\/script>\n</body>\n\n\n# e.stoppropagation()方法\n\n用来阻止事件继续传播\n\neg: 制作一个弹出层：点击按钮显示弹出层，点击网页任意地方，弹出层关闭\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta http-equiv="x-ua-compatible" content="ie=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>document</title>\n        <style>\n            #button {\n                z-index: -1;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n            }\n            .mask {\n                display: none;\n                position: absolute;\n                top: 0;\n                left: 0;\n                bottom: 0;\n                right: 0;\n                background-color: rgba(0, 0, 0, 0.445);\n            }\n        </style>\n    </head>\n    <body>\n        <div class="mask"></div>\n        <button id="button">按我打开弹出层</button>\n        <script>\n            var obutton = document.getelementbyid(\'button\')\n            var mask = document.getelementsbyclassname(\'mask\')[0]\n            obutton.onclick = function (e) {\n                mask.style.display = \'block\'\n                e.stoppropagation()\n                console.log(\'点击了按钮\')\n            }\n            document.onclick = function () {\n                mask.style.display = \'none\'\n                console.log(\'点击了网页\')\n            }\n        <\/script>\n    </body>\n</html>\n\n\n\n# 事件委托\n\n# 批量添加事件监听\n\n页面上有一个无序列表 ul，它内部共有 20 个 li 元素，请批量给它们添加点击事件监听，实现效果：点击哪个 li 元素，哪个 li 元素就变红\n\n# 批量添加事件监听的性能问题\n\n * 每一个事件监听注册都会消耗一定的系统内存，而批量添加事件会导致监听数量太多，内存消耗会非常大\n\n * 实际上，每个 li 的事件处理函数都是不同的函数，这些函数本身也会占用内存\n\n# 新增元素动态绑定事件\n\n页面上有一个无序列表 ul，它内部没有 1i 元素，请制作一个按钮，点击这个按钮就能增加一个 1i 元素。并且要求每个增加的 li 元素也要有点击事件监听，实现效果点击哪个 li 元素，哪个 1i 元素就变红\n\n# 动态绑定事件的问题\n\n * 新增元素必须分别添加事件监听，不能自动获得事件监听\n * 大量事件监听、大量事件处理函数都会产生大量消耗内存\n\n# 解决方案--事件委托\n\n * 利用事件冒泡机制，将后代元素事件委托给祖先元素\n\n\n\n * 事件委托通常需要结合使用 e.target 属性\n\n\n\neg：在下面的例子中，点击事件中，每个 li 元素就是事件源元素，而 list 就是e.currenttarget\n\n# 动态绑定事件 demo\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta http-equiv="x-ua-compatible" content="ie=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>document</title>\n    </head>\n    <body>\n        <button id="btn">点击我添加列表项</button>\n        <ul id="list"></ul>\n        <script>\n            var btn = document.getelementbyid(\'btn\')\n            var list = document.getelementbyid(\'list\')\n            btn.onclick = function () {\n                var li = document.createelement(\'li\')\n                li.innertext = \'我是新来的\'\n                list.appendchild(li)\n            }\n            list.onclick = function (e) {\n                e.target.style.color = \'red\'\n            }\n        <\/script>\n    </body>\n</html>\n\n\n# 事件委托的使用场景\n\n * 当有大量类似元素需要批量添加事件监听时，使用事件委托可以减少内存开销\n\n * 当有动态元素节点上树时，使用事件委托可以让新上树的元素具有事件监听\n\n\n# 使用事件委托时需要注意的事项\n\n * 使用事件委托时要注意：不能委托不冒泡的事件给祖先元素,比如：\n\nonmouseenter 和 onmouseover 都表示“鼠标进入”, onmouseenter 不冒泡, onmouseover 冒泡。\n\nonmouseenter 这个属性天生就是“不冒泡”的，相当于你事件处理函数附加给了哪个 dom 节点就是哪个 d0m 节点自己触发的事件，没有冒泡过程\n\n * 最内层元素不能再有额外的内层元素了，比如：\n\n\n\n\n# 定时器和延时器\n\n\n# 定时器\n\n * setinterval()函数可以重复调用一个函数，在每次调用之间具有固定的时间间隔\n\n\n\n * setinterval()函数可以接收第 3、4…个参数，它们将按顺序传入函数\n\n\n\n * 具名函数也可以传入 setinterval()\n\n\n\n# 清除定时器\n\nclearinterval()函数可以清除一个定时器\n\n\n\n\n# 延时器\n\nsettimeout()函数可以设置一个延时器，当指定时间到了之后，会执行函数一次，不再重复执行。\n\n\n\n# 清除延时器\n\ncleartimeout()函数可以清除延时器\n\n\n# 函数节流\n\n7 分钟理解 js 的节流、防抖及使用场景\n\n节流的意思是让函数有节制地执行，而不是毫无节制的触发一次就执行一次。什么叫有节制呢？第一次执行之后，在设定的时间之后才执行第二次。\n\n\n\n\n# 动画效果开发\n\n\n# 无缝连续滚动特效\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>document</title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n\n            .box {\n                width: 1000px;\n                height: 130px;\n                border: 1px solid #000;\n                margin: 50px auto;\n                overflow: hidden;\n            }\n\n            .box ul {\n                list-style: none;\n                /* 设置大一点，这样li才能浮动 */\n                width: 5000px;\n                position: relative;\n            }\n\n            .box ul li {\n                float: left;\n                margin-right: 10px;\n            }\n        </style>\n    </head>\n\n    <body>\n        <div id="box" class="box">\n            <ul id="list">\n                <li><img src="images/number/0.png" alt="" /></li>\n                <li><img src="images/number/1.png" alt="" /></li>\n                <li><img src="images/number/2.png" alt="" /></li>\n                <li><img src="images/number/3.png" alt="" /></li>\n                <li><img src="images/number/4.png" alt="" /></li>\n                <li><img src="images/number/5.png" alt="" /></li>\n            </ul>\n        </div>\n        <script>\n            var box = document.getelementbyid(\'box\')\n            var list = document.getelementbyid(\'list\')\n\n            // 复制多一遍所有的li\n            list.innerhtml += list.innerhtml\n\n            // 全局变量，表示当前list的left值\n            var left = 0\n\n            // 定时器，全局变量\n            var timer\n\n            move()\n\n            // 动画封装成函数\n            function move() {\n                // 设表先关，防止动画积累\n                clearinterval(timer)\n\n                timer = setinterval(function () {\n                    left -= 4\n                    // 验收\n                    if (left <= -1260) {\n                        left = 0\n                    }\n                    list.style.left = left + \'px\'\n                }, 20)\n            }\n\n            // 鼠标进入停止定时器\n            box.onmouseenter = function () {\n                clearinterval(timer)\n            }\n\n            // 鼠标离开继续定时器\n            box.onmouseleave = function () {\n                move()\n            }\n        <\/script>\n    </body>\n</html>\n\n\ntips\n\n * timer 延时器必须是全局变量，后面鼠标移入盒子需要清楚延时器。\n * 开启延时器之前要清除延时器，防止动画积累：’设表先关‘\n\n\n# 轮播图特效\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>document</title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n            .carousel {\n                width: 650px;\n                height: 360px;\n                border: 1px solid #000;\n                margin: 50px auto;\n                position: relative;\n                overflow: hidden;\n            }\n            .carousel ul {\n                list-style: none;\n                width: 6000px;\n                position: relative;\n                left: 0px;\n                transition: left 0.5s ease 0s;\n            }\n            .carousel ul li {\n                float: left;\n            }\n            .carousel .leftbtn {\n                position: absolute;\n                left: 20px;\n                top: 50%;\n                margin-top: -25px;\n                width: 50px;\n                height: 50px;\n                background-color: rgb(28, 180, 226);\n                border-radius: 50%;\n            }\n            .carousel .rightbtn {\n                position: absolute;\n                right: 20px;\n                top: 50%;\n                margin-top: -25px;\n                width: 50px;\n                height: 50px;\n                background-color: rgb(28, 180, 226);\n                border-radius: 50%;\n            }\n        </style>\n    </head>\n    <body>\n        <div class="carousel">\n            <ul id="list">\n                <li><img src="images/beijing/0.jpg" alt="" /></li>\n                <li><img src="images/beijing/1.jpg" alt="" /></li>\n                <li><img src="images/beijing/2.jpg" alt="" /></li>\n                <li><img src="images/beijing/3.jpg" alt="" /></li>\n                <li><img src="images/beijing/4.jpg" alt="" /></li>\n            </ul>\n            <a href="javascript:;" class="leftbtn" id="leftbtn"></a>\n            <a href="javascript:;" class="rightbtn" id="rightbtn"></a>\n        </div>\n        <script>\n            // 得到按钮和ul，ul整体进行运动\n            var leftbtn = document.getelementbyid(\'leftbtn\')\n            var rightbtn = document.getelementbyid(\'rightbtn\')\n            var list = document.getelementbyid(\'list\')\n            // 克隆第一张图片\n            var cloneli = list.firstelementchild.clonenode(true)\n            list.appendchild(cloneli)\n            // 当前ul显示到第几张了，从0开始数\n            var idx = 0\n            // 节流锁\n            var lock = true\n            // 右边按钮监听\n            rightbtn.onclick = function () {\n                // 判断锁的状态\n                if (!lock) return\n                lock = false\n                // 给list加过渡，为什么要加？？css中不是已经加了么？？这是因为最后一张图片会把过渡去掉\n                list.style.transition = \'left .5s ease 0s\'\n                idx++\n                if (idx > 4) {\n                    // 设置一个延时器，延时器的功能就是将ul瞬间拉回0的位置，延时器的目的就是让过渡动画结束之后\n                    settimeout(function () {\n                        // 取消掉过渡，因为要的是瞬间移动，不是“咕噜”回去\n                        list.style.transition = \'none\'\n                        list.style.left = 0\n                        idx = 0\n                    }, 500)\n                }\n                list.style.left = -idx * 650 + \'px\'\n                // 函数节流\n                settimeout(function () {\n                    lock = true\n                }, 500)\n            }\n            // 左边按钮监听\n            leftbtn.onclick = function () {\n                if (!lock) return\n                lock = false\n                // 判断是不是第0张，如果是，就要瞬间用假的替换真的\n                if (idx == 0) {\n                    // 取消掉过渡，因为要的是瞬间移动，不是“咕噜”过去\n                    list.style.transition = \'none\'\n                    // 直接瞬间移动到最后的假图片上\n                    list.style.left = -5 * 650 + \'px\'\n                    // 设置一个延时器，这个延时器的延时时间可以是0毫秒，虽然是0毫秒，但是可以让我们过渡先是瞬间取消，然后再加上\n                    settimeout(function () {\n                        // 加过渡\n                        list.style.transition = \'left .5s ease 0s\'\n                        // idx改为真正的最后一张\n                        idx = 4\n                        list.style.left = -idx * 650 + \'px\'\n                    }, 0)\n                } else {\n                    idx--\n                    list.style.left = -idx * 650 + \'px\'\n                }\n                // 函数节流\n                settimeout(function () {\n                    lock = true\n                }, 500)\n            }\n        <\/script>\n    </body>\n</html>\n\n\ntips\n\n * 获取元素的第一个子节点使用 element.firstelementchild\n * 关于 settimeout(function(),0):同步代码转异步代码，很常用的技巧。这是为了手动调配优先级不高的代码靠后执行\n * 函数节流的用法，第一次执行之后，在设定的时间之后才执行第二次，重点就是开关锁\n * 左右按钮的写法不一样，尤其注意是否采用if...else写法！\n\n\n# 呼吸轮播图\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>document</title>\n        <style>\n            * {\n                margin: 0;\n                padding: 0;\n            }\n\n            .carousel {\n                width: 650px;\n                height: 360px;\n                border: 1px solid #000;\n                margin: 50px auto;\n                position: relative;\n            }\n\n            .carousel ul {\n                list-style: none;\n            }\n\n            .carousel ul li {\n                position: absolute;\n                top: 0;\n                left: 0;\n                /* 透明度都是0 */\n                opacity: 0;\n                transition: opacity 1s ease 0s;\n            }\n\n            /* 只有第一张透明度是1 */\n            .carousel ul li:first-child {\n                opacity: 1;\n            }\n\n            .carousel .leftbtn {\n                position: absolute;\n                left: 20px;\n                top: 50%;\n                margin-top: -25px;\n                width: 50px;\n                height: 50px;\n                background-color: rgb(28, 180, 226);\n                border-radius: 50%;\n            }\n\n            .carousel .rightbtn {\n                position: absolute;\n                right: 20px;\n                top: 50%;\n                margin-top: -25px;\n                width: 50px;\n                height: 50px;\n                background-color: rgb(28, 180, 226);\n                border-radius: 50%;\n            }\n        </style>\n    </head>\n\n    <body>\n        <div class="carousel">\n            <ul id="list">\n                <li><img src="images/beijing/0.jpg" alt="" /></li>\n                <li><img src="images/beijing/1.jpg" alt="" /></li>\n                <li><img src="images/beijing/2.jpg" alt="" /></li>\n                <li><img src="images/beijing/3.jpg" alt="" /></li>\n                <li><img src="images/beijing/4.jpg" alt="" /></li>\n            </ul>\n            <a href="javascript:;" class="leftbtn" id="leftbtn"></a>\n            <a href="javascript:;" class="rightbtn" id="rightbtn"></a>\n        </div>\n        <script>\n            // 得到按钮和ul，ul整体进行运动\n            var leftbtn = document.getelementbyid(\'leftbtn\')\n            var rightbtn = document.getelementbyid(\'rightbtn\')\n            var list = document.getelementbyid(\'list\')\n            var lis = list.getelementsbytagname(\'li\')\n\n            // 当前是第几张图显示\n            var idx = 0\n\n            // 节流\n            var lock = true\n\n            // 右按钮\n            rightbtn.onclick = function () {\n                // 判断节流\n                if (!lock) return\n\n                lock = false\n\n                // 还没有改idx，此时的idx这个图片就是老图，老图淡出\n                lis[idx].style.opacity = 0\n                idx++\n                if (idx > 4) idx = 0\n                // 改了idx，此时的idx这个图片就是新图，新图淡入\n                lis[idx].style.opacity = 1\n\n                // 动画结束之后，开锁\n                settimeout(function () {\n                    lock = true\n                }, 1000)\n            }\n\n            // 左按钮\n            leftbtn.onclick = function () {\n                // 判断节流\n                if (!lock) return\n\n                lock = false\n\n                // 还没有改idx，此时的idx这个图片就是老图，老图淡出\n                lis[idx].style.opacity = 0\n                idx--\n                if (idx < 0) idx = 4\n                // 改了idx，此时的idx这个图片就是新图，新图淡入\n                lis[idx].style.opacity = 1\n\n                // 动画结束之后，开锁\n                settimeout(function () {\n                    lock = true\n                }, 1000)\n            }\n        <\/script>\n    </body>\n</html>\n',charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"函数",frontmatter:{title:"函数",date:"2022/05/09 16:58:15",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0.html",relativePath:"前端开发/JavaScript/JS基础/函数.md",key:"v-1cd5d196",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0.html",headers:[{level:2,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:2},{level:2,title:"函数表达式",slug:"函数表达式",normalizedTitle:"函数表达式",charIndex:104},{level:2,title:"函数的调用",slug:"函数的调用",normalizedTitle:"函数的调用",charIndex:155},{level:2,title:"函数声明的提升",slug:"函数声明的提升",normalizedTitle:"函数声明的提升",charIndex:221},{level:2,title:"JS 的预解析机制",slug:"js-的预解析机制",normalizedTitle:"js 的预解析机制",charIndex:488},{level:3,title:"预解析过程",slug:"预解析过程",normalizedTitle:"预解析过程",charIndex:957},{level:3,title:"执行过程",slug:"执行过程",normalizedTitle:"执行过程",charIndex:1164},{level:2,title:"函数的参数",slug:"函数的参数",normalizedTitle:"函数的参数",charIndex:1292},{level:3,title:"arguments",slug:"arguments",normalizedTitle:"arguments",charIndex:1415},{level:2,title:"函数的返回值",slug:"函数的返回值",normalizedTitle:"函数的返回值",charIndex:1744},{level:2,title:"闭包",slug:"闭包",normalizedTitle:"闭包",charIndex:2119},{level:3,title:"定义",slug:"定义-2",normalizedTitle:"定义",charIndex:2},{level:3,title:"使用闭包的注意点",slug:"使用闭包的注意点",normalizedTitle:"使用闭包的注意点",charIndex:2267},{level:3,title:"闭包的两道面试题",slug:"闭包的两道面试题",normalizedTitle:"闭包的两道面试题",charIndex:2396},{level:2,title:"立即执行函数 IIFE",slug:"立即执行函数-iife",normalizedTitle:"立即执行函数 iife",charIndex:2917}],headersStr:"定义 函数表达式 函数的调用 函数声明的提升 JS 的预解析机制 预解析过程 执行过程 函数的参数 arguments 函数的返回值 闭包 定义 使用闭包的注意点 闭包的两道面试题 立即执行函数 IIFE",content:"# 定义\n\n和变量类似，函数必须先定义然后才能使用\n\n使用 function 关键字定义函数， function 是“功能”的意思\n\nfunction fun() {\n    // 函数体语句\n}\n\n\n\n# 函数表达式\n\nvar fun = function () {\n    // 函数体语句\n}\n\n\n\n# 函数的调用\n\n执行函数体中的所有语句，就称为“调用函数\"\n\n调用函数非常简单，只需在函数名字后书写圆括号对即可:fun()\n\n\n# 函数声明的提升\n\n和变量声明提升类似，函数声明也可以被提升\n\n如果函数是用函数表达式的写法定义的，则没有提升特性\n\nfun() //引发错误\n\nvar fun = function () {\n    console.log(1)\n}\n\n\n而且函数是优先变量进行提升的：\n\nfun() //2\n\nfunction fun() {\n    console.log(2)\n}\n\n// 变量声明提升，无法覆盖提升的函数\nvar fun = function () {\n    console.log(1)\n}\n\nfun() //1\n\n\n\n# JS 的预解析机制\n\n全局作用域，函数(局部)作用域，都是通过以下两个步骤进行预解析的。\n\n 1. 先读取有 var 的变量(没有使用 var 的变量是不会被预解析的)，给赋值为：undefined。如果两个变量重名，并不影响预解析的过程，就写一个变量就行，因为都将变量赋值为 undefined（在逐行读取时，只是不同的赋值而已。），如果有函数名和变量重名，那就直接去掉变量，不进行解析。如果函数中存在参数，那么参数也一样使用 var 进行解析。如：var argument=undefined;\n\n 2. 再读取 function 后面的函数---fn，如果有多个函数名重复，那么取最后面一个函数进行声明。\n\nconsole.log(a) // 打印函数a函数体（function a() { console.log('a') }）\n\nvar a = 10\n\nconsole.log(a) // 10\n\nfunction a() {\n    console.log('a')\n}\n\nconsole.log(a) // 10\n\n\n\n# 预解析过程\n\n 1. 首先预解析到有变量 a存在，因此记录下 a这个名字，和其值 undefined\n 2. 接着预解析到有函数 a声明，记录下函数名 a\n 3. 但是发现已经记录了一个 a ，因此第 1 步操作无效，（如果有函数名和变量重名，那就直接去掉变量，不进行解析）将函数体与 a 这个名字相关联\n 4. 解析完毕\n\n结果：a = function () { console.log('a') }\n\n\n# 执行过程\n\n 1. 打印变量 a 的值 function a() { console.log('a') }\n 2. 变量 a 赋值为 10，将原来关联的函数覆盖\n 3. 打印变量 a 的值 10\n 4. 打印变量 a 的值 10\n 5. 执行完毕\n\n\n# 函数的参数\n\n * 参数是函数内的一些待定值，在调用函数时，必须传入这些参数的具体值\n * 函数的参数可多可少，函数可以没有参数，也可以有多个参数，多个参数之间需要用逗号隔开\n * 形参和实参，\"形实结合\"\n * 函数的参数也是局部变量\n\n\n# arguments\n\n函数内 arguments 表示它接收到的实参列表，它是一个类数组对象\n类数组对象：所有属性均为从 0 开始的自然数序列，并且有 length 属性，和数组类似可以用方括号书写下标访问对象的某个属性值，但是不能调用数组的方法\n\nfunction fun(a, b) {\n    console.log(arguments)\n    console.log('arguments长度' + arguments.length)\n    for (var i = 0; i < arguments.length; i++) {\n        console.log(arguments[i])\n    }\n}\nfun(1, 2)\n\n\n\n# 函数的返回值\n\n * 函数体内可以使用 return 关键字表示“函数的返回值”\n\n * 调用一个有返回值的函数，可以被当做一个普通值，从而可以出现在任何可以书写值的地方\n\nfunction add(a, b) {\n    return a + b\n}\nvar result = add(2, 3) + add(4, 5)\n\n\n * 调用函数时，一旦遇见 return 语句则会立即退出函数，将执行权交还给调用者\n\nfunction fun() {\n    console.log('a')\n    return 'b'\n    console.log('c') // 这条语句不会输出\n}\nconsole.log(1)\nvar char = fun() // b\n// console.log(char);\nconsole.log(2)\n\n\n\n# 闭包\n\n\n# 定义\n\n在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量。而引用了自由变量的函数，就叫闭包\n\n它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。\n\n\n# 使用闭包的注意点\n\n不能滥用闭包 否则会造成网页的性能问题，严重时可能导致内存泄露。所谓内存泄漏是指程序中已动态分配的内存由于某种原因未释放或无法释放。解决这个问题的办法就是在不使用这些变量时，及时把不需要的局部变量全部删除，即将它们置为 null\n\n\n# 闭包的两道面试题\n\nfunction addCount() {\n    var count = 0\n    return function () {\n        count = count + 1\n        console.log(count)\n    }\n}\nvar fun1 = addCount()\nvar fun2 = addCount()\nfun1()\nfun2()\nfun2()\nfun1()\n\n\n答案\n\n1 1 2 2\n\nfunction fn1() {\n    var num1 = 1\n    var num2 = 100\n    numadd = function () {\n        num2 += 10\n        alert(num2)\n    }\n    function fn2() {\n        num1 += 1\n        alert(num1)\n    }\n    return fn2\n}\nvar result = fn1()\nresult()\nnumadd()\nresult()\n\n\n答案\n\n执行结果： 2,110,3 （numdd 是定义在全局作用域的函数）\n\n\n# 立即执行函数 IIFE\n\nIIFE（ Immediately Invoked Function Expression，立即调用函数表达式）是一种特殊的 JavaScript 函数写法，一旦被定义，就立即被调用。\n\nIIFE 会通过声明并立即执行一个函数来创建作用域------你不知道的 js(上)\n\n;(function () {\n    console.log(1)\n})()\n\n\nIIFE 可以在一些场合（如 for 循环中）将全局变量变为局部变量:\n\nvar arr = []\nfor (var i = 0; i < 5; i++) {\n    arr.push(function () {\n        alert(i) // 变量i是全局变量，所有函数都共享内存中的同一个变量i\n    })\n}\narr[2]() // 5\n\n\n使用 IIFE 解决：\n\nvar arr = []\nfor (var i = 0; i < 5; i++) {\n    ;(function (i) {\n        arr.push(function () {\n            alert(i)\n        })\n    })(i)\n}\narr[2]() // 2\n",normalizedContent:"# 定义\n\n和变量类似，函数必须先定义然后才能使用\n\n使用 function 关键字定义函数， function 是“功能”的意思\n\nfunction fun() {\n    // 函数体语句\n}\n\n\n\n# 函数表达式\n\nvar fun = function () {\n    // 函数体语句\n}\n\n\n\n# 函数的调用\n\n执行函数体中的所有语句，就称为“调用函数\"\n\n调用函数非常简单，只需在函数名字后书写圆括号对即可:fun()\n\n\n# 函数声明的提升\n\n和变量声明提升类似，函数声明也可以被提升\n\n如果函数是用函数表达式的写法定义的，则没有提升特性\n\nfun() //引发错误\n\nvar fun = function () {\n    console.log(1)\n}\n\n\n而且函数是优先变量进行提升的：\n\nfun() //2\n\nfunction fun() {\n    console.log(2)\n}\n\n// 变量声明提升，无法覆盖提升的函数\nvar fun = function () {\n    console.log(1)\n}\n\nfun() //1\n\n\n\n# js 的预解析机制\n\n全局作用域，函数(局部)作用域，都是通过以下两个步骤进行预解析的。\n\n 1. 先读取有 var 的变量(没有使用 var 的变量是不会被预解析的)，给赋值为：undefined。如果两个变量重名，并不影响预解析的过程，就写一个变量就行，因为都将变量赋值为 undefined（在逐行读取时，只是不同的赋值而已。），如果有函数名和变量重名，那就直接去掉变量，不进行解析。如果函数中存在参数，那么参数也一样使用 var 进行解析。如：var argument=undefined;\n\n 2. 再读取 function 后面的函数---fn，如果有多个函数名重复，那么取最后面一个函数进行声明。\n\nconsole.log(a) // 打印函数a函数体（function a() { console.log('a') }）\n\nvar a = 10\n\nconsole.log(a) // 10\n\nfunction a() {\n    console.log('a')\n}\n\nconsole.log(a) // 10\n\n\n\n# 预解析过程\n\n 1. 首先预解析到有变量 a存在，因此记录下 a这个名字，和其值 undefined\n 2. 接着预解析到有函数 a声明，记录下函数名 a\n 3. 但是发现已经记录了一个 a ，因此第 1 步操作无效，（如果有函数名和变量重名，那就直接去掉变量，不进行解析）将函数体与 a 这个名字相关联\n 4. 解析完毕\n\n结果：a = function () { console.log('a') }\n\n\n# 执行过程\n\n 1. 打印变量 a 的值 function a() { console.log('a') }\n 2. 变量 a 赋值为 10，将原来关联的函数覆盖\n 3. 打印变量 a 的值 10\n 4. 打印变量 a 的值 10\n 5. 执行完毕\n\n\n# 函数的参数\n\n * 参数是函数内的一些待定值，在调用函数时，必须传入这些参数的具体值\n * 函数的参数可多可少，函数可以没有参数，也可以有多个参数，多个参数之间需要用逗号隔开\n * 形参和实参，\"形实结合\"\n * 函数的参数也是局部变量\n\n\n# arguments\n\n函数内 arguments 表示它接收到的实参列表，它是一个类数组对象\n类数组对象：所有属性均为从 0 开始的自然数序列，并且有 length 属性，和数组类似可以用方括号书写下标访问对象的某个属性值，但是不能调用数组的方法\n\nfunction fun(a, b) {\n    console.log(arguments)\n    console.log('arguments长度' + arguments.length)\n    for (var i = 0; i < arguments.length; i++) {\n        console.log(arguments[i])\n    }\n}\nfun(1, 2)\n\n\n\n# 函数的返回值\n\n * 函数体内可以使用 return 关键字表示“函数的返回值”\n\n * 调用一个有返回值的函数，可以被当做一个普通值，从而可以出现在任何可以书写值的地方\n\nfunction add(a, b) {\n    return a + b\n}\nvar result = add(2, 3) + add(4, 5)\n\n\n * 调用函数时，一旦遇见 return 语句则会立即退出函数，将执行权交还给调用者\n\nfunction fun() {\n    console.log('a')\n    return 'b'\n    console.log('c') // 这条语句不会输出\n}\nconsole.log(1)\nvar char = fun() // b\n// console.log(char);\nconsole.log(2)\n\n\n\n# 闭包\n\n\n# 定义\n\n在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量。而引用了自由变量的函数，就叫闭包\n\n它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。\n\n\n# 使用闭包的注意点\n\n不能滥用闭包 否则会造成网页的性能问题，严重时可能导致内存泄露。所谓内存泄漏是指程序中已动态分配的内存由于某种原因未释放或无法释放。解决这个问题的办法就是在不使用这些变量时，及时把不需要的局部变量全部删除，即将它们置为 null\n\n\n# 闭包的两道面试题\n\nfunction addcount() {\n    var count = 0\n    return function () {\n        count = count + 1\n        console.log(count)\n    }\n}\nvar fun1 = addcount()\nvar fun2 = addcount()\nfun1()\nfun2()\nfun2()\nfun1()\n\n\n答案\n\n1 1 2 2\n\nfunction fn1() {\n    var num1 = 1\n    var num2 = 100\n    numadd = function () {\n        num2 += 10\n        alert(num2)\n    }\n    function fn2() {\n        num1 += 1\n        alert(num1)\n    }\n    return fn2\n}\nvar result = fn1()\nresult()\nnumadd()\nresult()\n\n\n答案\n\n执行结果： 2,110,3 （numdd 是定义在全局作用域的函数）\n\n\n# 立即执行函数 iife\n\niife（ immediately invoked function expression，立即调用函数表达式）是一种特殊的 javascript 函数写法，一旦被定义，就立即被调用。\n\niife 会通过声明并立即执行一个函数来创建作用域------你不知道的 js(上)\n\n;(function () {\n    console.log(1)\n})()\n\n\niife 可以在一些场合（如 for 循环中）将全局变量变为局部变量:\n\nvar arr = []\nfor (var i = 0; i < 5; i++) {\n    arr.push(function () {\n        alert(i) // 变量i是全局变量，所有函数都共享内存中的同一个变量i\n    })\n}\narr[2]() // 5\n\n\n使用 iife 解决：\n\nvar arr = []\nfor (var i = 0; i < 5; i++) {\n    ;(function (i) {\n        arr.push(function () {\n            alert(i)\n        })\n    })(i)\n}\narr[2]() // 2\n",charsets:{cjk:!0},lastUpdated:"2022年05月10日",lastUpdatedTimestamp:1652199031e3},{title:"变量与数据类型",frontmatter:{title:"变量与数据类型",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"前端开发/JavaScript/JS基础/变量与数据类型.md",key:"v-0905848e",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",headers:[{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:2},{level:3,title:"变量的默认值",slug:"变量的默认值",normalizedTitle:"变量的默认值",charIndex:9},{level:3,title:"变量的常见错误",slug:"变量的常见错误",normalizedTitle:"变量的常见错误",charIndex:92},{level:3,title:"变量的合法命名",slug:"变量的合法命名",normalizedTitle:"变量的合法命名",charIndex:2270},{level:3,title:"变量声明的提升",slug:"变量声明的提升",normalizedTitle:"变量声明的提升",charIndex:2475},{level:2,title:"JS 基本数据类型",slug:"js-基本数据类型",normalizedTitle:"js 基本数据类型",charIndex:2912},{level:3,title:"数据类型分类",slug:"数据类型分类",normalizedTitle:"数据类型分类",charIndex:2945},{level:3,title:"基本数据类型和引用数据类型的区别",slug:"基本数据类型和引用数据类型的区别",normalizedTitle:"基本数据类型和引用数据类型的区别",charIndex:3229},{level:3,title:"typeof 运算符",slug:"typeof-运算符",normalizedTitle:"typeof 运算符",charIndex:3755},{level:3,title:"number 数字类型",slug:"number-数字类型",normalizedTitle:"number 数字类型",charIndex:4101},{level:3,title:"string 字符串类型",slug:"string-字符串类型",normalizedTitle:"string 字符串类型",charIndex:4748},{level:3,title:"boolean（布尔）类型",slug:"boolean-布尔-类型",normalizedTitle:"boolean（布尔）类型",charIndex:6132},{level:3,title:"undefined 类型",slug:"undefined-类型",normalizedTitle:"undefined 类型",charIndex:6180},{level:3,title:"null 类型",slug:"null-类型",normalizedTitle:"null 类型",charIndex:6648},{level:3,title:"null 和 undefined 的区别",slug:"null-和-undefined-的区别",normalizedTitle:"null 和 undefined 的区别",charIndex:7009},{level:2,title:"数据类型转换",slug:"数据类型转换",normalizedTitle:"数据类型转换",charIndex:7295},{level:3,title:"转数字",slug:"转数字",normalizedTitle:"转数字",charIndex:7354},{level:3,title:"转布尔",slug:"转布尔",normalizedTitle:"转布尔",charIndex:8114},{level:3,title:"转字符串",slug:"转字符串",normalizedTitle:"转字符串",charIndex:8190},{level:3,title:"对象转原始类型",slug:"对象转原始类型",normalizedTitle:"对象转原始类型",charIndex:8733}],headersStr:"变量 变量的默认值 变量的常见错误 变量的合法命名 变量声明的提升 JS 基本数据类型 数据类型分类 基本数据类型和引用数据类型的区别 typeof 运算符 number 数字类型 string 字符串类型 boolean（布尔）类型 undefined 类型 null 类型 null 和 undefined 的区别 数据类型转换 转数字 转布尔 转字符串 对象转原始类型",content:"# 变量\n\n\n# 变量的默认值\n\n 1. 一个变量只定义，但没有赋初值，默认值是 undefined\n\n 2. 一个变量只有被 var 定义，并赋初值之后，才算正式初始化完成\n\n\n# 变量的常见错误\n\n注意\n\n虽然可以通过省略 var 操作符定义全局变量，但不推荐这么做。在局部作用域中定义的全局变量很难维护，也会造成困惑。这是因为不能一下子断定省略 var 是不是有意而为之。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出错误\n\n * 不用 var 定义，而直接将值赋予它，虽不引发报错，但会产生作用域问题:\n\n在函数外，用 var声明的变量为全局变量，不用 var 声明的变量也为全局变量。全局变量其实是在 window对象中添加属性并赋值\n\nvar a = 123 // 使用var声明\nb = 456 // 不使用var声明\nconsole.log(a) // 123\nconsole.log(b) // 456\nconsole.log(window.a) // 123\nconsole.log(window.b) // 456\n\n\n在函数中，用 var 声明的变量为局部变量，不用 var声明的变量为全局变量\n\nfunction fn() {\n    var a = 123 // 使用var声明\n    b = 456 // 不使用var声明\n    console.log(a) // 123\n    console.log(b) // 456\n    console.log(window.a) // undefined\n    console.log(window.b) // 456\n}\nfn()\nconsole.log(b) // 456\n\n\ndelete 用来删除对象的属性，如果是不能删除的属性返回 false，其他情况返回 true,可以看到，变量 a b 都是全局变量，同为 window对象的其中一个属性，a 不可以删除，b 可以删除\n\nvar a = 123 // 使用var声明\nb = 456 // 不使用var声明\nconsole.log(window.a) // 123\nconsole.log(window.b) // 456\nconsole.log(delete a) // false\nconsole.log(delete b) // true\nconsole.log(window.a) // 123\nconsole.log(window.b) // undefined\n\n\n即：同为全局变量，同为 window对象的其中一个属性，用 var 声明的变量不可以删除，不用 var 声明的变量可以删除！\n\n对象属性是否可删除, 其实是可以配置的:\n\nObject.getOwnPropertyDescriptor()方法返回某个对象属性的描述对象\n\nvar a = 123 // 使用var声明\nb = 456 // 不使用var声明\nconsole.log(Object.getOwnPropertyDescriptor(window, 'a'))\n// {value: 123, writable: true, enumerable: true, configurable: false}\nconsole.log(Object.getOwnPropertyDescriptor(window, 'b'))\n// {value: 456, writable: true, enumerable: true, configurable: true}\n\n\n我们可以看到 window 对象的属性 a和 b 的描述对象包含以下信息:\n\n * value属性的值\n * writable 属性是否可被修改，布尔值\n * enumerable 属性是否可被枚举(遍历)，布尔值\n * configurable 属性是否可以被删除，布尔值\n * 属性 a 和 b 的描述对象区别在于是否可删除, 这个特性属性 a 为 configurable: false 不可删除,属性 b 为 configurable: true 可删除\n\n即：对象的属性是否可删除，取决于描述对象的属性 configurable，用 var 声明的变量默认不可删除，不用 var 声明的变量默认可删除\n\n经过下面代码在浏览器中测试，var 定义的全局变量，无法修改它的 configurable 属性，即它无法被修改为可删除。而不使用 var声明的全局变量可以修改它的 configurable 属性：\n\nvar a = 123 // 使用var声明\nb = 456 // 不使用var声明\nObject.defineProperty(window, 'b', { configurable: false }) // 默认为true\nconsole.log(delete b) // fasle\nObject.defineProperty(window, 'a', { configurable: true }) //无法重新定义属性: a at Function.defineProperty\n\n\n参考：Object.defineProperty()\n\n * 尝试使用一个既没有被var定义过，也没有赋过值的字符就会产生引用错误。\n\nconsole.log(b) //  b is not defined\n\n\n\n# 变量的合法命名\n\n提示\n\n变量，函数，对象的属性 一般都采用小驼峰命名法，类名，构造函数采用大驼峰命名法，即首字母也要大写\n\n关键字、保留字、true、false 和 null ,undefined不能作为标识符\n\n标识符就是变量，函数，属性或函数参数的名称\n\n * 只能由 字母、数字、下划线、$ 组成，但 不能 以数字开头\n\n * 不能是关键字或保留字\n\n * 大小写敏感，a和 A两个不同的变量\n\n\n# 变量声明的提升\n\n你可以提前使用一个稍后才声明的变量，而不会引发异常\n\n变量声明提升时，只提升变量的定义到当前作用域（全局作用域或者函数作用域）的顶部，不会提升它的值\n\n * 全局作用域：\n\nconsole.log(b) // 输出undefined\nvar b = 12\n\n\n * 函数作用域：\n\nvar a = 123\n// 函数作用域\nfunction fun() {\n    console.log(a)\n    // var 声明的变量没有块级作用域\n    if (false) {\n        var a = 456\n    }\n}\nfun() // undefined\n\n\n看道题\n\n下列代码输出结果是?\n\nvar val = 12\nfunction fun1() {\n    console.log(val)\n    var val = 20\n    console.log(val)\n}\nfun1()\n// undefined\n// 20\n\n\n\n# JS 基本数据类型\n\n深入理解 js 数据类型与堆栈内存\n\n\n# 数据类型分类\n\n * 基本数据类型：string,boolean,number,symbol（ES6 新增）,undefined, null\n * 引用数据类型：object\n * js 的常见内置对象：Date,Array,Math,Number,Boolean,String,Array,RegExp,Function...\n\n提示\n\n其中 Symbol 是 ES6 中新增的数据类型：\n\nSymbol符号是原始值，且符号实例是唯一、不可变的。 符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。\n\n更多 Symbol 细节见 ES6 章节\n\n\n# 基本数据类型和引用数据类型的区别\n\n内存的分配不同\n\n * 基本数据类型存储在栈中\n * 复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址\n\n访问机制不同\n\n * 基本数据类型是按值访问\n * 复杂数据类型按引用访问，JS 不允许直接访问保存在堆内存中的对象，在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象的值\n\n复制变量时不同a=b\n\n * 基本数据类型：a=b;是将 b 中保存的原始值的副本赋值给新变量 a,a 和 b 完全独立，互不影响\n\n * 复杂数据类型：a=b;将 b 保存的对象内存的引用地址赋值给了新变量 a;a和 b指向了同一个堆内存地址，其中一个值发生了改变，另一个也会改变\n\n比较变量时不同== , ===\n\n * 基本数据类型：==先进行类型转换再确定操作数的值是否相等，===不仅比较值是否相等，还会比较数据类型是否相同\n\n * 引用数据类型：不管是 == 还是 === ，都是比较内存地址是否相同，即比较是否都指向同一个对象\n\n参数传递的不同(实参/形参)\n\n函数传参都是按值传递(栈中的存储的内容)：基本数据类型，拷贝的是值；复杂数据类型，拷贝的是引用地址\n\n\n# typeof 运算符\n\n注意\n\n * 调用 typeof null 返回的是\"object\"。这是因为特殊值 null被认为是一个对空对象的引用\n\n * 严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是， 函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。\n\n对一个值使用 typeof操作符会返回下列字符串之一：\n\n * \"undefined\"表示值未定义\n * \"boolean\"表示值为布尔值\n * \"string\"表示值为字符串\n * \"number\"表示值为数值\n * \"object\"表示值为对象（而不是函数）或 null\n * \"function\"表示值为函数\n * \"symbol\"表示值为符号。\n\n\n# number 数字类型\n\n * 所有数字不分大小，不分整浮，不分正负，都是数字类型\n * 介于 0 和 1 之间的小数，0 可以省略\n\n# 科学计数法\n\n3e8 -> 300000000\n3e-4 -> 0.0003\n\n\n# 不同进制的数字\n\n * 二进制以 0b 开头\n\n0b10 // 2\n\n\n * 八进制以 0 开头\n\n017 // 15\n\n\n * 十六进制以 0x 开头\n\n0xf // 15\n\n\n# 特殊的数字型值 NaN\n\n * typeof NaN // number\n * 0 除以 0 的结果是 NaN，事实上，在数学运算中，若结果不能得到数字，其结果往往都是 NaN\n * NaN不自等:NaN 不等于 NaN\n\n原因\n\nNaN是一种异常的结果，也就是“not a number”，虽然它也是一个变量，但它是描述性变量，'a'不是一个数字（not a number），'b'也不是一个数字（not a number），但是'a'和'b'并不相等，所以NaN != NaN也就成立了。\n\n * 如何判断某变量值为NaN:isNaN()函数可以用来判断变量值是否为NaN,但 isNaN()也不好用，它的机理是：只要该变量传入Number()的执行结果是NaN，则 isNaN()函数都会得到 true\n\nisNaN(4) //false\nisNaN(NaN) //true\nisNaN(undefined) // true\nisNaN('我懂得') // true\n\n\n\n# string 字符串类型\n\n * 数字 11 和字符串\"11\"在语义上是不同的，前者表达一个数量，后者是一个文本\n\n * 加号可以用来拼接多个字符串\n\n'zha' + 'ng' // 'zhang'\n\n\n * 要将一个变量的值“插入”到字符串中，要“斩断链接\"\n\nvar year = 2022;\nvar str ='zfh'+year+‘哈哈’ //zfh2022哈哈\n\n\n * 空字符串，直接书写闭合的引号对即可\n\nvar str = ''\n\n\n * 字符串的 length属性\n\n'abcd'.length //4\n\n\n# 字符串的常用方法\n\ncharAt():可以得到指定位置的字符\n\n'abcd'.charAt(1) //b\n\n\nsubstring() ,substr()和 slice()方法\n\n * substring()\n\n 1. substring(a,b)可以得到从 a 开始到 b 结束（左闭右开，不包括 b 处）的子串\n\n'abcd'.substring(0, 2) //‘ab'\n\n\n 2. substring(a,b)方法如果省略第二个参数，返回的子串会一直到字符串的结尾\n\n'abcd'.substring(1) //‘bcd'\n\n\n 3. substring(a,b)中，a 可以大于 b，数字顺序将自动调整为小数在前\n\n'abcd'.substring(3, 2) //‘c'\n\n\n 4. 如果任一参数小于 0 或为 NaN，则被当作 0\n\n'abcd'.substring(-1, -2) // 'ab'\n\n\n 5. 如果任一参数大于字符串长度，则被当成字符串长度\n\n'abcd'.substring(0, 100) // 'abcd'\n\n\n * substr()\n\n警告\n\n尽管 String.prototype.substr(…) 没有严格被废弃 (as in \"removed from the Web standards\"), 但它被认作是遗留的函数并且可以的话应该避免使用。它并非JavaScript核心语言的一部分，未来将可能会被移除掉。如果可以的话，使用 substring() 替代它\n\n * slice()\n\n 1. slice(a,b)方法得到从a开始到 b结束（不包括 b 处）的子串,不会改变原字符串\n\n'abcd'.slice(0, 2) //‘ab'\n\n\n 2. slice(a,b)的参数可以是负数,表示倒数位置\n\n'abcd'.slice(-2, -1) // 'c'\n\n\n 3. slice(a,b)中，索引值 a 对应的位置必须在索引值 b 之前\n\ntoUpperCase(),toLowerCase()\n\n * toUpperCase() 转为大写\n * toLowerCase() 转为小写\n\nindexOf()\n\n * index0f()方法返回某个指定的字符串值在字符串中首次出现的位置\n * 如果要检索的字符串值没有出现，则该返回-1\n\n'abcd'.indexOf('a') // 0\n'abcd'.indexOf('e') // -1\n\n\nincludes()\n\nincludes() 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false\n\n\n# boolean（布尔）类型\n\n布尔型值只有两个：true和 false，分别表示真和假\n\n\n# undefined 类型\n\nundefined 表示一个变量自然的、最原始的状态值，就是此处应该有一个值，但是还没有定义\n\nundefined又是值，又是一种类型，这种类型只有它自己一个值\n\ntypeof undefined // undefined\n\n\nundefined一般会在以下 4 种场景中出现：\n\n * 声明了一个变量，但没有赋值，就等于 undefined\n\nvar a\nconsole.log(a) // undefined\n\n\n * 函数定义了形参，但没有传递实参，该参数等于 undefined\n\n//函数定义了形参 a\nfunction f(a) {\n    console.log(a) // undefined\n}\nf() //未传递实参\n\n\n * 访问对象上不存在的属性，该属性的值为 undefined\n\nvar a = new Object()\na.p // undefined\n\n\n * 函数没有返回值时，默认返回 undefined\n\nvar a = f()\na // undefined\n\n\n\n# null 类型\n\nnull 表示一个变量被人为的设置为空对象，而不是原始状态，即该处不应该有值\n\n使用 typeof检测 null 值，结果是object，这点 尤其要注意 ,类型和 typeof检测结果并不总是一一对应，比如数组用 typeof 检测结果也是 object\n\nnull一般会在以下 2 种场景中出现：\n\n * 利用 document.getElementById(‘XXX’) 寻找一个不存在的元素，将返回 null\n\nconsole.log(null == document.getElementById('notExistElement')) // true\n\n\n * 作为对象原型链的终点\n\nObject.getPrototypeOf(Object.prototype) // null\n\n\n\n# null 和 undefined 的区别\n\n最佳实践\n\n在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可\n\nundefined vs null\n\n 1. 数据类型不同\n\n 2. 转换为数值区别:null是一个表示\"无\"的对象，转为数值时为 0；undefined 是一个表示\"无\"的原始值，转为数值时为 NaN\n\n 3. null == undefined会返回true，因为它们是类似的值；但null === undefined会返回false，因为它们是不同类型的值。\n\n\n# 数据类型转换\n\n提示\n\n在 JS 中类型转换只有三种情况，分别是：转换为布尔值,转换为数字,转换为字符串\n\n\n\n\n# 转数字\n\n有 3 个函数可以将非数值转换为数值：Number()、parseInt()和 parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这 3 个函数执行的操作也不同:\n\n# Number()\n\n 1. 布尔值：true和false 将分别被转为 1 和 0\n\n 2. 数字值，直接返回\n\n 3. null 值，返回 0\n\n 4. undefined，返回 NaN\n\n 5. 如果是字符串：\n\n * 如果字符串中只包含数字（包括前面带正负号的情况），则转换为十进制数\n\n * 如果是空字符串，则转换为 0\n\n * 如果包含有效的浮点格式，则转换为浮点数值\n\n * 如果包含非数字内容，则转换为 NaN\n\n# parseInt()\n\n最佳实践\n\n不传底数参数相当于让 parseInt()自己决定如何解析，所以为了避免出错，请始终传给它第二个参数\n\nparseInt()可以为函数提供第二个参数：转换时使用的基数(2,8,10,16)\n\n它的工作方式是：\n\n * 如果第一个字符不是数字字符或者正负号，则返回 NaN(用 parseInt()转换空字符串时会返回 NaN)\n\n * 如果遇到的第一个字符是数字字符，parseInt()会继续解析后面的字符，直到解析完所有字符或遇到了非数字字符\n\n# parsefloat()\n\n也是从第一个字符开始解析，一直到字符串末尾或者遇见一个无效的浮点数字字符为止\n\n字符串中第一个小数点是有效地，而第二个小数点就是无效的了\n\n十六进制字符串会始终被转换成 0\n\n只解析十进制值，所以不指定第二个参数\n\n如果字符串包含的是一个可解析为整数的数（没有小数点或者小数点后面都是零），则返回整数值\n\n\n# 转布尔\n\n在条件判断时，除了 undefined， null，false，NaN，''， 0，-0，其他所有值都转为 true，包括所有对象。\n\n\n# 转字符串\n\n# toString()\n\n该方法可以用于数值，布尔值，对象，字符串值;null,undefined 没有该方法\n\n当数值调用该方法时，可以传入一个底数参数,表示以什么底数输出数值的字符串表示\n\n# String()\n\nString()转型函数遵循以下规则：\n\n * 如果值有 toString()方法，则调用该方法(不传参数)并返回结果\n * 如果值是 null，返回“null”\n * 如果值是 undefined,返回“undefined”\n\n# 用 ➕ 操作符加上一个空字符串“”\n\nconst num = 11233333333123\n\nconst str = '1'\n\nconst obj = { a: 1 }\n\nconst bool = true\n\nconsole.log(typeof (num + '')) // string\nconsole.log(typeof (obj + '')) // string\nconsole.log(typeof (obj + '')) // string\nconsole.log(typeof (bool + ''))// string\nconsole.log(typeof +str)  // number\n\n\n\n# 对象转原始类型\n\n对象在转换类型的时候，会调用内置的 Symbol.ToPrimitive 函数，对于该函数来说，算法逻辑一般来说如下：\n\n * 如果已经是原始类型了，那就不需要转换了\n * 调用 x.valueOf()，如果转换为基础类型，就返回转换的值\n * 调用 x.toString()，如果转换为基础类型，就返回转换的值\n * 如果都没有返回原始类型，就会报错\n\n当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高。\n\nlet a = {\n    valueOf() {\n        return 0\n    },\n    toString() {\n        return '1'\n    },\n    [Symbol.toPrimitive]() {\n        return 2\n    },\n}\n1 + a // => 3\n",normalizedContent:"# 变量\n\n\n# 变量的默认值\n\n 1. 一个变量只定义，但没有赋初值，默认值是 undefined\n\n 2. 一个变量只有被 var 定义，并赋初值之后，才算正式初始化完成\n\n\n# 变量的常见错误\n\n注意\n\n虽然可以通过省略 var 操作符定义全局变量，但不推荐这么做。在局部作用域中定义的全局变量很难维护，也会造成困惑。这是因为不能一下子断定省略 var 是不是有意而为之。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出错误\n\n * 不用 var 定义，而直接将值赋予它，虽不引发报错，但会产生作用域问题:\n\n在函数外，用 var声明的变量为全局变量，不用 var 声明的变量也为全局变量。全局变量其实是在 window对象中添加属性并赋值\n\nvar a = 123 // 使用var声明\nb = 456 // 不使用var声明\nconsole.log(a) // 123\nconsole.log(b) // 456\nconsole.log(window.a) // 123\nconsole.log(window.b) // 456\n\n\n在函数中，用 var 声明的变量为局部变量，不用 var声明的变量为全局变量\n\nfunction fn() {\n    var a = 123 // 使用var声明\n    b = 456 // 不使用var声明\n    console.log(a) // 123\n    console.log(b) // 456\n    console.log(window.a) // undefined\n    console.log(window.b) // 456\n}\nfn()\nconsole.log(b) // 456\n\n\ndelete 用来删除对象的属性，如果是不能删除的属性返回 false，其他情况返回 true,可以看到，变量 a b 都是全局变量，同为 window对象的其中一个属性，a 不可以删除，b 可以删除\n\nvar a = 123 // 使用var声明\nb = 456 // 不使用var声明\nconsole.log(window.a) // 123\nconsole.log(window.b) // 456\nconsole.log(delete a) // false\nconsole.log(delete b) // true\nconsole.log(window.a) // 123\nconsole.log(window.b) // undefined\n\n\n即：同为全局变量，同为 window对象的其中一个属性，用 var 声明的变量不可以删除，不用 var 声明的变量可以删除！\n\n对象属性是否可删除, 其实是可以配置的:\n\nobject.getownpropertydescriptor()方法返回某个对象属性的描述对象\n\nvar a = 123 // 使用var声明\nb = 456 // 不使用var声明\nconsole.log(object.getownpropertydescriptor(window, 'a'))\n// {value: 123, writable: true, enumerable: true, configurable: false}\nconsole.log(object.getownpropertydescriptor(window, 'b'))\n// {value: 456, writable: true, enumerable: true, configurable: true}\n\n\n我们可以看到 window 对象的属性 a和 b 的描述对象包含以下信息:\n\n * value属性的值\n * writable 属性是否可被修改，布尔值\n * enumerable 属性是否可被枚举(遍历)，布尔值\n * configurable 属性是否可以被删除，布尔值\n * 属性 a 和 b 的描述对象区别在于是否可删除, 这个特性属性 a 为 configurable: false 不可删除,属性 b 为 configurable: true 可删除\n\n即：对象的属性是否可删除，取决于描述对象的属性 configurable，用 var 声明的变量默认不可删除，不用 var 声明的变量默认可删除\n\n经过下面代码在浏览器中测试，var 定义的全局变量，无法修改它的 configurable 属性，即它无法被修改为可删除。而不使用 var声明的全局变量可以修改它的 configurable 属性：\n\nvar a = 123 // 使用var声明\nb = 456 // 不使用var声明\nobject.defineproperty(window, 'b', { configurable: false }) // 默认为true\nconsole.log(delete b) // fasle\nobject.defineproperty(window, 'a', { configurable: true }) //无法重新定义属性: a at function.defineproperty\n\n\n参考：object.defineproperty()\n\n * 尝试使用一个既没有被var定义过，也没有赋过值的字符就会产生引用错误。\n\nconsole.log(b) //  b is not defined\n\n\n\n# 变量的合法命名\n\n提示\n\n变量，函数，对象的属性 一般都采用小驼峰命名法，类名，构造函数采用大驼峰命名法，即首字母也要大写\n\n关键字、保留字、true、false 和 null ,undefined不能作为标识符\n\n标识符就是变量，函数，属性或函数参数的名称\n\n * 只能由 字母、数字、下划线、$ 组成，但 不能 以数字开头\n\n * 不能是关键字或保留字\n\n * 大小写敏感，a和 a两个不同的变量\n\n\n# 变量声明的提升\n\n你可以提前使用一个稍后才声明的变量，而不会引发异常\n\n变量声明提升时，只提升变量的定义到当前作用域（全局作用域或者函数作用域）的顶部，不会提升它的值\n\n * 全局作用域：\n\nconsole.log(b) // 输出undefined\nvar b = 12\n\n\n * 函数作用域：\n\nvar a = 123\n// 函数作用域\nfunction fun() {\n    console.log(a)\n    // var 声明的变量没有块级作用域\n    if (false) {\n        var a = 456\n    }\n}\nfun() // undefined\n\n\n看道题\n\n下列代码输出结果是?\n\nvar val = 12\nfunction fun1() {\n    console.log(val)\n    var val = 20\n    console.log(val)\n}\nfun1()\n// undefined\n// 20\n\n\n\n# js 基本数据类型\n\n深入理解 js 数据类型与堆栈内存\n\n\n# 数据类型分类\n\n * 基本数据类型：string,boolean,number,symbol（es6 新增）,undefined, null\n * 引用数据类型：object\n * js 的常见内置对象：date,array,math,number,boolean,string,array,regexp,function...\n\n提示\n\n其中 symbol 是 es6 中新增的数据类型：\n\nsymbol符号是原始值，且符号实例是唯一、不可变的。 符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。\n\n更多 symbol 细节见 es6 章节\n\n\n# 基本数据类型和引用数据类型的区别\n\n内存的分配不同\n\n * 基本数据类型存储在栈中\n * 复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址\n\n访问机制不同\n\n * 基本数据类型是按值访问\n * 复杂数据类型按引用访问，js 不允许直接访问保存在堆内存中的对象，在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象的值\n\n复制变量时不同a=b\n\n * 基本数据类型：a=b;是将 b 中保存的原始值的副本赋值给新变量 a,a 和 b 完全独立，互不影响\n\n * 复杂数据类型：a=b;将 b 保存的对象内存的引用地址赋值给了新变量 a;a和 b指向了同一个堆内存地址，其中一个值发生了改变，另一个也会改变\n\n比较变量时不同== , ===\n\n * 基本数据类型：==先进行类型转换再确定操作数的值是否相等，===不仅比较值是否相等，还会比较数据类型是否相同\n\n * 引用数据类型：不管是 == 还是 === ，都是比较内存地址是否相同，即比较是否都指向同一个对象\n\n参数传递的不同(实参/形参)\n\n函数传参都是按值传递(栈中的存储的内容)：基本数据类型，拷贝的是值；复杂数据类型，拷贝的是引用地址\n\n\n# typeof 运算符\n\n注意\n\n * 调用 typeof null 返回的是\"object\"。这是因为特殊值 null被认为是一个对空对象的引用\n\n * 严格来讲，函数在 ecmascript 中被认为是对象，并不代表一种数据类型。可是， 函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。\n\n对一个值使用 typeof操作符会返回下列字符串之一：\n\n * \"undefined\"表示值未定义\n * \"boolean\"表示值为布尔值\n * \"string\"表示值为字符串\n * \"number\"表示值为数值\n * \"object\"表示值为对象（而不是函数）或 null\n * \"function\"表示值为函数\n * \"symbol\"表示值为符号。\n\n\n# number 数字类型\n\n * 所有数字不分大小，不分整浮，不分正负，都是数字类型\n * 介于 0 和 1 之间的小数，0 可以省略\n\n# 科学计数法\n\n3e8 -> 300000000\n3e-4 -> 0.0003\n\n\n# 不同进制的数字\n\n * 二进制以 0b 开头\n\n0b10 // 2\n\n\n * 八进制以 0 开头\n\n017 // 15\n\n\n * 十六进制以 0x 开头\n\n0xf // 15\n\n\n# 特殊的数字型值 nan\n\n * typeof nan // number\n * 0 除以 0 的结果是 nan，事实上，在数学运算中，若结果不能得到数字，其结果往往都是 nan\n * nan不自等:nan 不等于 nan\n\n原因\n\nnan是一种异常的结果，也就是“not a number”，虽然它也是一个变量，但它是描述性变量，'a'不是一个数字（not a number），'b'也不是一个数字（not a number），但是'a'和'b'并不相等，所以nan != nan也就成立了。\n\n * 如何判断某变量值为nan:isnan()函数可以用来判断变量值是否为nan,但 isnan()也不好用，它的机理是：只要该变量传入number()的执行结果是nan，则 isnan()函数都会得到 true\n\nisnan(4) //false\nisnan(nan) //true\nisnan(undefined) // true\nisnan('我懂得') // true\n\n\n\n# string 字符串类型\n\n * 数字 11 和字符串\"11\"在语义上是不同的，前者表达一个数量，后者是一个文本\n\n * 加号可以用来拼接多个字符串\n\n'zha' + 'ng' // 'zhang'\n\n\n * 要将一个变量的值“插入”到字符串中，要“斩断链接\"\n\nvar year = 2022;\nvar str ='zfh'+year+‘哈哈’ //zfh2022哈哈\n\n\n * 空字符串，直接书写闭合的引号对即可\n\nvar str = ''\n\n\n * 字符串的 length属性\n\n'abcd'.length //4\n\n\n# 字符串的常用方法\n\ncharat():可以得到指定位置的字符\n\n'abcd'.charat(1) //b\n\n\nsubstring() ,substr()和 slice()方法\n\n * substring()\n\n 1. substring(a,b)可以得到从 a 开始到 b 结束（左闭右开，不包括 b 处）的子串\n\n'abcd'.substring(0, 2) //‘ab'\n\n\n 2. substring(a,b)方法如果省略第二个参数，返回的子串会一直到字符串的结尾\n\n'abcd'.substring(1) //‘bcd'\n\n\n 3. substring(a,b)中，a 可以大于 b，数字顺序将自动调整为小数在前\n\n'abcd'.substring(3, 2) //‘c'\n\n\n 4. 如果任一参数小于 0 或为 nan，则被当作 0\n\n'abcd'.substring(-1, -2) // 'ab'\n\n\n 5. 如果任一参数大于字符串长度，则被当成字符串长度\n\n'abcd'.substring(0, 100) // 'abcd'\n\n\n * substr()\n\n警告\n\n尽管 string.prototype.substr(…) 没有严格被废弃 (as in \"removed from the web standards\"), 但它被认作是遗留的函数并且可以的话应该避免使用。它并非javascript核心语言的一部分，未来将可能会被移除掉。如果可以的话，使用 substring() 替代它\n\n * slice()\n\n 1. slice(a,b)方法得到从a开始到 b结束（不包括 b 处）的子串,不会改变原字符串\n\n'abcd'.slice(0, 2) //‘ab'\n\n\n 2. slice(a,b)的参数可以是负数,表示倒数位置\n\n'abcd'.slice(-2, -1) // 'c'\n\n\n 3. slice(a,b)中，索引值 a 对应的位置必须在索引值 b 之前\n\ntouppercase(),tolowercase()\n\n * touppercase() 转为大写\n * tolowercase() 转为小写\n\nindexof()\n\n * index0f()方法返回某个指定的字符串值在字符串中首次出现的位置\n * 如果要检索的字符串值没有出现，则该返回-1\n\n'abcd'.indexof('a') // 0\n'abcd'.indexof('e') // -1\n\n\nincludes()\n\nincludes() 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false\n\n\n# boolean（布尔）类型\n\n布尔型值只有两个：true和 false，分别表示真和假\n\n\n# undefined 类型\n\nundefined 表示一个变量自然的、最原始的状态值，就是此处应该有一个值，但是还没有定义\n\nundefined又是值，又是一种类型，这种类型只有它自己一个值\n\ntypeof undefined // undefined\n\n\nundefined一般会在以下 4 种场景中出现：\n\n * 声明了一个变量，但没有赋值，就等于 undefined\n\nvar a\nconsole.log(a) // undefined\n\n\n * 函数定义了形参，但没有传递实参，该参数等于 undefined\n\n//函数定义了形参 a\nfunction f(a) {\n    console.log(a) // undefined\n}\nf() //未传递实参\n\n\n * 访问对象上不存在的属性，该属性的值为 undefined\n\nvar a = new object()\na.p // undefined\n\n\n * 函数没有返回值时，默认返回 undefined\n\nvar a = f()\na // undefined\n\n\n\n# null 类型\n\nnull 表示一个变量被人为的设置为空对象，而不是原始状态，即该处不应该有值\n\n使用 typeof检测 null 值，结果是object，这点 尤其要注意 ,类型和 typeof检测结果并不总是一一对应，比如数组用 typeof 检测结果也是 object\n\nnull一般会在以下 2 种场景中出现：\n\n * 利用 document.getelementbyid(‘xxx’) 寻找一个不存在的元素，将返回 null\n\nconsole.log(null == document.getelementbyid('notexistelement')) // true\n\n\n * 作为对象原型链的终点\n\nobject.getprototypeof(object.prototype) // null\n\n\n\n# null 和 undefined 的区别\n\n最佳实践\n\n在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可\n\nundefined vs null\n\n 1. 数据类型不同\n\n 2. 转换为数值区别:null是一个表示\"无\"的对象，转为数值时为 0；undefined 是一个表示\"无\"的原始值，转为数值时为 nan\n\n 3. null == undefined会返回true，因为它们是类似的值；但null === undefined会返回false，因为它们是不同类型的值。\n\n\n# 数据类型转换\n\n提示\n\n在 js 中类型转换只有三种情况，分别是：转换为布尔值,转换为数字,转换为字符串\n\n\n\n\n# 转数字\n\n有 3 个函数可以将非数值转换为数值：number()、parseint()和 parsefloat()。number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这 3 个函数执行的操作也不同:\n\n# number()\n\n 1. 布尔值：true和false 将分别被转为 1 和 0\n\n 2. 数字值，直接返回\n\n 3. null 值，返回 0\n\n 4. undefined，返回 nan\n\n 5. 如果是字符串：\n\n * 如果字符串中只包含数字（包括前面带正负号的情况），则转换为十进制数\n\n * 如果是空字符串，则转换为 0\n\n * 如果包含有效的浮点格式，则转换为浮点数值\n\n * 如果包含非数字内容，则转换为 nan\n\n# parseint()\n\n最佳实践\n\n不传底数参数相当于让 parseint()自己决定如何解析，所以为了避免出错，请始终传给它第二个参数\n\nparseint()可以为函数提供第二个参数：转换时使用的基数(2,8,10,16)\n\n它的工作方式是：\n\n * 如果第一个字符不是数字字符或者正负号，则返回 nan(用 parseint()转换空字符串时会返回 nan)\n\n * 如果遇到的第一个字符是数字字符，parseint()会继续解析后面的字符，直到解析完所有字符或遇到了非数字字符\n\n# parsefloat()\n\n也是从第一个字符开始解析，一直到字符串末尾或者遇见一个无效的浮点数字字符为止\n\n字符串中第一个小数点是有效地，而第二个小数点就是无效的了\n\n十六进制字符串会始终被转换成 0\n\n只解析十进制值，所以不指定第二个参数\n\n如果字符串包含的是一个可解析为整数的数（没有小数点或者小数点后面都是零），则返回整数值\n\n\n# 转布尔\n\n在条件判断时，除了 undefined， null，false，nan，''， 0，-0，其他所有值都转为 true，包括所有对象。\n\n\n# 转字符串\n\n# tostring()\n\n该方法可以用于数值，布尔值，对象，字符串值;null,undefined 没有该方法\n\n当数值调用该方法时，可以传入一个底数参数,表示以什么底数输出数值的字符串表示\n\n# string()\n\nstring()转型函数遵循以下规则：\n\n * 如果值有 tostring()方法，则调用该方法(不传参数)并返回结果\n * 如果值是 null，返回“null”\n * 如果值是 undefined,返回“undefined”\n\n# 用 ➕ 操作符加上一个空字符串“”\n\nconst num = 11233333333123\n\nconst str = '1'\n\nconst obj = { a: 1 }\n\nconst bool = true\n\nconsole.log(typeof (num + '')) // string\nconsole.log(typeof (obj + '')) // string\nconsole.log(typeof (obj + '')) // string\nconsole.log(typeof (bool + ''))// string\nconsole.log(typeof +str)  // number\n\n\n\n# 对象转原始类型\n\n对象在转换类型的时候，会调用内置的 symbol.toprimitive 函数，对于该函数来说，算法逻辑一般来说如下：\n\n * 如果已经是原始类型了，那就不需要转换了\n * 调用 x.valueof()，如果转换为基础类型，就返回转换的值\n * 调用 x.tostring()，如果转换为基础类型，就返回转换的值\n * 如果都没有返回原始类型，就会报错\n\n当然你也可以重写 symbol.toprimitive ，该方法在转原始类型时调用优先级最高。\n\nlet a = {\n    valueof() {\n        return 0\n    },\n    tostring() {\n        return '1'\n    },\n    [symbol.toprimitive]() {\n        return 2\n    },\n}\n1 + a // => 3\n",charsets:{cjk:!0},lastUpdated:"2022年06月11日",lastUpdatedTimestamp:1654959677e3},{title:"操作符",frontmatter:{title:"操作符",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%AC%A6.html",relativePath:"前端开发/JavaScript/JS基础/操作符.md",key:"v-861bc42a",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%AC%A6.html",headers:[{level:2,title:"一元操作符",slug:"一元操作符",normalizedTitle:"一元操作符",charIndex:94},{level:3,title:"递增/递减操作符",slug:"递增-递减操作符",normalizedTitle:"递增/递减操作符",charIndex:122},{level:3,title:"一元加和减",slug:"一元加和减",normalizedTitle:"一元加和减",charIndex:699},{level:2,title:"布尔操作符",slug:"布尔操作符",normalizedTitle:"布尔操作符",charIndex:987},{level:3,title:"逻辑非",slug:"逻辑非",normalizedTitle:"逻辑非",charIndex:1092},{level:3,title:"逻辑与",slug:"逻辑与",normalizedTitle:"逻辑与",charIndex:1462},{level:3,title:"逻辑或",slug:"逻辑或",normalizedTitle:"逻辑或",charIndex:1504},{level:3,title:"短路运算",slug:"短路运算",normalizedTitle:"短路运算",charIndex:1540},{level:2,title:"乘性操作符",slug:"乘性操作符",normalizedTitle:"乘性操作符",charIndex:1957},{level:3,title:"取模操作符",slug:"取模操作符",normalizedTitle:"取模操作符",charIndex:2072},{level:2,title:"指数操作符",slug:"指数操作符",normalizedTitle:"指数操作符",charIndex:2138},{level:2,title:"加性操作符",slug:"加性操作符",normalizedTitle:"加性操作符",charIndex:2262},{level:2,title:"关系操作符",slug:"关系操作符",normalizedTitle:"关系操作符",charIndex:2991},{level:2,title:"相等操作符",slug:"相等操作符",normalizedTitle:"相等操作符",charIndex:3499},{level:2,title:"条件操作符",slug:"条件操作符",normalizedTitle:"条件操作符",charIndex:4098},{level:2,title:"赋值操作符",slug:"赋值操作符",normalizedTitle:"赋值操作符",charIndex:4212}],headersStr:"一元操作符 递增/递减操作符 一元加和减 布尔操作符 逻辑非 逻辑与 逻辑或 短路运算 乘性操作符 取模操作符 指数操作符 加性操作符 关系操作符 相等操作符 条件操作符 赋值操作符",content:"基础概念\n\n * 操作符：也叫运算符，是一种符号。通过操作符可以对一个或多个值进行运算，并获取运算结果\n * 表达式：由数字、运算符、变量的组成的式子，一个表达式往往会产生一个值\n\n\n# 一元操作符\n\n只操作一个值的操作符叫一元操作符\n\n\n# 递增/递减操作符\n\n++是递增操作符，表示在自身基础上加 1\n\na++先用再加，++a 先加再用\n\nvar a = 3\nvar b = ++a\nconsole.log(b) // 4\n\n\nvar a = 3\nvar b = a++\nconsole.log(b) // 3\n\n\n递减操作符同理，不做赘述\n\n另外，这 4 个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。 递增和递减操作符遵循如下规则：\n\n * 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。\n * 对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN。变量类型从字符串变成数值。\n * 对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值。如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。\n * 对于浮点值，加 1 或减 1。\n * 如果是对象，则调用其 valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他规则。变量类型从对象变成数值。\n\nlet a = {\n    valueOf() {\n        return -1\n    },\n}\na-- // 值变成2\n\n\n\n# 一元加和减\n\n一元加由一个加号（+）表示，放在变量前头，对数值没有任何影响\n\n如果将一元加应用到非数值，则会执行与使用 Number()转型函数一样的类型转换：布尔值 false 和 true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf()和/或 toString()方法以得到可以转换的值。\n\n一元减由一个减号（-）表示，放在变量前头，主要用于把数值变成负值\n\n在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值\n\n一元加和减操作符主要用于基本的算术，但也可以像上面的例子那样，用于数据类型转换。\n\n\n# 布尔操作符\n\n布尔操作符的优先级是：非 → 与 → 或，而在 js 表达式中的优先级是：非 → 数学（乘性，加性）→ 关系 → 布尔，例如：\n\n!5 < 4 + 4 || 3 < 1 // true\n\n\n\n# 逻辑非\n\n逻辑非操作符由一个叹号（!）表示，这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。 逻辑非操作符会遵循如下规则：\n\n * 如果操作数是对象，则返回 false。\n * 如果操作数是空字符串，则返回 true。\n * 如果操作数是非空字符串，则返回 false。\n * 如果操作数是数值 0，则返回 true。\n * 如果操作数是非 0 数值（包括 Infinity），则返回 false。\n * 如果操作数是 null，则返回 true。\n * 如果操作数是 NaN，则返回 true。\n * 如果操作数是 undefined，则返回 true。\n\n逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（!!），相当于调用了转型函数 Boolean()\n\n\n# 逻辑与\n\n逻辑与操作符由两个和号（&&）表示，应用到两个值,两个值都真才真\n\n\n# 逻辑或\n\n逻辑或操作符由两个管道符（||）表示，两个值有真就真\n\n\n# 短路运算\n\n# a&&b\n\n * 如果 a 是真的，b 的真假决定结果，b 真结果就真，b 假结果就假，所以它的结果就是 b\n * 如果 a 是假的，不用看 b 了，被短路了。结果就是 a\n\n3 && 6 // 6\nnull && 2 // null\n\n\n# a||b\n\n * 如果 a 是真的，不用看 b 了，被短路了。结果就是 a\n * 如果 a 是假的，b 的真假决定结果，b 真结果就真，b 假结果就假，所以它的结果就是 b\n\n如果出现布尔运算符连续的情况\n\n先计算前面的结果，拿这个结果和后面的进行计算：\n\nfalse || false || 123 =>123\n\nfunction  getDisplayName(WrappedComponent) {\n\treturn WrappedComponent.displayName || WrappedComponent.name || 'Component'\n}\n\n\n\n# 乘性操作符\n\nECMAScript 定义了 3 个乘性操作符：乘法、除法和取模。\n\n乘法操作符由一个星号（*）表示，可以用于计算两个数值的乘积。\n\n除法操作符由一个斜杠（/）表示，用于计算第一个操作数除以第二个操作数的商\n\n\n# 取模操作符\n\n * 取模操作符用百分号“%″表示\n\n * a%b表示求 a 除以 b 的余数，它不关心整数部分，只关心余数\n\n\n# 指数操作符\n\nECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符**，结果是一样的：\n\nconsole.log(Math.pow(3, 2); // 9\nconsole.log(3 ** 2);// 9\n\n\n\n# 加性操作符\n\n加性操作符，即加法和减法操作符\n\n加法操作符有“加法”和“连字符”两种作用,如果加号两边的操作数都是数字，则为“加法”\n\n如果有一方是字符串的话，加号的作用就是将他们进行拼接,在这种情况下，另一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，对于 undefined 和 null ,则调用 String() 函数， 分别获取 \"undefined\"和\"null\"\n\n如果加号两边均是布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再执行数学运算。如果转换结果是 NaN，则计算的结果是NaN；如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则计算的结果是 NaN。如果对象没有 valueOf()方法(Math 和 Error 对象没有 valueOf 方法)，则调用其 toString()方法，然后再将得到的字符串转换为数值\n\n减法操作符，除了基本的数学运算外，只要有一个操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再执行数学运算。如果转换结果是 NaN，则减法计算的结果是NaN；如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值\n\n一道NT面试题\n\n'a' + +'b' // -> \"aNaN\"\n\n\n因为 + 'b' 等于 NaN，所以结果为 \"aNaN\"\n\n\n# 关系操作符\n\n关系操作符执行比较两个值的操作，包括小于（<）、大于（>）、小于等于（<=）和大于等于（>=）,这几个操作符都返回布尔值\n\n * 如果操作数都是数值，则执行数值比较。\n * 如果操作数都是字符串，则逐个比较字符串中对应字符的编码。\n * 如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。\n * 如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。\n\nlet a = {\n    valueOf() {\n        return 0\n    },\n    toString() {\n        return '1'\n    },\n}\na > -1 // true\n\n\n在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。\n\n * 如果有任一操作数是布尔值，则将其转换为数值再执行比较。\n\njs 中没有连比\n\n2 < a <= 15 // ❌\n\na > 2 && a <= 15 // √\n\n\n\n# 相等操作符\n\n * 两个等号==运算符不比较值的类型，它会进行隐式转换后比较值是否相等\n\n * 三个等号===运算符，不仅比较值是否相同，也比较类型是否相同,只有两个操作数在不转换的前提下相等才返回 true。\n\n在转换操作数的类型时，相等和不相等操作符遵循如下规则:\n\n * 如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true转换为 1。\n * 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否 相等。\n * 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较。\n\n在进行比较时，这两个操作符会遵循如下规则:\n\n * null 和 undefined 相等。\n * null 和 undefined 不能转换为其他类型的值再进行比较。\n * 如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两 个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。\n * 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等。 全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。\n\n\n# 条件操作符\n\nvar a = b ? 1 : 2\n\n\n上面的代码执行了条件赋值操作，即根据条件表达式 b 的值决定将哪个值赋 给变量 a 。如果 b 是 true ，则赋值 1 ；如果 b 是 false，则赋值 2。\n\n\n# 赋值操作符\n\n简单赋值用等于号（=）表示，将右手边的值赋给左手边的变量\n\n每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：\n\n * 乘后赋值（*=）\n * 除后赋值（/=）\n * 取模后赋值（%=）\n * 加后赋值（+=）\n * 减后赋值（-=）",normalizedContent:"基础概念\n\n * 操作符：也叫运算符，是一种符号。通过操作符可以对一个或多个值进行运算，并获取运算结果\n * 表达式：由数字、运算符、变量的组成的式子，一个表达式往往会产生一个值\n\n\n# 一元操作符\n\n只操作一个值的操作符叫一元操作符\n\n\n# 递增/递减操作符\n\n++是递增操作符，表示在自身基础上加 1\n\na++先用再加，++a 先加再用\n\nvar a = 3\nvar b = ++a\nconsole.log(b) // 4\n\n\nvar a = 3\nvar b = a++\nconsole.log(b) // 3\n\n\n递减操作符同理，不做赘述\n\n另外，这 4 个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。 递增和递减操作符遵循如下规则：\n\n * 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。\n * 对于字符串，如果不是有效的数值形式，则将变量的值设置为 nan。变量类型从字符串变成数值。\n * 对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值。如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。\n * 对于浮点值，加 1 或减 1。\n * 如果是对象，则调用其 valueof()方法取得可以操作的值。对得到的值应用上述规则。如果是 nan，则调用 tostring()并再次应用其他规则。变量类型从对象变成数值。\n\nlet a = {\n    valueof() {\n        return -1\n    },\n}\na-- // 值变成2\n\n\n\n# 一元加和减\n\n一元加由一个加号（+）表示，放在变量前头，对数值没有任何影响\n\n如果将一元加应用到非数值，则会执行与使用 number()转型函数一样的类型转换：布尔值 false 和 true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueof()和/或 tostring()方法以得到可以转换的值。\n\n一元减由一个减号（-）表示，放在变量前头，主要用于把数值变成负值\n\n在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值\n\n一元加和减操作符主要用于基本的算术，但也可以像上面的例子那样，用于数据类型转换。\n\n\n# 布尔操作符\n\n布尔操作符的优先级是：非 → 与 → 或，而在 js 表达式中的优先级是：非 → 数学（乘性，加性）→ 关系 → 布尔，例如：\n\n!5 < 4 + 4 || 3 < 1 // true\n\n\n\n# 逻辑非\n\n逻辑非操作符由一个叹号（!）表示，这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。 逻辑非操作符会遵循如下规则：\n\n * 如果操作数是对象，则返回 false。\n * 如果操作数是空字符串，则返回 true。\n * 如果操作数是非空字符串，则返回 false。\n * 如果操作数是数值 0，则返回 true。\n * 如果操作数是非 0 数值（包括 infinity），则返回 false。\n * 如果操作数是 null，则返回 true。\n * 如果操作数是 nan，则返回 true。\n * 如果操作数是 undefined，则返回 true。\n\n逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（!!），相当于调用了转型函数 boolean()\n\n\n# 逻辑与\n\n逻辑与操作符由两个和号（&&）表示，应用到两个值,两个值都真才真\n\n\n# 逻辑或\n\n逻辑或操作符由两个管道符（||）表示，两个值有真就真\n\n\n# 短路运算\n\n# a&&b\n\n * 如果 a 是真的，b 的真假决定结果，b 真结果就真，b 假结果就假，所以它的结果就是 b\n * 如果 a 是假的，不用看 b 了，被短路了。结果就是 a\n\n3 && 6 // 6\nnull && 2 // null\n\n\n# a||b\n\n * 如果 a 是真的，不用看 b 了，被短路了。结果就是 a\n * 如果 a 是假的，b 的真假决定结果，b 真结果就真，b 假结果就假，所以它的结果就是 b\n\n如果出现布尔运算符连续的情况\n\n先计算前面的结果，拿这个结果和后面的进行计算：\n\nfalse || false || 123 =>123\n\nfunction  getdisplayname(wrappedcomponent) {\n\treturn wrappedcomponent.displayname || wrappedcomponent.name || 'component'\n}\n\n\n\n# 乘性操作符\n\necmascript 定义了 3 个乘性操作符：乘法、除法和取模。\n\n乘法操作符由一个星号（*）表示，可以用于计算两个数值的乘积。\n\n除法操作符由一个斜杠（/）表示，用于计算第一个操作数除以第二个操作数的商\n\n\n# 取模操作符\n\n * 取模操作符用百分号“%″表示\n\n * a%b表示求 a 除以 b 的余数，它不关心整数部分，只关心余数\n\n\n# 指数操作符\n\necmascript 7 新增了指数操作符，math.pow()现在有了自己的操作符**，结果是一样的：\n\nconsole.log(math.pow(3, 2); // 9\nconsole.log(3 ** 2);// 9\n\n\n\n# 加性操作符\n\n加性操作符，即加法和减法操作符\n\n加法操作符有“加法”和“连字符”两种作用,如果加号两边的操作数都是数字，则为“加法”\n\n如果有一方是字符串的话，加号的作用就是将他们进行拼接,在这种情况下，另一操作数是对象、数值或布尔值，则调用它们的 tostring()方法以获取字符串，对于 undefined 和 null ,则调用 string() 函数， 分别获取 \"undefined\"和\"null\"\n\n如果加号两边均是布尔值、null 或 undefined，则先在后台使用 number()将其转换为数值，然后再执行数学运算。如果转换结果是 nan，则计算的结果是nan；如果有任一操作数是对象，则调用其 valueof()方法取得表示它的数值。如果该值是 nan，则计算的结果是 nan。如果对象没有 valueof()方法(math 和 error 对象没有 valueof 方法)，则调用其 tostring()方法，然后再将得到的字符串转换为数值\n\n减法操作符，除了基本的数学运算外，只要有一个操作数是字符串、布尔值、null 或 undefined，则先在后台使用 number()将其转换为数值，然后再执行数学运算。如果转换结果是 nan，则减法计算的结果是nan；如果有任一操作数是对象，则调用其 valueof()方法取得表示它的数值。如果该值是 nan，则减法计算的结果是 nan。如果对象没有 valueof()方法，则调用其 tostring()方法，然后再将得到的字符串转换为数值\n\n一道nt面试题\n\n'a' + +'b' // -> \"anan\"\n\n\n因为 + 'b' 等于 nan，所以结果为 \"anan\"\n\n\n# 关系操作符\n\n关系操作符执行比较两个值的操作，包括小于（<）、大于（>）、小于等于（<=）和大于等于（>=）,这几个操作符都返回布尔值\n\n * 如果操作数都是数值，则执行数值比较。\n * 如果操作数都是字符串，则逐个比较字符串中对应字符的编码。\n * 如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。\n * 如果有任一操作数是对象，则调用其 valueof()方法，取得结果后再根据前面的规则执行比较。如果没有 valueof()操作符，则调用 tostring()方法，取得结果后再根据前面的规则执行比较。\n\nlet a = {\n    valueof() {\n        return 0\n    },\n    tostring() {\n        return '1'\n    },\n}\na > -1 // true\n\n\n在以上代码中，因为 a 是对象，所以会通过 valueof 转换为原始类型再比较值。\n\n * 如果有任一操作数是布尔值，则将其转换为数值再执行比较。\n\njs 中没有连比\n\n2 < a <= 15 // ❌\n\na > 2 && a <= 15 // √\n\n\n\n# 相等操作符\n\n * 两个等号==运算符不比较值的类型，它会进行隐式转换后比较值是否相等\n\n * 三个等号===运算符，不仅比较值是否相同，也比较类型是否相同,只有两个操作数在不转换的前提下相等才返回 true。\n\n在转换操作数的类型时，相等和不相等操作符遵循如下规则:\n\n * 如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true转换为 1。\n * 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否 相等。\n * 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueof()方法取得其原始值，再根据前面的规则进行比较。\n\n在进行比较时，这两个操作符会遵循如下规则:\n\n * null 和 undefined 相等。\n * null 和 undefined 不能转换为其他类型的值再进行比较。\n * 如果有任一操作数是 nan，则相等操作符返回 false，不相等操作符返回 true。记住：即使两 个操作数都是 nan，相等操作符也返回 false，因为按照规则，nan 不等于 nan。\n * 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等。 全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。\n\n\n# 条件操作符\n\nvar a = b ? 1 : 2\n\n\n上面的代码执行了条件赋值操作，即根据条件表达式 b 的值决定将哪个值赋 给变量 a 。如果 b 是 true ，则赋值 1 ；如果 b 是 false，则赋值 2。\n\n\n# 赋值操作符\n\n简单赋值用等于号（=）表示，将右手边的值赋给左手边的变量\n\n每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：\n\n * 乘后赋值（*=）\n * 除后赋值（/=）\n * 取模后赋值（%=）\n * 加后赋值（+=）\n * 减后赋值（-=）",charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"数组",frontmatter:{title:"数组",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84.html",relativePath:"前端开发/JavaScript/JS基础/数组.md",key:"v-3b874c4a",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84.html",headers:[{level:2,title:"数组简介和基本使用",slug:"数组简介和基本使用",normalizedTitle:"数组简介和基本使用",charIndex:2},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:4},{level:3,title:"定义方法",slug:"定义方法",normalizedTitle:"定义方法",charIndex:73},{level:3,title:"访问数组项",slug:"访问数组项",normalizedTitle:"访问数组项",charIndex:192},{level:3,title:"下标越界",slug:"下标越界",normalizedTitle:"下标越界",charIndex:256},{level:3,title:"数组的长度",slug:"数组的长度",normalizedTitle:"数组的长度",charIndex:308},{level:3,title:"更改数组项",slug:"更改数组项",normalizedTitle:"更改数组项",charIndex:364},{level:3,title:"数组的遍历",slug:"数组的遍历",normalizedTitle:"数组的遍历",charIndex:433},{level:3,title:"数组类型的检测",slug:"数组类型的检测",normalizedTitle:"数组类型的检测",charIndex:530},{level:2,title:"数组的常用方法",slug:"数组的常用方法",normalizedTitle:"数组的常用方法",charIndex:599},{level:3,title:"数组的头尾操作",slug:"数组的头尾操作",normalizedTitle:"数组的头尾操作",charIndex:642},{level:3,title:"数组的常用方法",slug:"数组的常用方法-2",normalizedTitle:"数组的常用方法",charIndex:599},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:635},{level:2,title:"数组相关算法",slug:"数组相关算法",normalizedTitle:"数组相关算法",charIndex:5844},{level:3,title:"数组遍历",slug:"数组遍历",normalizedTitle:"数组遍历",charIndex:5855},{level:3,title:"数组去重",slug:"数组去重",normalizedTitle:"数组去重",charIndex:6169},{level:3,title:"随机样本",slug:"随机样本",normalizedTitle:"随机样本",charIndex:6474},{level:3,title:"冒泡排序",slug:"冒泡排序",normalizedTitle:"冒泡排序",charIndex:6736},{level:2,title:"二维数组",slug:"二维数组",normalizedTitle:"二维数组",charIndex:7327}],headersStr:"数组简介和基本使用 简介 定义方法 访问数组项 下标越界 数组的长度 更改数组项 数组的遍历 数组类型的检测 数组的常用方法 数组的头尾操作 数组的常用方法 总结 数组相关算法 数组遍历 数组去重 随机样本 冒泡排序 二维数组",content:"# 数组简介和基本使用\n\n\n# 简介\n\n数组（Array），顾名思义，用来存储组相关的值，从而方便进行求和、计算平均数、逐项遍历等操作。\n\n\n# 定义方法\n\n 1. var arr=[1,2,3]\n 2. var arr=new Array(1,2,3) //包装类\n 3. var arr=new Array(3) // 长度为 3 的数字，每一项都是 undefined\n\n\n# 访问数组项\n\n数组每一项都有下标，下标从 0 开始\n\nvar arr = (1, 2, 3)\narr[1] // 2\n\n\n\n# 下标越界\n\nJavaScrip 规定，访问数组中不存在的项会返回 undefined，不会报错\n\n\n# 数组的长度\n\n * 数组的 length 属性表示它的长度\n * 数组最后一项的下标是数组的长度减 1\n\n\n# 更改数组项\n\n * 数组并不是只读的，我们可以修改它其中任何项的值\n * 如果更改的数组项超过了 length-1，则会创造这项\n\n\n# 数组的遍历\n\nvar arr = [1, 2, 3]\nfor (var i = 0; i < arr.length; i++) {\n    console.log(arr[i])\n}\n\n\n\n# 数组类型的检测\n\n 1. arr instanceof Array // 返回 true\n 2. arr.isArray()方法\n\n\n# 数组的常用方法\n\n[7000 字]JavaScript 数组所有方法基础总结\n\n\n# 数组的头尾操作\n\n 1. push()\n\n * push()方法用来在数组末尾推入新项，参数就是要推入的项\n * 如果要推入多项，可以用逗号隔开\n * 调用 push()方法后，数组会立即改变，不需要赋值\n * 该方法会返回新的长度\n\n 2. pop()\n\n * 与 push()相反，pop()方法用来删除数组中的最后一项\n * pop()方法不仅会删除数组末项，而且会返回被删除的项\n\n 3. unshift()\n\n * unshift()方法用来在数组头部插入新项，参数就是要插入的项\n * 如果要插入多项，可以用逗号隔开\n * 调用 unshift()方法后，数组会立即改变，不需要赋值\n * 该方法会返回新的长度\n\n 4. shift()\n\n * 与 unshift()相反， shift()方法用来删除数组中下标为 0的项\n * shift()方法不仅会删除数组首项，而且会返回被删除的项\n\n\n# 数组的常用方法\n\n# splice()\n\n * splice()方法用于替换数组中的指定项\n\nvar arr = [3, 1, 3, 4]\narr.splice(1, 2, 4, 5) //从下标为1的项开始，连续替换两项\nconsole.log(arr) // [3,4,5,4]\n\n\n * splice()方法可以用于在指定位置插入新项\n\nvar arr = [3, 1, 3, 4]\narr.splice(1, 0, 6, 7) // 在下标为1的位置插入两项，不替换\nconsole.log(arr) // [3,6,7,1,3,4]\n\n\n * splice()方法可以用于删除指定项\n\nvar arr = [3, 1, 3, 4]\narr.splice(1, 1) // 没有设置替换的新项，仅删除1项\nconsole.log(arr) // [3,3,4]\n\n\n * splice()方法会以数组形式返回被删除的项\n\n# slice()\n\n * slice()方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝\n * slice(a,b)截取的子数组从下标为 a 的项开始，到下标为 b（但不包括下标为 b 的项）结束\n * slice(a,b)方法不会更改原有数组\n * slice()如果不提供第二个参数，则表示从指定项开始，提取所有后续所有项作为子数组\n * slice()方法的参数允许为负数，表示数组的倒数第几项\n * 如果同时省略begin 和 end参数，将返回一个原数组的浅拷贝\n\n// 浅拷贝\nlet arr = [\n    1,\n    3,\n    {\n        username: ' kobe',\n    },\n]\nlet arr3 = arr.slice()\narr3[2].username = 'wade'\nconsole.log(arr) // [ 1, 3, { username: 'wade' } ]\n\n\n# join()和 split()方法\n\n数组的 join()方法可以使数组转为字符串；字符串的split()方法可以使字符串转为数组。\n\n * join()的参数表示以什么字符作为连接符，如果留空则默认以逗号分隔，如同调用 tostring()方法\n * split()的参数表示以什么字符拆分字符串，一般不能留空=>(str.split(''))\n\n'abcd'.split('') // [ 'a', 'b', 'c', 'd' ]\n\n\n字符串和数组更多相关性\n\n * 字符串也可以使用方括号内写下标的形式，访问某个字符等价于 charAt()方法,意味着字符串可以直接遍历\n\nvar str = '123456'\nfor (var i = 0; i < str.length; i++) {\n    console.log(str[i])\n}\n\n\n * 字符串的一些算法问题有时候会转换为数组解决\n\n# concat()\n\nconcat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组\n\n参数：数组和/或值，将被合并到一个新的数组中。如果没有参数，则 concat 会返回调用此方法的现存数组的一个浅拷贝\n\n返回值：一个新的数组\n\nconst array1 = ['a', 'b', 'c']\nconst array2 = ['d', 'e', 'f']\nconst array3 = array1.concat(array2)\n\nconsole.log(array3)\n\n\n# reverse()\n\nreverse()方法用来将一个数组中的全部项顺序置反\n\n# indexOf()和 includes()方法\n\n * indexOf()方法的功能是搜索数组中的元素，并返回它所在的位置，如果元素不存在，则返回-1\n * includes()方法的功能是判断一个数组是否包含一个指定的值，返回布尔值\n\n# filter()\n\nfilter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。\n\n返回值：一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。\n\ncallback(用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。)被调用时传入三个参数：元素的值，元素的索引，被遍历的数组本身\n\nconst words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present']\n\nconst result = words.filter(word => word.length > 6)\n\nconsole.log(result)\n// expected output: Array [\"exuberant\", \"destruction\", \"present\"]\n\n\n# forEach()\n\nforEach() 方法对数组的每个元素执行一次给定的函数\n\n返回值：undefined\n\ncallback 被调用时传入三个参数：数组当前项的值，数组当前项的索引，数组对象本身\n\nconst array1 = ['a', 'b', 'c']\n\narray1.forEach(element => console.log(element))\n\n// expected output: \"a\"\n// expected output: \"b\"\n// expected output: \"c\"\n\n\n# map()\n\nmap()方法的回调函数每次执行后的返回值组合起来形成一个新数组\n\n返回值：一个由原数组每个元素执行回调函数的结果组成的新数组。\n\ncallback 被调用时传入三个参数：数组元素，元素索引，原数组本身\n\nconst array1 = [1, 4, 9, 16]\n\n// pass a function to map\nconst map1 = array1.map(x => {\n    return x * 2\n})\n\nconsole.log(map1)\n// expected output: Array [2, 8, 18, 32]\n\n\nforEach() 和 map() 的区别\n\n返回值:forEach()方法返回 undefined ，而 map()返回一个包含已转换元素的新数组\n\n链接其他方法:map()方法输出可以与其他方法(如 reduce()、sort()、filter())链接在一起，以便在一条语句中执行多个操作。另一方面，forEach()不能与其他方法链接，因为它返回 undefined。\n\n性能:map()方法比 forEach()转换元素要好。\n\n中断遍历:这两种方法都不能用 break 中断，否则会引发异常\n\n建议使用 map()转换数组的元素，因为它语法短，可链接且性能更好。\n\n如果不想返回的数组或不转换数组的元素，则使用 forEach() 方法。\n\n最后，如果要基于某种条件停止或中断数组的遍历，则应使用简单的 for 循环或 for-of / for-in 循环。\n\n参考：数组中 forEach() 和 map() 的区别\n\n# reduce()\n\nreduce() 方法对数组中的每个元素执行一个由您提供的 reducer 函数，将其结果汇总为单个返回值。\n\n返回值：函数累计处理的结果\n\n参数：reducer 函数,initialValue\n\nreducer 函数接收 4 个参数:\n\n * previousValue (pre) (上一次调用 reducer 函数的返回值)\n * currentValue (cur) (数组中正在处理的元素)\n * currentIndex(idx) (数组中正在处理的元素的索引 )\n * array (arr) (用于遍历的数组)\n\n每一次运行 reducer函数会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。\n\ninitialValue(可选): 作为第一次调用 reducer函数时的previousValue的值。如果没有提供初始值，则将使用数组中的第一个元素,currentValue 将使用数组第二个元素;若指定了初始值 initialValue，则 currentValue 则将使用数组第一个元素\n\nconst array1 = [1, 2, 3, 4]\ntotal = array1.reduce((acc, cur) => {\n    return acc + cur\n})\nconsole.log(total) //10\n\n\n# sort()\n\n特别注意：sort 方法的返回值是对原数组的引用。数组在原数组上进行排序，不生成副本。\n\nconst arr = [1, 2, 0, 123, -1]\nconst arr2 = arr.sort((a, b) => {\n    return a - b\n})\nconsole.log(arr) // [ -1, 0, 1, 2, 123 ]\nconsole.log(arr === arr2) // true\n\n\nArray.prototype.sort()\n\n * 升序排序\n\narrObject.sort(function(a,b){return a-b})\n\n当 a==b 时，返回值是 0，a 和 b 不用交换位置。\n\n当 a>b 时，返回值大于 0，a 放置在 b 后面。\n\n当 a< b 时，返回值小于 0，a 和 b 不用交换位置。\n\n * 降序排序\n\narrObject.sort(function(a,b){return b-a})\n\n当 a==b 时，返回值是 0，a 和 b 不用交换位置。\n\n当 a>b 时，返回值小于 0，a 和 b 不用交换位置。\n\n当 a< b 时，返回值大于 0，a 放置在 b 后面。\n\n\n# 总结\n\n注意\n\n后面括号中为该方法是否改变原数组\n\n * push：用来在数组末尾推入新项（改变）\n * pop：用来删除数组中的最后一项（改变）\n * unshift：用来在数组开头插入新项（改变）\n * shift：用来删除数组中的第一个元素（改变）\n * splice：用于替换数组中的指定项（改变）\n * reverse：用来将一个数组中的全部项顺序置反（改变）\n * slice：用于得到子数组（不改变）\n * join： 使数组转为字符串（不改变）\n * concat：合并连接多个数组,返回一个新的数组（不改变）\n * indexOf：搜索数组中的元素，并返回它所在的位置（不改变）\n * includes：判断一个数组是否包含一个指定的值（不改变）\n * sort: 在原数组上进行排序，不生成副本（改变）\n * fifter: 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素（不改变）\n * forEach: 对数组的每个元素执行一次给定的函数,返回值为 undefined（不改变:forEach 不会直接改变调用它的对象，但是那个对象可能会被 callback 函数改变）\n * map: 创建一个新数组, 新数组中的元素是原数组中的每个元素调用一次提供的函数后的返回值（不改变）\n * reduce: 对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值（不改变）\n\n\n# 数组相关算法\n\n\n# 数组遍历\n\n * 求数组的和，平均数\n * 求数组的最大值，最小值\n\n// 求数组的最大值，最小值\nvar arr = [1, 2, 3, 45, 9, 2, 5, 67]\nvar max = arr[0]\nvar min = arr[0]\nfor (i = 1; i < arr.length; i++) {\n    if (max < arr[i]) {\n        max = arr[i]\n    } else if (arr[i] < min) {\n        min = arr[i]\n    }\n}\nconsole.log('最大值' + max + '<br>' + '最小值' + min)\n\n\n\n# 数组去重\n\n// 算法思路：准备一个空数组，遍历原数组，如果遍历到的项不在结果数组内，则推入结果数组\nvar arr = [1, 2, 1, 3, 4, 5, 5, 5, 6]\n//  结果数组\nvar result = []\nfor (var i = 0; i < arr.length; i++) {\n    // include 是判断一个数组是否包含一个指定的值\n    if (!result.includes(arr[i])) {\n        //  在数组尾部插入新项\n        result.push(arr[i])\n    }\n}\nconsole.log(result)\n\n\n\n# 随机样本\n\n// 算法思路：准备一个空数组，遍历原数组，随机选择一项，推入结果数组，并且将这项删除\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8]\n// 结果数组\nvar result = []\nfor (var i = 0; i < 3; i++) {\n    var n = Math.floor(Math.random() * arr.length)\n    result.push(arr[n])\n    arr.splice(n, 1)\n}\nconsole.log(result)\n\n\n\n# 冒泡排序\n\n冒洵排序的核心思路是一趟一趟地进行多次项的两两比较每次都会将最小的元素排好位置，如同水中的气泡上浮一样\n\n\n\nvar arr = [1, 23, 4, 5]\nfor (var i = 1; i < arr.length; i++) {\n    //  j>=i ?  j代表的就是数组的下标数,总是结束在趟号那项,j=i就是最后一次比较\n    for (var j = arr.length - 1; j >= i; j--) {\n        // 内层循环负责两个数字进行比较，如果前一项大于这一项，则两项更换位置\n        if (arr[j - 1] > arr[j]) {\n            // var temp = arr[j-1]\n            // arr[j-1] = arr[j]\n            // arr[j] =temp\n            // 解构赋值\n            ;[arr[j - 1], arr[j]] = [arr[j], arr[j - 1]]\n        }\n    }\n}\nconsole.log(arr)\n\n\n * 4 个数字，共需要比较 3 趟，比较次数为 3+2+1=6 次\n * n 个数字，共需要比较 n-1 趟，比较次数为 n（n-1）/2 次。\n\n\n# 二维数组\n\n以数组作为数组元素的数组，即“数组的数组“",normalizedContent:"# 数组简介和基本使用\n\n\n# 简介\n\n数组（array），顾名思义，用来存储组相关的值，从而方便进行求和、计算平均数、逐项遍历等操作。\n\n\n# 定义方法\n\n 1. var arr=[1,2,3]\n 2. var arr=new array(1,2,3) //包装类\n 3. var arr=new array(3) // 长度为 3 的数字，每一项都是 undefined\n\n\n# 访问数组项\n\n数组每一项都有下标，下标从 0 开始\n\nvar arr = (1, 2, 3)\narr[1] // 2\n\n\n\n# 下标越界\n\njavascrip 规定，访问数组中不存在的项会返回 undefined，不会报错\n\n\n# 数组的长度\n\n * 数组的 length 属性表示它的长度\n * 数组最后一项的下标是数组的长度减 1\n\n\n# 更改数组项\n\n * 数组并不是只读的，我们可以修改它其中任何项的值\n * 如果更改的数组项超过了 length-1，则会创造这项\n\n\n# 数组的遍历\n\nvar arr = [1, 2, 3]\nfor (var i = 0; i < arr.length; i++) {\n    console.log(arr[i])\n}\n\n\n\n# 数组类型的检测\n\n 1. arr instanceof array // 返回 true\n 2. arr.isarray()方法\n\n\n# 数组的常用方法\n\n[7000 字]javascript 数组所有方法基础总结\n\n\n# 数组的头尾操作\n\n 1. push()\n\n * push()方法用来在数组末尾推入新项，参数就是要推入的项\n * 如果要推入多项，可以用逗号隔开\n * 调用 push()方法后，数组会立即改变，不需要赋值\n * 该方法会返回新的长度\n\n 2. pop()\n\n * 与 push()相反，pop()方法用来删除数组中的最后一项\n * pop()方法不仅会删除数组末项，而且会返回被删除的项\n\n 3. unshift()\n\n * unshift()方法用来在数组头部插入新项，参数就是要插入的项\n * 如果要插入多项，可以用逗号隔开\n * 调用 unshift()方法后，数组会立即改变，不需要赋值\n * 该方法会返回新的长度\n\n 4. shift()\n\n * 与 unshift()相反， shift()方法用来删除数组中下标为 0的项\n * shift()方法不仅会删除数组首项，而且会返回被删除的项\n\n\n# 数组的常用方法\n\n# splice()\n\n * splice()方法用于替换数组中的指定项\n\nvar arr = [3, 1, 3, 4]\narr.splice(1, 2, 4, 5) //从下标为1的项开始，连续替换两项\nconsole.log(arr) // [3,4,5,4]\n\n\n * splice()方法可以用于在指定位置插入新项\n\nvar arr = [3, 1, 3, 4]\narr.splice(1, 0, 6, 7) // 在下标为1的位置插入两项，不替换\nconsole.log(arr) // [3,6,7,1,3,4]\n\n\n * splice()方法可以用于删除指定项\n\nvar arr = [3, 1, 3, 4]\narr.splice(1, 1) // 没有设置替换的新项，仅删除1项\nconsole.log(arr) // [3,3,4]\n\n\n * splice()方法会以数组形式返回被删除的项\n\n# slice()\n\n * slice()方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝\n * slice(a,b)截取的子数组从下标为 a 的项开始，到下标为 b（但不包括下标为 b 的项）结束\n * slice(a,b)方法不会更改原有数组\n * slice()如果不提供第二个参数，则表示从指定项开始，提取所有后续所有项作为子数组\n * slice()方法的参数允许为负数，表示数组的倒数第几项\n * 如果同时省略begin 和 end参数，将返回一个原数组的浅拷贝\n\n// 浅拷贝\nlet arr = [\n    1,\n    3,\n    {\n        username: ' kobe',\n    },\n]\nlet arr3 = arr.slice()\narr3[2].username = 'wade'\nconsole.log(arr) // [ 1, 3, { username: 'wade' } ]\n\n\n# join()和 split()方法\n\n数组的 join()方法可以使数组转为字符串；字符串的split()方法可以使字符串转为数组。\n\n * join()的参数表示以什么字符作为连接符，如果留空则默认以逗号分隔，如同调用 tostring()方法\n * split()的参数表示以什么字符拆分字符串，一般不能留空=>(str.split(''))\n\n'abcd'.split('') // [ 'a', 'b', 'c', 'd' ]\n\n\n字符串和数组更多相关性\n\n * 字符串也可以使用方括号内写下标的形式，访问某个字符等价于 charat()方法,意味着字符串可以直接遍历\n\nvar str = '123456'\nfor (var i = 0; i < str.length; i++) {\n    console.log(str[i])\n}\n\n\n * 字符串的一些算法问题有时候会转换为数组解决\n\n# concat()\n\nconcat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组\n\n参数：数组和/或值，将被合并到一个新的数组中。如果没有参数，则 concat 会返回调用此方法的现存数组的一个浅拷贝\n\n返回值：一个新的数组\n\nconst array1 = ['a', 'b', 'c']\nconst array2 = ['d', 'e', 'f']\nconst array3 = array1.concat(array2)\n\nconsole.log(array3)\n\n\n# reverse()\n\nreverse()方法用来将一个数组中的全部项顺序置反\n\n# indexof()和 includes()方法\n\n * indexof()方法的功能是搜索数组中的元素，并返回它所在的位置，如果元素不存在，则返回-1\n * includes()方法的功能是判断一个数组是否包含一个指定的值，返回布尔值\n\n# filter()\n\nfilter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。\n\n返回值：一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。\n\ncallback(用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。)被调用时传入三个参数：元素的值，元素的索引，被遍历的数组本身\n\nconst words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present']\n\nconst result = words.filter(word => word.length > 6)\n\nconsole.log(result)\n// expected output: array [\"exuberant\", \"destruction\", \"present\"]\n\n\n# foreach()\n\nforeach() 方法对数组的每个元素执行一次给定的函数\n\n返回值：undefined\n\ncallback 被调用时传入三个参数：数组当前项的值，数组当前项的索引，数组对象本身\n\nconst array1 = ['a', 'b', 'c']\n\narray1.foreach(element => console.log(element))\n\n// expected output: \"a\"\n// expected output: \"b\"\n// expected output: \"c\"\n\n\n# map()\n\nmap()方法的回调函数每次执行后的返回值组合起来形成一个新数组\n\n返回值：一个由原数组每个元素执行回调函数的结果组成的新数组。\n\ncallback 被调用时传入三个参数：数组元素，元素索引，原数组本身\n\nconst array1 = [1, 4, 9, 16]\n\n// pass a function to map\nconst map1 = array1.map(x => {\n    return x * 2\n})\n\nconsole.log(map1)\n// expected output: array [2, 8, 18, 32]\n\n\nforeach() 和 map() 的区别\n\n返回值:foreach()方法返回 undefined ，而 map()返回一个包含已转换元素的新数组\n\n链接其他方法:map()方法输出可以与其他方法(如 reduce()、sort()、filter())链接在一起，以便在一条语句中执行多个操作。另一方面，foreach()不能与其他方法链接，因为它返回 undefined。\n\n性能:map()方法比 foreach()转换元素要好。\n\n中断遍历:这两种方法都不能用 break 中断，否则会引发异常\n\n建议使用 map()转换数组的元素，因为它语法短，可链接且性能更好。\n\n如果不想返回的数组或不转换数组的元素，则使用 foreach() 方法。\n\n最后，如果要基于某种条件停止或中断数组的遍历，则应使用简单的 for 循环或 for-of / for-in 循环。\n\n参考：数组中 foreach() 和 map() 的区别\n\n# reduce()\n\nreduce() 方法对数组中的每个元素执行一个由您提供的 reducer 函数，将其结果汇总为单个返回值。\n\n返回值：函数累计处理的结果\n\n参数：reducer 函数,initialvalue\n\nreducer 函数接收 4 个参数:\n\n * previousvalue (pre) (上一次调用 reducer 函数的返回值)\n * currentvalue (cur) (数组中正在处理的元素)\n * currentindex(idx) (数组中正在处理的元素的索引 )\n * array (arr) (用于遍历的数组)\n\n每一次运行 reducer函数会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。\n\ninitialvalue(可选): 作为第一次调用 reducer函数时的previousvalue的值。如果没有提供初始值，则将使用数组中的第一个元素,currentvalue 将使用数组第二个元素;若指定了初始值 initialvalue，则 currentvalue 则将使用数组第一个元素\n\nconst array1 = [1, 2, 3, 4]\ntotal = array1.reduce((acc, cur) => {\n    return acc + cur\n})\nconsole.log(total) //10\n\n\n# sort()\n\n特别注意：sort 方法的返回值是对原数组的引用。数组在原数组上进行排序，不生成副本。\n\nconst arr = [1, 2, 0, 123, -1]\nconst arr2 = arr.sort((a, b) => {\n    return a - b\n})\nconsole.log(arr) // [ -1, 0, 1, 2, 123 ]\nconsole.log(arr === arr2) // true\n\n\narray.prototype.sort()\n\n * 升序排序\n\narrobject.sort(function(a,b){return a-b})\n\n当 a==b 时，返回值是 0，a 和 b 不用交换位置。\n\n当 a>b 时，返回值大于 0，a 放置在 b 后面。\n\n当 a< b 时，返回值小于 0，a 和 b 不用交换位置。\n\n * 降序排序\n\narrobject.sort(function(a,b){return b-a})\n\n当 a==b 时，返回值是 0，a 和 b 不用交换位置。\n\n当 a>b 时，返回值小于 0，a 和 b 不用交换位置。\n\n当 a< b 时，返回值大于 0，a 放置在 b 后面。\n\n\n# 总结\n\n注意\n\n后面括号中为该方法是否改变原数组\n\n * push：用来在数组末尾推入新项（改变）\n * pop：用来删除数组中的最后一项（改变）\n * unshift：用来在数组开头插入新项（改变）\n * shift：用来删除数组中的第一个元素（改变）\n * splice：用于替换数组中的指定项（改变）\n * reverse：用来将一个数组中的全部项顺序置反（改变）\n * slice：用于得到子数组（不改变）\n * join： 使数组转为字符串（不改变）\n * concat：合并连接多个数组,返回一个新的数组（不改变）\n * indexof：搜索数组中的元素，并返回它所在的位置（不改变）\n * includes：判断一个数组是否包含一个指定的值（不改变）\n * sort: 在原数组上进行排序，不生成副本（改变）\n * fifter: 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素（不改变）\n * foreach: 对数组的每个元素执行一次给定的函数,返回值为 undefined（不改变:foreach 不会直接改变调用它的对象，但是那个对象可能会被 callback 函数改变）\n * map: 创建一个新数组, 新数组中的元素是原数组中的每个元素调用一次提供的函数后的返回值（不改变）\n * reduce: 对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值（不改变）\n\n\n# 数组相关算法\n\n\n# 数组遍历\n\n * 求数组的和，平均数\n * 求数组的最大值，最小值\n\n// 求数组的最大值，最小值\nvar arr = [1, 2, 3, 45, 9, 2, 5, 67]\nvar max = arr[0]\nvar min = arr[0]\nfor (i = 1; i < arr.length; i++) {\n    if (max < arr[i]) {\n        max = arr[i]\n    } else if (arr[i] < min) {\n        min = arr[i]\n    }\n}\nconsole.log('最大值' + max + '<br>' + '最小值' + min)\n\n\n\n# 数组去重\n\n// 算法思路：准备一个空数组，遍历原数组，如果遍历到的项不在结果数组内，则推入结果数组\nvar arr = [1, 2, 1, 3, 4, 5, 5, 5, 6]\n//  结果数组\nvar result = []\nfor (var i = 0; i < arr.length; i++) {\n    // include 是判断一个数组是否包含一个指定的值\n    if (!result.includes(arr[i])) {\n        //  在数组尾部插入新项\n        result.push(arr[i])\n    }\n}\nconsole.log(result)\n\n\n\n# 随机样本\n\n// 算法思路：准备一个空数组，遍历原数组，随机选择一项，推入结果数组，并且将这项删除\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8]\n// 结果数组\nvar result = []\nfor (var i = 0; i < 3; i++) {\n    var n = math.floor(math.random() * arr.length)\n    result.push(arr[n])\n    arr.splice(n, 1)\n}\nconsole.log(result)\n\n\n\n# 冒泡排序\n\n冒洵排序的核心思路是一趟一趟地进行多次项的两两比较每次都会将最小的元素排好位置，如同水中的气泡上浮一样\n\n\n\nvar arr = [1, 23, 4, 5]\nfor (var i = 1; i < arr.length; i++) {\n    //  j>=i ?  j代表的就是数组的下标数,总是结束在趟号那项,j=i就是最后一次比较\n    for (var j = arr.length - 1; j >= i; j--) {\n        // 内层循环负责两个数字进行比较，如果前一项大于这一项，则两项更换位置\n        if (arr[j - 1] > arr[j]) {\n            // var temp = arr[j-1]\n            // arr[j-1] = arr[j]\n            // arr[j] =temp\n            // 解构赋值\n            ;[arr[j - 1], arr[j]] = [arr[j], arr[j - 1]]\n        }\n    }\n}\nconsole.log(arr)\n\n\n * 4 个数字，共需要比较 3 趟，比较次数为 3+2+1=6 次\n * n 个数字，共需要比较 n-1 趟，比较次数为 n（n-1）/2 次。\n\n\n# 二维数组\n\n以数组作为数组元素的数组，即“数组的数组“",charsets:{cjk:!0},lastUpdated:"2022年06月04日",lastUpdatedTimestamp:1654357652e3},{title:"正则表达式",frontmatter:{title:"正则表达式",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"前端开发/JavaScript/JS基础/正则表达式.md",key:"v-773a8648",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",headers:[{level:2,title:"正则表达式的创建",slug:"正则表达式的创建",normalizedTitle:"正则表达式的创建",charIndex:141},{level:2,title:"元字符",slug:"元字符",normalizedTitle:"元字符",charIndex:351},{level:2,title:"方括号表示法",slug:"方括号表示法",normalizedTitle:"方括号表示法",charIndex:1162},{level:2,title:"量词",slug:"量词",normalizedTitle:"量词",charIndex:1291},{level:2,title:"修饰符",slug:"修饰符",normalizedTitle:"修饰符",charIndex:1393},{level:2,title:"正则表达式的相关方法",slug:"正则表达式的相关方法",normalizedTitle:"正则表达式的相关方法",charIndex:1447},{level:2,title:"字符串的相关方法",slug:"字符串的相关方法",normalizedTitle:"字符串的相关方法",charIndex:1560},{level:2,title:"正则的应用",slug:"正则的应用",normalizedTitle:"正则的应用",charIndex:2114}],headersStr:"正则表达式的创建 元字符 方括号表示法 量词 修饰符 正则表达式的相关方法 字符串的相关方法 正则的应用",content:'正则表达式(regular expression)描述了字符串的“构成模式”，经常被用于检查字符串是否符合预定的格式要求\n\n正则表达式“按位”描述规则，是指它是一位一位的描述字符串的构成形式\n\n正则表达式可以调用 test()方法，检查某字符串是否符合正则表达式规定的规则\n\n\n# 正则表达式的创建\n\n * 使用/内容/的语法形式，可以快速创建正则表达式\n * 也可以使用 new RegExp(\'内容\')的形式，创建正则表达式(这种写法有坑！)\n   \n   警告\n   \n   如果使用 new RegExp() 写法，反斜杠需要多写一个，比如/^\\d$/和 new RegExp（\'^\\\\d$\'）是相同的意思\n\n * 使用 typeof 运算符检查正则表达式的类型，结果是 object\n\n\n# 元字符\n\n"元字符”是指 一位 指定类型的字符\n\n\n\n开头和结尾\n\n\n\n元字符：|\n\n正则中使用竖线" | "表示或，表示只匹配指定几项之间的一项\n\neg:只匹配纯数字或纯字母\n\nvar str1 = \'1111\'\nvar str2 = \'imooc\'\nvar str3 = \'1111imooc\'\nvar reg = /^\\d+$|^[a-zA-Z]+$/\nconsole.log(reg.test(str1)) // true\nconsole.log(reg.test(str2)) // true\nconsole.log(reg.test(str3)) // false\n\n\n注意\n\n反斜杠用来在文本字符串中插入省略号、换行符、引号和其他特殊字符。在 JavaScript 中，字符串使用单引号或者双引号来起始或者结束。\n\nvar txt="We are the so-called "Vikings" from the north."\nconsole.log(txt)\n\n\n这意味着上面的字符串将被截为：We are the so-called。要解决这个问题，就必须把在 "Viking" 中的引号前面加上反斜杠。这样就可以把每个双引号转换为字面上的字符串。\n\n下面的表格列出了其余的特殊字符，这些特殊字符都可以使用反斜杠来添加到文本字符串中：\n\n\n\n最佳实践\n\n不管一个符号有没有特殊意义，都可以在其之前加上一个\\以确保它表达的是这个符号本身\n\neg 某产品批号形式为：123.45^67#89，请使用正则表达式检查某字符串是否符合此格式\n\n提示\n\n.(点)必须前加\\，因为在正则表达式中元字符.代表匹配任意字符\n\nconst reg = /^123\\.45\\^67\\#89$/\nconst n1 = \'123.45^67#19\'\nconsole.log(reg.test(n1)) //false\n\n\n\n# 方括号表示法\n\n使用方括号，比如[xyz]，可以创建个字符集合，表示匹配方括号中的任意字符\n\neg:比如某学校的学号规定：第 1 位是一个字母，b 表示本科生， y 表示研究生，后面是 7 位数字，用正则表示为:\n\n;/^[by]\\d{7}$/ //{7}为量词\n\n\n提示\n\n可以使用短横-来指定一个字符范围，^表示否定\n\n\n\n\n# 量词\n\n\n\neg 请验证字符串是否符合手机号码的规则：11 位数字，并且肯定以 1 开头\n\n;/^1\\d{10}$/\n\n\n\n# 修饰符\n\n修饰符也叫作标志（flags），用于使用正则表达式实现高级搜索\n\n\n\n修饰符的使用：\n\n\n\n\n# 正则表达式的相关方法\n\n\n\n\n\n注意\n\n只有一个结果原因：没有加 g 修饰符\n\nexec()方法最有趣的是，有"g′修饰符的正则表达式将自动成为“有状态”的，这意味着可以对单个字符串中的多次匹配结果进行逐条的遍历\n\n\n\n\n# 字符串的相关方法\n\n\n\nvar str = \'abc123def4567ghi89\'\n// search()方法，很像indexOf()，返回查找到的第一个下标，如果找不到就是-1\nvar result1 = str.search(/\\d+/g)\nvar result2 = str.search(/m/g)\nconsole.log(result1) // 3\nconsole.log(result2) // -1\n// match()方法，返回查找到的数组，找不到就是null\nvar result3 = str.match(/\\d+/g)\nconsole.log(result3) // ["123", "4567", "89"]\n// replace()方法，进行替换\nvar result4 = str.replace(/[a-z]+/g, \'*\') // 注意+表示贪婪的，尽可能多的连续匹配小写字母\nconsole.log(result4) // *123*4567*89\n\n// split()方法，进行字符串拆为数组\nvar result5 = str.split(/\\d+/g)\nconsole.log(result5) // ["abc", "def", "ghi", ""]\n\n\n\n# 正则的应用\n\n实际上，很多正则表达式不需要我们自己写，可以通过搜索引擎查找，可以拿来即用\n\n表单验证 DEMO\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>demo</title>\n        <style>\n            body {\n                font-size: 13px;\n            }\n\n            .form {\n                width: 520px;\n                padding: 20px 50px;\n                margin: 50px auto;\n                border: 2px solid orange;\n                border-radius: 10px;\n            }\n\n            .form p {\n                margin-bottom: 30px;\n            }\n\n            .form input {\n                width: 180px;\n                margin-right: 15px;\n            }\n\n            .form .required {\n                color: red;\n            }\n\n            .form .nameField {\n                margin-left: 5px;\n            }\n\n            .form .tips {\n                color: orange;\n            }\n\n            .form .strength {\n                width: 35px;\n                height: 5px;\n                background-color: rgb(209, 207, 207);\n                display: inline-block;\n            }\n\n            .form .warning {\n                color: red;\n                margin-left: 10px;\n                display: none;\n            }\n\n            .form .submit {\n                width: 200px;\n                height: 35px;\n                margin-left: 160px;\n                border: none;\n                outline: none;\n                background-color: #ff6500;\n                color: white;\n                border-radius: 6px;\n                cursor: pointer;\n            }\n\n            .form .submit:hover {\n                background-color: #ff9900;\n            }\n        </style>\n    </head>\n\n    <body>\n        <div class="form">\n            <p>\n                <span class="required">*</span>用&nbsp;户&nbsp;名：\n                <input\n                    type="text"\n                    class="nameField"\n                    id="nameField"\n                    placeholder="用户名设置成功后不可修改"\n                />\n                <span class="tips" id="tips"\n                    >6-30位字母、数字或“_”，字母开头</span\n                >\n            </p>\n            <p>\n                <span class="required">*</span>登陆密码：\n                <input\n                    type="password"\n                    id="passWord"\n                    placeholder="6-20位字母或数字"\n                />\n                <span class="strength" id="level1"></span>\n                <span class="strength" id="level2"></span>\n                <span class="strength" id="level3"></span>\n                <span class="warning" id="warning">6-20位字母或数字</span>\n            </p>\n            <p>\n                <span class="required">*</span>确认密码：\n                <input\n                    type="password"\n                    id="confirmPsw"\n                    placeholder="再次输入您的登录密码"\n                />\n                <span id="dif"></span>\n            </p>\n            <button class="submit" id="submit">注册</button>\n        </div>\n\n        <script>\n            // 用户名输入框\n            var nameField = document.getElementById(\'nameField\')\n            var tips = document.getElementById(\'tips\')\n            var verifyName = false\n\n            nameField.onblur = function () {\n                if (/^[a-zA-Z]\\w{5,29}$/.test(nameField.value)) {\n                    // 正确\n                    tips.innerText = \'用户名输入正确\'\n                    tips.style.color = \'green\'\n                    verifyName = true\n                } else {\n                    // 错误\n                    tips.innerText = \'6-30位字母、数字或“_”，字母开头\'\n                    tips.style.color = \'red\'\n                    verifyName = false\n                }\n            }\n\n            // 密码输入框\n            var passWord = document.getElementById(\'passWord\')\n            var level1 = document.getElementById(\'level1\')\n            var level2 = document.getElementById(\'level2\')\n            var level3 = document.getElementById(\'level3\')\n            var warning = document.getElementById(\'warning\')\n            var verifyPsw = false\n\n            passWord.onblur = function () {\n                if (/^[a-zA-Z0-9]{6,20}$/.test(passWord.value)) {\n                    // 正确\n                    warning.style.display = \'none\'\n                    verifyPsw = true\n                    if (\n                        /^[0-9]{6,20}$/.test(passWord.value) ||\n                        /^[a-z]{6,20}$/.test(passWord.value) ||\n                        /^[A-Z]{6,20}$/.test(passWord.value)\n                    ) {\n                        // 密码强度低\n                        level1.style.backgroundColor = \'red\'\n                        level2.style.backgroundColor = \'rgb(209, 207, 207)\'\n                        level3.style.backgroundColor = \'rgb(209, 207, 207)\'\n                    } else if (\n                        /^[0-9a-z]{6,20}$/.test(passWord.value) ||\n                        /^[0-9A-Z]{6,20}$/.test(passWord.value) ||\n                        /^[a-zA-Z]{6,20}$/.test(passWord.value)\n                    ) {\n                        // 密码强度一般\n                        level1.style.backgroundColor = \'red\'\n                        level2.style.backgroundColor = \'orange\'\n                        level3.style.backgroundColor = \'rgb(209, 207, 207)\'\n                    } else {\n                        // 密码强度高\n                        level1.style.backgroundColor = \'red\'\n                        level2.style.backgroundColor = \'orange\'\n                        level3.style.backgroundColor = \'green\'\n                    }\n                } else {\n                    // 错误\n                    verifyPsw = false\n                    warning.style.display = \'inline\'\n                    level1.style.backgroundColor = \'rgb(209, 207, 207)\'\n                    level2.style.backgroundColor = \'rgb(209, 207, 207)\'\n                    level3.style.backgroundColor = \'rgb(209, 207, 207)\'\n                }\n            }\n\n            // 密码确认框\n            var confirmPsw = document.getElementById(\'confirmPsw\')\n            var dif = document.getElementById(\'dif\')\n            var verifyConfirm = false\n\n            confirmPsw.onblur = function () {\n                if (!confirmPsw.value) {\n                    // 空\n                    dif.innerText = \'输入框不能为空\'\n                    dif.style.color = \'red\'\n                    verifyConfirm = false\n                } else if (confirmPsw.value != passWord.value) {\n                    // 不一致\n                    dif.innerText = \'两次密码输入不一致，请重新输入\'\n                    dif.style.color = \'red\'\n                    verifyConfirm = false\n                } else {\n                    // 一致\n                    dif.innerText = \'两次输入一致\'\n                    dif.style.color = \'green\'\n                    verifyConfirm = true\n                }\n            }\n\n            // 注册按钮\n            var submit = document.getElementById(\'submit\')\n\n            submit.onclick = function () {\n                if (verifyName && verifyPsw && verifyConfirm) {\n                    // 满足条件\n                    alert(\'信息填写正确\')\n                } else {\n                    // 不满足条件\n                    alert(\'请填写正确的信息\')\n                }\n            }\n        <\/script>\n    </body>\n</html>\n',normalizedContent:'正则表达式(regular expression)描述了字符串的“构成模式”，经常被用于检查字符串是否符合预定的格式要求\n\n正则表达式“按位”描述规则，是指它是一位一位的描述字符串的构成形式\n\n正则表达式可以调用 test()方法，检查某字符串是否符合正则表达式规定的规则\n\n\n# 正则表达式的创建\n\n * 使用/内容/的语法形式，可以快速创建正则表达式\n * 也可以使用 new regexp(\'内容\')的形式，创建正则表达式(这种写法有坑！)\n   \n   警告\n   \n   如果使用 new regexp() 写法，反斜杠需要多写一个，比如/^\\d$/和 new regexp（\'^\\\\d$\'）是相同的意思\n\n * 使用 typeof 运算符检查正则表达式的类型，结果是 object\n\n\n# 元字符\n\n"元字符”是指 一位 指定类型的字符\n\n\n\n开头和结尾\n\n\n\n元字符：|\n\n正则中使用竖线" | "表示或，表示只匹配指定几项之间的一项\n\neg:只匹配纯数字或纯字母\n\nvar str1 = \'1111\'\nvar str2 = \'imooc\'\nvar str3 = \'1111imooc\'\nvar reg = /^\\d+$|^[a-za-z]+$/\nconsole.log(reg.test(str1)) // true\nconsole.log(reg.test(str2)) // true\nconsole.log(reg.test(str3)) // false\n\n\n注意\n\n反斜杠用来在文本字符串中插入省略号、换行符、引号和其他特殊字符。在 javascript 中，字符串使用单引号或者双引号来起始或者结束。\n\nvar txt="we are the so-called "vikings" from the north."\nconsole.log(txt)\n\n\n这意味着上面的字符串将被截为：we are the so-called。要解决这个问题，就必须把在 "viking" 中的引号前面加上反斜杠。这样就可以把每个双引号转换为字面上的字符串。\n\n下面的表格列出了其余的特殊字符，这些特殊字符都可以使用反斜杠来添加到文本字符串中：\n\n\n\n最佳实践\n\n不管一个符号有没有特殊意义，都可以在其之前加上一个\\以确保它表达的是这个符号本身\n\neg 某产品批号形式为：123.45^67#89，请使用正则表达式检查某字符串是否符合此格式\n\n提示\n\n.(点)必须前加\\，因为在正则表达式中元字符.代表匹配任意字符\n\nconst reg = /^123\\.45\\^67\\#89$/\nconst n1 = \'123.45^67#19\'\nconsole.log(reg.test(n1)) //false\n\n\n\n# 方括号表示法\n\n使用方括号，比如[xyz]，可以创建个字符集合，表示匹配方括号中的任意字符\n\neg:比如某学校的学号规定：第 1 位是一个字母，b 表示本科生， y 表示研究生，后面是 7 位数字，用正则表示为:\n\n;/^[by]\\d{7}$/ //{7}为量词\n\n\n提示\n\n可以使用短横-来指定一个字符范围，^表示否定\n\n\n\n\n# 量词\n\n\n\neg 请验证字符串是否符合手机号码的规则：11 位数字，并且肯定以 1 开头\n\n;/^1\\d{10}$/\n\n\n\n# 修饰符\n\n修饰符也叫作标志（flags），用于使用正则表达式实现高级搜索\n\n\n\n修饰符的使用：\n\n\n\n\n# 正则表达式的相关方法\n\n\n\n\n\n注意\n\n只有一个结果原因：没有加 g 修饰符\n\nexec()方法最有趣的是，有"g′修饰符的正则表达式将自动成为“有状态”的，这意味着可以对单个字符串中的多次匹配结果进行逐条的遍历\n\n\n\n\n# 字符串的相关方法\n\n\n\nvar str = \'abc123def4567ghi89\'\n// search()方法，很像indexof()，返回查找到的第一个下标，如果找不到就是-1\nvar result1 = str.search(/\\d+/g)\nvar result2 = str.search(/m/g)\nconsole.log(result1) // 3\nconsole.log(result2) // -1\n// match()方法，返回查找到的数组，找不到就是null\nvar result3 = str.match(/\\d+/g)\nconsole.log(result3) // ["123", "4567", "89"]\n// replace()方法，进行替换\nvar result4 = str.replace(/[a-z]+/g, \'*\') // 注意+表示贪婪的，尽可能多的连续匹配小写字母\nconsole.log(result4) // *123*4567*89\n\n// split()方法，进行字符串拆为数组\nvar result5 = str.split(/\\d+/g)\nconsole.log(result5) // ["abc", "def", "ghi", ""]\n\n\n\n# 正则的应用\n\n实际上，很多正则表达式不需要我们自己写，可以通过搜索引擎查找，可以拿来即用\n\n表单验证 demo\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta http-equiv="x-ua-compatible" content="ie=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>demo</title>\n        <style>\n            body {\n                font-size: 13px;\n            }\n\n            .form {\n                width: 520px;\n                padding: 20px 50px;\n                margin: 50px auto;\n                border: 2px solid orange;\n                border-radius: 10px;\n            }\n\n            .form p {\n                margin-bottom: 30px;\n            }\n\n            .form input {\n                width: 180px;\n                margin-right: 15px;\n            }\n\n            .form .required {\n                color: red;\n            }\n\n            .form .namefield {\n                margin-left: 5px;\n            }\n\n            .form .tips {\n                color: orange;\n            }\n\n            .form .strength {\n                width: 35px;\n                height: 5px;\n                background-color: rgb(209, 207, 207);\n                display: inline-block;\n            }\n\n            .form .warning {\n                color: red;\n                margin-left: 10px;\n                display: none;\n            }\n\n            .form .submit {\n                width: 200px;\n                height: 35px;\n                margin-left: 160px;\n                border: none;\n                outline: none;\n                background-color: #ff6500;\n                color: white;\n                border-radius: 6px;\n                cursor: pointer;\n            }\n\n            .form .submit:hover {\n                background-color: #ff9900;\n            }\n        </style>\n    </head>\n\n    <body>\n        <div class="form">\n            <p>\n                <span class="required">*</span>用&nbsp;户&nbsp;名：\n                <input\n                    type="text"\n                    class="namefield"\n                    id="namefield"\n                    placeholder="用户名设置成功后不可修改"\n                />\n                <span class="tips" id="tips"\n                    >6-30位字母、数字或“_”，字母开头</span\n                >\n            </p>\n            <p>\n                <span class="required">*</span>登陆密码：\n                <input\n                    type="password"\n                    id="password"\n                    placeholder="6-20位字母或数字"\n                />\n                <span class="strength" id="level1"></span>\n                <span class="strength" id="level2"></span>\n                <span class="strength" id="level3"></span>\n                <span class="warning" id="warning">6-20位字母或数字</span>\n            </p>\n            <p>\n                <span class="required">*</span>确认密码：\n                <input\n                    type="password"\n                    id="confirmpsw"\n                    placeholder="再次输入您的登录密码"\n                />\n                <span id="dif"></span>\n            </p>\n            <button class="submit" id="submit">注册</button>\n        </div>\n\n        <script>\n            // 用户名输入框\n            var namefield = document.getelementbyid(\'namefield\')\n            var tips = document.getelementbyid(\'tips\')\n            var verifyname = false\n\n            namefield.onblur = function () {\n                if (/^[a-za-z]\\w{5,29}$/.test(namefield.value)) {\n                    // 正确\n                    tips.innertext = \'用户名输入正确\'\n                    tips.style.color = \'green\'\n                    verifyname = true\n                } else {\n                    // 错误\n                    tips.innertext = \'6-30位字母、数字或“_”，字母开头\'\n                    tips.style.color = \'red\'\n                    verifyname = false\n                }\n            }\n\n            // 密码输入框\n            var password = document.getelementbyid(\'password\')\n            var level1 = document.getelementbyid(\'level1\')\n            var level2 = document.getelementbyid(\'level2\')\n            var level3 = document.getelementbyid(\'level3\')\n            var warning = document.getelementbyid(\'warning\')\n            var verifypsw = false\n\n            password.onblur = function () {\n                if (/^[a-za-z0-9]{6,20}$/.test(password.value)) {\n                    // 正确\n                    warning.style.display = \'none\'\n                    verifypsw = true\n                    if (\n                        /^[0-9]{6,20}$/.test(password.value) ||\n                        /^[a-z]{6,20}$/.test(password.value) ||\n                        /^[a-z]{6,20}$/.test(password.value)\n                    ) {\n                        // 密码强度低\n                        level1.style.backgroundcolor = \'red\'\n                        level2.style.backgroundcolor = \'rgb(209, 207, 207)\'\n                        level3.style.backgroundcolor = \'rgb(209, 207, 207)\'\n                    } else if (\n                        /^[0-9a-z]{6,20}$/.test(password.value) ||\n                        /^[0-9a-z]{6,20}$/.test(password.value) ||\n                        /^[a-za-z]{6,20}$/.test(password.value)\n                    ) {\n                        // 密码强度一般\n                        level1.style.backgroundcolor = \'red\'\n                        level2.style.backgroundcolor = \'orange\'\n                        level3.style.backgroundcolor = \'rgb(209, 207, 207)\'\n                    } else {\n                        // 密码强度高\n                        level1.style.backgroundcolor = \'red\'\n                        level2.style.backgroundcolor = \'orange\'\n                        level3.style.backgroundcolor = \'green\'\n                    }\n                } else {\n                    // 错误\n                    verifypsw = false\n                    warning.style.display = \'inline\'\n                    level1.style.backgroundcolor = \'rgb(209, 207, 207)\'\n                    level2.style.backgroundcolor = \'rgb(209, 207, 207)\'\n                    level3.style.backgroundcolor = \'rgb(209, 207, 207)\'\n                }\n            }\n\n            // 密码确认框\n            var confirmpsw = document.getelementbyid(\'confirmpsw\')\n            var dif = document.getelementbyid(\'dif\')\n            var verifyconfirm = false\n\n            confirmpsw.onblur = function () {\n                if (!confirmpsw.value) {\n                    // 空\n                    dif.innertext = \'输入框不能为空\'\n                    dif.style.color = \'red\'\n                    verifyconfirm = false\n                } else if (confirmpsw.value != password.value) {\n                    // 不一致\n                    dif.innertext = \'两次密码输入不一致，请重新输入\'\n                    dif.style.color = \'red\'\n                    verifyconfirm = false\n                } else {\n                    // 一致\n                    dif.innertext = \'两次输入一致\'\n                    dif.style.color = \'green\'\n                    verifyconfirm = true\n                }\n            }\n\n            // 注册按钮\n            var submit = document.getelementbyid(\'submit\')\n\n            submit.onclick = function () {\n                if (verifyname && verifypsw && verifyconfirm) {\n                    // 满足条件\n                    alert(\'信息填写正确\')\n                } else {\n                    // 不满足条件\n                    alert(\'请填写正确的信息\')\n                }\n            }\n        <\/script>\n    </body>\n</html>\n',charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"面向对象",frontmatter:{title:"面向对象",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"前端开发/JavaScript/JS基础/面向对象.md",key:"v-4fa67b80",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:2},{level:3,title:"属性的访问",slug:"属性的访问",normalizedTitle:"属性的访问",charIndex:157},{level:3,title:"属性的更改",slug:"属性的更改",normalizedTitle:"属性的更改",charIndex:962},{level:3,title:"属性的创建",slug:"属性的创建",normalizedTitle:"属性的创建",charIndex:1043},{level:3,title:"属性的删除",slug:"属性的删除",normalizedTitle:"属性的删除",charIndex:1151},{level:3,title:"对象的方法",slug:"对象的方法",normalizedTitle:"对象的方法",charIndex:1224},{level:3,title:"对象的遍历",slug:"对象的遍历",normalizedTitle:"对象的遍历",charIndex:1316},{level:3,title:"对象的深浅克隆",slug:"对象的深浅克隆",normalizedTitle:"对象的深浅克隆",charIndex:3254},{level:2,title:"this 指向问题",slug:"this-指向问题",normalizedTitle:"this 指向问题",charIndex:5203},{level:3,title:"this 绑定规则",slug:"this-绑定规则",normalizedTitle:"this 绑定规则",charIndex:5393},{level:3,title:"this 规则之外",slug:"this-规则之外",normalizedTitle:"this 规则之外",charIndex:9738},{level:2,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:8860},{level:2,title:"原型原型链",slug:"原型原型链",normalizedTitle:"原型原型链",charIndex:10820},{level:3,title:"prototype",slug:"prototype",normalizedTitle:"prototype",charIndex:1491},{level:3,title:"原型链查找",slug:"原型链查找",normalizedTitle:"原型链查找",charIndex:11309},{level:3,title:"hasOwnProperty",slug:"hasownproperty",normalizedTitle:"hasownproperty",charIndex:1529},{level:3,title:"instanceof 运算符",slug:"instanceof-运算符",normalizedTitle:"instanceof 运算符",charIndex:11635},{level:3,title:"in 运算符",slug:"in-运算符",normalizedTitle:"in 运算符",charIndex:11776},{level:3,title:"getPrototypeOf",slug:"getprototypeof",normalizedTitle:"getprototypeof",charIndex:12006},{level:3,title:"create",slug:"create",normalizedTitle:"create",charIndex:12165},{level:3,title:"在 prototype 上添加方法",slug:"在-prototype-上添加方法",normalizedTitle:"在 prototype 上添加方法",charIndex:12643},{level:3,title:"原型链的终点",slug:"原型链的终点",normalizedTitle:"原型链的终点",charIndex:12913},{level:3,title:"js 实现继承",slug:"js-实现继承",normalizedTitle:"js 实现继承",charIndex:12989},{level:2,title:"面向对象案例",slug:"面向对象案例",normalizedTitle:"面向对象案例",charIndex:13871},{level:3,title:"红绿灯案例",slug:"红绿灯案例",normalizedTitle:"红绿灯案例",charIndex:14005},{level:3,title:"炫彩小球小案例",slug:"炫彩小球小案例",normalizedTitle:"炫彩小球小案例",charIndex:15566},{level:2,title:"内置对象",slug:"内置对象",normalizedTitle:"内置对象",charIndex:19234},{level:3,title:"包装类",slug:"包装类",normalizedTitle:"包装类",charIndex:19243},{level:3,title:"Math 对象",slug:"math-对象",normalizedTitle:"math 对象",charIndex:19468},{level:3,title:"Date 对象",slug:"date-对象",normalizedTitle:"date 对象",charIndex:20870}],headersStr:"对象 属性的访问 属性的更改 属性的创建 属性的删除 对象的方法 对象的遍历 对象的深浅克隆 this 指向问题 this 绑定规则 this 规则之外 构造函数 原型原型链 prototype 原型链查找 hasOwnProperty instanceof 运算符 in 运算符 getPrototypeOf create 在 prototype 上添加方法 原型链的终点 js 实现继承 面向对象案例 红绿灯案例 炫彩小球小案例 内置对象 包装类 Math 对象 Date 对象",content:"# 对象\n\n * 对象（ object）是“键值对”的集合，表示属性和值的映射关系\n * 如果对象的属性键名不符合标识符命名规范，则这个键名必须用引号包裹\n\nvar frank = {\n    name: 'frank',\n    'favorite-song': 'see-you-again',\n}\n\n\n\n# 属性的访问\n\nin运算符\n\n检查属性是否存在的操作符 \"in\"。\n\n语法是：\"key\" in object 例如：\n\nlet user = { name: \"John\", age: 30 };\n\nalert( \"age\" in user ); // true，user.age 存在\nalert( \"blabla\" in user ); // false，user.blabla 不存在。\n\n\n * 普通属性名使用点语法来访问\n\n * 如果属性名不符合标识符命名规范，则必须用方括号的写法来访问\n\nfrank['favorite-song'] //‘see-you-again’\n\n\n * 如果属性名以变量形式存储，则必须使用方括号形式\n\n提示\n\n虽然可以采用纯数字作为 key,但这本身就是不合法的标识符命名，所以访问需要使用方括号语法\n\nvar obj = {\n    a: 1,\n    b: 2,\n}\nvar key = 'b' // 属性名用变量存储\nconsole.log(obj.key) // undefined\nconsole.log(obj[key]) // 2\n\n\n * 可选链：?.：是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误\n   * 如果可选链?. 前面的部分是 undefined 或者 null，它会停止运算并返回该部分\n   * 可选链?.语法有三种形式:\n     * obj?.prop —— 如果 obj存在则返回 obj.prop，否则返回 undefined。\n     * obj?.[prop] —— 如果 obj存在则返回obj[prop]，否则返回 undefined。\n     * obj.method?.() —— 如果 obj.method 存在则调用 obj.method()，否则返回 undefined。\n\n\n# 属性的更改\n\n直接使用赋值运算符重新对某属性赋值即可更改属性\n\nvar obj = {\n    a: 10,\n}\nobj.a = 30\nobj.a++\n\n\n\n# 属性的创建\n\n如果对象本身没有某个属性值，则用点语法赋值时，这个属性会被创建出来\n\nvar obj = {\n    a: 10,\n}\nobj.b = 30\nconsole.log(obj.b) // 30\n\n\n\n# 属性的删除\n\n使用 delete操作符\n\nvar obj = {\n    a: 1,\n    b: 2,\n}\ndelete obj.a\n\n\n\n# 对象的方法\n\n * 如果某个属性值是函数，则它也被称为对象的 方法\n * 使用点语法可以调用对象的方法\n * 方法也是函数，只不过方法是对象的 函数属性,它需要用对象打点调用\n\n\n# 对象的遍历\n\n遍历对象需要使用 for...in循环\n\n// k 循环变量，它会依次成为对象的每一个键\nfor (var k in obj) {\n    console.log('属性' + k + '的值是' + obj[k])\n}\n\n\n一般情况下，for...in 循环只会遍历我们自定义的属性，原型上默认的属性不会遍历出来。例如 Object.prototype.toString()、Object.prototype.hasOwnProperty()是不会被遍历出来的。\n\n但在实际应用中，如果是在原型中新增属性或者方法，for...in 会将原型中新增的属性和方法遍历出来。\n\nconst obj = {\n    a: 1,\n    b: 2,\n}\nObject.prototype.c = 3\nfor (var x in obj) {\n    console.log(x, obj[x])\n    // a 1\n    // b 2\n    // c 3\n}\n\n\n所以我们不能依赖于 for...in 来获取对象的成员名称，一般使用 hasOwnProperty 来判断下\n\nconst obj = {\n    a: 1,\n    b: 2,\n}\nObject.prototype.c = 3\nfor (var x in obj) {\n    if (obj.hasOwnProperty(x)) {\n        console.log(x, obj[x])\n        // a 1\n        // b 2\n    }\n}\n\n\n用它循环对象，循环出来的属性顺序并不可靠，所以不要在for...in中做依赖对象属性顺序的逻辑判断。\n\nJavaScript for...in循环出来的对象属性顺序到底是什么规律？\n\n先遍历出整数属性（integer properties，按照升序），然后其他属性按照创建时候的顺序遍历出来。\n\nlet codes = {\n    49: 'Germany',\n    41: 'Switzerland',\n    44: 'Great Britain',\n    1: 'USA',\n}\n\nfor (let code in codes) {\n    alert(code) // 1, 41, 44, 49\n}\n\n\n最终遍历出来的结果是：属性 1 先遍历出来， 49 最后遍历出来。\n\n这里的 1、41、44 和 49 就是整数属性。\n\n那什么是整数属性呢？我们可以用下面的比较结果说明：\n\nString(Math.trunc(Number(prop)) === prop // 当判断结果为 true，prop 就是整数属性，否则不是。\n\n\n所以\n\n * \"49\" 是整数属性，因为 String(Math.trunc(Number('49')) 的结果还是 \"49\"。\n * \"+49\" 不是整数属性，因为 String(Math.trunc(Number('+49')) 的结果是 \"49\"，不是 \"+49\"。\n * \"1.2\" 不是整数属性，因为 String(Math.trunc(Number('1.2')) 的结果是 \"1\"，不是 \"1.2\"。\n\n上面的例子中，如果想按照创建顺序循环出来，可以用一个 讨巧 的方法：\n\nlet codes = {\n    '+49': 'Germany',\n    '+41': 'Switzerland',\n    '+44': 'Great Britain',\n    // ..,\n    '+1': 'USA',\n}\n\nfor (let code in codes) {\n    console.log(+code) // 49, 41, 44, 1\n}\n\n\n原型中新增的属性或方法，总是在最后按照顺序打印\n\nconst obj = {\n    3: 'xx',\n    1: 'frank',\n    2: 'chang',\n    name: 'zfh',\n    age: 18,\n}\nObject.prototype[7] = 'zhang'\nObject.prototype[6] = 'frank1'\nfor (var k in obj) {\n    console.log('属性' + k + '的值是' + obj[k])\n}\n// 属性1的值是frank\n// 属性2的值是chang\n// 属性3的值是xx\n// 属性name的值是zfh\n// 属性age的值是18\n// 属性6的值是frank1\n// 属性7的值是zhang\n\n\n\n# 对象的深浅克隆\n\n对象是引用类型值，这意味着：\n\n不能用 var obj2=obj1这样的语法克隆一个对象。使用==或者===进行对象的比较时，比较的是它们是否为内存中的同一个对象，而不是比较值是否相同。\n\nvar obj1 = {\n    a: 1,\n    b: 2,\n    c: [1, 23, 4123],\n}\nvar obj2 = {}\nfor (var k in obj1) {\n    obj2[k] = obj1[k]\n}\nconsole.log(obj2.c === obj2.a) // true，浅克隆不可隆属性值为引用类型的键\n\n\nJS 的原生不支持深拷贝，上面代码使用for...in,还有Object.assign 和{...obj}都属于浅拷贝；数组可以利用Array.prototype.concat(),Array.prototype.slice()实现浅拷贝。\n\nJSON.sringify 和 JSON.parse 可以实现深拷贝，原理就是先将对象转换为字符串，再通过JSON.parse 重新建立一个对象。 但是这种方法的局限也很多：\n\n * 不能复制 function、正则、Symbol\n\nlet obj = {\n    reg: /^asd$/,\n    fun: function () {},\n    syb: Symbol('foo'),\n    asd: 'asd',\n}\nlet cp = JSON.parse(JSON.stringify(obj))\nconsole.log(cp) // { reg: {}, asd: 'asd' },可以看到，函数、正则、Symbol 都没有被正确的复制.\n\n\n * 循环引用报错，当对象 1 中的某个属性指向对象 2，对象 2 中的某个属性指向对象 1 就会出现循环引用\n\nfunction circularReference() {\n    let obj1 = {}\n    let obj2 = {\n        b: obj1,\n    }\n    obj1.a = obj2\n}\n\n\n对包含循环引用的对象（对象之间相互引用，形成无限循环）执行 JSON.stringify()，会抛出错误\n\n * 相同的引用会被重复复制\n\nlet obj = { asd: 'asd' }\nlet obj2 = { name: 'aaaaa' }\nobj.ttt1 = obj2\nobj.ttt2 = obj2\nlet cp = JSON.parse(JSON.stringify(obj))\nobj.ttt1.name = 'change'\ncp.ttt1.name = 'change'\nconsole.log(obj, cp)\n\n\n在原对象 obj 中的 ttt1 和 ttt2 指向了同一个对象 obj2，那么我在深拷贝的时候，就应该只拷贝一次 obj2 ，下面我们看看运行结果：\n\n\n\n我们可以看到（上面的为原对象，下面的为复制对象），原对象改变 ttt1.name 也会改变 ttt2.name ，因为他们指向相同的对象。\n\n但是，复制的对象中，ttt1 和 ttt2 分别指向了两个对象。复制对象没有保持和原对象一样的结构。因此，JSON 实现深复制不能处理指向相同引用的情况，相同的引用会被重复复制。\n\n递归实现深拷贝，对于简单类型，直接复制。对于引用类型，递归复制它的每一个属性\n\n/**\n * 实现的深拷贝仅仅是解决了深拷贝的关键问题，还需要针对不同的数据类型进行完善\n */\n\nfunction deepClone(o) {\n    // 判断是否是数组\n    if (Array.isArray(o)) {\n        var result = [] //此数组解决了循环引用和相同引用的问题，它存放已经递归到的目标对象\n        for (let k = 0; k < o.length; k++) {\n            result.push(deepClone(o[k]))\n        }\n        // 来到这里的都是对象\n    } else if (typeof o === 'object') {\n        var result = {}\n        for (var k in o) {\n            result[k] = deepClone(o[k])\n        }\n    } else {\n        var result = o\n    }\n    return result\n}\n\n\n\n# this 指向问题\n\n彻底搞懂 this 指向\n\n开发中很少直接在全局作用域下去使用 this(浏览器环境下，全局作用域中的 this非严格模式下为 window)，通常都是在函数中使用\n\n在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了,因为 this 的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境\n\n\n# this 绑定规则\n\nthis 无非就是在函数调用时被绑定的一个对象，我们就需要知道它在不同的场景下的绑定规则:\n\n 1. 默认绑定\n\n什么情况下使用默认绑定呢？独立函数调用\n\n独立的函数调用我们可以理解成函数没有被绑定到某个对象上进行调用\n\n案例一：普通函数调用\n\n * 该函数直接被调用，并没有进行任何的对象关联；\n * 这种独立的函数调用会使用默认绑定，通常默认绑定时，函数中的 this 指向全局对象window；\n\nfunction foo() {\n    console.log(this) // window\n}\n\nfoo()\n\n\n案例二：函数调用链（一个函数又调用另外一个函数）\n\n所有的函数调用都没有被绑定到某个对象上\n\nfunction test1() {\n    console.log(this) // window\n    test2()\n}\n\nfunction test2() {\n    console.log(this) // window\n    test3()\n}\n\nfunction test3() {\n    console.log(this) // window\n}\ntest1()\n\n\n案例三：将函数作为参数，传入到另一个函数中\n\nfunction foo(func) {\n    func()\n}\n\nfunction bar() {\n    console.log(this) // window\n}\n\nfoo(bar)\n\n\n稍微修改一下：\n\nfunction foo(func) {\n    func()\n}\n\nvar obj = {\n    name: 'why',\n    bar: function () {\n        console.log(this) // window\n    },\n}\n\nfoo(obj.bar)\n\n\n结果依然是window,原因非常简单，在真正函数调用的位置，并没有进行任何的对象绑定，只是一个独立函数的调用；\n\n 2. 隐式绑定\n\n另外一种比较常见的调用方式是通过某个对象进行调用的：也就是它的调用位置中，是通过某个对象发起的函数调用\n\n案例一：通过对象调用函数\n\nfoo是通过 obj.foo()方式进行调用的\n\n那么 foo 调用时this会隐式的被绑定到 obj 对象上\n\nfunction foo() {\n    console.log(this) // obj对象\n}\n\nvar obj = {\n    name: 'why',\n    foo: foo,\n}\n\nobj.foo()\n\n\n案例二：案例一的变化\n\n我们通过 obj2 又引用了 obj1对象，再通过 obj1 对象调用foo函数；\n\n那么 foo调用的位置上其实还是 obj1被绑定了 this；\n\nfunction foo() {\n    console.log(this) // obj1对象\n}\n\nvar obj1 = {\n    name: 'obj1',\n    foo: foo,\n}\n\nvar obj2 = {\n    name: 'obj2',\n    obj1: obj1,\n}\n\nobj2.obj1.foo()\n\n\n案例三：隐式丢失\n\n结果最终是 window，因为foo 最终被调用的位置是 bar，而 bar 在进行调用时没有绑定任何的对象，也就没有形成隐式绑定；相当于是一种默认绑定；\n\nfunction foo() {\n    console.log(this) // window\n}\n\nvar obj1 = {\n    name: 'obj1',\n    foo: foo,\n}\n\n// 将obj1的foo赋值给bar\nvar bar = obj1.foo\nbar()\n\n\n 3. 显式绑定\n\n隐式绑定有一个前提条件：\n\n * 必须在调用的对象内部有一个对函数的引用（比如一个属性）；\n * 如果没有这样的引用，在进行调用时，会报找不到该函数的错误；\n * 正是通过这个引用，间接的将 this 绑定到了这个对象上；\n\n如果我们不希望在 对象内部 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？\n\nJavaScript 所有的函数都可以使用 call 和 apply 以及 bind 显式指定 this。\n\n这三个函数的第一个参数都要求是一个对象，这个对象的作用是什么呢？就是给 this准备的。\n\n在调用这个函数时，会将 this 绑定到这个传入的对象上\n\n因为上面的过程，我们明确的绑定了 this 指向的对象，所以称之为 显式绑定\n\ncall,apply,bind 三者区别\n\ncall apply bind 三者的用法和区别\n\ncall()、apply()、bind() 都是用来重定义 this 这个对象的\n\nbind 返回的是一个新的函数，你必须调用它才会被执行 ,其余两个都是立即执行的\n\nbind 和 call 参数形式一致，apply 需要把参数写到数组里\n\n有些时候，我们会调用一些 JavaScript的内置函数，或者一些第三方库中的内置函数\n\n这些内置函数会要求我们传入另外一个函数；\n\n我们自己并不会显示的调用这些函数，而且 JavaScript内部或者第三方库内部会帮助我们执行；\n\n这些函数中的 this又是如何绑定的呢？\n\n案例一：setTimeout\n\nsetTimeout 中会传入一个函数，这个函数中的 this 通常是 window\n\nsetTimeout(function () {\n    console.log(this) // window\n}, 1000)\n\n\n为什么这里是 window呢？\n\n这个和 setTimeout源码的内部调用有关；setTimeout内部是通过 apply 进行绑定的 this对象，并且绑定的是全局对象；\n\n那如果我们想让这里的 this不是 window呢？比如我们希望点击 box 盒子延时 2 秒变为红色,那么我们就需要备份一下 this：\n\nvar box = document.getElementById('box')\nfunction bRed() {\n    var self = this // 备份this\n    setTimeout(function () {\n        self.style.backgroundColor = 'red'\n    }, 2000)\n}\nbox.onclick = bRed\n\n\n或者使用箭头函数：\n\nvar box = document.getElementById('box')\nfunction bRed() {\n    setTimeout(() => {\n        this.style.backgroundColor = 'red'\n    }, 2000)\n}\nbox.onclick = bRed\n\n\n案例二：数组的 forEach\n\n在 forEach 中传入的函数打印的也是 Window对象； 这是因为默认情况下传入的函数是自动调用函数（默认绑定）；\n\nvar names = ['abc', 'cba', 'nba']\nnames.forEach(function (item) {\n    console.log(this) // 三次window\n})\n\n\n当然我们可以通过 forEach的第二个参数改变 this指向\n\nvar names = ['abc', 'cba', 'nba']\nvar obj = { name: 'why' }\nnames.forEach(function (item) {\n    console.log(this) // 三次obj对象\n}, obj)\n\n\n案例三：div 的点击\n\n获取 box 元素节点，并且监听点击：\n\n在点击事件的回调中，this 指向谁呢？box 对象； 这是因为在发生点击时，执行传入的回调函数被调用时，会将 box 对象绑定到该函数中；\n\nvar box = document.querySelector('.box')\nbox.onclick = function () {\n    console.log(this) // box对象\n}\n\n\n 4. new绑定\n\n见构造函数章节\n\n 5. 规则优先级\n\n * 默认规则的优先级最低\n\n毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定 this\n\n * 显示绑定优先级高于隐式绑定\n\nfunction foo() {\n    console.log(this)\n}\n\nvar obj1 = {\n    name: 'obj1',\n    foo: foo,\n}\n\nvar obj2 = {\n    name: 'obj2',\n    foo: foo,\n}\n\n// 隐式绑定\nobj1.foo() // obj1\nobj2.foo() // obj2\n\n// 隐式绑定和显示绑定同时存在\nobj1.foo.call(obj2) // obj2, 说明显式绑定优先级更高\n\n\n * new 绑定优先级高于隐式绑定\n\nfunction foo() {\n    console.log(this)\n}\n\nvar obj = {\n    name: 'why',\n    foo: foo,\n}\n\nnew obj.foo() // foo对象, 说明new绑定优先级更高\n\n\n * new 绑定优先级高于 bind\n\nnew 绑定和 call、apply 是不允许同时使用的，所以不存在谁的优先级更高\n\nfunction foo() {\n    console.log(this)\n}\n\nvar obj = {\n    name: 'obj',\n}\n\nvar foo = new foo.call(obj) //报错\n\n\n但是 new 绑定可以和 bind后的函数同时使用\n\nfunction foo() {\n    console.log(this)\n}\n\nvar obj = {\n    name: 'obj',\n}\n\nvar bar = foo.bind(obj)\nvar foo = new bar() // 打印foo, 说明使用的是new绑定\n\n\n优先级总结：new 绑定 > 显示绑定（bind）> 隐式绑定 > 默认绑定\n\n\n# this 规则之外\n\n 1. 忽略显式绑定\n\n如果在显式绑定中，我们传入一个 null 或者 undefined，那么这个显示绑定会被忽略，使用默认规则：\n\nfunction foo() {\n    console.log(this)\n}\n\nvar obj = {\n    name: 'why',\n}\n\nfoo.call(obj) // obj对象\nfoo.call(null) // window\nfoo.call(undefined) // window\n\nvar bar = foo.bind(null)\nbar() // window\n\n\n 2. 间接函数引用\n\n另外一种情况，创建一个函数的 间接引用，这种情况使用默认绑定规则。\n\nfunction foo() {\n    console.log(this)\n}\n\nvar obj1 = {\n    name: 'obj1',\n    foo: foo,\n}\n\nvar obj2 = {\n    name: 'obj2',\n}\n\nobj1.foo() // obj1对象\n;(obj2.foo = obj1.foo)() // window\n\n\n赋值(obj2.foo = obj1.foo)的结果是 foo 函数；foo 函数被直接调用，那么是默认绑定；\n\n 3. ES6 箭头函数\n\n箭头函数不使用 this 的四种标准规则（也就是不绑定 this），而是根据外层作用域来决定 this\n\n箭头函数中的 this 指向\n\n\n# 构造函数\n\n * 用 new 调用一个函数，这个函数就被称为“构造函数”，任何函数都可以是构造函数，只需要用 new 调用它\n * 顾名思义，构造函数用来“构造新对象”，它内部的语句将为新对象添加若干属性和方法，完成对象的初始化\n * 构造函数必须用 new 关键字调用，否则不能正常工作，正因如此，开发者约定构造函数命名时首字母要大写\n * 使用 new 调用构造函数，会执行以下操作：\n\n1）在内存中创建一个新对象\n\n2）将新对象与构造函数通过原型链连接起来\n\n3）将构造函数中的this 绑定到新对象上\n\n4）执行构造函数内部的代码\n\n5）如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象\n\nfunction Fun(a) {\n    this.a = a\n    return { [a]: 1 }\n}\nconst obj = new Fun(2)\nconsole.log(obj) // { '2': 1 }而不是 { a: 2 }\n\n\n\n# 原型原型链\n\n\n# prototype\n\n\n\n * 任何函数都有prototype属性， prototype是英语“原型“的意思\n\n * prototype属性值是个对象，它默认拥有 constructor属性指回函数\n\nfunction sum(a, b) {\n    return a + b\n}\nconsole.log(sum.prototype)\nconsole.log(sum.prototype.constructor === sum) // true\n\n\n * 普通函数来说的prototype属性没有任何用处，而构造函数的prototype属性非常有用\n * 构造函数的 prototype 属性是它的实例的原型\n\n注： __proto__：每个对象都有一个proto，可称为隐式原型\n\n代码实现：\n\nfunction Fun(a, b) {\n    this.a = a\n    this.b = b\n}\nvar o = new Fun(1, 2)\nconsole.log(Fun.prototype === o.__proto__) //true\n\n\n\n# 原型链查找\n\n实例可以打点访问它的原型的属性和方法，这被称为“原型链查找”\n\n如果实例化出来的对象已经有了原型上的同名属性，那么就不会进行原型链查找\n\n\n# hasOwnProperty\n\n检查对象是否真正“自己拥有某属性或者方法\"\n\nfunction Fun(a, b) {\n    this.a = a\n    this.b = b\n}\nFun.prototype.c = '5'\nvar o = new Fun(1, 2)\nconsole.log(o.c) //5\nconsole.log(o.hasOwnProperty('a')) //true\nconsole.log(o.hasOwnProperty('c')) //false\n\n\n\n# instanceof 运算符\n\ninstanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。\n\nobject instanceof constructor //object 某个实例对象 constructor 某个构造函数\n\n\n\n# in 运算符\n\nin 只能检查某个属性或方法是否可以被对象访问，不能检查是否是自己的属性或方法\n\nfunction Fun(a, b) {\n    this.a = a\n    this.b = b\n}\nFun.prototype.c = '5'\nvar o = new Fun(1, 2)\nconsole.log(o.c) //5\nconsole.log('a' in o) //true\nconsole.log('c' in o) //true\n\n\n\n# getPrototypeOf\n\nObject.getPrototypeOf() 方法返回指定对象的原型\n\nconst obj = {}\nconsole.log(Object.getPrototypeOf(obj) === Object.prototype)\n// expected output: true\n\n\n\n# create\n\nObject.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。\n\nconst person = {\n    isHuman: false,\n    printIntroduction: function () {\n        console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`)\n    },\n}\n\nconst me = Object.create(person)\n\nme.name = 'Matthew' // \"name\" is a property set on \"me\", but not on \"person\"\nme.isHuman = true // inherited properties can be overwritten\n\nme.printIntroduction()\n// expected output: \"My name is Matthew. Am I human? true\"\n\n\n\n# 在 prototype 上添加方法\n\n之前是把方法直接添加到实例身上的缺点：每个实例和每个实例的方法函数都是内存中不同的函数，造成了内存的浪费，解决办法：将方法写到 prototype 上\n\nfunction Fun(a, b) {\n    this.a = a\n    this.b = b\n}\nFun.prototype.sum = function (x) {\n    return this.a + this.b + x\n}\nvar o = new Fun(1, 2)\nconsole.log(o.sum(3)) //6\n\n\n\n# 原型链的终点\n\n原型链的终点是 Object.prototype，所以这就是新建的对象为什么能够使用 toString() 等方法的原因。\n\n\n\n\n# js 实现继承\n\nfunction People(name, age, sex) {\n    this.name = name\n    this.age = age\n    this.sex = sex\n}\nPeople.prototype.sayhello = function () {\n    console.log('你好' + '我是' + this.name)\n}\nPeople.prototype.sleep = function () {\n    console.log('我要睡觉！！')\n}\nfunction Student(name, age, sex, school, classNumber) {\n    this.name = name\n    this.age = age\n    this.sex = sex\n    this.school = school\n    this.class = classNumber\n}\n// 实现继承\nStudent.prototype = new People()\n// 必须在下边代码之前\nStudent.prototype.study = function () {\n    console.log(this.school + '都是好学生')\n}\nStudent.prototype.exam = function () {\n    console.log(this.name + '考的不错')\n}\nvar frank = new Student('frank', 22, '男', 'SNUT', '1')\n\n\n原型链继承的缺点：\n\n 1. 原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。\n\n 2. 子类型在实例化时不能给父类型的构造函数传参。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。\n\n\n# 面向对象案例\n\nJS 是面向过程、面向对象还是基于对象？面向对象的代码体现\n\n面向对象的本质：定义不同的类，让类的实例工作\n\n面向对象的优点：程序编写更清晰、代码结构更严密、使代码更健壮更利于维护\n\n面向对象经常用到的场合：需要封裝和复用性的场合（组件思维）\n\n\n# 红绿灯案例\n\n页面上做一个红绿灯，点击红灯就变黄，点击黄灯就变绿，点击绿灯就变回红灯；如果页面上有 100 个这样的红绿灯呢？\n\n代码\n\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n        <div id=\"box\"></div>\n    </head>\n    <body>\n        <script>\n            var box = document.getElementById('box')\n            function TrafficLight() {\n                this.color = 1\n                this.init()\n                this.changeColor()\n            }\n            TrafficLight.prototype.init = function () {\n                this.dom = document.createElement('img')\n                this.dom.src = './' + this.color + '.jpg'\n                box.appendChild(this.dom)\n            }\n            TrafficLight.prototype.changeColor = function () {\n                var self = this\n                // 这里的this指向的是实例化出来的对象\n                self.dom.onclick = function () {\n                    // 这里的this指向的是事件处理函数绑定的D0M元素\n                    // 如果直接使用this，DOM元素有color属性？对吧，理解了\n                    self.color++\n                    if (self.color == 4) {\n                        self.color = 1\n                    }\n                    self.dom.src = './' + self.color + '.jpg'\n                }\n            }\n\n            var light1 = new TrafficLight()\n            var light2 = new TrafficLight()\n            var light3 = new TrafficLight()\n            var light4 = new TrafficLight()\n        <\/script>\n    </body>\n</html>\n\n\n素材：\n\n\n# 炫彩小球小案例\n\n代码\n\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n        <style>\n            body {\n                background-color: black;\n            }\n\n            .ball {\n                position: absolute;\n                border-radius: 50%;\n            }\n        </style>\n    </head>\n\n    <body>\n        <script>\n            // 小球类\n            function Ball(x, y) {\n                // 属性x、y表示的是圆心的坐标\n                this.x = x\n                this.y = y\n                // 半径属性\n                this.r = 20\n                // 透明度\n                this.opacity = 1\n                // 小球背景颜色，从颜色数组中随机选择一个颜色\n                this.color =\n                    colorArr[Math.floor(Math.random() * colorArr.length)]\n                // 这个小球的x增量和y的增量，使用do while语句，可以防止dX和dY都是零\n                do {\n                    this.dX = Math.floor(Math.random() * 20) - 10\n                    this.dY = Math.floor(Math.random() * 20) - 10\n                } while (this.dX == 0 && this.dY == 0)\n\n                // 初始化\n                this.init()\n                // 把自己推入数组，注意，这里的this不是类本身，而是实例\n                ballArr.push(this)\n            }\n            // 初始化方法\n            Ball.prototype.init = function () {\n                // 创建自己的dom\n                this.dom = document.createElement('div')\n                this.dom.className = 'ball'\n                this.dom.style.width = this.r * 2 + 'px'\n                this.dom.style.height = this.r * 2 + 'px'\n                this.dom.style.left = this.x - this.r + 'px'\n                this.dom.style.top = this.y - this.r + 'px'\n                this.dom.style.backgroundColor = this.color\n                // 上树\n                document.body.appendChild(this.dom)\n            }\n            // 更新\n            Ball.prototype.update = function () {\n                // 位置改变\n                this.x += this.dX\n                this.y -= this.dY\n                // 半径改变\n                this.r += 0.2\n                // 透明度改变\n                this.opacity -= 0.01\n                this.dom.style.width = this.r * 2 + 'px'\n                this.dom.style.height = this.r * 2 + 'px'\n                this.dom.style.left = this.x - this.r + 'px'\n                this.dom.style.top = this.y - this.r + 'px'\n                this.dom.style.opacity = this.opacity\n\n                // 当透明度小于0的时候，就需要从数组中删除自己，DOM元素也要删掉自己\n                if (this.opacity < 0) {\n                    // 从数组中删除自己\n                    for (var i = 0; i < ballArr.length; i++) {\n                        if (ballArr[i] == this) {\n                            ballArr.splice(i, 1)\n                        }\n                    }\n                    // 还要删除自己的dom\n                    document.body.removeChild(this.dom)\n                }\n            }\n\n            // 把所有的小球实例都放到一个数组中\n            var ballArr = []\n\n            // 初始颜色数组\n            var colorArr = [\n                '#66CCCC',\n                '#CCFF66',\n                '#FF99CC',\n                '#FF6666',\n                '#CC3399',\n                '#FF6600',\n            ]\n\n            // 定时器，负责更新所有的小球实例\n            setInterval(function () {\n                // 遍历数组，调用调用的update方法\n                for (var i = 0; i < ballArr.length; i++) {\n                    ballArr[i].update()\n                }\n            }, 20)\n\n            // 鼠标指针的监听\n            document.onmousemove = function (e) {\n                // 得到鼠标指针的位置\n                var x = e.clientX\n                var y = e.clientY\n\n                new Ball(x, y)\n            }\n        <\/script>\n    </body>\n</html>\n\n\n\n# 内置对象\n\n\n# 包装类\n\n * Number()、 String()和 Boolean()分别是数字、字符串布尔值的“包装类\"----说白了就是构造函数！\n\n * 包装类的目的就是为了让基本类型值可以从它们的构造函数的 prototype 上获得方法\n\n * Number()、 String()和 Boolean()的实例都是 object 类型它们的 Primitivevalue 属性存储它们的本身值\n\n * new 出来的基本类型值可以正常参与运算\n\n\n# Math 对象\n\nMath 是一个内置对象，它拥有一些数学常数属性和数学函数方法。Math 不是一个函数对象。\n\n# 幂和开方\n\nMath.pow(),Math.sqrt()\n\nMath.pow(2, 3) // 8\nMath.pow(3, 2) // 9\nMath.sqrt(81) // 9\nMath.sqrt(-81) // NaN\n\n\nMath.pow()现在有了自己的操作符：**,Math.pow(2, 3)和2**3是一样的\n\n# 向上取整向下取整\n\nMath.ceil()向上取整;Math.floor()向下取整\n\nconsole.log(Math.ceil(123.1)) // 124\nconsole.log(Math.floor(123.1)) // 123\n\n\n# 有关 IEEE754\n\n * 在 JavaScript 中，有些小数的数学运算不是很精准:0.1+0.2 不等于 0.3\n\n * Javascript 使用了 IEEE754 二进制浮点数算术标准，这会使一些个别的小数运算产生“丢失精度”问题\n\n * 解决办法：在进行小数运算时，要调用数字的 toFixed() 方法保留指定的小数位数\n\nconsole.log((0.1 + 0.2).toFixed(1)) // 0.3\n\n\n# 四舍五入 Math.round()\n\n如何四舍五入到小数点某位？\n\n\n\n// 四舍五入到小数点后两位\nvar n1 = 3.1231\nvar n2 = Math.round(n1 * 100) / 100\nconsole.log(n2) //3.12\n\n\n# Math.max()和 Math.min()\n\n * Math.max()可以得到参数列表的最大值\n\n-Math.min()可以得到参数列表的最小值\n\n如果有任一参数不能被转换为数值，结果为 NaN\n\n * 如何利用 Math.max()求数组最大值?\n\nMath.max（）要求参数必须是“罗列出来”，而不能是数组\n\n利用 apply 方法，它可以指定函数的上下文，并且以数组的形式传入“零散值”当做函数的参数\n\nvar arr = [1, 23, 444, 4, 4, 41, 12312312]\nconsole.log(Math.max.apply(null, arr)) //123212312\n\n\n这里并没有使用 apply 指定函数上下文所以用 null,表示空对象，而是利用它可以以数组的形式传入“零散值”当做函数的参数\n\n# 随机数 Math.random()\n\nparseInt 是用于字符串，而不是用于数字\n\njs 生成[n,m]的随机数\n\n可以得到 0 到 1 的随机小数\n\n为了得到[a,b]区间内的整数，可以使用 这个公式：\n\n// 这里也可以使用Math.trunc()\nMath.floor(Math.random() * (b - a + 1)) + 1\n\n\n# Math.trunc()\n\nMath.trunc()方法会将数字的小数部分去掉，只保留整数部分。\n\n不像 Math 的其他三个方法：Math.floor()、Math.ceil()、Math.round() ，Math.trunc() 的执行逻辑很简单，仅仅是删除掉数字的小数部分和小数点，不管参数是正数还是负数\n\n\n# Date 对象\n\n * 使用 new Date()即可得到当前时间的日期对象，它是 Object 类型值\n * 使用 new date(2020,11,1)即可得到指定日期的日期对象，注意第二个参数表示月份，从 0 开始算，11 表示 12 月\n * 也可以是new Date('2020-12-01')这样的写法\n\n# 日期对象常见方法\n\n\n\n# 时间戳\n\n * 时间戳表示 1970 年 1 月 1 日零点整距离某时刻的毫秒数\n * 通过 getTime()实例方法 或者Date.parse()可以将日期对象变为时间戳\n\nvar day = new Date('2021-1-12')\n\nconsole.log(day.getTime()) // 1610380800000\n\nconsole.log(Date.parse(day)) //1610380800000\n\n\n * 通过 new date(时间戳)的写法，可以将时间戳变为日期对象",normalizedContent:"# 对象\n\n * 对象（ object）是“键值对”的集合，表示属性和值的映射关系\n * 如果对象的属性键名不符合标识符命名规范，则这个键名必须用引号包裹\n\nvar frank = {\n    name: 'frank',\n    'favorite-song': 'see-you-again',\n}\n\n\n\n# 属性的访问\n\nin运算符\n\n检查属性是否存在的操作符 \"in\"。\n\n语法是：\"key\" in object 例如：\n\nlet user = { name: \"john\", age: 30 };\n\nalert( \"age\" in user ); // true，user.age 存在\nalert( \"blabla\" in user ); // false，user.blabla 不存在。\n\n\n * 普通属性名使用点语法来访问\n\n * 如果属性名不符合标识符命名规范，则必须用方括号的写法来访问\n\nfrank['favorite-song'] //‘see-you-again’\n\n\n * 如果属性名以变量形式存储，则必须使用方括号形式\n\n提示\n\n虽然可以采用纯数字作为 key,但这本身就是不合法的标识符命名，所以访问需要使用方括号语法\n\nvar obj = {\n    a: 1,\n    b: 2,\n}\nvar key = 'b' // 属性名用变量存储\nconsole.log(obj.key) // undefined\nconsole.log(obj[key]) // 2\n\n\n * 可选链：?.：是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误\n   * 如果可选链?. 前面的部分是 undefined 或者 null，它会停止运算并返回该部分\n   * 可选链?.语法有三种形式:\n     * obj?.prop —— 如果 obj存在则返回 obj.prop，否则返回 undefined。\n     * obj?.[prop] —— 如果 obj存在则返回obj[prop]，否则返回 undefined。\n     * obj.method?.() —— 如果 obj.method 存在则调用 obj.method()，否则返回 undefined。\n\n\n# 属性的更改\n\n直接使用赋值运算符重新对某属性赋值即可更改属性\n\nvar obj = {\n    a: 10,\n}\nobj.a = 30\nobj.a++\n\n\n\n# 属性的创建\n\n如果对象本身没有某个属性值，则用点语法赋值时，这个属性会被创建出来\n\nvar obj = {\n    a: 10,\n}\nobj.b = 30\nconsole.log(obj.b) // 30\n\n\n\n# 属性的删除\n\n使用 delete操作符\n\nvar obj = {\n    a: 1,\n    b: 2,\n}\ndelete obj.a\n\n\n\n# 对象的方法\n\n * 如果某个属性值是函数，则它也被称为对象的 方法\n * 使用点语法可以调用对象的方法\n * 方法也是函数，只不过方法是对象的 函数属性,它需要用对象打点调用\n\n\n# 对象的遍历\n\n遍历对象需要使用 for...in循环\n\n// k 循环变量，它会依次成为对象的每一个键\nfor (var k in obj) {\n    console.log('属性' + k + '的值是' + obj[k])\n}\n\n\n一般情况下，for...in 循环只会遍历我们自定义的属性，原型上默认的属性不会遍历出来。例如 object.prototype.tostring()、object.prototype.hasownproperty()是不会被遍历出来的。\n\n但在实际应用中，如果是在原型中新增属性或者方法，for...in 会将原型中新增的属性和方法遍历出来。\n\nconst obj = {\n    a: 1,\n    b: 2,\n}\nobject.prototype.c = 3\nfor (var x in obj) {\n    console.log(x, obj[x])\n    // a 1\n    // b 2\n    // c 3\n}\n\n\n所以我们不能依赖于 for...in 来获取对象的成员名称，一般使用 hasownproperty 来判断下\n\nconst obj = {\n    a: 1,\n    b: 2,\n}\nobject.prototype.c = 3\nfor (var x in obj) {\n    if (obj.hasownproperty(x)) {\n        console.log(x, obj[x])\n        // a 1\n        // b 2\n    }\n}\n\n\n用它循环对象，循环出来的属性顺序并不可靠，所以不要在for...in中做依赖对象属性顺序的逻辑判断。\n\njavascript for...in循环出来的对象属性顺序到底是什么规律？\n\n先遍历出整数属性（integer properties，按照升序），然后其他属性按照创建时候的顺序遍历出来。\n\nlet codes = {\n    49: 'germany',\n    41: 'switzerland',\n    44: 'great britain',\n    1: 'usa',\n}\n\nfor (let code in codes) {\n    alert(code) // 1, 41, 44, 49\n}\n\n\n最终遍历出来的结果是：属性 1 先遍历出来， 49 最后遍历出来。\n\n这里的 1、41、44 和 49 就是整数属性。\n\n那什么是整数属性呢？我们可以用下面的比较结果说明：\n\nstring(math.trunc(number(prop)) === prop // 当判断结果为 true，prop 就是整数属性，否则不是。\n\n\n所以\n\n * \"49\" 是整数属性，因为 string(math.trunc(number('49')) 的结果还是 \"49\"。\n * \"+49\" 不是整数属性，因为 string(math.trunc(number('+49')) 的结果是 \"49\"，不是 \"+49\"。\n * \"1.2\" 不是整数属性，因为 string(math.trunc(number('1.2')) 的结果是 \"1\"，不是 \"1.2\"。\n\n上面的例子中，如果想按照创建顺序循环出来，可以用一个 讨巧 的方法：\n\nlet codes = {\n    '+49': 'germany',\n    '+41': 'switzerland',\n    '+44': 'great britain',\n    // ..,\n    '+1': 'usa',\n}\n\nfor (let code in codes) {\n    console.log(+code) // 49, 41, 44, 1\n}\n\n\n原型中新增的属性或方法，总是在最后按照顺序打印\n\nconst obj = {\n    3: 'xx',\n    1: 'frank',\n    2: 'chang',\n    name: 'zfh',\n    age: 18,\n}\nobject.prototype[7] = 'zhang'\nobject.prototype[6] = 'frank1'\nfor (var k in obj) {\n    console.log('属性' + k + '的值是' + obj[k])\n}\n// 属性1的值是frank\n// 属性2的值是chang\n// 属性3的值是xx\n// 属性name的值是zfh\n// 属性age的值是18\n// 属性6的值是frank1\n// 属性7的值是zhang\n\n\n\n# 对象的深浅克隆\n\n对象是引用类型值，这意味着：\n\n不能用 var obj2=obj1这样的语法克隆一个对象。使用==或者===进行对象的比较时，比较的是它们是否为内存中的同一个对象，而不是比较值是否相同。\n\nvar obj1 = {\n    a: 1,\n    b: 2,\n    c: [1, 23, 4123],\n}\nvar obj2 = {}\nfor (var k in obj1) {\n    obj2[k] = obj1[k]\n}\nconsole.log(obj2.c === obj2.a) // true，浅克隆不可隆属性值为引用类型的键\n\n\njs 的原生不支持深拷贝，上面代码使用for...in,还有object.assign 和{...obj}都属于浅拷贝；数组可以利用array.prototype.concat(),array.prototype.slice()实现浅拷贝。\n\njson.sringify 和 json.parse 可以实现深拷贝，原理就是先将对象转换为字符串，再通过json.parse 重新建立一个对象。 但是这种方法的局限也很多：\n\n * 不能复制 function、正则、symbol\n\nlet obj = {\n    reg: /^asd$/,\n    fun: function () {},\n    syb: symbol('foo'),\n    asd: 'asd',\n}\nlet cp = json.parse(json.stringify(obj))\nconsole.log(cp) // { reg: {}, asd: 'asd' },可以看到，函数、正则、symbol 都没有被正确的复制.\n\n\n * 循环引用报错，当对象 1 中的某个属性指向对象 2，对象 2 中的某个属性指向对象 1 就会出现循环引用\n\nfunction circularreference() {\n    let obj1 = {}\n    let obj2 = {\n        b: obj1,\n    }\n    obj1.a = obj2\n}\n\n\n对包含循环引用的对象（对象之间相互引用，形成无限循环）执行 json.stringify()，会抛出错误\n\n * 相同的引用会被重复复制\n\nlet obj = { asd: 'asd' }\nlet obj2 = { name: 'aaaaa' }\nobj.ttt1 = obj2\nobj.ttt2 = obj2\nlet cp = json.parse(json.stringify(obj))\nobj.ttt1.name = 'change'\ncp.ttt1.name = 'change'\nconsole.log(obj, cp)\n\n\n在原对象 obj 中的 ttt1 和 ttt2 指向了同一个对象 obj2，那么我在深拷贝的时候，就应该只拷贝一次 obj2 ，下面我们看看运行结果：\n\n\n\n我们可以看到（上面的为原对象，下面的为复制对象），原对象改变 ttt1.name 也会改变 ttt2.name ，因为他们指向相同的对象。\n\n但是，复制的对象中，ttt1 和 ttt2 分别指向了两个对象。复制对象没有保持和原对象一样的结构。因此，json 实现深复制不能处理指向相同引用的情况，相同的引用会被重复复制。\n\n递归实现深拷贝，对于简单类型，直接复制。对于引用类型，递归复制它的每一个属性\n\n/**\n * 实现的深拷贝仅仅是解决了深拷贝的关键问题，还需要针对不同的数据类型进行完善\n */\n\nfunction deepclone(o) {\n    // 判断是否是数组\n    if (array.isarray(o)) {\n        var result = [] //此数组解决了循环引用和相同引用的问题，它存放已经递归到的目标对象\n        for (let k = 0; k < o.length; k++) {\n            result.push(deepclone(o[k]))\n        }\n        // 来到这里的都是对象\n    } else if (typeof o === 'object') {\n        var result = {}\n        for (var k in o) {\n            result[k] = deepclone(o[k])\n        }\n    } else {\n        var result = o\n    }\n    return result\n}\n\n\n\n# this 指向问题\n\n彻底搞懂 this 指向\n\n开发中很少直接在全局作用域下去使用 this(浏览器环境下，全局作用域中的 this非严格模式下为 window)，通常都是在函数中使用\n\n在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了,因为 this 的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境\n\n\n# this 绑定规则\n\nthis 无非就是在函数调用时被绑定的一个对象，我们就需要知道它在不同的场景下的绑定规则:\n\n 1. 默认绑定\n\n什么情况下使用默认绑定呢？独立函数调用\n\n独立的函数调用我们可以理解成函数没有被绑定到某个对象上进行调用\n\n案例一：普通函数调用\n\n * 该函数直接被调用，并没有进行任何的对象关联；\n * 这种独立的函数调用会使用默认绑定，通常默认绑定时，函数中的 this 指向全局对象window；\n\nfunction foo() {\n    console.log(this) // window\n}\n\nfoo()\n\n\n案例二：函数调用链（一个函数又调用另外一个函数）\n\n所有的函数调用都没有被绑定到某个对象上\n\nfunction test1() {\n    console.log(this) // window\n    test2()\n}\n\nfunction test2() {\n    console.log(this) // window\n    test3()\n}\n\nfunction test3() {\n    console.log(this) // window\n}\ntest1()\n\n\n案例三：将函数作为参数，传入到另一个函数中\n\nfunction foo(func) {\n    func()\n}\n\nfunction bar() {\n    console.log(this) // window\n}\n\nfoo(bar)\n\n\n稍微修改一下：\n\nfunction foo(func) {\n    func()\n}\n\nvar obj = {\n    name: 'why',\n    bar: function () {\n        console.log(this) // window\n    },\n}\n\nfoo(obj.bar)\n\n\n结果依然是window,原因非常简单，在真正函数调用的位置，并没有进行任何的对象绑定，只是一个独立函数的调用；\n\n 2. 隐式绑定\n\n另外一种比较常见的调用方式是通过某个对象进行调用的：也就是它的调用位置中，是通过某个对象发起的函数调用\n\n案例一：通过对象调用函数\n\nfoo是通过 obj.foo()方式进行调用的\n\n那么 foo 调用时this会隐式的被绑定到 obj 对象上\n\nfunction foo() {\n    console.log(this) // obj对象\n}\n\nvar obj = {\n    name: 'why',\n    foo: foo,\n}\n\nobj.foo()\n\n\n案例二：案例一的变化\n\n我们通过 obj2 又引用了 obj1对象，再通过 obj1 对象调用foo函数；\n\n那么 foo调用的位置上其实还是 obj1被绑定了 this；\n\nfunction foo() {\n    console.log(this) // obj1对象\n}\n\nvar obj1 = {\n    name: 'obj1',\n    foo: foo,\n}\n\nvar obj2 = {\n    name: 'obj2',\n    obj1: obj1,\n}\n\nobj2.obj1.foo()\n\n\n案例三：隐式丢失\n\n结果最终是 window，因为foo 最终被调用的位置是 bar，而 bar 在进行调用时没有绑定任何的对象，也就没有形成隐式绑定；相当于是一种默认绑定；\n\nfunction foo() {\n    console.log(this) // window\n}\n\nvar obj1 = {\n    name: 'obj1',\n    foo: foo,\n}\n\n// 将obj1的foo赋值给bar\nvar bar = obj1.foo\nbar()\n\n\n 3. 显式绑定\n\n隐式绑定有一个前提条件：\n\n * 必须在调用的对象内部有一个对函数的引用（比如一个属性）；\n * 如果没有这样的引用，在进行调用时，会报找不到该函数的错误；\n * 正是通过这个引用，间接的将 this 绑定到了这个对象上；\n\n如果我们不希望在 对象内部 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？\n\njavascript 所有的函数都可以使用 call 和 apply 以及 bind 显式指定 this。\n\n这三个函数的第一个参数都要求是一个对象，这个对象的作用是什么呢？就是给 this准备的。\n\n在调用这个函数时，会将 this 绑定到这个传入的对象上\n\n因为上面的过程，我们明确的绑定了 this 指向的对象，所以称之为 显式绑定\n\ncall,apply,bind 三者区别\n\ncall apply bind 三者的用法和区别\n\ncall()、apply()、bind() 都是用来重定义 this 这个对象的\n\nbind 返回的是一个新的函数，你必须调用它才会被执行 ,其余两个都是立即执行的\n\nbind 和 call 参数形式一致，apply 需要把参数写到数组里\n\n有些时候，我们会调用一些 javascript的内置函数，或者一些第三方库中的内置函数\n\n这些内置函数会要求我们传入另外一个函数；\n\n我们自己并不会显示的调用这些函数，而且 javascript内部或者第三方库内部会帮助我们执行；\n\n这些函数中的 this又是如何绑定的呢？\n\n案例一：settimeout\n\nsettimeout 中会传入一个函数，这个函数中的 this 通常是 window\n\nsettimeout(function () {\n    console.log(this) // window\n}, 1000)\n\n\n为什么这里是 window呢？\n\n这个和 settimeout源码的内部调用有关；settimeout内部是通过 apply 进行绑定的 this对象，并且绑定的是全局对象；\n\n那如果我们想让这里的 this不是 window呢？比如我们希望点击 box 盒子延时 2 秒变为红色,那么我们就需要备份一下 this：\n\nvar box = document.getelementbyid('box')\nfunction bred() {\n    var self = this // 备份this\n    settimeout(function () {\n        self.style.backgroundcolor = 'red'\n    }, 2000)\n}\nbox.onclick = bred\n\n\n或者使用箭头函数：\n\nvar box = document.getelementbyid('box')\nfunction bred() {\n    settimeout(() => {\n        this.style.backgroundcolor = 'red'\n    }, 2000)\n}\nbox.onclick = bred\n\n\n案例二：数组的 foreach\n\n在 foreach 中传入的函数打印的也是 window对象； 这是因为默认情况下传入的函数是自动调用函数（默认绑定）；\n\nvar names = ['abc', 'cba', 'nba']\nnames.foreach(function (item) {\n    console.log(this) // 三次window\n})\n\n\n当然我们可以通过 foreach的第二个参数改变 this指向\n\nvar names = ['abc', 'cba', 'nba']\nvar obj = { name: 'why' }\nnames.foreach(function (item) {\n    console.log(this) // 三次obj对象\n}, obj)\n\n\n案例三：div 的点击\n\n获取 box 元素节点，并且监听点击：\n\n在点击事件的回调中，this 指向谁呢？box 对象； 这是因为在发生点击时，执行传入的回调函数被调用时，会将 box 对象绑定到该函数中；\n\nvar box = document.queryselector('.box')\nbox.onclick = function () {\n    console.log(this) // box对象\n}\n\n\n 4. new绑定\n\n见构造函数章节\n\n 5. 规则优先级\n\n * 默认规则的优先级最低\n\n毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定 this\n\n * 显示绑定优先级高于隐式绑定\n\nfunction foo() {\n    console.log(this)\n}\n\nvar obj1 = {\n    name: 'obj1',\n    foo: foo,\n}\n\nvar obj2 = {\n    name: 'obj2',\n    foo: foo,\n}\n\n// 隐式绑定\nobj1.foo() // obj1\nobj2.foo() // obj2\n\n// 隐式绑定和显示绑定同时存在\nobj1.foo.call(obj2) // obj2, 说明显式绑定优先级更高\n\n\n * new 绑定优先级高于隐式绑定\n\nfunction foo() {\n    console.log(this)\n}\n\nvar obj = {\n    name: 'why',\n    foo: foo,\n}\n\nnew obj.foo() // foo对象, 说明new绑定优先级更高\n\n\n * new 绑定优先级高于 bind\n\nnew 绑定和 call、apply 是不允许同时使用的，所以不存在谁的优先级更高\n\nfunction foo() {\n    console.log(this)\n}\n\nvar obj = {\n    name: 'obj',\n}\n\nvar foo = new foo.call(obj) //报错\n\n\n但是 new 绑定可以和 bind后的函数同时使用\n\nfunction foo() {\n    console.log(this)\n}\n\nvar obj = {\n    name: 'obj',\n}\n\nvar bar = foo.bind(obj)\nvar foo = new bar() // 打印foo, 说明使用的是new绑定\n\n\n优先级总结：new 绑定 > 显示绑定（bind）> 隐式绑定 > 默认绑定\n\n\n# this 规则之外\n\n 1. 忽略显式绑定\n\n如果在显式绑定中，我们传入一个 null 或者 undefined，那么这个显示绑定会被忽略，使用默认规则：\n\nfunction foo() {\n    console.log(this)\n}\n\nvar obj = {\n    name: 'why',\n}\n\nfoo.call(obj) // obj对象\nfoo.call(null) // window\nfoo.call(undefined) // window\n\nvar bar = foo.bind(null)\nbar() // window\n\n\n 2. 间接函数引用\n\n另外一种情况，创建一个函数的 间接引用，这种情况使用默认绑定规则。\n\nfunction foo() {\n    console.log(this)\n}\n\nvar obj1 = {\n    name: 'obj1',\n    foo: foo,\n}\n\nvar obj2 = {\n    name: 'obj2',\n}\n\nobj1.foo() // obj1对象\n;(obj2.foo = obj1.foo)() // window\n\n\n赋值(obj2.foo = obj1.foo)的结果是 foo 函数；foo 函数被直接调用，那么是默认绑定；\n\n 3. es6 箭头函数\n\n箭头函数不使用 this 的四种标准规则（也就是不绑定 this），而是根据外层作用域来决定 this\n\n箭头函数中的 this 指向\n\n\n# 构造函数\n\n * 用 new 调用一个函数，这个函数就被称为“构造函数”，任何函数都可以是构造函数，只需要用 new 调用它\n * 顾名思义，构造函数用来“构造新对象”，它内部的语句将为新对象添加若干属性和方法，完成对象的初始化\n * 构造函数必须用 new 关键字调用，否则不能正常工作，正因如此，开发者约定构造函数命名时首字母要大写\n * 使用 new 调用构造函数，会执行以下操作：\n\n1）在内存中创建一个新对象\n\n2）将新对象与构造函数通过原型链连接起来\n\n3）将构造函数中的this 绑定到新对象上\n\n4）执行构造函数内部的代码\n\n5）如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象\n\nfunction fun(a) {\n    this.a = a\n    return { [a]: 1 }\n}\nconst obj = new fun(2)\nconsole.log(obj) // { '2': 1 }而不是 { a: 2 }\n\n\n\n# 原型原型链\n\n\n# prototype\n\n\n\n * 任何函数都有prototype属性， prototype是英语“原型“的意思\n\n * prototype属性值是个对象，它默认拥有 constructor属性指回函数\n\nfunction sum(a, b) {\n    return a + b\n}\nconsole.log(sum.prototype)\nconsole.log(sum.prototype.constructor === sum) // true\n\n\n * 普通函数来说的prototype属性没有任何用处，而构造函数的prototype属性非常有用\n * 构造函数的 prototype 属性是它的实例的原型\n\n注： __proto__：每个对象都有一个proto，可称为隐式原型\n\n代码实现：\n\nfunction fun(a, b) {\n    this.a = a\n    this.b = b\n}\nvar o = new fun(1, 2)\nconsole.log(fun.prototype === o.__proto__) //true\n\n\n\n# 原型链查找\n\n实例可以打点访问它的原型的属性和方法，这被称为“原型链查找”\n\n如果实例化出来的对象已经有了原型上的同名属性，那么就不会进行原型链查找\n\n\n# hasownproperty\n\n检查对象是否真正“自己拥有某属性或者方法\"\n\nfunction fun(a, b) {\n    this.a = a\n    this.b = b\n}\nfun.prototype.c = '5'\nvar o = new fun(1, 2)\nconsole.log(o.c) //5\nconsole.log(o.hasownproperty('a')) //true\nconsole.log(o.hasownproperty('c')) //false\n\n\n\n# instanceof 运算符\n\ninstanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。\n\nobject instanceof constructor //object 某个实例对象 constructor 某个构造函数\n\n\n\n# in 运算符\n\nin 只能检查某个属性或方法是否可以被对象访问，不能检查是否是自己的属性或方法\n\nfunction fun(a, b) {\n    this.a = a\n    this.b = b\n}\nfun.prototype.c = '5'\nvar o = new fun(1, 2)\nconsole.log(o.c) //5\nconsole.log('a' in o) //true\nconsole.log('c' in o) //true\n\n\n\n# getprototypeof\n\nobject.getprototypeof() 方法返回指定对象的原型\n\nconst obj = {}\nconsole.log(object.getprototypeof(obj) === object.prototype)\n// expected output: true\n\n\n\n# create\n\nobject.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。\n\nconst person = {\n    ishuman: false,\n    printintroduction: function () {\n        console.log(`my name is ${this.name}. am i human? ${this.ishuman}`)\n    },\n}\n\nconst me = object.create(person)\n\nme.name = 'matthew' // \"name\" is a property set on \"me\", but not on \"person\"\nme.ishuman = true // inherited properties can be overwritten\n\nme.printintroduction()\n// expected output: \"my name is matthew. am i human? true\"\n\n\n\n# 在 prototype 上添加方法\n\n之前是把方法直接添加到实例身上的缺点：每个实例和每个实例的方法函数都是内存中不同的函数，造成了内存的浪费，解决办法：将方法写到 prototype 上\n\nfunction fun(a, b) {\n    this.a = a\n    this.b = b\n}\nfun.prototype.sum = function (x) {\n    return this.a + this.b + x\n}\nvar o = new fun(1, 2)\nconsole.log(o.sum(3)) //6\n\n\n\n# 原型链的终点\n\n原型链的终点是 object.prototype，所以这就是新建的对象为什么能够使用 tostring() 等方法的原因。\n\n\n\n\n# js 实现继承\n\nfunction people(name, age, sex) {\n    this.name = name\n    this.age = age\n    this.sex = sex\n}\npeople.prototype.sayhello = function () {\n    console.log('你好' + '我是' + this.name)\n}\npeople.prototype.sleep = function () {\n    console.log('我要睡觉！！')\n}\nfunction student(name, age, sex, school, classnumber) {\n    this.name = name\n    this.age = age\n    this.sex = sex\n    this.school = school\n    this.class = classnumber\n}\n// 实现继承\nstudent.prototype = new people()\n// 必须在下边代码之前\nstudent.prototype.study = function () {\n    console.log(this.school + '都是好学生')\n}\nstudent.prototype.exam = function () {\n    console.log(this.name + '考的不错')\n}\nvar frank = new student('frank', 22, '男', 'snut', '1')\n\n\n原型链继承的缺点：\n\n 1. 原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。\n\n 2. 子类型在实例化时不能给父类型的构造函数传参。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。\n\n\n# 面向对象案例\n\njs 是面向过程、面向对象还是基于对象？面向对象的代码体现\n\n面向对象的本质：定义不同的类，让类的实例工作\n\n面向对象的优点：程序编写更清晰、代码结构更严密、使代码更健壮更利于维护\n\n面向对象经常用到的场合：需要封裝和复用性的场合（组件思维）\n\n\n# 红绿灯案例\n\n页面上做一个红绿灯，点击红灯就变黄，点击黄灯就变绿，点击绿灯就变回红灯；如果页面上有 100 个这样的红绿灯呢？\n\n代码\n\n<!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>document</title>\n        <div id=\"box\"></div>\n    </head>\n    <body>\n        <script>\n            var box = document.getelementbyid('box')\n            function trafficlight() {\n                this.color = 1\n                this.init()\n                this.changecolor()\n            }\n            trafficlight.prototype.init = function () {\n                this.dom = document.createelement('img')\n                this.dom.src = './' + this.color + '.jpg'\n                box.appendchild(this.dom)\n            }\n            trafficlight.prototype.changecolor = function () {\n                var self = this\n                // 这里的this指向的是实例化出来的对象\n                self.dom.onclick = function () {\n                    // 这里的this指向的是事件处理函数绑定的d0m元素\n                    // 如果直接使用this，dom元素有color属性？对吧，理解了\n                    self.color++\n                    if (self.color == 4) {\n                        self.color = 1\n                    }\n                    self.dom.src = './' + self.color + '.jpg'\n                }\n            }\n\n            var light1 = new trafficlight()\n            var light2 = new trafficlight()\n            var light3 = new trafficlight()\n            var light4 = new trafficlight()\n        <\/script>\n    </body>\n</html>\n\n\n素材：\n\n\n# 炫彩小球小案例\n\n代码\n\n<!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>document</title>\n        <style>\n            body {\n                background-color: black;\n            }\n\n            .ball {\n                position: absolute;\n                border-radius: 50%;\n            }\n        </style>\n    </head>\n\n    <body>\n        <script>\n            // 小球类\n            function ball(x, y) {\n                // 属性x、y表示的是圆心的坐标\n                this.x = x\n                this.y = y\n                // 半径属性\n                this.r = 20\n                // 透明度\n                this.opacity = 1\n                // 小球背景颜色，从颜色数组中随机选择一个颜色\n                this.color =\n                    colorarr[math.floor(math.random() * colorarr.length)]\n                // 这个小球的x增量和y的增量，使用do while语句，可以防止dx和dy都是零\n                do {\n                    this.dx = math.floor(math.random() * 20) - 10\n                    this.dy = math.floor(math.random() * 20) - 10\n                } while (this.dx == 0 && this.dy == 0)\n\n                // 初始化\n                this.init()\n                // 把自己推入数组，注意，这里的this不是类本身，而是实例\n                ballarr.push(this)\n            }\n            // 初始化方法\n            ball.prototype.init = function () {\n                // 创建自己的dom\n                this.dom = document.createelement('div')\n                this.dom.classname = 'ball'\n                this.dom.style.width = this.r * 2 + 'px'\n                this.dom.style.height = this.r * 2 + 'px'\n                this.dom.style.left = this.x - this.r + 'px'\n                this.dom.style.top = this.y - this.r + 'px'\n                this.dom.style.backgroundcolor = this.color\n                // 上树\n                document.body.appendchild(this.dom)\n            }\n            // 更新\n            ball.prototype.update = function () {\n                // 位置改变\n                this.x += this.dx\n                this.y -= this.dy\n                // 半径改变\n                this.r += 0.2\n                // 透明度改变\n                this.opacity -= 0.01\n                this.dom.style.width = this.r * 2 + 'px'\n                this.dom.style.height = this.r * 2 + 'px'\n                this.dom.style.left = this.x - this.r + 'px'\n                this.dom.style.top = this.y - this.r + 'px'\n                this.dom.style.opacity = this.opacity\n\n                // 当透明度小于0的时候，就需要从数组中删除自己，dom元素也要删掉自己\n                if (this.opacity < 0) {\n                    // 从数组中删除自己\n                    for (var i = 0; i < ballarr.length; i++) {\n                        if (ballarr[i] == this) {\n                            ballarr.splice(i, 1)\n                        }\n                    }\n                    // 还要删除自己的dom\n                    document.body.removechild(this.dom)\n                }\n            }\n\n            // 把所有的小球实例都放到一个数组中\n            var ballarr = []\n\n            // 初始颜色数组\n            var colorarr = [\n                '#66cccc',\n                '#ccff66',\n                '#ff99cc',\n                '#ff6666',\n                '#cc3399',\n                '#ff6600',\n            ]\n\n            // 定时器，负责更新所有的小球实例\n            setinterval(function () {\n                // 遍历数组，调用调用的update方法\n                for (var i = 0; i < ballarr.length; i++) {\n                    ballarr[i].update()\n                }\n            }, 20)\n\n            // 鼠标指针的监听\n            document.onmousemove = function (e) {\n                // 得到鼠标指针的位置\n                var x = e.clientx\n                var y = e.clienty\n\n                new ball(x, y)\n            }\n        <\/script>\n    </body>\n</html>\n\n\n\n# 内置对象\n\n\n# 包装类\n\n * number()、 string()和 boolean()分别是数字、字符串布尔值的“包装类\"----说白了就是构造函数！\n\n * 包装类的目的就是为了让基本类型值可以从它们的构造函数的 prototype 上获得方法\n\n * number()、 string()和 boolean()的实例都是 object 类型它们的 primitivevalue 属性存储它们的本身值\n\n * new 出来的基本类型值可以正常参与运算\n\n\n# math 对象\n\nmath 是一个内置对象，它拥有一些数学常数属性和数学函数方法。math 不是一个函数对象。\n\n# 幂和开方\n\nmath.pow(),math.sqrt()\n\nmath.pow(2, 3) // 8\nmath.pow(3, 2) // 9\nmath.sqrt(81) // 9\nmath.sqrt(-81) // nan\n\n\nmath.pow()现在有了自己的操作符：**,math.pow(2, 3)和2**3是一样的\n\n# 向上取整向下取整\n\nmath.ceil()向上取整;math.floor()向下取整\n\nconsole.log(math.ceil(123.1)) // 124\nconsole.log(math.floor(123.1)) // 123\n\n\n# 有关 ieee754\n\n * 在 javascript 中，有些小数的数学运算不是很精准:0.1+0.2 不等于 0.3\n\n * javascript 使用了 ieee754 二进制浮点数算术标准，这会使一些个别的小数运算产生“丢失精度”问题\n\n * 解决办法：在进行小数运算时，要调用数字的 tofixed() 方法保留指定的小数位数\n\nconsole.log((0.1 + 0.2).tofixed(1)) // 0.3\n\n\n# 四舍五入 math.round()\n\n如何四舍五入到小数点某位？\n\n\n\n// 四舍五入到小数点后两位\nvar n1 = 3.1231\nvar n2 = math.round(n1 * 100) / 100\nconsole.log(n2) //3.12\n\n\n# math.max()和 math.min()\n\n * math.max()可以得到参数列表的最大值\n\n-math.min()可以得到参数列表的最小值\n\n如果有任一参数不能被转换为数值，结果为 nan\n\n * 如何利用 math.max()求数组最大值?\n\nmath.max（）要求参数必须是“罗列出来”，而不能是数组\n\n利用 apply 方法，它可以指定函数的上下文，并且以数组的形式传入“零散值”当做函数的参数\n\nvar arr = [1, 23, 444, 4, 4, 41, 12312312]\nconsole.log(math.max.apply(null, arr)) //123212312\n\n\n这里并没有使用 apply 指定函数上下文所以用 null,表示空对象，而是利用它可以以数组的形式传入“零散值”当做函数的参数\n\n# 随机数 math.random()\n\nparseint 是用于字符串，而不是用于数字\n\njs 生成[n,m]的随机数\n\n可以得到 0 到 1 的随机小数\n\n为了得到[a,b]区间内的整数，可以使用 这个公式：\n\n// 这里也可以使用math.trunc()\nmath.floor(math.random() * (b - a + 1)) + 1\n\n\n# math.trunc()\n\nmath.trunc()方法会将数字的小数部分去掉，只保留整数部分。\n\n不像 math 的其他三个方法：math.floor()、math.ceil()、math.round() ，math.trunc() 的执行逻辑很简单，仅仅是删除掉数字的小数部分和小数点，不管参数是正数还是负数\n\n\n# date 对象\n\n * 使用 new date()即可得到当前时间的日期对象，它是 object 类型值\n * 使用 new date(2020,11,1)即可得到指定日期的日期对象，注意第二个参数表示月份，从 0 开始算，11 表示 12 月\n * 也可以是new date('2020-12-01')这样的写法\n\n# 日期对象常见方法\n\n\n\n# 时间戳\n\n * 时间戳表示 1970 年 1 月 1 日零点整距离某时刻的毫秒数\n * 通过 gettime()实例方法 或者date.parse()可以将日期对象变为时间戳\n\nvar day = new date('2021-1-12')\n\nconsole.log(day.gettime()) // 1610380800000\n\nconsole.log(date.parse(day)) //1610380800000\n\n\n * 通过 new date(时间戳)的写法，可以将时间戳变为日期对象",charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"流程控制语句",frontmatter:{title:"流程控制语句",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html",relativePath:"前端开发/JavaScript/JS基础/流程控制语句.md",key:"v-94f2abb4",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%9F%BA%E7%A1%80/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html",headers:[{level:2,title:"条件语句",slug:"条件语句",normalizedTitle:"条件语句",charIndex:2},{level:3,title:"if 语句(一般和 else 一起使用)",slug:"if-语句-一般和-else-一起使用",normalizedTitle:"if 语句(一般和 else 一起使用)",charIndex:11},{level:3,title:"switch 语句",slug:"switch-语句",normalizedTitle:"switch 语句",charIndex:599},{level:3,title:"三元运算符",slug:"三元运算符",normalizedTitle:"三元运算符",charIndex:947},{level:2,title:"循环语句",slug:"循环语句",normalizedTitle:"循环语句",charIndex:1143},{level:3,title:"for",slug:"for",normalizedTitle:"for",charIndex:1152},{level:3,title:"while",slug:"while",normalizedTitle:"while",charIndex:2357},{level:3,title:"break,continue",slug:"break-continue",normalizedTitle:"break,continue",charIndex:2839},{level:3,title:"do...while",slug:"do-while",normalizedTitle:"do...while",charIndex:3047},{level:3,title:"3 种循环对比",slug:"_3-种循环对比",normalizedTitle:"3 种循环对比",charIndex:3749},{level:2,title:"拓展案例",slug:"拓展案例",normalizedTitle:"拓展案例",charIndex:3763},{level:3,title:"累加器累乘器",slug:"累加器累乘器",normalizedTitle:"累加器累乘器",charIndex:3772},{level:3,title:"穷举法",slug:"穷举法",normalizedTitle:"穷举法",charIndex:4079},{level:3,title:"循环嵌套",slug:"循环嵌套",normalizedTitle:"循环嵌套",charIndex:4461}],headersStr:"条件语句 if 语句(一般和 else 一起使用) switch 语句 三元运算符 循环语句 for while break,continue do...while 3 种循环对比 拓展案例 累加器累乘器 穷举法 循环嵌套",content:"# 条件语句\n\n\n# if 语句(一般和 else 一起使用)\n\n * 表示如果...就...否则...\n * 在 if 语句中，else 是可以省略的\n\nvar a = 1\nif ((a = 1)) {\n    console.log('a=1')\n}\n\n\n * 如果 if 语句体中只有一行语句，可以省略大括号和换行\n\nif ((a = 1)) console.log('a=1')\n\n\n# if...else...if 多条件分支\n\n\n\n# if 语句的嵌套\n\n\n\nvar Price = function (age, day) {\n    var price = 0\n    if (age < 10) {\n        if (day == 0 || day == 6) {\n            price = 210\n        } else {\n            price = 140\n        }\n    } else {\n        if (day == 0 || day == 6) {\n            price = 500\n        } else {\n            price = 300\n        }\n    }\n    return price\n}\nconsole.log(Price(10, 1))\n\n\n\n# switch 语句\n\nswitch 语句的用途：当一个变量被分类讨论的情形。\n\n\n\n\n\n * 在 switch()的圆括号中一般是一个变量名，这个变量将被分类讨论\n * case 表示“情况”，它后面没有圆括号，直接跟一个值。程序会依次将 case 后面的值与 switch 圆括号中的值进行全等比对，如果比对相同，则执行这条 case 冒号后面的语句。\n * default 表示默认情况。\n * 多条 case 可以共用同一个语句体。\n * switch 语句并不像 if 语句那样当执行了某一个分支之后会自动跳出 if 语句体，程序员必须主动调用 break 来跳出 switch 语句体。如果不书写 break，则后面的所有 case 都将被视为匹配，直到遇见 break。\n\n\n\n\n# 三元运算符\n\n条件表达式？表达式 1：表达式 2\n\n问号前面是判断的条件，问号后面用冒号隔开两个表达式。当条件表达式为真时调用表达式 1，为假时调用表达式 2。\n\n三元运算符的用途：根据某个条件是否成立，在两个不同值中选择变量的值\n\nvar age = 18\nvar res = age >= 18 ? '成年人' : '未成年人'\nconsole.log(res) // 成年人\n\n\n\n# 循环语句\n\n\n# for\n\n# for 语句的执行机理\n\n\n\nfor 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\n\nfor (let i = 0; i < 3; i++) {\n    let i = 'abc'\n    console.log(i)\n}\n// abc\n// abc\n// abc\n\n\n上面代码正确运行，输出了 3 次 abc。这表明函数内部的变量 i 与循环变量 i 不在同一个作用域，有各自单独的作用域（同一个作用域不可使用  let  重复声明同一个变量）。\n\n# for 循环的高级用法\n\n语法：label : statement\n\n①label 表示标签名\n\n②statement 表示代码块\n\n③label 标签名与 statement 表示代码块之间使用英文状态下的冒号分隔\n\n定义的标签可以在将来由 break 或 continue 语句引用。\n\nvar num = 0\nouternum: for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n        if (i == 5 && j == 5) {\n            break outernum\n        }\n        num++\n    }\n}\nalert(num) //55\n\n\n在这个例子中，outernum 标签表示外部的 for 语句。如果每个循环正常执行 10 次，则 num++语句就会正常执行 100 次。换句话说，如果两个循环都自然结束，num 的值应该是 100。但内部循环中的 break 语句带了一个参数（outernum 标签）。添加这个标签的结果将导致 break 语句不仅会退出内部的 for 语句（即使用变量 j 的循环），而且也会退出外部的 for 语句（即使用变量 i 的循环）。为此，当变量 i 和 j 都等于 5 时，num 的值正好是 55。同样，continue 语句也可以像这样与 1abel 语句联用，如下面的例子所示：\n\nvar num = 0\nouternum: for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n        if (i == 5 && j == 5) {\n            continue outernum\n        }\n        num++\n    }\n}\nalert(num) //95\n\n\n在这种情况下，continue 语句会强制继续执行循环，即退出内部循环，执行外部循环。当 j 是 5 时，continue 语句执行，而这也就意味着内部循环少执行了 5 次，因此 num 的结果是 95。\n\n\n# while\n\n * while 语句，是一种“不定范围”循环.\n * While 语句事先不指定循环开始、结束的范围，只要测试条件满足，就一直执行循环体\n * while 循环没有显式定义循环变量，必须自己在 while 循环外先定义好循环变量，有时甚至可以没有循环变量。\n\nvar n = 1\nvar result = 0\nwhile (n <= 100) {\n    result += n\n    n++\n}\nconsole.log(result) // 输出1到100的和\n\n\n * 循环体内的语句，必须使循环测试条件趋向不成立，否则会死循环\n * 一定要注意“出一”错误 小兔子拔萝卜，第 1 天拔 1 个，第 2 天拔 2 个，第 3 天拔 3 个问：第几天能拔光 500 个萝卜？\n\nvar sum = 0\nwhile (sum < 500) {\n    sum += n // 32天的时候已经拔了超过500个萝卜\n    n++ // 但是这条语句还会执行，导致出一错误\n}\nconsole.log(n - 1) // 所以最好要减一\n\n\n\n# break,continue\n\n * break 表示立即终止循环，它只能用在循环语句中，在 for 循环和 while 循环中都可以使用\n * break 用在 while 语句中，通常和 While（true）{}搭配使用\n   \n   > while(true){}是一个死循环，通过 break 可以让它终止循环。\n\n * continue 用于跳过循环中的一个迭代，并继续执行循环中的下一个迭代。\n\n\n# do...while\n\n * do while 循环是一种“后测试循环语句”。它不同于 for 循环和 While 循环每次都是“先测试条件是否满足，然后执行循环体″，do- While 循环是“先执行循环体，然后测试条件是否满足\n\n\n\n * do- while 循环将循环执行条件写到了循环体的后面，这样一来，循环体一定会至少执行一次，然后再检测循环执行条件是否为 true，决定是否继续执行循环体。\n\nvar i = 11\ndo {\n    console.log(i)\n    i++\n} while (i <= 10)\n\n\n# 随机数函数\n\nparseInt 是用于字符串，而不是用于数字\n\njs 生成[n,m]的随机数\n\nMath.random()返回介于 0（包含） ~ 1（不包含） 之间的一个随机数\n\n如果想要得到[a,b]区间的整数，公式\n\n// 这里也可以使用Math.trunc()\nMath.floor(Math.random() * (b - a + 1)) + a\n\n\neg：请编写程序，随机生成两个变量 dx 和 dy，它们均在【-4,4】 区间随机取值，但要求 dx 和 dy 不能同时为 0\n\nvar a = -4\nvar b = 4\ndo {\n    var x = Math.floor(Math.random() * (b - a + 1)) + a\n    var y = Math.floor(Math.random() * (b - a + 1)) + a\n} while (x == 0 && y == 0)\nconsole.log(x, y)\n\n\n\n# 3 种循环对比\n\n\n\n\n# 拓展案例\n\n\n# 累加器累乘器\n\n【某大厂面试题】圆周率 π 可以由下面的莱布尼茨级数公式计算出来，请由用户输入参数 n，计算圆周率 π\n\n// 累加器 就是最后的答案\nvar sum = 0\n// 累乘器，用于制作每一项，制作出来的每一项，往累加器里加\nvar item = 1\nvar lai = function (n) {\n    for (var i = 1; i <= n; i++) {\n        item *= i / (2 * i + 1)\n        sum += item\n    }\n    return (sum + 1) * 2\n}\n\nconsole.log(lai(10000))\n\n\n\n# 穷举法\n\n# 寻找全部的水仙花数\n\n 1. 遍历所有的 3 位数\n 2. 把数字转换为字符串进行拆位，可以利用字符串的方法：charAt()方法\n 3. 利用 if 进行条件匹配，输出结果\n\nfor (var i = 100; i < 1000; i++) {\n    var str = String(i)\n    var g = Number(str.charAt(2)) //个位\n    var s = Number(str.charAt(1))\n    var b = Number(str.charAt(0))\n    if (Math.pow(g, 3) + Math.pow(s, 3) + Math.pow(b, 3) === i) {\n        console.log(i) //153，370，371，407\n    }\n}\n\n\n\n# 循环嵌套\n\n\n\n# 寻找 1-100 的所有质数\n\n质数：只能够被 1 和它本身整除的数字，最小的质数是 2\n\nouter: for (var i = 2; i <= 100; i++) {\n    // 内层循环开始从2开始到小于这个数字的每一个数字都尝试除i，如果能够整除，说明它不是质数，就可以筛选下一个数字了\n    for (var j = 2; j < i; j++) {\n        if (i % j == 0) {\n            // 说明数字i不是质数，因为它找到了除1和它自身之外的约数了，测试下一个数字了\n            // continue表示放弃这个数字，开始迭代下个数字，continue它负责的是它所在的最内层的for循环\n            // 要给外层for循环加上label，然后在continue的后面加上这个label，\n            // 这样就表示立即开始迭代外层for循环的下一个数字了,而不是内层for循环\n            continue outer\n        }\n    }\n\n    // 能够遇见这条语句的数字i，一定是质数，否则就被continue略过了\n    console.log(i)\n}\n\n\n# 鸡兔同笼\n\n假设鸡有 a 只，兔有 b 只\n\nfor (var a = 0; a <= 35; a++) {\n    for (var b = 0; b <= 35; b++) {\n        if (a + b == 35 && 2 * a + 4 * b == 94) {\n            console.log('小鸡有' + a + '只，兔子有' + b + '只')\n        }\n    }\n}\n",normalizedContent:"# 条件语句\n\n\n# if 语句(一般和 else 一起使用)\n\n * 表示如果...就...否则...\n * 在 if 语句中，else 是可以省略的\n\nvar a = 1\nif ((a = 1)) {\n    console.log('a=1')\n}\n\n\n * 如果 if 语句体中只有一行语句，可以省略大括号和换行\n\nif ((a = 1)) console.log('a=1')\n\n\n# if...else...if 多条件分支\n\n\n\n# if 语句的嵌套\n\n\n\nvar price = function (age, day) {\n    var price = 0\n    if (age < 10) {\n        if (day == 0 || day == 6) {\n            price = 210\n        } else {\n            price = 140\n        }\n    } else {\n        if (day == 0 || day == 6) {\n            price = 500\n        } else {\n            price = 300\n        }\n    }\n    return price\n}\nconsole.log(price(10, 1))\n\n\n\n# switch 语句\n\nswitch 语句的用途：当一个变量被分类讨论的情形。\n\n\n\n\n\n * 在 switch()的圆括号中一般是一个变量名，这个变量将被分类讨论\n * case 表示“情况”，它后面没有圆括号，直接跟一个值。程序会依次将 case 后面的值与 switch 圆括号中的值进行全等比对，如果比对相同，则执行这条 case 冒号后面的语句。\n * default 表示默认情况。\n * 多条 case 可以共用同一个语句体。\n * switch 语句并不像 if 语句那样当执行了某一个分支之后会自动跳出 if 语句体，程序员必须主动调用 break 来跳出 switch 语句体。如果不书写 break，则后面的所有 case 都将被视为匹配，直到遇见 break。\n\n\n\n\n# 三元运算符\n\n条件表达式？表达式 1：表达式 2\n\n问号前面是判断的条件，问号后面用冒号隔开两个表达式。当条件表达式为真时调用表达式 1，为假时调用表达式 2。\n\n三元运算符的用途：根据某个条件是否成立，在两个不同值中选择变量的值\n\nvar age = 18\nvar res = age >= 18 ? '成年人' : '未成年人'\nconsole.log(res) // 成年人\n\n\n\n# 循环语句\n\n\n# for\n\n# for 语句的执行机理\n\n\n\nfor 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。\n\nfor (let i = 0; i < 3; i++) {\n    let i = 'abc'\n    console.log(i)\n}\n// abc\n// abc\n// abc\n\n\n上面代码正确运行，输出了 3 次 abc。这表明函数内部的变量 i 与循环变量 i 不在同一个作用域，有各自单独的作用域（同一个作用域不可使用  let  重复声明同一个变量）。\n\n# for 循环的高级用法\n\n语法：label : statement\n\n①label 表示标签名\n\n②statement 表示代码块\n\n③label 标签名与 statement 表示代码块之间使用英文状态下的冒号分隔\n\n定义的标签可以在将来由 break 或 continue 语句引用。\n\nvar num = 0\nouternum: for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n        if (i == 5 && j == 5) {\n            break outernum\n        }\n        num++\n    }\n}\nalert(num) //55\n\n\n在这个例子中，outernum 标签表示外部的 for 语句。如果每个循环正常执行 10 次，则 num++语句就会正常执行 100 次。换句话说，如果两个循环都自然结束，num 的值应该是 100。但内部循环中的 break 语句带了一个参数（outernum 标签）。添加这个标签的结果将导致 break 语句不仅会退出内部的 for 语句（即使用变量 j 的循环），而且也会退出外部的 for 语句（即使用变量 i 的循环）。为此，当变量 i 和 j 都等于 5 时，num 的值正好是 55。同样，continue 语句也可以像这样与 1abel 语句联用，如下面的例子所示：\n\nvar num = 0\nouternum: for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n        if (i == 5 && j == 5) {\n            continue outernum\n        }\n        num++\n    }\n}\nalert(num) //95\n\n\n在这种情况下，continue 语句会强制继续执行循环，即退出内部循环，执行外部循环。当 j 是 5 时，continue 语句执行，而这也就意味着内部循环少执行了 5 次，因此 num 的结果是 95。\n\n\n# while\n\n * while 语句，是一种“不定范围”循环.\n * while 语句事先不指定循环开始、结束的范围，只要测试条件满足，就一直执行循环体\n * while 循环没有显式定义循环变量，必须自己在 while 循环外先定义好循环变量，有时甚至可以没有循环变量。\n\nvar n = 1\nvar result = 0\nwhile (n <= 100) {\n    result += n\n    n++\n}\nconsole.log(result) // 输出1到100的和\n\n\n * 循环体内的语句，必须使循环测试条件趋向不成立，否则会死循环\n * 一定要注意“出一”错误 小兔子拔萝卜，第 1 天拔 1 个，第 2 天拔 2 个，第 3 天拔 3 个问：第几天能拔光 500 个萝卜？\n\nvar sum = 0\nwhile (sum < 500) {\n    sum += n // 32天的时候已经拔了超过500个萝卜\n    n++ // 但是这条语句还会执行，导致出一错误\n}\nconsole.log(n - 1) // 所以最好要减一\n\n\n\n# break,continue\n\n * break 表示立即终止循环，它只能用在循环语句中，在 for 循环和 while 循环中都可以使用\n * break 用在 while 语句中，通常和 while（true）{}搭配使用\n   \n   > while(true){}是一个死循环，通过 break 可以让它终止循环。\n\n * continue 用于跳过循环中的一个迭代，并继续执行循环中的下一个迭代。\n\n\n# do...while\n\n * do while 循环是一种“后测试循环语句”。它不同于 for 循环和 while 循环每次都是“先测试条件是否满足，然后执行循环体″，do- while 循环是“先执行循环体，然后测试条件是否满足\n\n\n\n * do- while 循环将循环执行条件写到了循环体的后面，这样一来，循环体一定会至少执行一次，然后再检测循环执行条件是否为 true，决定是否继续执行循环体。\n\nvar i = 11\ndo {\n    console.log(i)\n    i++\n} while (i <= 10)\n\n\n# 随机数函数\n\nparseint 是用于字符串，而不是用于数字\n\njs 生成[n,m]的随机数\n\nmath.random()返回介于 0（包含） ~ 1（不包含） 之间的一个随机数\n\n如果想要得到[a,b]区间的整数，公式\n\n// 这里也可以使用math.trunc()\nmath.floor(math.random() * (b - a + 1)) + a\n\n\neg：请编写程序，随机生成两个变量 dx 和 dy，它们均在【-4,4】 区间随机取值，但要求 dx 和 dy 不能同时为 0\n\nvar a = -4\nvar b = 4\ndo {\n    var x = math.floor(math.random() * (b - a + 1)) + a\n    var y = math.floor(math.random() * (b - a + 1)) + a\n} while (x == 0 && y == 0)\nconsole.log(x, y)\n\n\n\n# 3 种循环对比\n\n\n\n\n# 拓展案例\n\n\n# 累加器累乘器\n\n【某大厂面试题】圆周率 π 可以由下面的莱布尼茨级数公式计算出来，请由用户输入参数 n，计算圆周率 π\n\n// 累加器 就是最后的答案\nvar sum = 0\n// 累乘器，用于制作每一项，制作出来的每一项，往累加器里加\nvar item = 1\nvar lai = function (n) {\n    for (var i = 1; i <= n; i++) {\n        item *= i / (2 * i + 1)\n        sum += item\n    }\n    return (sum + 1) * 2\n}\n\nconsole.log(lai(10000))\n\n\n\n# 穷举法\n\n# 寻找全部的水仙花数\n\n 1. 遍历所有的 3 位数\n 2. 把数字转换为字符串进行拆位，可以利用字符串的方法：charat()方法\n 3. 利用 if 进行条件匹配，输出结果\n\nfor (var i = 100; i < 1000; i++) {\n    var str = string(i)\n    var g = number(str.charat(2)) //个位\n    var s = number(str.charat(1))\n    var b = number(str.charat(0))\n    if (math.pow(g, 3) + math.pow(s, 3) + math.pow(b, 3) === i) {\n        console.log(i) //153，370，371，407\n    }\n}\n\n\n\n# 循环嵌套\n\n\n\n# 寻找 1-100 的所有质数\n\n质数：只能够被 1 和它本身整除的数字，最小的质数是 2\n\nouter: for (var i = 2; i <= 100; i++) {\n    // 内层循环开始从2开始到小于这个数字的每一个数字都尝试除i，如果能够整除，说明它不是质数，就可以筛选下一个数字了\n    for (var j = 2; j < i; j++) {\n        if (i % j == 0) {\n            // 说明数字i不是质数，因为它找到了除1和它自身之外的约数了，测试下一个数字了\n            // continue表示放弃这个数字，开始迭代下个数字，continue它负责的是它所在的最内层的for循环\n            // 要给外层for循环加上label，然后在continue的后面加上这个label，\n            // 这样就表示立即开始迭代外层for循环的下一个数字了,而不是内层for循环\n            continue outer\n        }\n    }\n\n    // 能够遇见这条语句的数字i，一定是质数，否则就被continue略过了\n    console.log(i)\n}\n\n\n# 鸡兔同笼\n\n假设鸡有 a 只，兔有 b 只\n\nfor (var a = 0; a <= 35; a++) {\n    for (var b = 0; b <= 35; b++) {\n        if (a + b == 35 && 2 * a + 4 * b == 94) {\n            console.log('小鸡有' + a + '只，兔子有' + b + '只')\n        }\n    }\n}\n",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"面向对象",frontmatter:{title:"面向对象",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"前端开发/JavaScript/JS设计模式/面向对象.md",key:"v-0267583d",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"深入理解javascript原型和闭包",frontmatter:{title:"深入理解javascript原型和闭包",sidebarDepth:2,readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85.html",relativePath:"前端开发/JavaScript/深入理解javascript原型和闭包.md",key:"v-58f9bc27",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85.html",headers:[{level:2,title:"一切都是对象",slug:"一切都是对象",normalizedTitle:"一切都是对象",charIndex:2},{level:2,title:"函数和对象的关系",slug:"函数和对象的关系",normalizedTitle:"函数和对象的关系",charIndex:2044},{level:2,title:"prototype 原型",slug:"prototype-原型",normalizedTitle:"prototype 原型",charIndex:2943},{level:2,title:"隐式原型",slug:"隐式原型",normalizedTitle:"隐式原型",charIndex:3874},{level:2,title:"instanceof",slug:"instanceof",normalizedTitle:"instanceof",charIndex:760},{level:2,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:6239},{level:2,title:"原型的灵活性",slug:"原型的灵活性",normalizedTitle:"原型的灵活性",charIndex:7439},{level:2,title:"简述【执行上下文】上",slug:"简述【执行上下文】上",normalizedTitle:"简述【执行上下文】上",charIndex:8050},{level:2,title:"简述【执行上下文】下",slug:"简述【执行上下文】下",normalizedTitle:"简述【执行上下文】下",charIndex:9342},{level:2,title:"this",slug:"this",normalizedTitle:"this",charIndex:1184},{level:3,title:"情况 1：构造函数",slug:"情况-1-构造函数",normalizedTitle:"情况 1：构造函数",charIndex:10266},{level:3,title:"情况 2：函数作为对象的一个属性",slug:"情况-2-函数作为对象的一个属性",normalizedTitle:"情况 2：函数作为对象的一个属性",charIndex:10574},{level:3,title:"情况 3：函数用 call 或者 apply 调用",slug:"情况-3-函数用-call-或者-apply-调用",normalizedTitle:"情况 3：函数用 call 或者 apply 调用",charIndex:10832},{level:3,title:"情况 4 全局 & 调用普通函数",slug:"情况-4-全局-调用普通函数",normalizedTitle:"情况 4 全局 &amp; 调用普通函数",charIndex:null},{level:3,title:"补充",slug:"补充",normalizedTitle:"补充",charIndex:11131},{level:2,title:"执行上下文栈",slug:"执行上下文栈",normalizedTitle:"执行上下文栈",charIndex:9934},{level:2,title:"简介【作用域】",slug:"简介【作用域】",normalizedTitle:"简介【作用域】",charIndex:12120},{level:2,title:"【作用域】和【上下文环境】",slug:"【作用域】和【上下文环境】",normalizedTitle:"【作用域】和【上下文环境】",charIndex:12750},{level:2,title:"从【自由变量】到【作用域链】",slug:"从【自由变量】到【作用域链】",normalizedTitle:"从【自由变量】到【作用域链】",charIndex:13619},{level:2,title:"闭包",slug:"闭包",normalizedTitle:"闭包",charIndex:12088},{level:3,title:"第一，函数作为返回值",slug:"第一-函数作为返回值",normalizedTitle:"第一，函数作为返回值",charIndex:14740},{level:3,title:"第二，函数作为参数被传递",slug:"第二-函数作为参数被传递",normalizedTitle:"第二，函数作为参数被传递",charIndex:14836},{level:2,title:"补充：上下文环境和作用域的关系",slug:"补充-上下文环境和作用域的关系",normalizedTitle:"补充：上下文环境和作用域的关系",charIndex:16131}],headersStr:"一切都是对象 函数和对象的关系 prototype 原型 隐式原型 instanceof 继承 原型的灵活性 简述【执行上下文】上 简述【执行上下文】下 this 情况 1：构造函数 情况 2：函数作为对象的一个属性 情况 3：函数用 call 或者 apply 调用 情况 4 全局 & 调用普通函数 补充 执行上下文栈 简介【作用域】 【作用域】和【上下文环境】 从【自由变量】到【作用域链】 闭包 第一，函数作为返回值 第二，函数作为参数被传递 补充：上下文环境和作用域的关系",content:"# 一切都是对象\n\n“一切都是对象”这句话的重点在于如何去理解“对象”这个概念。\n\n——当然，也不是所有的都是对象，值类型就不是对象。\n\n首先咱们还是先看看 javascript 中一个常用的运算符——typeof。typeof 应该算是咱们的老朋友，还有谁没用过它？\n\ntypeof 函数输出的一共有几种类型，在此列出：\n\nfunction show(x) {\n    console.log(typeof x) // undefined\n    console.log(typeof 10) // number\n    console.log(typeof 'abc') // string\n    console.log(typeof true) // boolean\n\n    console.log(typeof function () {}) //function\n\n    console.log(typeof [1, 'a', true]) //object\n    console.log(typeof { a: 10, b: 20 }) //object\n    console.log(typeof null) //object\n    console.log(typeof new Number(10)) //object\n}\nshow()\n\n\n以上代码列出了 typeof 输出的结果，其中上面的四种（undefined, number, string, boolean）属于简单的值类型，不是对象。剩下的几种情况——函数、数组、对象、null、new Number(10)都是对象。他们都是引用类型。\n\n判断一个变量是不是对象非常简单。值类型的类型判断用 typeof，引用类型的类型判断用 instanceof。\n\nvar fn = function () {}\nconsole.log(fn instanceof Object) // true\n\n\n那么在 javascript 中的对象，到底该如何定义呢？\n\n对象——若干属性的集合。\n\njava 或者 C#中的对象都是 new 一个 class 出来的，而且里面有字段、属性、方法，规定的非常严格。但是 javascript 就比较随意了——数组是对象，函数是对象，对象还是对象。对象里面的一切都是属性，只有属性，没有方法。那么这样方法如何表示呢？——方法也是一种属性。因为它的属性表示为键值对的形式。\n\n而且，更加好玩的事，javascript 中的对象可以任意的扩展属性，没有 class 的约束。这个大家应该都知道，就不再强调了。\n\n先说个最常见的例子：\n\nvar obj = {\n    a: 10,\n    b: function (x) {\n        alert(this.a + x)\n    },\n    c: {\n        name: 'alex',\n        year: 1999,\n    },\n}\n\n\n以上代码中，obj 是一个自定义的对象，其中 a、b、c 就是它的属性，而且在 c 的属性值还是一个对象，它又有 name、year 两个属性。\n\n这个可能比较好理解，那么函数和数组也可以这样定义属性吗？——当然不行，但是它可以用另一种形式，总之函数/数组之流，只要是对象，它就是属性的集合。\n\n以函数为例子：\n\nvar fn = function () {\n    alert(100)\n}\nfn.a = 10\nfn.b = function () {\n    alert(123)\n}\nfn.c = {\n    name: '王福朋',\n    year: 1988,\n}\n\n\n上段代码中，函数就作为对象被赋值了 a、b、c 三个属性——很明显，这就是属性的集合吗。\n\n你问：这个有用吗？\n\n回答：可以看看 jQuery 源码！\n\n在 jQuery 源码中，“jQuery”或者“$”，这个变量其实是一个函数，不信你可以叫咱们的老朋友 typeof 验证一下。\n\nconsole.log(typeof $) // function\nconsole.log($.trim(' ABC '))\n\n\n验明正身！的确是个函数。那么咱们常用的 $.trim() 也是个函数，经常用，就不用验了吧！\n\n很明显，这就是在$或者 jQuery 函数上加了一个 trim 属性，属性值是函数，作用是截取前后空格。\n\n其次要解释的就是本文的内容 —— 一切（引用类型）都是对象，对象是属性的集合。 最需要了解的就是对象的概念，和 java/C#完全不一样。所以，切记切记\n\n最后，有个疑问。在 typeof 的输出类型中，function 和 object 都是对象，为何却要输出两种答案呢？都叫做 object 不行吗？——当然不行。\n\n具体原因，且听下回分解！\n\n\n# 函数和对象的关系\n\n上文 (一切都是对象)已经提到，函数就是对象的一种，因为通过 instanceof 函数可以判断。\n\nvar fn = function () {}\nconsole.log(fn instanceof Object) // true\n\n\n函数是一种对象，但是函数却不像数组一样——你可以说数组是对象的一种，因为数组就像是对象的一个子集一样。但是函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑，咱们这一节就缕一缕。\n\nfunction Fn() {\n    this.name = '王福朋'\n    this.year = 1988\n}\nvar fn1 = new Fn()\n\n\n上面的这个例子很简单，它能说明：对象可以通过函数来创建 对！也只能说明这一点。\n\n但是我要说——对象都是通过函数创建的——有些人可能反驳：不对！因为：\n\nvar obj = { a: 10, b: 20 }\nvar arr = [5, 'x', true]\n\n\n但是不好意思，这个——真的只是一种——“快捷方式”，在编程语言中，一般叫做“语法糖”。\n\n其实以上代码的本质是：\n\n//var obj = { a: 10, b: 20 };\n//var arr = [5, 'x', true];\n\nvar obj = new Object()\nobj.a = 10\nobj.b = 20\n\nvar arr = new Array()\narr[0] = 5\narr[1] = 'x'\narr[2] = true\n\n\n而其中的 Object 和 Array 都是函数：\n\nconsole.log(typeof Object) // function\nconsole.log(typeof Array) // function\n\n\n所以，可以很负责任的说——对象都是通过函数来创建的。\n\n现在是不是糊涂了—— 对象是函数创建的，而函数却又是一种对象——天哪！函数和对象到底是什么关系啊？\n\n别着急！揭开这个谜底，还得先去了解一下另一位老朋友——prototype 原型。\n\n\n# prototype 原型\n\n在咱们的第一节中说道,函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性。\n\n不用等咱们去试验，javascript 自己就先做了表率，人家就默认的给函数一个属性——prototype。对，每个函数都有一个属性叫做 prototype。\n\n这个 prototype 的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。\n\n\n\n如上图，SuperType 是是一个函数，右侧的方框就是它的原型。\n\n原型既然作为对象，属性的集合，不可能就只弄个 constructor 来玩玩，肯定可以自定义的增加许多属性。例如这位 Object 大哥，人家的 prototype 里面，就有好几个其他属性。\n\n\n\n咦，有些方法怎么似曾相似？\n\n对！别着急，之后会让你知道他们为何似曾相识。\n\n接着往下说，你也可以在自己自定义的函数的 prototype 中新增自己的属性\n\nfunction Fn() {}\nFn.prototype.name = '王福朋'\nFn.prototype.getYear = function () {\n    return 1988\n}\n\n\n看到没有，这样就变成了\n\n\n\n但是，这样做有何用呢？如果用咱们自己的代码来演示，就是这样\n\nfunction Fn() {}\nFn.prototype.name = '王福朋'\nFn.prototype.getYear = function () {\n    return 1988\n}\n\nvar fn = new Fn()\nconsole.log(fn.name)\nconsole.log(fn.getYear())\n\n\n即，Fn 是一个函数，fn 对象是从 Fn 函数 new 出来的，这样 fn 对象就可以调用 Fn.prototype 中的属性。\n\n因为每个对象都有一个隐藏的属性——__proto__，这个属性引用了创建这个对象的函数的 prototype。即：fn.__proto__ === Fn.prototype\n\n这里的\"__proto__\"称为“隐式原型”，下回继续分解。\n\n\n# 隐式原型\n\n上节已经提到，每个函数 function 都有一个 prototype，即原型。这里再加一句话——每个对象都有一个__proto__，可称为隐式原型。\n\n这个__proto__是一个隐藏的属性，javascript 不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。所以你在 Visual Studio 2012 这样很高级很智能的编辑器中，都不会有__proto__的智能提示，但是你不用管它，直接写出来就是了。\n\n\n\n上面截图看来，obj.proto和 Object.prototype 的属性一样！这么巧！\n\n答案就是一样。\n\nobj 这个对象本质上是被 Object 函数创建的，因此obj.__proto__=== Object.prototype。我们可以用一个图来表示。\n\n\n\n那么上图中的“Object.prototype”也是一个对象，它的__proto__指向哪里？\n\n好问题！\n\n在说明“Object.prototype”之前，先说一下自定义函数的 prototype。自定义函数的 prototype 本质上就是和 var obj = {} 是一样的，都是被 Object 创建，所以它的__proto__指向的就是 Object.prototype。\n\n但是 Object.prototype 却是一个特例——它的proto指向的是 null，切记切记！\n\n> 批注：这就是原型链的终点\n\n\n\n还有——函数也是一种对象，函数也有__proto__吗？\n\n又一个好问题！——当然有。\n\n函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？——Function——注意这个大写的“F”。\n\n且看如下代码。\n\n\n\n以上代码中，第一种方式是比较传统的函数创建方式，第二种是用 new Functoin 创建。\n\n首先根本不推荐用第二种方式。\n\n这里只是向大家演示，函数是被 Function 创建的。\n\n好了，根据上面说的一句话——对象的__proto__指向的是创建它的函数的 prototype，就会出现：Object.__proto__=== Function.prototype。用一个图来表示。\n\n\n\n上图中，很明显的标出了：自定义函数Foo.__proto__指向Function.prototype，Object.__proto__指向Function.prototype，唉，怎么还有一个 Function.proto指向 Function.prototype？这不成了循环引用了？\n\n对！是一个环形结构。\n\n其实稍微想一下就明白了。Function 也是一个函数，函数是一种对象，也有__proto__属性。既然是函数，那么它一定是被 Function 创建。所以——Function 是被自身创建的。所以它的__proto__指向了自身的 Prototype。\n\n最后一个问题：Function.prototype 指向的对象，它的__proto__是不是也指向 Object.prototype？\n\n答案是肯定的。因为 Function.prototype 指向的对象也是一个普通的被 Object 创建的对象，所以也遵循基本的规则。\n\n\n\n\n# instanceof\n\n> instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。\n\nobject instanceof constructor //object 某个实例对象;constructor 某个构造函数\n\n\n又介绍一个老朋友——instanceof。\n\n对于值类型，你可以通过 typeof 判断，string/number/boolean 都很清楚，但是 typeof 在判断到引用类型的时候，返回值只有 object/function，你不知道它到底是一个 object 对象，还是数组，还是 new Number 等等。\n\n这个时候就需要用到 instanceof。例如：\n\n\n\n上图中，f1 这个对象是被 Foo 创建，但是“f1 instanceof Object”为什么是 true 呢？\n\n至于为什么过会儿再说，先把 instanceof 判断的规则告诉大家。根据以上代码看下图：\n\n\n\ninstanceof 运算符的第一个变量是一个对象，暂时称为 A；第二个变量一般是一个函数，暂时称为 B。\n\ninstanceof 的判断规则是：沿着 A 的proto这条线来找，同时沿着 B 的 prototype 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回 true。如果找到终点还未重合，则返回 false。\n\n按照以上规则，大家看看“ f1 instanceof Object ”这句代码是不是 true？ 根据上图很容易就能看出来，就是 true。\n\n通过上以规则，你可以解释很多比较怪异的现象，例如\n\n\n\n这些看似很混乱的东西，答案却都是 true，这是为何？\n\n正好，这里也接上了咱们上一节说的“乱”。\n\n上一节咱们贴了好多的图片，其实那些图片是可以联合成一个整体的，即：\n\n\n\n看这个图片，千万不要嫌烦，必须一条线一条线挨着分析。如果上一节你看的比较仔细，再结合刚才咱们介绍的 instanceof 的概念，相信能看懂这个图片的内容。\n\n看看这个图片，你也就知道为何上面三个看似混乱的语句返回的是 true 了。\n\n问题又出来了。instanceof 这样设计，到底有什么用？到底 instanceof 想表达什么呢？\n\n重点就这样被这位老朋友给引出来了——继承——原型链。\n\n即，instanceof 表示的就是一种继承关系，或者原型链的结构。请看下节分解。\n\n\n# 继承\n\n为何用“继承”为标题，而不用“原型链”？\n\n原型链如果解释清楚了很容易理解，不会与常用的 java/C#产生混淆。而“继承”却是常用面向对象语言中最基本的概念，但是 java 中的继承与 javascript 中的继承又完全是两回事儿。因此，这里把“继承”着重拿出来，就为了体现这个不同。\n\njavascript 中的继承是通过原型链来体现的。先看几句代码\n\n\n\n以上代码中，f1 是 Foo 函数 new 出来的对象，f1.a 是 f1 对象的基本属性，f1.b 是怎么来的呢？——从 Foo.prototype 得来，因为 f1.proto指向的是 Foo.prototype\n\n访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。\n\n看图说话：\n\n\n\n上图中，访问 f1.b 时，f1 的基本属性中没有 b，于是沿着proto找到了 Foo.prototype.b。\n\n那么我们在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？大家可能都知道答案了——hasOwnProperty，特别是在 for…in…循环中，一定要注意。\n\n\n\n等等，不对！ f1 的这个 hasOwnProperty 方法是从哪里来的？ f1 本身没有，Foo.prototype 中也没有，哪儿来的？\n\n好问题。\n\n它是从 Object.prototype 中来的，请看图：\n\n\n\n对象的原型链是沿着__proto__这条线走的，因此在查找 f1.hasOwnProperty 属性时，就会顺着原型链一直查找到 Object.prototype。\n\n由于所有的对象的原型链都会找到 Object.prototype，因此所有的对象都会有 Object.prototype 的方法。这就是所谓的“继承”。\n\n当然这只是一个例子，你可以自定义函数和对象来实现自己的继承。\n\n说一个函数的例子吧。\n\n我们都知道每个函数都有 call，apply 方法，都有 length，arguments，caller 等属性。为什么每个函数都有？这肯定是“继承”的。函数由 Function 函数创建，因此继承的是 Function.prototype 中的方法。不信可以，我们验证一下：\n\n\n\n看到了吧，有 call、length 等这些属性。\n\n那怎么还有 hasOwnProperty 呢？——那是 Function.prototype 继承自 Object.prototype 的方法。有疑问可以看看上一节将 instanceof 时候那个大图，看看Function.prototype.proto是否指向 Object.prototype。\n\n\n# 原型的灵活性\n\n在 Java 和 C#中，你可以简单的理解 class 是一个模子，对象就是被这个模子压出来的一批一批月饼（中秋节刚过完）。压个啥样，就得是个啥样，不能随便动，动一动就坏了。\n\n而在 javascript 中，就没有模子了，月饼被换成了面团，你可以捏成自己想要的样子。\n\n首先，对象属性可以随时改动。\n\n对象或者函数，刚开始 new 出来之后，可能啥属性都没有。但是你可以这会儿加一个，过一会儿在加两个，非常灵活。\n\n其次，如果继承的方法不合适，可以做出修改。\n\n\n\n如上图，Object 和 Array 的 toString()方法不一样。肯定是 Array.prototype.toString()方法做了修改。\n\n同理，我也可以自定义一个函数，并自己去修改 prototype.toString()方法。\n\n\n\n最后，如果感觉当前缺少你要用的方法，可以自己去创建 => (内置对象添加原型的方法(属性))\n\n//在字符串中添加一个倒序字符串的方法\nString.prototype.myReverse = function () {\n    for (var i = this.length - 1; i >= 0; i--) {\n        console.log(this[i])\n    }\n}\nvar str = 'abcd'\nstr.myReverse() //'dcba'\n\n\n\n# 简述【执行上下文】上\n\n什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码：\n\n\n\n第一句报错，a 未定义，很正常。第二句、第三句输出都是 undefined，说明浏览器在执行 console.log(a)时，已经知道了 a 是 undefined，但却不知道 a 是 10（第三句中）。\n\n在一段 js 代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟：\n\n\n\n下面还有。先来个简单的。\n\n\n\n有 js 开发经验的朋友应该都知道，你无论在哪个位置获取 this，都是有值的。至于 this 的取值情况，比较复杂，会专门拿出一篇文章来讲解。\n\n与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给 this 赋值。这也是“准备工作”情况要做的事情之一。\n\n下面还有。。。第三种情况。\n\n在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。\n\n\n\n看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。\n\n没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。\n\n好了，“准备工作”介绍完毕。\n\n我们总结一下，在“准备工作”中完成了哪些工作：\n\n * 变量、函数表达式——变量声明，默认赋值为 undefined；\n * this——赋值；\n * 函数声明——赋值；\n\n这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。\n\n> 这里插一句题外话：通过以上三种情况，你可能会联想到网上的有些考 js 语法的题目/面试题。的确，几乎每个 js 语法题中都有这种题目出现。之前你遇到这种题目是不是靠背诵来解决？背过了，隔几天又忘记了。——任何问题，都要去追根溯源，要知道这个问题是真正出自哪一块知识点，要真正去理解。光靠背诵是没用的。\n\n细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。\n\n其实，javascript 在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval 代码。\n\n这里解释一下为什么代码段分为这三种。\n\n所谓“代码段”就是一段文本形式的代码。\n\n首先，全局代码是一种，这个应该没有非议，本来就是手写文本到 script 标签里面的。\n\n其次，eval 代码接收的也是一段文本形式的代码。\n\n\n\n\n\n最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。\n\n\n\n这样解释应该能理解了。\n\n最后，eval 不常用，也不推荐大家用。\n\n下一节我们介绍函数的情况，并一起总结一下执行上下文到底包含哪些内容。敬请期待。\n\n\n# 简述【执行上下文】下\n\n上一篇我们讲到在全局环境下的代码段中，执行上下文环境中有如何数据：\n\n * 变量、函数表达式——变量声明，默认赋值为 undefined；\n * this——赋值；\n * 函数声明——赋值；\n\n如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码：\n\n\n\n以上代码展示了在函数体的语句执行之前，arguments 变量和函数的参数都已经被赋值。从这里可以看出，函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数。\n\n另外一点不同在于，函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。至于“自由变量”和“作用域”是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下：\n\n\n\n全局代码的上下文环境数据内容为：\n\n\n\n如果代码段是函数体，那么在此基础上需要附加：\n\n\n\n给执行上下文环境下一个通俗的定义——在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用 undefined 占个空。\n\n了解了执行上下文环境中的数据信息，你就不用再去死记硬背那些可恶的面试题了。理解了就不用背诵！\n\n讲完了上下文环境，又来了新的问题——在执行 js 代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？ 通过“执行上下文栈”来解释这个问题。\n\n不过别着急，在解释“执行上下文栈”之前，还需要把 this 说一下，this 还是挺重要的。\n\n说完 this，接着说执行上下文栈。\n\n\n# this\n\n接着上一节讲的话，应该轮到“执行上下文栈”了，但是这里不得不插入一节，把 this 说一下。因为 this 很重要，js 的面试题如果不出几个与 this 有关的，那出题者都不合格。\n\n其实，this 的取值，分四种情况。我们来挨个看一下。\n\n在此再强调一遍一个非常重要的知识点：在函数中 this 到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为 this 的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。\n\n\n# 情况 1：构造函数\n\n所谓构造函数就是用来 new 对象的函数。其实严格来说，所有的函数都可以 new 一个对象，但是有些函数的定义是为了 new 一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function 等。\n\n\n\n以上代码中，如果函数作为构造函数用，那么其中的 this 就代表它即将 new 出来的对象。\n\n注意，以上仅限 new Foo()的情况，即 Foo 函数作为构造函数的情况。如果直接调用 Foo 函数，而不是 new Foo()，情况就大不一样了。\n\n\n\n这种情况下 this 是 window，我们后文中会说到。\n\n\n# 情况 2：函数作为对象的一个属性\n\n如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的 this 指向该对象。\n\n\n\n以上代码中，fn 不仅作为一个对象的一个属性，而且的确是作为对象的一个属性被调用。结果 this 就是 obj 对象。\n\n注意，如果 fn 函数不作为 obj 的一个属性被调用，会是什么结果呢？\n\n\n\n如上代码，如果 fn 函数被赋值到了另一个变量中，并没有作为 obj 的一个属性被调用，那么 this 的值就是 window，this.x 为 undefined。\n\n\n# 情况 3：函数用 call 或者 apply 调用\n\n当一个函数被 call 和 apply 调用时，this 的值就取传入的对象的值。\n\n\n\n\n# 情况 4 全局 & 调用普通函数\n\n> 非严格模式下!\n\n在全局环境下，this 永远是 window，这个应该没有非议。\n\nconsole.log(this === window) // true\n\n\n普通函数在调用时，其中的 this 也都是 window。\n\n\n\n以上代码很好理解。\n\n不过下面的情况你需要注意一下：\n\n\n\n函数 f 虽然是在 obj.fn 内部定义的，但是它仍然是一个普通的函数，this 仍然指向 window。\n\n\n# 补充\n\n原文中 this 的其中一种情况是构造函数的，具体的内容可以参考原文，此处不再赘述。\n\n要补充的内容是，在构造函数的 prototype 中，this 代表着什么。\n\n\n\n如上代码，在 Fn.prototype.getName 函数中，this 指向的是 f1 对象。因此可以通过 this.name 获取 f1.name 的值。\n\n其实，不仅仅是构造函数的 prototype，即便是在整个原型链中，this 代表的也都是当前对象的值。\n\n\n# 执行上下文栈\n\n执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。\n\n其实这是一个压栈出栈的过程——执行上下文栈。如下图：\n\n\n\n可根据以下代码来详细介绍上下文栈的压栈、出栈过程。\n\n\n\n如上代码。\n\n在执行代码之前，首先将创建全局上下文环境。\n\n\n\n然后是代码执行。代码执行到第 12 行之前，上下文环境中的变量都在执行过程中被赋值。\n\n\n\n执行到第 13 行，调用 bar 函数。\n\n跳转到 bar 函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。\n\n\n\n并将这个执行上下文环境压栈，设置为活动状态。\n\n\n\n执行到第 5 行，又调用了 fn 函数。进入 fn 函数，在执行函数体语句之前，会创建 fn 函数的执行上下文环境，并压栈，设置为活动状态。\n\n\n\n待第 5 行执行完毕，即 fn 函数执行完毕后，此次调用 fn 所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。\n\n\n\n同理，待第 13 行执行完毕，即 bar 函数执行完毕后，调用 bar 函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。\n\n\n\n好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。\n\n讲到这里，我不得不很遗憾的跟大家说：其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。\n\n要说闭包，咱们还得先从自由变量和作用域说起。\n\n\n# 简介【作用域】\n\n> 特别注意：es6 已加入块作用域\n\n提到作用域，有一句话大家（有 js 开发经验者）可能比较熟悉：“javascript 没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如 if 语句：\n\n\n\n再比如 for 语句：\n\n\n\n所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义。如：\n\n\n\n其实，你光知道“javascript 没有块级作用域”是完全不够的，你需要知道的是——javascript 除了全局作用域之外，只有函数可以创建的作用域。\n\n> 当然这句话现在来说也是错误的，es6 中加入的 let const 会创建块级作用域\n\n所以，我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单 var”形式。\n\n下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘”\n\n\n\n如上图，全局代码和 fn、bar 两个函数都会形成一个作用域。而且，作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。例如，fn 作用域下创建了 bar 函数，那么“fn 作用域”就是“bar 作用域”的上级。\n\n作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。\n\n\n# 【作用域】和【上下文环境】\n\n上文简单介绍了作用域，本文把作用域和上下文环境结合起来说一下，会理解的更深一些。\n\n\n\n如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。\n\n第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。\n\n\n\n第二步，程序执行到第 27 行，调用 fn(10)，此时生成此次调用 fn 函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。\n\n\n\n第三步，执行到第 23 行时，调用 bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。\n\n\n\n第四步，执行完第 23 行，bar(100)调用完成。则 bar(100)上下文环境被销毁。接着执行第 24 行，调用 bar(200)，则又生成 bar(200)的上下文环境，压栈，设置为活动状态。\n\n\n\n第五步，执行完第 24 行，则 bar(200)调用结束，其上下文环境被销毁。此时会回到 fn(10)上下文环境，变为活动状态。\n\n\n\n第六步，执行完第 27 行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。\n\n最后我们可以把以上这几个图片连接起来看看。\n\n\n\n连接起来看，还是挺有意思的。作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。\n\n所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。\n\n虽然本文很长，但是文字较少，图片居多，图片都有形象的展示，大家花十几分钟也能慢慢看完。但是，这节内容真的很重要。\n\n以上代码中，咱们还没有设计到跨作用域取值的情况，即——自由变量。详细内容且听下回分解。\n\n\n# 从【自由变量】到【作用域链】\n\n先解释一下什么是“自由变量”。\n\n在 A 作用域中使用的变量 x，却没有在 A 作用域中声明（即在其他作用域中声明的），对于 A 作用域来说，x 就是一个自由变量。如下图\n\n\n\n如上程序中，在调用 fn()函数时，函数体中第 6 行。取 b 的值就直接可以在 fn 作用域中取，因为 b 就是在这里定义的。而取 x 的值时，就需要到另一个作用域中取。到哪个作用域中取呢？\n\n有人说过要到父作用域中取，其实有时候这种解释会产生歧义。例如：\n\n\n\n所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切——要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记——其实这就是所谓的“静态作用域”。\n\n区分静态（词法）作用域和动态作用域\n\n词法作用域： 在代码书写的时候完成划分，作用域链沿着它定义的位置往外延伸\n\n动态作用域： 在代码运行时完成划分，作用域链沿着它的调用栈往外延伸\n\n对于本文第一段代码，在 fn 函数中，取自由变量 x 的值时，要到哪个作用域中取？——要到创建 fn 函数的那个作用域中取——无论 fn 函数将在哪里调用。\n\n上面描述的只是跨一步作用域去寻找。\n\n如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。\n\n这个一步一步“跨”的路线，我们称之为——作用域链。\n\n我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设 a 是自由变量）\n\n第一步，现在当前作用域查找 a，如果有则获取并结束。如果没有则继续；\n\n第二步，如果当前作用域是全局作用域，则证明 a 未定义，结束；否则继续；\n\n第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；\n\n第四步，跳转到第一步。\n\n\n\n以上代码中：第 13 行，fn()返回的是 bar 函数，赋值给 x。执行 x()，即执行 bar 函数代码。取 b 的值时，直接在 fn 作用域取出。取 a 的值时，试图在 fn 作用域取，但是取不到，只能转向创建 fn 的那个作用域中去查找，结果找到了。\n\n这一节看似很轻松的把作用域链引出来，并讲完了。之所有轻松是有前几节的基础，否则将很难解释。\n\n接下来咱们开始正式说说一直期待依旧的朋友——闭包。敬请期待下一节。\n\n\n# 闭包\n\n前面提到的上下文环境和作用域的知识，除了了解这些知识之外，还是理解闭包的基础。\n\n至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。\n\n但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递。\n\n\n# 第一，函数作为返回值\n\n如上代码，bar 函数作为返回值，赋值给 f1 变量。执行 f1(15)时，用到了 fn 作用域下的 max 变量的值。至于如何跨作用域取值，可以参考上一节。\n\n\n# 第二，函数作为参数被传递\n\n\n\n如上代码中，fn 函数作为一个参数被传递进入另一个函数，赋值给 f 参数。执行 f(15)时，max 变量的取值是 10，而不是 100。\n\n上一节讲到自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。（不明白的朋友一定要去上一节看看，这个很重要！）\n\n另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。\n\n在前面讲执行上下文栈时，我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。\n\n但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。\n\n咱们可以拿本文的第一段代码（稍作修改）来分析一下。\n\n\n\n第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。\n\n\n\n第二步，执行第 17 行代码时，调用 fn()，产生 fn()执行上下文环境，压栈，并设置为活动状态。\n\n\n\n第三步，执行完第 17 行，fn()调用完成。按理说应该销毁掉 fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行 fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量 max 要引用 fn 作用域下的 fn()上下文环境中的 max。因此，这个 max 不能被销毁，销毁了之后 bar 函数中的 max 就找不到值了。\n\n因此，这里的 fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。\n\n——即，执行到第 18 行时，全局上下文环境将变为活动状态，但是 fn()上下文环境依然会在执行上下文栈中。另外，执行完第 18 行，全局上下文环境中的 max 被赋值为 100。如下图：\n\n\n\n第四步，执行到第 20 行，执行 f1(15)，即执行 bar(15)，创建 bar(15)上下文环境，并将其设置为活动状态。\n\n\n\n执行 bar(15)时，max 是自由变量，需要向创建 bar 函数的作用域中查找，找到了 max 的值为 10。这个过程在作用域链一节已经讲过。\n\n这里的重点就在于，创建 bar 函数是在执行 fn()时创建的。fn()早就执行结束了，但是 fn()执行上下文环境还存在与栈中，因此 bar(15)时，max 可以查找到。如果 fn()上下文环境销毁了，那么 max 就找不到了。\n\n使用闭包会增加内容开销，现在很明显了吧！\n\n第五步，执行完 20 行就是上下文环境的销毁过程，这里就不再赘述了。\n\n闭包和作用域、上下文环境有着密不可分的关系，真的是“想说爱你不容易”！\n\n无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了 BUG 你都不知道为什么，因为这些 BUG 可能完全在你的知识范围之外。\n\n\n# 补充：上下文环境和作用域的关系\n\n本系列用了大量的篇幅讲解了上下文环境和作用域，有些人反映这两个是一回儿事。本文就用一个小例子来说明一下，作用域和上下文环境绝对不是一回事儿。\n\n再说明之前，咱们先用简单的语言来概括一下这两个的区别。\n\n 1. 上下文环境：\n\n可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量都在里面存储着，要不然咱们定义的变量在哪里存？\n\n另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数？\n\n 2. 作用域：\n    \n    > 这句话现在看来是错误的\n\n首先，它很抽象。第二，记住一句话：除了全局作用域，只有函数才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域，就有自己的一个“地盘”。\n\n 3. 两者：\n\n一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。\n\n上面的文字不理解没关系，且看下面的例子。\n\n第一，除了全局作用域外，每个函数都要创建一个作用域。作用域之间的变量是相互独立的。因此，全局作用域中的 x 和 fn 作用域中的 x，两者毫无关系，互不影响，和平相处。\n\n\n\n第二，程序执行之前，会生成全局上下文环境，并在程序执行时，对其中的变量赋值。\n\n\n\n第三，程序执行到第 17 行，调用 fn(5)，会产生 fn(5)的上下文环境，并压栈，并设置为活动状态。\n\n\n\n第四，执行完第 17 行，fn(5)的返回值赋值给了 f1。此时执行上下文环境又重新回到全局，但是 fn(5)的上下文环境不能就此销毁，因为其中有闭包的引用（可翻看前面文章，此处不再赘述）。\n\n\n\n转载自\n\n王福朋深入理解 javascript 原型和闭包（完结）",normalizedContent:"# 一切都是对象\n\n“一切都是对象”这句话的重点在于如何去理解“对象”这个概念。\n\n——当然，也不是所有的都是对象，值类型就不是对象。\n\n首先咱们还是先看看 javascript 中一个常用的运算符——typeof。typeof 应该算是咱们的老朋友，还有谁没用过它？\n\ntypeof 函数输出的一共有几种类型，在此列出：\n\nfunction show(x) {\n    console.log(typeof x) // undefined\n    console.log(typeof 10) // number\n    console.log(typeof 'abc') // string\n    console.log(typeof true) // boolean\n\n    console.log(typeof function () {}) //function\n\n    console.log(typeof [1, 'a', true]) //object\n    console.log(typeof { a: 10, b: 20 }) //object\n    console.log(typeof null) //object\n    console.log(typeof new number(10)) //object\n}\nshow()\n\n\n以上代码列出了 typeof 输出的结果，其中上面的四种（undefined, number, string, boolean）属于简单的值类型，不是对象。剩下的几种情况——函数、数组、对象、null、new number(10)都是对象。他们都是引用类型。\n\n判断一个变量是不是对象非常简单。值类型的类型判断用 typeof，引用类型的类型判断用 instanceof。\n\nvar fn = function () {}\nconsole.log(fn instanceof object) // true\n\n\n那么在 javascript 中的对象，到底该如何定义呢？\n\n对象——若干属性的集合。\n\njava 或者 c#中的对象都是 new 一个 class 出来的，而且里面有字段、属性、方法，规定的非常严格。但是 javascript 就比较随意了——数组是对象，函数是对象，对象还是对象。对象里面的一切都是属性，只有属性，没有方法。那么这样方法如何表示呢？——方法也是一种属性。因为它的属性表示为键值对的形式。\n\n而且，更加好玩的事，javascript 中的对象可以任意的扩展属性，没有 class 的约束。这个大家应该都知道，就不再强调了。\n\n先说个最常见的例子：\n\nvar obj = {\n    a: 10,\n    b: function (x) {\n        alert(this.a + x)\n    },\n    c: {\n        name: 'alex',\n        year: 1999,\n    },\n}\n\n\n以上代码中，obj 是一个自定义的对象，其中 a、b、c 就是它的属性，而且在 c 的属性值还是一个对象，它又有 name、year 两个属性。\n\n这个可能比较好理解，那么函数和数组也可以这样定义属性吗？——当然不行，但是它可以用另一种形式，总之函数/数组之流，只要是对象，它就是属性的集合。\n\n以函数为例子：\n\nvar fn = function () {\n    alert(100)\n}\nfn.a = 10\nfn.b = function () {\n    alert(123)\n}\nfn.c = {\n    name: '王福朋',\n    year: 1988,\n}\n\n\n上段代码中，函数就作为对象被赋值了 a、b、c 三个属性——很明显，这就是属性的集合吗。\n\n你问：这个有用吗？\n\n回答：可以看看 jquery 源码！\n\n在 jquery 源码中，“jquery”或者“$”，这个变量其实是一个函数，不信你可以叫咱们的老朋友 typeof 验证一下。\n\nconsole.log(typeof $) // function\nconsole.log($.trim(' abc '))\n\n\n验明正身！的确是个函数。那么咱们常用的 $.trim() 也是个函数，经常用，就不用验了吧！\n\n很明显，这就是在$或者 jquery 函数上加了一个 trim 属性，属性值是函数，作用是截取前后空格。\n\n其次要解释的就是本文的内容 —— 一切（引用类型）都是对象，对象是属性的集合。 最需要了解的就是对象的概念，和 java/c#完全不一样。所以，切记切记\n\n最后，有个疑问。在 typeof 的输出类型中，function 和 object 都是对象，为何却要输出两种答案呢？都叫做 object 不行吗？——当然不行。\n\n具体原因，且听下回分解！\n\n\n# 函数和对象的关系\n\n上文 (一切都是对象)已经提到，函数就是对象的一种，因为通过 instanceof 函数可以判断。\n\nvar fn = function () {}\nconsole.log(fn instanceof object) // true\n\n\n函数是一种对象，但是函数却不像数组一样——你可以说数组是对象的一种，因为数组就像是对象的一个子集一样。但是函数与对象之间，却不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑，咱们这一节就缕一缕。\n\nfunction fn() {\n    this.name = '王福朋'\n    this.year = 1988\n}\nvar fn1 = new fn()\n\n\n上面的这个例子很简单，它能说明：对象可以通过函数来创建 对！也只能说明这一点。\n\n但是我要说——对象都是通过函数创建的——有些人可能反驳：不对！因为：\n\nvar obj = { a: 10, b: 20 }\nvar arr = [5, 'x', true]\n\n\n但是不好意思，这个——真的只是一种——“快捷方式”，在编程语言中，一般叫做“语法糖”。\n\n其实以上代码的本质是：\n\n//var obj = { a: 10, b: 20 };\n//var arr = [5, 'x', true];\n\nvar obj = new object()\nobj.a = 10\nobj.b = 20\n\nvar arr = new array()\narr[0] = 5\narr[1] = 'x'\narr[2] = true\n\n\n而其中的 object 和 array 都是函数：\n\nconsole.log(typeof object) // function\nconsole.log(typeof array) // function\n\n\n所以，可以很负责任的说——对象都是通过函数来创建的。\n\n现在是不是糊涂了—— 对象是函数创建的，而函数却又是一种对象——天哪！函数和对象到底是什么关系啊？\n\n别着急！揭开这个谜底，还得先去了解一下另一位老朋友——prototype 原型。\n\n\n# prototype 原型\n\n在咱们的第一节中说道,函数也是一种对象。他也是属性的集合，你也可以对函数进行自定义属性。\n\n不用等咱们去试验，javascript 自己就先做了表率，人家就默认的给函数一个属性——prototype。对，每个函数都有一个属性叫做 prototype。\n\n这个 prototype 的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。\n\n\n\n如上图，supertype 是是一个函数，右侧的方框就是它的原型。\n\n原型既然作为对象，属性的集合，不可能就只弄个 constructor 来玩玩，肯定可以自定义的增加许多属性。例如这位 object 大哥，人家的 prototype 里面，就有好几个其他属性。\n\n\n\n咦，有些方法怎么似曾相似？\n\n对！别着急，之后会让你知道他们为何似曾相识。\n\n接着往下说，你也可以在自己自定义的函数的 prototype 中新增自己的属性\n\nfunction fn() {}\nfn.prototype.name = '王福朋'\nfn.prototype.getyear = function () {\n    return 1988\n}\n\n\n看到没有，这样就变成了\n\n\n\n但是，这样做有何用呢？如果用咱们自己的代码来演示，就是这样\n\nfunction fn() {}\nfn.prototype.name = '王福朋'\nfn.prototype.getyear = function () {\n    return 1988\n}\n\nvar fn = new fn()\nconsole.log(fn.name)\nconsole.log(fn.getyear())\n\n\n即，fn 是一个函数，fn 对象是从 fn 函数 new 出来的，这样 fn 对象就可以调用 fn.prototype 中的属性。\n\n因为每个对象都有一个隐藏的属性——__proto__，这个属性引用了创建这个对象的函数的 prototype。即：fn.__proto__ === fn.prototype\n\n这里的\"__proto__\"称为“隐式原型”，下回继续分解。\n\n\n# 隐式原型\n\n上节已经提到，每个函数 function 都有一个 prototype，即原型。这里再加一句话——每个对象都有一个__proto__，可称为隐式原型。\n\n这个__proto__是一个隐藏的属性，javascript 不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。所以你在 visual studio 2012 这样很高级很智能的编辑器中，都不会有__proto__的智能提示，但是你不用管它，直接写出来就是了。\n\n\n\n上面截图看来，obj.proto和 object.prototype 的属性一样！这么巧！\n\n答案就是一样。\n\nobj 这个对象本质上是被 object 函数创建的，因此obj.__proto__=== object.prototype。我们可以用一个图来表示。\n\n\n\n那么上图中的“object.prototype”也是一个对象，它的__proto__指向哪里？\n\n好问题！\n\n在说明“object.prototype”之前，先说一下自定义函数的 prototype。自定义函数的 prototype 本质上就是和 var obj = {} 是一样的，都是被 object 创建，所以它的__proto__指向的就是 object.prototype。\n\n但是 object.prototype 却是一个特例——它的proto指向的是 null，切记切记！\n\n> 批注：这就是原型链的终点\n\n\n\n还有——函数也是一种对象，函数也有__proto__吗？\n\n又一个好问题！——当然有。\n\n函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？——function——注意这个大写的“f”。\n\n且看如下代码。\n\n\n\n以上代码中，第一种方式是比较传统的函数创建方式，第二种是用 new functoin 创建。\n\n首先根本不推荐用第二种方式。\n\n这里只是向大家演示，函数是被 function 创建的。\n\n好了，根据上面说的一句话——对象的__proto__指向的是创建它的函数的 prototype，就会出现：object.__proto__=== function.prototype。用一个图来表示。\n\n\n\n上图中，很明显的标出了：自定义函数foo.__proto__指向function.prototype，object.__proto__指向function.prototype，唉，怎么还有一个 function.proto指向 function.prototype？这不成了循环引用了？\n\n对！是一个环形结构。\n\n其实稍微想一下就明白了。function 也是一个函数，函数是一种对象，也有__proto__属性。既然是函数，那么它一定是被 function 创建。所以——function 是被自身创建的。所以它的__proto__指向了自身的 prototype。\n\n最后一个问题：function.prototype 指向的对象，它的__proto__是不是也指向 object.prototype？\n\n答案是肯定的。因为 function.prototype 指向的对象也是一个普通的被 object 创建的对象，所以也遵循基本的规则。\n\n\n\n\n# instanceof\n\n> instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。\n\nobject instanceof constructor //object 某个实例对象;constructor 某个构造函数\n\n\n又介绍一个老朋友——instanceof。\n\n对于值类型，你可以通过 typeof 判断，string/number/boolean 都很清楚，但是 typeof 在判断到引用类型的时候，返回值只有 object/function，你不知道它到底是一个 object 对象，还是数组，还是 new number 等等。\n\n这个时候就需要用到 instanceof。例如：\n\n\n\n上图中，f1 这个对象是被 foo 创建，但是“f1 instanceof object”为什么是 true 呢？\n\n至于为什么过会儿再说，先把 instanceof 判断的规则告诉大家。根据以上代码看下图：\n\n\n\ninstanceof 运算符的第一个变量是一个对象，暂时称为 a；第二个变量一般是一个函数，暂时称为 b。\n\ninstanceof 的判断规则是：沿着 a 的proto这条线来找，同时沿着 b 的 prototype 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回 true。如果找到终点还未重合，则返回 false。\n\n按照以上规则，大家看看“ f1 instanceof object ”这句代码是不是 true？ 根据上图很容易就能看出来，就是 true。\n\n通过上以规则，你可以解释很多比较怪异的现象，例如\n\n\n\n这些看似很混乱的东西，答案却都是 true，这是为何？\n\n正好，这里也接上了咱们上一节说的“乱”。\n\n上一节咱们贴了好多的图片，其实那些图片是可以联合成一个整体的，即：\n\n\n\n看这个图片，千万不要嫌烦，必须一条线一条线挨着分析。如果上一节你看的比较仔细，再结合刚才咱们介绍的 instanceof 的概念，相信能看懂这个图片的内容。\n\n看看这个图片，你也就知道为何上面三个看似混乱的语句返回的是 true 了。\n\n问题又出来了。instanceof 这样设计，到底有什么用？到底 instanceof 想表达什么呢？\n\n重点就这样被这位老朋友给引出来了——继承——原型链。\n\n即，instanceof 表示的就是一种继承关系，或者原型链的结构。请看下节分解。\n\n\n# 继承\n\n为何用“继承”为标题，而不用“原型链”？\n\n原型链如果解释清楚了很容易理解，不会与常用的 java/c#产生混淆。而“继承”却是常用面向对象语言中最基本的概念，但是 java 中的继承与 javascript 中的继承又完全是两回事儿。因此，这里把“继承”着重拿出来，就为了体现这个不同。\n\njavascript 中的继承是通过原型链来体现的。先看几句代码\n\n\n\n以上代码中，f1 是 foo 函数 new 出来的对象，f1.a 是 f1 对象的基本属性，f1.b 是怎么来的呢？——从 foo.prototype 得来，因为 f1.proto指向的是 foo.prototype\n\n访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。\n\n看图说话：\n\n\n\n上图中，访问 f1.b 时，f1 的基本属性中没有 b，于是沿着proto找到了 foo.prototype.b。\n\n那么我们在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？大家可能都知道答案了——hasownproperty，特别是在 for…in…循环中，一定要注意。\n\n\n\n等等，不对！ f1 的这个 hasownproperty 方法是从哪里来的？ f1 本身没有，foo.prototype 中也没有，哪儿来的？\n\n好问题。\n\n它是从 object.prototype 中来的，请看图：\n\n\n\n对象的原型链是沿着__proto__这条线走的，因此在查找 f1.hasownproperty 属性时，就会顺着原型链一直查找到 object.prototype。\n\n由于所有的对象的原型链都会找到 object.prototype，因此所有的对象都会有 object.prototype 的方法。这就是所谓的“继承”。\n\n当然这只是一个例子，你可以自定义函数和对象来实现自己的继承。\n\n说一个函数的例子吧。\n\n我们都知道每个函数都有 call，apply 方法，都有 length，arguments，caller 等属性。为什么每个函数都有？这肯定是“继承”的。函数由 function 函数创建，因此继承的是 function.prototype 中的方法。不信可以，我们验证一下：\n\n\n\n看到了吧，有 call、length 等这些属性。\n\n那怎么还有 hasownproperty 呢？——那是 function.prototype 继承自 object.prototype 的方法。有疑问可以看看上一节将 instanceof 时候那个大图，看看function.prototype.proto是否指向 object.prototype。\n\n\n# 原型的灵活性\n\n在 java 和 c#中，你可以简单的理解 class 是一个模子，对象就是被这个模子压出来的一批一批月饼（中秋节刚过完）。压个啥样，就得是个啥样，不能随便动，动一动就坏了。\n\n而在 javascript 中，就没有模子了，月饼被换成了面团，你可以捏成自己想要的样子。\n\n首先，对象属性可以随时改动。\n\n对象或者函数，刚开始 new 出来之后，可能啥属性都没有。但是你可以这会儿加一个，过一会儿在加两个，非常灵活。\n\n其次，如果继承的方法不合适，可以做出修改。\n\n\n\n如上图，object 和 array 的 tostring()方法不一样。肯定是 array.prototype.tostring()方法做了修改。\n\n同理，我也可以自定义一个函数，并自己去修改 prototype.tostring()方法。\n\n\n\n最后，如果感觉当前缺少你要用的方法，可以自己去创建 => (内置对象添加原型的方法(属性))\n\n//在字符串中添加一个倒序字符串的方法\nstring.prototype.myreverse = function () {\n    for (var i = this.length - 1; i >= 0; i--) {\n        console.log(this[i])\n    }\n}\nvar str = 'abcd'\nstr.myreverse() //'dcba'\n\n\n\n# 简述【执行上下文】上\n\n什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码：\n\n\n\n第一句报错，a 未定义，很正常。第二句、第三句输出都是 undefined，说明浏览器在执行 console.log(a)时，已经知道了 a 是 undefined，但却不知道 a 是 10（第三句中）。\n\n在一段 js 代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟：\n\n\n\n下面还有。先来个简单的。\n\n\n\n有 js 开发经验的朋友应该都知道，你无论在哪个位置获取 this，都是有值的。至于 this 的取值情况，比较复杂，会专门拿出一篇文章来讲解。\n\n与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给 this 赋值。这也是“准备工作”情况要做的事情之一。\n\n下面还有。。。第三种情况。\n\n在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。\n\n\n\n看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。\n\n没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。\n\n好了，“准备工作”介绍完毕。\n\n我们总结一下，在“准备工作”中完成了哪些工作：\n\n * 变量、函数表达式——变量声明，默认赋值为 undefined；\n * this——赋值；\n * 函数声明——赋值；\n\n这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。\n\n> 这里插一句题外话：通过以上三种情况，你可能会联想到网上的有些考 js 语法的题目/面试题。的确，几乎每个 js 语法题中都有这种题目出现。之前你遇到这种题目是不是靠背诵来解决？背过了，隔几天又忘记了。——任何问题，都要去追根溯源，要知道这个问题是真正出自哪一块知识点，要真正去理解。光靠背诵是没用的。\n\n细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。\n\n其实，javascript 在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval 代码。\n\n这里解释一下为什么代码段分为这三种。\n\n所谓“代码段”就是一段文本形式的代码。\n\n首先，全局代码是一种，这个应该没有非议，本来就是手写文本到 script 标签里面的。\n\n其次，eval 代码接收的也是一段文本形式的代码。\n\n\n\n\n\n最后，函数体是代码段是因为函数在创建时，本质上是 new function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。\n\n\n\n这样解释应该能理解了。\n\n最后，eval 不常用，也不推荐大家用。\n\n下一节我们介绍函数的情况，并一起总结一下执行上下文到底包含哪些内容。敬请期待。\n\n\n# 简述【执行上下文】下\n\n上一篇我们讲到在全局环境下的代码段中，执行上下文环境中有如何数据：\n\n * 变量、函数表达式——变量声明，默认赋值为 undefined；\n * this——赋值；\n * 函数声明——赋值；\n\n如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码：\n\n\n\n以上代码展示了在函数体的语句执行之前，arguments 变量和函数的参数都已经被赋值。从这里可以看出，函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数。\n\n另外一点不同在于，函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。至于“自由变量”和“作用域”是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下：\n\n\n\n全局代码的上下文环境数据内容为：\n\n\n\n如果代码段是函数体，那么在此基础上需要附加：\n\n\n\n给执行上下文环境下一个通俗的定义——在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用 undefined 占个空。\n\n了解了执行上下文环境中的数据信息，你就不用再去死记硬背那些可恶的面试题了。理解了就不用背诵！\n\n讲完了上下文环境，又来了新的问题——在执行 js 代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？ 通过“执行上下文栈”来解释这个问题。\n\n不过别着急，在解释“执行上下文栈”之前，还需要把 this 说一下，this 还是挺重要的。\n\n说完 this，接着说执行上下文栈。\n\n\n# this\n\n接着上一节讲的话，应该轮到“执行上下文栈”了，但是这里不得不插入一节，把 this 说一下。因为 this 很重要，js 的面试题如果不出几个与 this 有关的，那出题者都不合格。\n\n其实，this 的取值，分四种情况。我们来挨个看一下。\n\n在此再强调一遍一个非常重要的知识点：在函数中 this 到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为 this 的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。\n\n\n# 情况 1：构造函数\n\n所谓构造函数就是用来 new 对象的函数。其实严格来说，所有的函数都可以 new 一个对象，但是有些函数的定义是为了 new 一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：object、array、function 等。\n\n\n\n以上代码中，如果函数作为构造函数用，那么其中的 this 就代表它即将 new 出来的对象。\n\n注意，以上仅限 new foo()的情况，即 foo 函数作为构造函数的情况。如果直接调用 foo 函数，而不是 new foo()，情况就大不一样了。\n\n\n\n这种情况下 this 是 window，我们后文中会说到。\n\n\n# 情况 2：函数作为对象的一个属性\n\n如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的 this 指向该对象。\n\n\n\n以上代码中，fn 不仅作为一个对象的一个属性，而且的确是作为对象的一个属性被调用。结果 this 就是 obj 对象。\n\n注意，如果 fn 函数不作为 obj 的一个属性被调用，会是什么结果呢？\n\n\n\n如上代码，如果 fn 函数被赋值到了另一个变量中，并没有作为 obj 的一个属性被调用，那么 this 的值就是 window，this.x 为 undefined。\n\n\n# 情况 3：函数用 call 或者 apply 调用\n\n当一个函数被 call 和 apply 调用时，this 的值就取传入的对象的值。\n\n\n\n\n# 情况 4 全局 & 调用普通函数\n\n> 非严格模式下!\n\n在全局环境下，this 永远是 window，这个应该没有非议。\n\nconsole.log(this === window) // true\n\n\n普通函数在调用时，其中的 this 也都是 window。\n\n\n\n以上代码很好理解。\n\n不过下面的情况你需要注意一下：\n\n\n\n函数 f 虽然是在 obj.fn 内部定义的，但是它仍然是一个普通的函数，this 仍然指向 window。\n\n\n# 补充\n\n原文中 this 的其中一种情况是构造函数的，具体的内容可以参考原文，此处不再赘述。\n\n要补充的内容是，在构造函数的 prototype 中，this 代表着什么。\n\n\n\n如上代码，在 fn.prototype.getname 函数中，this 指向的是 f1 对象。因此可以通过 this.name 获取 f1.name 的值。\n\n其实，不仅仅是构造函数的 prototype，即便是在整个原型链中，this 代表的也都是当前对象的值。\n\n\n# 执行上下文栈\n\n执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。\n\n其实这是一个压栈出栈的过程——执行上下文栈。如下图：\n\n\n\n可根据以下代码来详细介绍上下文栈的压栈、出栈过程。\n\n\n\n如上代码。\n\n在执行代码之前，首先将创建全局上下文环境。\n\n\n\n然后是代码执行。代码执行到第 12 行之前，上下文环境中的变量都在执行过程中被赋值。\n\n\n\n执行到第 13 行，调用 bar 函数。\n\n跳转到 bar 函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。\n\n\n\n并将这个执行上下文环境压栈，设置为活动状态。\n\n\n\n执行到第 5 行，又调用了 fn 函数。进入 fn 函数，在执行函数体语句之前，会创建 fn 函数的执行上下文环境，并压栈，设置为活动状态。\n\n\n\n待第 5 行执行完毕，即 fn 函数执行完毕后，此次调用 fn 所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。\n\n\n\n同理，待第 13 行执行完毕，即 bar 函数执行完毕后，调用 bar 函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。\n\n\n\n好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。\n\n讲到这里，我不得不很遗憾的跟大家说：其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。\n\n要说闭包，咱们还得先从自由变量和作用域说起。\n\n\n# 简介【作用域】\n\n> 特别注意：es6 已加入块作用域\n\n提到作用域，有一句话大家（有 js 开发经验者）可能比较熟悉：“javascript 没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如 if 语句：\n\n\n\n再比如 for 语句：\n\n\n\n所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义。如：\n\n\n\n其实，你光知道“javascript 没有块级作用域”是完全不够的，你需要知道的是——javascript 除了全局作用域之外，只有函数可以创建的作用域。\n\n> 当然这句话现在来说也是错误的，es6 中加入的 let const 会创建块级作用域\n\n所以，我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单 var”形式。\n\n下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘”\n\n\n\n如上图，全局代码和 fn、bar 两个函数都会形成一个作用域。而且，作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。例如，fn 作用域下创建了 bar 函数，那么“fn 作用域”就是“bar 作用域”的上级。\n\n作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。\n\n\n# 【作用域】和【上下文环境】\n\n上文简单介绍了作用域，本文把作用域和上下文环境结合起来说一下，会理解的更深一些。\n\n\n\n如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。\n\n第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。\n\n\n\n第二步，程序执行到第 27 行，调用 fn(10)，此时生成此次调用 fn 函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。\n\n\n\n第三步，执行到第 23 行时，调用 bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。\n\n\n\n第四步，执行完第 23 行，bar(100)调用完成。则 bar(100)上下文环境被销毁。接着执行第 24 行，调用 bar(200)，则又生成 bar(200)的上下文环境，压栈，设置为活动状态。\n\n\n\n第五步，执行完第 24 行，则 bar(200)调用结束，其上下文环境被销毁。此时会回到 fn(10)上下文环境，变为活动状态。\n\n\n\n第六步，执行完第 27 行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。\n\n最后我们可以把以上这几个图片连接起来看看。\n\n\n\n连接起来看，还是挺有意思的。作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。\n\n所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。\n\n虽然本文很长，但是文字较少，图片居多，图片都有形象的展示，大家花十几分钟也能慢慢看完。但是，这节内容真的很重要。\n\n以上代码中，咱们还没有设计到跨作用域取值的情况，即——自由变量。详细内容且听下回分解。\n\n\n# 从【自由变量】到【作用域链】\n\n先解释一下什么是“自由变量”。\n\n在 a 作用域中使用的变量 x，却没有在 a 作用域中声明（即在其他作用域中声明的），对于 a 作用域来说，x 就是一个自由变量。如下图\n\n\n\n如上程序中，在调用 fn()函数时，函数体中第 6 行。取 b 的值就直接可以在 fn 作用域中取，因为 b 就是在这里定义的。而取 x 的值时，就需要到另一个作用域中取。到哪个作用域中取呢？\n\n有人说过要到父作用域中取，其实有时候这种解释会产生歧义。例如：\n\n\n\n所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切——要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记——其实这就是所谓的“静态作用域”。\n\n区分静态（词法）作用域和动态作用域\n\n词法作用域： 在代码书写的时候完成划分，作用域链沿着它定义的位置往外延伸\n\n动态作用域： 在代码运行时完成划分，作用域链沿着它的调用栈往外延伸\n\n对于本文第一段代码，在 fn 函数中，取自由变量 x 的值时，要到哪个作用域中取？——要到创建 fn 函数的那个作用域中取——无论 fn 函数将在哪里调用。\n\n上面描述的只是跨一步作用域去寻找。\n\n如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。\n\n这个一步一步“跨”的路线，我们称之为——作用域链。\n\n我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设 a 是自由变量）\n\n第一步，现在当前作用域查找 a，如果有则获取并结束。如果没有则继续；\n\n第二步，如果当前作用域是全局作用域，则证明 a 未定义，结束；否则继续；\n\n第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；\n\n第四步，跳转到第一步。\n\n\n\n以上代码中：第 13 行，fn()返回的是 bar 函数，赋值给 x。执行 x()，即执行 bar 函数代码。取 b 的值时，直接在 fn 作用域取出。取 a 的值时，试图在 fn 作用域取，但是取不到，只能转向创建 fn 的那个作用域中去查找，结果找到了。\n\n这一节看似很轻松的把作用域链引出来，并讲完了。之所有轻松是有前几节的基础，否则将很难解释。\n\n接下来咱们开始正式说说一直期待依旧的朋友——闭包。敬请期待下一节。\n\n\n# 闭包\n\n前面提到的上下文环境和作用域的知识，除了了解这些知识之外，还是理解闭包的基础。\n\n至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。\n\n但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递。\n\n\n# 第一，函数作为返回值\n\n如上代码，bar 函数作为返回值，赋值给 f1 变量。执行 f1(15)时，用到了 fn 作用域下的 max 变量的值。至于如何跨作用域取值，可以参考上一节。\n\n\n# 第二，函数作为参数被传递\n\n\n\n如上代码中，fn 函数作为一个参数被传递进入另一个函数，赋值给 f 参数。执行 f(15)时，max 变量的取值是 10，而不是 100。\n\n上一节讲到自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。（不明白的朋友一定要去上一节看看，这个很重要！）\n\n另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。\n\n在前面讲执行上下文栈时，我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。\n\n但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。\n\n咱们可以拿本文的第一段代码（稍作修改）来分析一下。\n\n\n\n第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。\n\n\n\n第二步，执行第 17 行代码时，调用 fn()，产生 fn()执行上下文环境，压栈，并设置为活动状态。\n\n\n\n第三步，执行完第 17 行，fn()调用完成。按理说应该销毁掉 fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行 fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量 max 要引用 fn 作用域下的 fn()上下文环境中的 max。因此，这个 max 不能被销毁，销毁了之后 bar 函数中的 max 就找不到值了。\n\n因此，这里的 fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。\n\n——即，执行到第 18 行时，全局上下文环境将变为活动状态，但是 fn()上下文环境依然会在执行上下文栈中。另外，执行完第 18 行，全局上下文环境中的 max 被赋值为 100。如下图：\n\n\n\n第四步，执行到第 20 行，执行 f1(15)，即执行 bar(15)，创建 bar(15)上下文环境，并将其设置为活动状态。\n\n\n\n执行 bar(15)时，max 是自由变量，需要向创建 bar 函数的作用域中查找，找到了 max 的值为 10。这个过程在作用域链一节已经讲过。\n\n这里的重点就在于，创建 bar 函数是在执行 fn()时创建的。fn()早就执行结束了，但是 fn()执行上下文环境还存在与栈中，因此 bar(15)时，max 可以查找到。如果 fn()上下文环境销毁了，那么 max 就找不到了。\n\n使用闭包会增加内容开销，现在很明显了吧！\n\n第五步，执行完 20 行就是上下文环境的销毁过程，这里就不再赘述了。\n\n闭包和作用域、上下文环境有着密不可分的关系，真的是“想说爱你不容易”！\n\n无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了 bug 你都不知道为什么，因为这些 bug 可能完全在你的知识范围之外。\n\n\n# 补充：上下文环境和作用域的关系\n\n本系列用了大量的篇幅讲解了上下文环境和作用域，有些人反映这两个是一回儿事。本文就用一个小例子来说明一下，作用域和上下文环境绝对不是一回事儿。\n\n再说明之前，咱们先用简单的语言来概括一下这两个的区别。\n\n 1. 上下文环境：\n\n可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量都在里面存储着，要不然咱们定义的变量在哪里存？\n\n另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数？\n\n 2. 作用域：\n    \n    > 这句话现在看来是错误的\n\n首先，它很抽象。第二，记住一句话：除了全局作用域，只有函数才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域，就有自己的一个“地盘”。\n\n 3. 两者：\n\n一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。\n\n上面的文字不理解没关系，且看下面的例子。\n\n第一，除了全局作用域外，每个函数都要创建一个作用域。作用域之间的变量是相互独立的。因此，全局作用域中的 x 和 fn 作用域中的 x，两者毫无关系，互不影响，和平相处。\n\n\n\n第二，程序执行之前，会生成全局上下文环境，并在程序执行时，对其中的变量赋值。\n\n\n\n第三，程序执行到第 17 行，调用 fn(5)，会产生 fn(5)的上下文环境，并压栈，并设置为活动状态。\n\n\n\n第四，执行完第 17 行，fn(5)的返回值赋值给了 f1。此时执行上下文环境又重新回到全局，但是 fn(5)的上下文环境不能就此销毁，因为其中有闭包的引用（可翻看前面文章，此处不再赘述）。\n\n\n\n转载自\n\n王福朋深入理解 javascript 原型和闭包（完结）",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"TS基础",frontmatter:{title:"TS基础",sidebarDepth:2,readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E5%9F%BA%E7%A1%80.html",relativePath:"前端开发/TypeScript/TS基础.md",key:"v-00baf344",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E5%9F%BA%E7%A1%80.html",headers:[{level:2,title:"TypeScript Environment",slug:"typescript-environment",normalizedTitle:"typescript environment",charIndex:2},{level:2,title:"TypeScript type",slug:"typescript-type",normalizedTitle:"typescript type",charIndex:192},{level:3,title:"boolean",slug:"boolean",normalizedTitle:"boolean",charIndex:212},{level:3,title:"number",slug:"number",normalizedTitle:"number",charIndex:274},{level:3,title:"string",slug:"string",normalizedTitle:"string",charIndex:325},{level:3,title:"array",slug:"array",normalizedTitle:"array",charIndex:413},{level:3,title:"tuple",slug:"tuple",normalizedTitle:"tuple",charIndex:596},{level:3,title:"union",slug:"union",normalizedTitle:"union",charIndex:928},{level:3,title:"literal",slug:"literal",normalizedTitle:"literal",charIndex:1119},{level:3,title:"enum",slug:"enum",normalizedTitle:"enum",charIndex:1253},{level:3,title:"any",slug:"any",normalizedTitle:"any",charIndex:551},{level:3,title:"unknown",slug:"unknown",normalizedTitle:"unknown",charIndex:2051},{level:3,title:"void",slug:"void",normalizedTitle:"void",charIndex:2297},{level:3,title:"never",slug:"never",normalizedTitle:"never",charIndex:2544},{level:3,title:"function",slug:"function",normalizedTitle:"function",charIndex:2142},{level:2,title:"Type Assertions",slug:"type-assertions",normalizedTitle:"type assertions",charIndex:3229},{level:2,title:"Type Inference",slug:"type-inference",normalizedTitle:"type inference",charIndex:3395}],headersStr:"TypeScript Environment TypeScript type boolean number string array tuple union literal enum any unknown void never function Type Assertions Type Inference",content:"# TypeScript Environment\n\n 1. 安装 ts:npm i -g typescript,编译 ts: tsc xxx.ts,得到 js 文件执行\n\n 2. 直接使用 ts-node 运行 ts 文件:\n    \n    * npm i ts-node -g\n    * npm i typescript -g\n    * ts-node xxx.ts\n\n\n# TypeScript type\n\n\n# boolean\n\nconst bool1 = true\nconst bool2: boolean = false\n\n\n\n# number\n\nconst num1: number = 1\nconst num2 = 2\n\n\n\n# string\n\nconst str1 = 'frank'\nconst str2: string = 'frank'\nconst str3 = `我叫${str2}`\n\n\n\n# array\n\n数组的几种声明方式：\n\nlet list1: number[] = [1, 2, 3, 4]\nlet list2 = [1, 2, 3, '4']\nlet list3: Array<number> = [1, 2, 3, 4] // 泛型\nlet list4: any[] = [1, 'ddd', { a: 1 }, [1, 2, 3]]\n\n\n\n# tuple\n\n元组类型是另一种类型 Array，它确切地知道它包含多少个元素，以及它在特定位置包含哪些类型（官方文档元组定义翻译）\n\nlet person: [number, string] = [1, '123']\n\nconsole.log(person)\n\n\n当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型:\n\nlet tom: [string, number]\ntom = ['Tom', 25]\ntom.push('male')\ntom.push(true)\n// Argument of type 'true' is not assignable to parameter of type 'string | number'.\n\n\n\n# union\n\n联合类型 Union Types 表示取值可以为多种类型中的一种\n\n联合类型使用 |分隔每个类型\n\nlet union1: number | string\nunion1 = 123\nunion1 = '456'\n\nlet union2: number | string | string[] | boolean\n\nlet union3: 1 | 2 | 3\n\n\n\n# literal\n\n字面量 Literal 类型的特定数据就是 它自己的类型\n\nconst num = 1\n// 与联合类型结合\nlet nums: 1 | 2 | 3\nnums = 2\nnums = 4 // 报错 nums只能是 1,2,3 中的其中一个\n\n\n\n# enum\n\n使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。\n\nenum Color {\n    red,\n    green,\n    blue,\n}\nconsole.log(Color.red) // 2\n// 给枚举项手动赋值\nenum Color2 {\n    red = 5,\n    green,\n    blue,\n}\nconsole.log(Color2.red) // 7\nenum Color3 {\n    red = 'red',\n    green = 'green',\n    blue = 'blue',\n}\nconsole.log(Color3.red) // 'red'\n\n\n结合 switch 语句使用\n\n// 使用枚举\nenum Sex {\n    MALE,\n    FEMALE,\n    UNKNOWN,\n}\n\nlet member_sex: number = Sex.FEMALE\n\nswitch (member_sex) {\n    case Sex.MALE:\n        console.log('男')\n        break\n    case Sex.FEMALE:\n        console.log('女')\n        break\n    case Sex.UNKNOWN:\n        console.log('未知')\n        break\n    default:\n        break\n}\n\n\n\n# any\n\n任意值 Any 用来表示允许赋值为任意类型\n\nlet result: any = 555\nresult = { a: 1 }\nresult = []\nresult = false\n\n\n\n# unknown\n\nunknown 不保证类型，但保证类型安全(类型安全的 any)，只有确定了变量类型以后，才能正常使用\n\nlet res: unknown = 123\nres = function () {\n    console.log('res')\n}\nif (typeof res === 'function') {\n    res()\n}\nres = 123\nif (typeof res === 'number') {\n    console.log(res++)\n}\n\n\n\n# void\n\nvoid 和 undefined\n\nvoid 代表变量本身就不存在，undefined代表应该此处应该有一个变量，但是没有没有定义\n\n在 TypeScript 中，可以用 void 表示没有任何返回值的函数:\n\nfunction printRes(): void {\n    console.log('string')\n}\n\nfunction printRes2(): undefined {\n    console.log('string')\n    return\n}\n\n\n\n# never\n\n一个函数永远执行不完，这就是 never 的本质\n\nfunction throwErr(mes: string, errCode: number): never {\n    throw {\n        mes,\n        errCode,\n    }\n}\nconsole.log(throwErr('not fonund', 404))\n\nfunction whileLoop(): never {\n    while (true) {\n        console.log('1')\n    }\n}\n\n\n\n# function\n\nts 函数，可选参数，默认参数，剩余参数\n\n注意\n\n * 默认参数和可选参数无法同时使用\n\n * 三种参数都应定义在参数列表的末尾\n\n// 可选参数\nfunction fun(a: number, b?: number) {\n    console.log(a, b) // 1 undefined\n}\n\nfun(1)\n// 默认参数\nfunction fun2(a: number = 1, b: number = 2) {\n    console.log(a + b) //3\n}\n\nfun2(1)\n// 剩余参数\nfunction fun3(a: number, b: number, ...c: number[]) {\n    console.log(a + b + c.reduce((pre, cur) => pre + cur)) //16\n}\n\nfun3(1, 2, 3, 4, 6)\n\n\n\n# Type Assertions\n\n类型断言Type Assertions可以用来手动指定一个值的类型。\n\nlet x: any\nx = '123' // 仍然是any类型\nlet s1 = (<string>x).charAt(1) //  1\nlet s2 = (x as string).charAt(2) // 2\n\n\n\n# Type Inference\n\n如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。\n\n以下代码虽然没有指定类型，但是会在编译的时候报错：\n\nlet myFavoriteNumber = 'seven'\nmyFavoriteNumber = 7\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\n\n\n事实上，它等价于：\n\nlet myFavoriteNumber: string = 'seven'\nmyFavoriteNumber = 7\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\n\n\n如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：\n\nlet myFavoriteNumber\nmyFavoriteNumber = 'seven'\nmyFavoriteNumber = 7\n",normalizedContent:"# typescript environment\n\n 1. 安装 ts:npm i -g typescript,编译 ts: tsc xxx.ts,得到 js 文件执行\n\n 2. 直接使用 ts-node 运行 ts 文件:\n    \n    * npm i ts-node -g\n    * npm i typescript -g\n    * ts-node xxx.ts\n\n\n# typescript type\n\n\n# boolean\n\nconst bool1 = true\nconst bool2: boolean = false\n\n\n\n# number\n\nconst num1: number = 1\nconst num2 = 2\n\n\n\n# string\n\nconst str1 = 'frank'\nconst str2: string = 'frank'\nconst str3 = `我叫${str2}`\n\n\n\n# array\n\n数组的几种声明方式：\n\nlet list1: number[] = [1, 2, 3, 4]\nlet list2 = [1, 2, 3, '4']\nlet list3: array<number> = [1, 2, 3, 4] // 泛型\nlet list4: any[] = [1, 'ddd', { a: 1 }, [1, 2, 3]]\n\n\n\n# tuple\n\n元组类型是另一种类型 array，它确切地知道它包含多少个元素，以及它在特定位置包含哪些类型（官方文档元组定义翻译）\n\nlet person: [number, string] = [1, '123']\n\nconsole.log(person)\n\n\n当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型:\n\nlet tom: [string, number]\ntom = ['tom', 25]\ntom.push('male')\ntom.push(true)\n// argument of type 'true' is not assignable to parameter of type 'string | number'.\n\n\n\n# union\n\n联合类型 union types 表示取值可以为多种类型中的一种\n\n联合类型使用 |分隔每个类型\n\nlet union1: number | string\nunion1 = 123\nunion1 = '456'\n\nlet union2: number | string | string[] | boolean\n\nlet union3: 1 | 2 | 3\n\n\n\n# literal\n\n字面量 literal 类型的特定数据就是 它自己的类型\n\nconst num = 1\n// 与联合类型结合\nlet nums: 1 | 2 | 3\nnums = 2\nnums = 4 // 报错 nums只能是 1,2,3 中的其中一个\n\n\n\n# enum\n\n使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 typescript 支持数字的和基于字符串的枚举。\n\nenum color {\n    red,\n    green,\n    blue,\n}\nconsole.log(color.red) // 2\n// 给枚举项手动赋值\nenum color2 {\n    red = 5,\n    green,\n    blue,\n}\nconsole.log(color2.red) // 7\nenum color3 {\n    red = 'red',\n    green = 'green',\n    blue = 'blue',\n}\nconsole.log(color3.red) // 'red'\n\n\n结合 switch 语句使用\n\n// 使用枚举\nenum sex {\n    male,\n    female,\n    unknown,\n}\n\nlet member_sex: number = sex.female\n\nswitch (member_sex) {\n    case sex.male:\n        console.log('男')\n        break\n    case sex.female:\n        console.log('女')\n        break\n    case sex.unknown:\n        console.log('未知')\n        break\n    default:\n        break\n}\n\n\n\n# any\n\n任意值 any 用来表示允许赋值为任意类型\n\nlet result: any = 555\nresult = { a: 1 }\nresult = []\nresult = false\n\n\n\n# unknown\n\nunknown 不保证类型，但保证类型安全(类型安全的 any)，只有确定了变量类型以后，才能正常使用\n\nlet res: unknown = 123\nres = function () {\n    console.log('res')\n}\nif (typeof res === 'function') {\n    res()\n}\nres = 123\nif (typeof res === 'number') {\n    console.log(res++)\n}\n\n\n\n# void\n\nvoid 和 undefined\n\nvoid 代表变量本身就不存在，undefined代表应该此处应该有一个变量，但是没有没有定义\n\n在 typescript 中，可以用 void 表示没有任何返回值的函数:\n\nfunction printres(): void {\n    console.log('string')\n}\n\nfunction printres2(): undefined {\n    console.log('string')\n    return\n}\n\n\n\n# never\n\n一个函数永远执行不完，这就是 never 的本质\n\nfunction throwerr(mes: string, errcode: number): never {\n    throw {\n        mes,\n        errcode,\n    }\n}\nconsole.log(throwerr('not fonund', 404))\n\nfunction whileloop(): never {\n    while (true) {\n        console.log('1')\n    }\n}\n\n\n\n# function\n\nts 函数，可选参数，默认参数，剩余参数\n\n注意\n\n * 默认参数和可选参数无法同时使用\n\n * 三种参数都应定义在参数列表的末尾\n\n// 可选参数\nfunction fun(a: number, b?: number) {\n    console.log(a, b) // 1 undefined\n}\n\nfun(1)\n// 默认参数\nfunction fun2(a: number = 1, b: number = 2) {\n    console.log(a + b) //3\n}\n\nfun2(1)\n// 剩余参数\nfunction fun3(a: number, b: number, ...c: number[]) {\n    console.log(a + b + c.reduce((pre, cur) => pre + cur)) //16\n}\n\nfun3(1, 2, 3, 4, 6)\n\n\n\n# type assertions\n\n类型断言type assertions可以用来手动指定一个值的类型。\n\nlet x: any\nx = '123' // 仍然是any类型\nlet s1 = (<string>x).charat(1) //  1\nlet s2 = (x as string).charat(2) // 2\n\n\n\n# type inference\n\n如果没有明确的指定类型，那么 typescript 会依照类型推论（type inference）的规则推断出一个类型。\n\n以下代码虽然没有指定类型，但是会在编译的时候报错：\n\nlet myfavoritenumber = 'seven'\nmyfavoritenumber = 7\n// index.ts(2,1): error ts2322: type 'number' is not assignable to type 'string'.\n\n\n事实上，它等价于：\n\nlet myfavoritenumber: string = 'seven'\nmyfavoritenumber = 7\n\n// index.ts(2,1): error ts2322: type 'number' is not assignable to type 'string'.\n\n\n如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：\n\nlet myfavoritenumber\nmyfavoritenumber = 'seven'\nmyfavoritenumber = 7\n",charsets:{cjk:!0},lastUpdated:"2022年05月24日",lastUpdatedTimestamp:1653404643e3},{title:"TS进阶",frontmatter:{title:"TS进阶",date:"2022/05/24 22:50:17",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E8%BF%9B%E9%98%B6.html",relativePath:"前端开发/TypeScript/TS进阶.md",key:"v-b93431e0",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E8%BF%9B%E9%98%B6.html",headers:[{level:2,title:"类型别名",slug:"类型别名",normalizedTitle:"类型别名",charIndex:2},{level:3,title:"类型别名与接口的区别",slug:"类型别名与接口的区别",normalizedTitle:"类型别名与接口的区别",charIndex:297},{level:2,title:"类型保护",slug:"类型保护",normalizedTitle:"类型保护",charIndex:1696},{level:2,title:"函数重载",slug:"函数重载",normalizedTitle:"函数重载",charIndex:2241},{level:2,title:"方法重载",slug:"方法重载",normalizedTitle:"方法重载",charIndex:3233},{level:2,title:"构造器重载",slug:"构造器重载",normalizedTitle:"构造器重载",charIndex:4141},{level:2,title:"调用签名",slug:"调用签名",normalizedTitle:"调用签名",charIndex:4821},{level:3,title:"函数类型表达式",slug:"函数类型表达式",normalizedTitle:"函数类型表达式",charIndex:4830},{level:2,title:"构造签名",slug:"构造签名",normalizedTitle:"构造签名",charIndex:5748},{level:2,title:"索引签名",slug:"索引签名",normalizedTitle:"索引签名",charIndex:6017},{level:2,title:"双重断言",slug:"双重断言",normalizedTitle:"双重断言",charIndex:6381},{level:2,title:"常量断言",slug:"常量断言",normalizedTitle:"常量断言",charIndex:6465},{level:2,title:"typeof 操作符",slug:"typeof-操作符",normalizedTitle:"typeof 操作符",charIndex:6902},{level:2,title:"keyof 操作符",slug:"keyof-操作符",normalizedTitle:"keyof 操作符",charIndex:7035},{level:2,title:"类型查找",slug:"类型查找",normalizedTitle:"类型查找",charIndex:7186},{level:2,title:"类型映射",slug:"类型映射",normalizedTitle:"类型映射",charIndex:7610},{level:2,title:"映射修饰符",slug:"映射修饰符",normalizedTitle:"映射修饰符",charIndex:7831}],headersStr:"类型别名 类型别名与接口的区别 类型保护 函数重载 方法重载 构造器重载 调用签名 函数类型表达式 构造签名 索引签名 双重断言 常量断言 typeof 操作符 keyof 操作符 类型查找 类型映射 映射修饰符",content:"# 类型别名\n\n类型别名用来给一个类型起个新名字。\n\ntype Name = string\ntype NameResolver = () => string\ntype NameOrResolver = Name | NameResolver\nfunction getName(n: NameOrResolver): Name {\n    if (typeof n === 'string') {\n        return n\n    } else {\n        return n()\n    }\n}\n\n\n上例中，我们使用 type 创建类型别名。\n\n类型别名常用于联合类型。\n\n\n# 类型别名与接口的区别\n\n# 相同点\n\n都可以描述一个对象或者函数：\n\ninterface\n\ninterface User {\n    name: string\n    age: number\n}\n\ninterface SetUser {\n    (name: string, age: number): void\n}\n\n\ntype\n\ntype User = {\n    name: string\n    age: number\n}\n\ntype SetUser = (name: string, age: number) => void\n\n\n都允许拓展（extends）：\n\nterface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。\n\ninterface extends interface\n\ninterface Name {\n    name: string\n}\ninterface User extends Name {\n    age: number\n}\n\n\ntype extends type\n\ntype Name = {\n    name: string\n}\ntype User = Name & { age: number }\n\n\ninterface extends type\n\ntype Name = {\n    name: string\n}\ninterface User extends Name {\n    age: number\n}\n\n\ntype extends interface\n\ninterface Name {\n    name: string\n}\ntype User = Name & {\n    age: number\n}\n\n\n# 不同点\n\ntype 可以而 interface 不行：\n\n * type 可以声明基本类型别名，联合类型，元组等类型\n\n// 基本类型别名\ntype Name = string\n\n// 联合类型\ninterface Dog {\n    wong()\n}\ninterface Cat {\n    miao()\n}\n\ntype Pet = Dog | Cat\n\n// 具体定义数组每个位置的类型\ntype PetList = [Dog, Pet]\n\n\n * type 语句中还可以使用 typeof 获取实例的 类型进行赋值\n\n// 当你想获取一个变量的类型时，使用 typeof\nlet div = document.createElement('div')\ntype B = typeof div\n\n\ninterface 可以而 type 不行：\n\ninterface 能够声明合并\n\ninterface User {\n    name: string\n    age: number\n}\n\ninterface User {\n    sex: string\n}\n\n/*\nUser 接口为 {\n  name: string\n  age: number\n  sex: string \n}\n*/\n\n\n用 interface 描述数据结构，用 type 描述类型关系\n\n\n# 类型保护\n\ntypescript-typeguard\n\nis 是 TypeScript 中的一个关键字，一般用于函数返回值类型中，判断参数是否属于某一类型，并根据结果返回对应的布尔类型\n\ntype Square = {\n    size: number\n}\ntype Rectangle = {\n    width: number\n    height: number\n}\n\nfunction isSquare(shape: Shape): shape is Square {\n    return 'size' in shape\n}\n\nfunction isRectangle(shape: Shape): shape is Rectangle {\n    return 'width' in shape\n}\n\ntype Shape = Square | Rectangle\n\nfunction area(shape: Shape) {\n    if (isSquare(shape)) return shape.size * shape.size\n    if (isRectangle(shape)) return shape.width * shape.height\n}\n\n\n\n# 函数重载\n\nTS 中几种函数重载\n\n重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n\n比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 'hello' 的时候，输出反转的字符串 'olleh'。\n\n利用联合类型，我们可以这么实现：\n\nfunction reverse(x: number | string): number | string | void {\n    if (typeof x === 'number') {\n        return Number(x.toString().split('').reverse().join(''))\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('')\n    }\n}\n\n\n然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。\n\n这时，我们可以使用重载定义多个 reverse 的函数类型：\n\nfunction reverse(x: number): number // 重载签名\nfunction reverse(x: string): string // 重载签名\nfunction reverse(x: number | string): number | string | void { // 实现签名\n    if (typeof x === 'number') {\n        return Number(x.toString().split('').reverse().join(''))\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('')\n    }\n}\n\n\n上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。\n\n注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。\n\n\n# 方法重载\n\n下面来实现一个方法重载 以 ArrayList 为例,可以查看数据,可以删除数据,删除可以通过 id 或者对象删除可以获取数据\n\nclass ArrayList {\n    constructor(public element: object[]) {}\n    /**\n     * 获取某一个值\n     * @param index\n     * @returns\n     */\n    get(index: number) {\n        return this.element[index]\n    }\n    // 显示值\n    show() {\n        this.element.forEach(i => console.log(i))\n    }\n\n    remove(val: number): number\n    remove(val: Object): Object // 实现删除方法重载\n\n    remove(val: number | Object) {\n        this.element = this.element.filter((e, index) => {\n            if (typeof val === 'number') {\n                return val !== index\n            } else {\n                return val !== e\n            }\n        })\n        return val\n    }\n}\nlet a = { name: 'zixia', age: 12 },\n    b = { name: 'selfsummer', age: 88 },\n    c = { name: '自夏', age: 18 }\n\nlet newAr = new ArrayList([a, b, c])\n\nnewAr.remove(1)\nnewAr.remove(c)\nconsole.log(newAr)\n\n\n\n# 构造器重载\n\n// 类型别名\ntype TypeWowen = {\n    name: string\n    age: number\n}\n\nclass Wowen {\n    name: string\n    age: number\n    constructor(age: number, name?: string)\n    constructor(paramObj: TypeWowen)\n    constructor(paramObj: any, name = '未知') {\n        if (typeof paramObj === 'object') {\n            const { name, age } = paramObj\n            this.name = name\n            this.age = age\n        } else {\n            this.age = paramObj\n            this.name = name\n        }\n    }\n}\nconst w1 = new Wowen({ name: 'frank', age: 123 })\nconst w2 = new Wowen(123, 'frank')\n// const w3 = new Wowen({ name: 'frank', age: 123 }, 123)\n\nconsole.log(w1)\nconsole.log(w2)\nconsole.log(w3)\n\n\n\n# 调用签名\n\n\n# 函数类型表达式\n\n最简单描述一个函数的方式是使用**函数类型表达式（function type expression）。**它的写法有点类似于箭头函数：\n\nfunction greeter(fn: (a: string) => void) {\n    fn('Hello, World')\n}\n\nfunction printToConsole(s: string) {\n    console.log(s)\n}\n\ngreeter(printToConsole)\n\n\n语法 (a: string) => void 表示一个函数有一个名为 a ，类型是字符串的参数，这个函数并没有返回任何值。\n\n如果一个函数参数的类型并没有明确给出，它会被隐式设置为 any。\n\n当然了，我们也可以使用类型别名 定义一个函数类型：\n\ntype GreetFunction = (a: string) => void\nfunction greeter(fn: GreetFunction) {\n    // ...\n}\n\n\n在 JavaScript 中，函数除了可以被调用，自己也是可以有属性值的。然而函数类型表达式并不能支持声明属性，如果我们想描述一个带有属性的函数，我们可以在一个对象类型中写一个调用签名（call signature）\n\ntype DescribableFunction = {\n    description: string\n    (someArg: number): boolean\n}\nconst fn: DescribableFunction = someArg => {\n    return someArg > 0\n}\n\nfn.description = '是否大于0'\n\nfunction doSomething(fn: DescribableFunction) {\n    console.log(`${fn.description},returned:${fn(6)}`)\n}\n\ndoSomething(fn)\n\n\n注意这个语法跟函数类型表达式稍有不同，在参数列表和返回的类型之间用的是 : 而不是 =>。\n\n\n# 构造签名\n\nJavaScript 函数也可以使用 new 操作符调用，当被调用的时候，TypeScript 会认为这是一个构造函数( constructors (构造函数) )，因为他们会产生一个新对象。你可以写一个构造签名，方法是在调用签名前面加一个 new 关键词：\n\ntype SomeConstructor = {\n    new (s: string): SomeObject\n}\nfunction fn(ctor: SomeConstructor) {\n    return new ctor('hello')\n}\n\n\n\n# 索引签名\n\n有的时候，你不能提前知道一个类型里的所有属性的名字，但是你知道这些值的特征。\n\n这种情况，你就可以用一个索引签名 (index signature) 来描述可能的值的类型，举个例子：\n\ninterface StringArray {\n    [index: number]: string\n}\n\nconst myArray: StringArray = getStringArray()\nconst secondItem = myArray[1] // const secondItem: string\n\n\n这样，我们就有了一个具有索引签名的接口 StringArray，这个索引签名表示当一个 StringArray 类型的值使用 number 类型的值进行索引的时候，会返回一个 string类型的值。\n\n\n# 双重断言\n\n利用双重断言可以完成一些不可能的类型转换，虽然没什么卵用\n\nlet x = '123' as any as number // x:number\n\n\n\n# 常量断言\n\n常量断言，可以用于断言任何一个类型：\n\nconst frank = {\n    age: 22,\n    hobby: 'js',\n} as const\n\ninterface Isetting {\n    align: 'center' | 'left' | 'right'\n    padding: number\n}\n\nfunction layout(setting: Isetting) {\n    console.log('Layout', setting)\n}\n\nconst paramer = {\n    align: 'left' as const,\n    padding: 0,\n}\nlayout(paramer)\n\n\n在大部分的代码中，元组只是被创建，使用完后也不会被修改，所以尽可能的将元组设置为 readonly 是一个好习惯。\n\nlet t1: readonly [string, number] = ['123', 123]\n\n\n\n# typeof 操作符\n\nTypeScript 添加的 typeof 方法可以在类型上下文（type context）中使用，用于获取一个变量或者属性的类型\n\nlet s = 'hello'\nlet n: typeof s\n// let n: string\n\n\n\n# keyof 操作符\n\n对一个对象类型使用 keyof 操作符，会返回该对象属性名组成的一个字符串或者数字字面量的联合。这个例子中的类型 P 就等同于 \"x\" | \"y\"：\n\ntype Point = { x: number; y: number }\ntype P = keyof Point\n\n\n\n# 类型查找\n\n我们可以使用类型查找 查找另外一个类型上的特定属性：\n\ntype Person = { age: number; name: string; alive: boolean }\ntype Age = Person['age']\n// type Age = number\n\n\n复制代码\n\n因为索引名本身就是一个类型，所以我们也可以使用联合、keyof 或者其他类型：\n\ntype I1 = Person['age' | 'name']\n// type I1 = string | number\n\ntype I2 = Person[keyof Person]\n// type I2 = string | number | boolean\n\ntype AliveOrName = 'alive' | 'name'\ntype I3 = Person[AliveOrName]\n// type I3 = string | boolean\n\n\n\n# 类型映射\n\n有的时候，一个类型需要基于另外一个类型，但是你又不想拷贝一份，这个时候可以考虑使用映射类型。\n\ntype Point2D = {\n    x: number\n    y: number\n}\n\ntype Point3D = {\n    [key in keyof Point2D]: number\n} & {\n    z: number\n}\n\nlet p2: Point3D = { x: 1, y: 2, z: 3 }\n\n\n\n# 映射修饰符\n\n在使用类型映射时，有两个额外的修饰符可能会用到，一个是 readonly，用于设置属性只读，一个是 ? ，用于设置属性可选。\n\n你可以通过前缀 - 或者 + 删除或者添加这些修饰符，如果没有写前缀，相当于使用了 + 前缀。\n\n// 删除属性中的只读属性\ntype CreateMutable<Type> = {\n    -readonly [Property in keyof Type]: Type[Property]\n}\n\ntype LockedAccount = {\n    readonly id: string\n    readonly name: string\n}\n\ntype UnlockedAccount = CreateMutable<LockedAccount>\n\n// type UnlockedAccount = {\n//    id: string;\n//    name: string;\n// }\n\n\n// 删除属性中的可选属性\ntype Concrete<Type> = {\n    [Property in keyof Type]-?: Type[Property]\n}\n\ntype MaybeUser = {\n    id: string\n    name?: string\n    age?: number\n}\n\ntype User = Concrete<MaybeUser>\n// type User = {\n//    id: string;\n//    name: string;\n//    age: number;\n// }\n",normalizedContent:"# 类型别名\n\n类型别名用来给一个类型起个新名字。\n\ntype name = string\ntype nameresolver = () => string\ntype nameorresolver = name | nameresolver\nfunction getname(n: nameorresolver): name {\n    if (typeof n === 'string') {\n        return n\n    } else {\n        return n()\n    }\n}\n\n\n上例中，我们使用 type 创建类型别名。\n\n类型别名常用于联合类型。\n\n\n# 类型别名与接口的区别\n\n# 相同点\n\n都可以描述一个对象或者函数：\n\ninterface\n\ninterface user {\n    name: string\n    age: number\n}\n\ninterface setuser {\n    (name: string, age: number): void\n}\n\n\ntype\n\ntype user = {\n    name: string\n    age: number\n}\n\ntype setuser = (name: string, age: number) => void\n\n\n都允许拓展（extends）：\n\nterface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。\n\ninterface extends interface\n\ninterface name {\n    name: string\n}\ninterface user extends name {\n    age: number\n}\n\n\ntype extends type\n\ntype name = {\n    name: string\n}\ntype user = name & { age: number }\n\n\ninterface extends type\n\ntype name = {\n    name: string\n}\ninterface user extends name {\n    age: number\n}\n\n\ntype extends interface\n\ninterface name {\n    name: string\n}\ntype user = name & {\n    age: number\n}\n\n\n# 不同点\n\ntype 可以而 interface 不行：\n\n * type 可以声明基本类型别名，联合类型，元组等类型\n\n// 基本类型别名\ntype name = string\n\n// 联合类型\ninterface dog {\n    wong()\n}\ninterface cat {\n    miao()\n}\n\ntype pet = dog | cat\n\n// 具体定义数组每个位置的类型\ntype petlist = [dog, pet]\n\n\n * type 语句中还可以使用 typeof 获取实例的 类型进行赋值\n\n// 当你想获取一个变量的类型时，使用 typeof\nlet div = document.createelement('div')\ntype b = typeof div\n\n\ninterface 可以而 type 不行：\n\ninterface 能够声明合并\n\ninterface user {\n    name: string\n    age: number\n}\n\ninterface user {\n    sex: string\n}\n\n/*\nuser 接口为 {\n  name: string\n  age: number\n  sex: string \n}\n*/\n\n\n用 interface 描述数据结构，用 type 描述类型关系\n\n\n# 类型保护\n\ntypescript-typeguard\n\nis 是 typescript 中的一个关键字，一般用于函数返回值类型中，判断参数是否属于某一类型，并根据结果返回对应的布尔类型\n\ntype square = {\n    size: number\n}\ntype rectangle = {\n    width: number\n    height: number\n}\n\nfunction issquare(shape: shape): shape is square {\n    return 'size' in shape\n}\n\nfunction isrectangle(shape: shape): shape is rectangle {\n    return 'width' in shape\n}\n\ntype shape = square | rectangle\n\nfunction area(shape: shape) {\n    if (issquare(shape)) return shape.size * shape.size\n    if (isrectangle(shape)) return shape.width * shape.height\n}\n\n\n\n# 函数重载\n\nts 中几种函数重载\n\n重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n\n比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 'hello' 的时候，输出反转的字符串 'olleh'。\n\n利用联合类型，我们可以这么实现：\n\nfunction reverse(x: number | string): number | string | void {\n    if (typeof x === 'number') {\n        return number(x.tostring().split('').reverse().join(''))\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('')\n    }\n}\n\n\n然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。\n\n这时，我们可以使用重载定义多个 reverse 的函数类型：\n\nfunction reverse(x: number): number // 重载签名\nfunction reverse(x: string): string // 重载签名\nfunction reverse(x: number | string): number | string | void { // 实现签名\n    if (typeof x === 'number') {\n        return number(x.tostring().split('').reverse().join(''))\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('')\n    }\n}\n\n\n上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。\n\n注意，typescript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。\n\n\n# 方法重载\n\n下面来实现一个方法重载 以 arraylist 为例,可以查看数据,可以删除数据,删除可以通过 id 或者对象删除可以获取数据\n\nclass arraylist {\n    constructor(public element: object[]) {}\n    /**\n     * 获取某一个值\n     * @param index\n     * @returns\n     */\n    get(index: number) {\n        return this.element[index]\n    }\n    // 显示值\n    show() {\n        this.element.foreach(i => console.log(i))\n    }\n\n    remove(val: number): number\n    remove(val: object): object // 实现删除方法重载\n\n    remove(val: number | object) {\n        this.element = this.element.filter((e, index) => {\n            if (typeof val === 'number') {\n                return val !== index\n            } else {\n                return val !== e\n            }\n        })\n        return val\n    }\n}\nlet a = { name: 'zixia', age: 12 },\n    b = { name: 'selfsummer', age: 88 },\n    c = { name: '自夏', age: 18 }\n\nlet newar = new arraylist([a, b, c])\n\nnewar.remove(1)\nnewar.remove(c)\nconsole.log(newar)\n\n\n\n# 构造器重载\n\n// 类型别名\ntype typewowen = {\n    name: string\n    age: number\n}\n\nclass wowen {\n    name: string\n    age: number\n    constructor(age: number, name?: string)\n    constructor(paramobj: typewowen)\n    constructor(paramobj: any, name = '未知') {\n        if (typeof paramobj === 'object') {\n            const { name, age } = paramobj\n            this.name = name\n            this.age = age\n        } else {\n            this.age = paramobj\n            this.name = name\n        }\n    }\n}\nconst w1 = new wowen({ name: 'frank', age: 123 })\nconst w2 = new wowen(123, 'frank')\n// const w3 = new wowen({ name: 'frank', age: 123 }, 123)\n\nconsole.log(w1)\nconsole.log(w2)\nconsole.log(w3)\n\n\n\n# 调用签名\n\n\n# 函数类型表达式\n\n最简单描述一个函数的方式是使用**函数类型表达式（function type expression）。**它的写法有点类似于箭头函数：\n\nfunction greeter(fn: (a: string) => void) {\n    fn('hello, world')\n}\n\nfunction printtoconsole(s: string) {\n    console.log(s)\n}\n\ngreeter(printtoconsole)\n\n\n语法 (a: string) => void 表示一个函数有一个名为 a ，类型是字符串的参数，这个函数并没有返回任何值。\n\n如果一个函数参数的类型并没有明确给出，它会被隐式设置为 any。\n\n当然了，我们也可以使用类型别名 定义一个函数类型：\n\ntype greetfunction = (a: string) => void\nfunction greeter(fn: greetfunction) {\n    // ...\n}\n\n\n在 javascript 中，函数除了可以被调用，自己也是可以有属性值的。然而函数类型表达式并不能支持声明属性，如果我们想描述一个带有属性的函数，我们可以在一个对象类型中写一个调用签名（call signature）\n\ntype describablefunction = {\n    description: string\n    (somearg: number): boolean\n}\nconst fn: describablefunction = somearg => {\n    return somearg > 0\n}\n\nfn.description = '是否大于0'\n\nfunction dosomething(fn: describablefunction) {\n    console.log(`${fn.description},returned:${fn(6)}`)\n}\n\ndosomething(fn)\n\n\n注意这个语法跟函数类型表达式稍有不同，在参数列表和返回的类型之间用的是 : 而不是 =>。\n\n\n# 构造签名\n\njavascript 函数也可以使用 new 操作符调用，当被调用的时候，typescript 会认为这是一个构造函数( constructors (构造函数) )，因为他们会产生一个新对象。你可以写一个构造签名，方法是在调用签名前面加一个 new 关键词：\n\ntype someconstructor = {\n    new (s: string): someobject\n}\nfunction fn(ctor: someconstructor) {\n    return new ctor('hello')\n}\n\n\n\n# 索引签名\n\n有的时候，你不能提前知道一个类型里的所有属性的名字，但是你知道这些值的特征。\n\n这种情况，你就可以用一个索引签名 (index signature) 来描述可能的值的类型，举个例子：\n\ninterface stringarray {\n    [index: number]: string\n}\n\nconst myarray: stringarray = getstringarray()\nconst seconditem = myarray[1] // const seconditem: string\n\n\n这样，我们就有了一个具有索引签名的接口 stringarray，这个索引签名表示当一个 stringarray 类型的值使用 number 类型的值进行索引的时候，会返回一个 string类型的值。\n\n\n# 双重断言\n\n利用双重断言可以完成一些不可能的类型转换，虽然没什么卵用\n\nlet x = '123' as any as number // x:number\n\n\n\n# 常量断言\n\n常量断言，可以用于断言任何一个类型：\n\nconst frank = {\n    age: 22,\n    hobby: 'js',\n} as const\n\ninterface isetting {\n    align: 'center' | 'left' | 'right'\n    padding: number\n}\n\nfunction layout(setting: isetting) {\n    console.log('layout', setting)\n}\n\nconst paramer = {\n    align: 'left' as const,\n    padding: 0,\n}\nlayout(paramer)\n\n\n在大部分的代码中，元组只是被创建，使用完后也不会被修改，所以尽可能的将元组设置为 readonly 是一个好习惯。\n\nlet t1: readonly [string, number] = ['123', 123]\n\n\n\n# typeof 操作符\n\ntypescript 添加的 typeof 方法可以在类型上下文（type context）中使用，用于获取一个变量或者属性的类型\n\nlet s = 'hello'\nlet n: typeof s\n// let n: string\n\n\n\n# keyof 操作符\n\n对一个对象类型使用 keyof 操作符，会返回该对象属性名组成的一个字符串或者数字字面量的联合。这个例子中的类型 p 就等同于 \"x\" | \"y\"：\n\ntype point = { x: number; y: number }\ntype p = keyof point\n\n\n\n# 类型查找\n\n我们可以使用类型查找 查找另外一个类型上的特定属性：\n\ntype person = { age: number; name: string; alive: boolean }\ntype age = person['age']\n// type age = number\n\n\n复制代码\n\n因为索引名本身就是一个类型，所以我们也可以使用联合、keyof 或者其他类型：\n\ntype i1 = person['age' | 'name']\n// type i1 = string | number\n\ntype i2 = person[keyof person]\n// type i2 = string | number | boolean\n\ntype aliveorname = 'alive' | 'name'\ntype i3 = person[aliveorname]\n// type i3 = string | boolean\n\n\n\n# 类型映射\n\n有的时候，一个类型需要基于另外一个类型，但是你又不想拷贝一份，这个时候可以考虑使用映射类型。\n\ntype point2d = {\n    x: number\n    y: number\n}\n\ntype point3d = {\n    [key in keyof point2d]: number\n} & {\n    z: number\n}\n\nlet p2: point3d = { x: 1, y: 2, z: 3 }\n\n\n\n# 映射修饰符\n\n在使用类型映射时，有两个额外的修饰符可能会用到，一个是 readonly，用于设置属性只读，一个是 ? ，用于设置属性可选。\n\n你可以通过前缀 - 或者 + 删除或者添加这些修饰符，如果没有写前缀，相当于使用了 + 前缀。\n\n// 删除属性中的只读属性\ntype createmutable<type> = {\n    -readonly [property in keyof type]: type[property]\n}\n\ntype lockedaccount = {\n    readonly id: string\n    readonly name: string\n}\n\ntype unlockedaccount = createmutable<lockedaccount>\n\n// type unlockedaccount = {\n//    id: string;\n//    name: string;\n// }\n\n\n// 删除属性中的可选属性\ntype concrete<type> = {\n    [property in keyof type]-?: type[property]\n}\n\ntype maybeuser = {\n    id: string\n    name?: string\n    age?: number\n}\n\ntype user = concrete<maybeuser>\n// type user = {\n//    id: string;\n//    name: string;\n//    age: number;\n// }\n",charsets:{cjk:!0},lastUpdated:"2022年05月24日",lastUpdatedTimestamp:1653404643e3},{title:"AntDesgin组件库",frontmatter:{title:"AntDesgin组件库",date:"2022/05/15 15:39:39",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/AntDesgin%E7%BB%84%E4%BB%B6%E5%BA%93.html",relativePath:"前端开发/前端框架/React/AntDesgin组件库.md",key:"v-dd911646",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/AntDesgin%E7%BB%84%E4%BB%B6%E5%BA%93.html",headers:[{level:2,title:"AntDesign的安装",slug:"antdesign的安装",normalizedTitle:"antdesign的安装",charIndex:191},{level:2,title:"craco",slug:"craco",normalizedTitle:"craco",charIndex:311},{level:3,title:"使用craco",slug:"使用craco",normalizedTitle:"使用craco",charIndex:436},{level:3,title:"配置主题",slug:"配置主题",normalizedTitle:"配置主题",charIndex:762},{level:3,title:"配置别名",slug:"配置别名",normalizedTitle:"配置别名",charIndex:777}],headersStr:"AntDesign的安装 craco 使用craco 配置主题 配置别名",content:'官方网站\n\n国内镜像\n\nAntDesign ，简称 antd 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。\n\n中后台的产品 属于工具性产品，很多优秀的设计团队通过自身的探索和积累，形成了自己的设计体系。\n\nAntDesign的兼容性：现代浏览器和 IE11（需要 polyfills）,支持服务端渲染,Electron\n\n\n# AntDesign的安装\n\n 1. yarn add antd\n\n 2. 我们需要在index.js中引入全局的Antd样式：import "antd/dist/antd.css";\n\n 3. 在App.js中就可以使用一些组件了\n\n\n# craco\n\n上面的使用过程是无法对主题进行配置的，好像对主题等相关的高级特性进行配置，需要修改create-react-app 的默认配置。\n\n如何修改create-react-app 的默认配置呢？craco；（目前antd推荐的方案）\n\n\n# 使用craco\n\n 1. yarn add @craco/craco\n 2. 修改package.json文件\n\n"scripts": {\n- "start": "react-scripts start",\n- "build": "react-scripts build",\n- "test": "react-scripts test", \n+ "start": "craco start", \n+ "build": "craco build", \n+ "test": "craco test", \n}\n\n\n 3. 在根目录下创建craco.config.js文件用于修改默认配置\n\nmodule.exports = { // 配置文件 }\n\n\n\n# 配置主题\n\n官方文档\n\n\n# 配置别名\n\n配置别名也需要修改webpack的配置，当然我们也可以借助于 craco 来完成：\n\nconst path = require("path");\nconst resolve = dir => path.resolve(__dirname, dir);\n\nmodule.exports = {\n    webpack: {\n        alias: {\n            \'@\': resolve("src")\n        }\n    }\n\n\n在导入时就可以按照下面的方式来使用了：\n\nimport HYCommentInput from \'@/components/comment-input\'; \n',normalizedContent:'官方网站\n\n国内镜像\n\nantdesign ，简称 antd 是基于 ant design 设计体系的 react ui 组件库，主要用于研发企业级中后台产品。\n\n中后台的产品 属于工具性产品，很多优秀的设计团队通过自身的探索和积累，形成了自己的设计体系。\n\nantdesign的兼容性：现代浏览器和 ie11（需要 polyfills）,支持服务端渲染,electron\n\n\n# antdesign的安装\n\n 1. yarn add antd\n\n 2. 我们需要在index.js中引入全局的antd样式：import "antd/dist/antd.css";\n\n 3. 在app.js中就可以使用一些组件了\n\n\n# craco\n\n上面的使用过程是无法对主题进行配置的，好像对主题等相关的高级特性进行配置，需要修改create-react-app 的默认配置。\n\n如何修改create-react-app 的默认配置呢？craco；（目前antd推荐的方案）\n\n\n# 使用craco\n\n 1. yarn add @craco/craco\n 2. 修改package.json文件\n\n"scripts": {\n- "start": "react-scripts start",\n- "build": "react-scripts build",\n- "test": "react-scripts test", \n+ "start": "craco start", \n+ "build": "craco build", \n+ "test": "craco test", \n}\n\n\n 3. 在根目录下创建craco.config.js文件用于修改默认配置\n\nmodule.exports = { // 配置文件 }\n\n\n\n# 配置主题\n\n官方文档\n\n\n# 配置别名\n\n配置别名也需要修改webpack的配置，当然我们也可以借助于 craco 来完成：\n\nconst path = require("path");\nconst resolve = dir => path.resolve(__dirname, dir);\n\nmodule.exports = {\n    webpack: {\n        alias: {\n            \'@\': resolve("src")\n        }\n    }\n\n\n在导入时就可以按照下面的方式来使用了：\n\nimport hycommentinput from \'@/components/comment-input\'; \n',charsets:{cjk:!0},lastUpdated:"2022年05月17日",lastUpdatedTimestamp:1652802362e3},{title:"JSX核心语法",frontmatter:{title:"JSX核心语法",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/JSX%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95.html",relativePath:"前端开发/前端框架/React/JSX核心语法.md",key:"v-132c28d6",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/JSX%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95.html",headers:[{level:2,title:"认识 JSX",slug:"认识-jsx",normalizedTitle:"认识 jsx",charIndex:403},{level:2,title:"JSX 的书写规范",slug:"jsx-的书写规范",normalizedTitle:"jsx 的书写规范",charIndex:641},{level:2,title:"JSX 中的注释",slug:"jsx-中的注释",normalizedTitle:"jsx 中的注释",charIndex:923},{level:2,title:"JSX 嵌入变量",slug:"jsx-嵌入变量",normalizedTitle:"jsx 嵌入变量",charIndex:957},{level:2,title:"JSX 嵌入表达式",slug:"jsx-嵌入表达式",normalizedTitle:"jsx 嵌入表达式",charIndex:1295},{level:2,title:"JSX 绑定属性",slug:"jsx-绑定属性",normalizedTitle:"jsx 绑定属性",charIndex:1663},{level:2,title:"React 事件绑定",slug:"react-事件绑定",normalizedTitle:"react 事件绑定",charIndex:3308},{level:3,title:"this 的绑定问题",slug:"this-的绑定问题",normalizedTitle:"this 的绑定问题",charIndex:3607},{level:3,title:"事件参数传递",slug:"事件参数传递",normalizedTitle:"事件参数传递",charIndex:4052},{level:2,title:"React 条件渲染",slug:"react-条件渲染",normalizedTitle:"react 条件渲染",charIndex:4854},{level:2,title:"React 列表渲染",slug:"react-列表渲染",normalizedTitle:"react 列表渲染",charIndex:5642}],headersStr:"认识 JSX JSX 的书写规范 JSX 中的注释 JSX 嵌入变量 JSX 嵌入表达式 JSX 绑定属性 React 事件绑定 this 的绑定问题 事件参数传递 React 条件渲染 React 列表渲染",content:"<body>\n<div id=\"app\"></div>\n\x3c!-- 使用jsx，并且希望script中的代码被解析，必须在script标签中添加一个属性 --\x3e\n<script type=\"text/babel\">\n    const element = <h2>hello world！</h2>\n    ReactDOM.render(element, document.getElementById('app'));\n<\/script>\n</body>\n\n\n这段 element 变量的声明右侧赋值的标签语法是什么呢？\n\n * 它不是一段字符串（因为没有使用引号包裹），它看起来是一段 HTML原生，但是我们能在 js中直接给一个变量赋值html 吗？其实是不可以的，如果我们将 type=\"text/babel\" 去除掉，那么就会出现语法错误\n * 它到底是什么呢？其实它是一段jsx的语法\n\n\n# 认识 JSX\n\n * JSX是一种JavaScript的语法扩展extension，也在很多地方称之为 JavaScript XML，因为看起就是一段XML 语法\n * 它用于描述我们的 UI界面，并且其完全可以和 JavaScript融合在一起使用\n * 它不同于 Vue中的模块语法，你不需要专门学习模板语法中的一些指令（比如 v-for、v-if、v-else、v-bind）\n\n在这里，我们只需要知道，JSX 其实是嵌入到JavaScript中的一种结构语法\n\n\n# JSX 的书写规范\n\n * JSX的顶层只能有一个根元素，所以我们很多时候会在外层包裹一个 div 原生\n\n * 为了方便阅读，我们通常在 jsx的外层包裹一个小括号()，这样可以方便阅读，并且 jsx可以进行换行书写\n\n            render(){\n                return (\n                <div>'hello,world'</div>\n                )\n            }\n\n\n * JSX 中的标签可以是单标签，也可以是双标签(注意：如果是单标签，必须以/>结尾)\n\n\n# JSX 中的注释\n\n{\n    /*我是一段注释*/\n}\n\n\n\n# JSX 嵌入变量\n\n * 情况一：当变量是Number、String、Array类型时，可以直接显示\n\nrender(){\n    return (\n    <div>\n    <h2>{this.state.arr}<h2>\n    </div>\n    )\n}\n\n\n * 情况二：当变量是null、undefined、Boolean类型时，内容为空；\n   \n   * 如果希望可以显示 null、undefined、Boolean，那么需要转成字符串；\n   * 转换的方式有很多，比如toString 方法、和空字符串拼接，String(变量)等方式\n\n情况三：对象类型不能显示(Objects are not valid as a React child)\n\n\n# JSX 嵌入表达式\n\n * 运算表达式\n * 三元运算符\n * 执行一个函数\n\nclass App extends React.Component {\n    constructor() {\n        super()\n        this.state = {\n            xing: 'zhang',\n            ming: 'fanhang',\n        }\n    }\n    render() {\n        return <div>{this.getFullName()}</div> /*执行一个函数*/\n    }\n    getFullName() {\n        return this.state.xing + this.state.ming\n    }\n}\n\n\n\n# JSX 绑定属性\n\n * 比如元素都会有 title 属性\n\n<div title={this.state.title}></div>\n\n\n * 比如 img元素会有 src属性(有坑注意 ⚠️)\n * 比如 a 元素会有 href 属性\n * 比如元素可能需要绑定 class\n\n注意\n\n这里必须写className,不能写class\n\n绑定普通类名：\n\n<div className=\"active\"></div>\n\n\n动态添加类名:\n\n  ......\n\n    <style>\n        .active{\n            color:red\n        }\n        .fz30{\n            font-size:30px\n        }\n    </style>\n\n    ......\n\n\n<div  className={'fz30 ' + (this.state.active?'active':'')}>'hello,world'</div>\n\n\nReact在JSX给了我们开发者足够多的灵活性，你可以像编写JavaScript代码一样，通过一些逻辑来决定是否添加某些class\n\n这个时候我们可以借助于一个第三方的库：classnames 很明显，这是一个用于动态添加classnames的一个库\n\nclassNames('foo', 'bar'); // => 'foo bar'\nclassNames('foo', { bar: true }); // => 'foo bar'\nclassNames({ 'foo-bar': true }); // => 'foo-bar'\nclassNames({ 'foo-bar': false }); // => ''\nclassNames({ foo: true }, { bar: true }); // => 'foo bar'\nclassNames({ foo: true, bar: true }); // => 'foo bar'\n\n// lots of arguments of various types\nclassNames('foo', { bar: true, duck: false }, 'baz', { quux: true }); // => 'foo bar baz quux'\n\n// other falsy values are just ignored\nclassNames(null, false, 'bar', undefined, 0, 1, { baz: null }, ''); // => 'bar 1'\n\n// Arrays will be recursively flattened (扁平化) as per the rules above:\nvar arr = ['b', { c: true, d: false }];\nclassNames('a', arr); // => 'a b c'\n\n// If you're in an environment that supports computed (计算) keys (available in ES2015 and Babel) you can use dynamic class names\nlet buttonType = 'primary';\nclassNames({ [`btn-${buttonType}`]: true });\n\n\n * 比如原生使用内联样式style\n   \n   注意\n   \n   在 jsx中书写css 属性时，必须使用小驼峰：font-size 必须写为 fontSize，且必须为JavaScript 样式对象\n\n<img style={{ width: '140px', height: '140px' }} />\n\n\n\n# React 事件绑定\n\n如果原生 DOM 原生有一个监听事件，我们可以如何操作呢？\n\n方式一：获取 DOM原生，添加监听事件:object.onclick=function(){SomeJavaScriptCode}\n\n方式二：在 HTML原生中，直接绑定 onclick:<element onclick=\"SomeJavaScriptCode\" />\n\n在 React中是如何操作呢？\n\n我们来实现一下 React中的事件监听，这里主要有两点不同\n\nReact事件的命名采用小驼峰式camelCase，而不是纯小写\n\n我们需要通过{}传入一个事件处理函数，这个函数会在事件发生时被执行\n\n\n# this 的绑定问题\n\n在事件执行后，我们可能需要获取当前类的对象中相关的属性，这个时候需要用到this\n\n如果我们这里直接打印this，也会发现它是一个 undefined\n\n为什么是 undefined 呢？\n\n原因是 btnClick函数并不是我们主动调用的，而且当 button发生改变时，React内部调用了 btnClick 函数\n\n而它内部调用时，并不知道要如何绑定正确的 this\n\n如何解决 this 的问题呢？\n\n方案一：bind 给 btnClick 显示绑定 this\n\n<button onClick={this.btnClick.bind(this)}>Click</button>\n\n\n方案二：事件监听时传入箭头函数（推荐）\n\n// this 为上一层render() 函数的this\n<button\n    onClick={() => {\n        this.btnClick()\n    }}\n>\n    Click\n</button>\n\n\n\n# 事件参数传递\n\n官方文档:向事件处理程序传递参数\n\n在执行事件函数时，有可能我们需要获取一些参数信息：比如 event 对象、其他参数\n\n情况一：获取 event 对象\n\n * 很多时候我们需要拿到 event 对象来做一些事情（比如阻止默认行为）\n\n * 假如我们用不到this，那么直接传入函数就可以获取到 event 对象\n\n            render() {\n                return (\n                    <div>\n                        <div>'hello,world'</div>\n                        <button onClick={this.btnClick}>click</button>\n                    </div>\n                )\n            }\n            btnClick(event) {\n                console.log(event)\n            }\n\n\n情况二：获取更多参数 有更多参数时，我们最好的方式就是通过箭头函数的方式，此时事件对象必须显式的进行传递\n\n<button\n    onClick={event => {\n        this.btnClick(item, index, event)\n    }}\n>\n    Click\n</button>\n\n\n当然下面这种方式也是可以的，注意这里不要显式传入event参数,通过 bind 的方式，事件对象会被作为最后一个参数隐式的进行传递\n\n<button onClick={this.btnClick.bind(this, item, index)}>Click</button>\n\n\n\n# React 条件渲染\n\n某些情况下，界面的内容会根据不同的情况显示不同的内容，或者决定是否渲染某部分内容：\n\n * 在 vue中，我们会通过指令来控制：比如v-if、v-show\n * 在 React 中，所有的条件判断都和普通的 JavaScript 代码一致\n\n常见的条件渲染的方式有哪些呢？\n\n 1. 条件判断语句:适合逻辑较多的情况\n\nlet welcome = null\nif (this.state.isLogin) {\n    welcome = '欢迎回来'\n} else {\n    welcome = '马上登录'\n}\nreturn <div>{welcome}</div>\n\n\n 2. 三元运算符:适合逻辑比较简单\n\nreturn <div>{this.state.isLogin ? '欢迎回来' : '马上登录'}</div>\n\n\n 3. 与运算符&&: 适合如果条件成立，渲染某一个组件；如果条件不成立，什么内容也不渲染；\n\n// ...\nclass App extends React.Component {\n    constructor() {\n        super()\n        this.state = {\n            login: true,\n        }\n    }\n    render() {\n        const login = this.state.login\n        return <div>{login && <IsLogin />}</div>\n    }\n}\n\n\nv-show 的效果:主要是控制 display 属性是否为 none\n\n<h2 style={{ display: isLogin ? 'block' : 'false' }}>欢迎回来</h2>\n\n\n\n# React 列表渲染\n\n在 React中并没有像 Vue模版语法中的 v-for指令，而且需要我们通过JavaScript代码的方式组织数据，转成JSX：\n\n在 React 中，展示列表最多的方式就是使用数组的 map高阶函数:\n\nclass App extends React.Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            movie: ['流浪地球', '长津湖', '信条', '肖生客的救赎'],\n        }\n    }\n    render() {\n        return (\n            <div>\n                <ul>\n                    {this.state.movie.map(item => {\n                        return <li>{item}</li>\n                    })}\n                </ul>\n            </div>\n        )\n    }\n}\nReactDOM.render(<App />, document.getElementById('app'))\n\n\n很多时候我们在展示一个数组中的数据之前，需要先对它进行一些处理：\n\n比如过滤掉一些内容：filter 函数\n\n比如截取数组中的一部分内容：slice 函数",normalizedContent:"<body>\n<div id=\"app\"></div>\n\x3c!-- 使用jsx，并且希望script中的代码被解析，必须在script标签中添加一个属性 --\x3e\n<script type=\"text/babel\">\n    const element = <h2>hello world！</h2>\n    reactdom.render(element, document.getelementbyid('app'));\n<\/script>\n</body>\n\n\n这段 element 变量的声明右侧赋值的标签语法是什么呢？\n\n * 它不是一段字符串（因为没有使用引号包裹），它看起来是一段 html原生，但是我们能在 js中直接给一个变量赋值html 吗？其实是不可以的，如果我们将 type=\"text/babel\" 去除掉，那么就会出现语法错误\n * 它到底是什么呢？其实它是一段jsx的语法\n\n\n# 认识 jsx\n\n * jsx是一种javascript的语法扩展extension，也在很多地方称之为 javascript xml，因为看起就是一段xml 语法\n * 它用于描述我们的 ui界面，并且其完全可以和 javascript融合在一起使用\n * 它不同于 vue中的模块语法，你不需要专门学习模板语法中的一些指令（比如 v-for、v-if、v-else、v-bind）\n\n在这里，我们只需要知道，jsx 其实是嵌入到javascript中的一种结构语法\n\n\n# jsx 的书写规范\n\n * jsx的顶层只能有一个根元素，所以我们很多时候会在外层包裹一个 div 原生\n\n * 为了方便阅读，我们通常在 jsx的外层包裹一个小括号()，这样可以方便阅读，并且 jsx可以进行换行书写\n\n            render(){\n                return (\n                <div>'hello,world'</div>\n                )\n            }\n\n\n * jsx 中的标签可以是单标签，也可以是双标签(注意：如果是单标签，必须以/>结尾)\n\n\n# jsx 中的注释\n\n{\n    /*我是一段注释*/\n}\n\n\n\n# jsx 嵌入变量\n\n * 情况一：当变量是number、string、array类型时，可以直接显示\n\nrender(){\n    return (\n    <div>\n    <h2>{this.state.arr}<h2>\n    </div>\n    )\n}\n\n\n * 情况二：当变量是null、undefined、boolean类型时，内容为空；\n   \n   * 如果希望可以显示 null、undefined、boolean，那么需要转成字符串；\n   * 转换的方式有很多，比如tostring 方法、和空字符串拼接，string(变量)等方式\n\n情况三：对象类型不能显示(objects are not valid as a react child)\n\n\n# jsx 嵌入表达式\n\n * 运算表达式\n * 三元运算符\n * 执行一个函数\n\nclass app extends react.component {\n    constructor() {\n        super()\n        this.state = {\n            xing: 'zhang',\n            ming: 'fanhang',\n        }\n    }\n    render() {\n        return <div>{this.getfullname()}</div> /*执行一个函数*/\n    }\n    getfullname() {\n        return this.state.xing + this.state.ming\n    }\n}\n\n\n\n# jsx 绑定属性\n\n * 比如元素都会有 title 属性\n\n<div title={this.state.title}></div>\n\n\n * 比如 img元素会有 src属性(有坑注意 ⚠️)\n * 比如 a 元素会有 href 属性\n * 比如元素可能需要绑定 class\n\n注意\n\n这里必须写classname,不能写class\n\n绑定普通类名：\n\n<div classname=\"active\"></div>\n\n\n动态添加类名:\n\n  ......\n\n    <style>\n        .active{\n            color:red\n        }\n        .fz30{\n            font-size:30px\n        }\n    </style>\n\n    ......\n\n\n<div  classname={'fz30 ' + (this.state.active?'active':'')}>'hello,world'</div>\n\n\nreact在jsx给了我们开发者足够多的灵活性，你可以像编写javascript代码一样，通过一些逻辑来决定是否添加某些class\n\n这个时候我们可以借助于一个第三方的库：classnames 很明显，这是一个用于动态添加classnames的一个库\n\nclassnames('foo', 'bar'); // => 'foo bar'\nclassnames('foo', { bar: true }); // => 'foo bar'\nclassnames({ 'foo-bar': true }); // => 'foo-bar'\nclassnames({ 'foo-bar': false }); // => ''\nclassnames({ foo: true }, { bar: true }); // => 'foo bar'\nclassnames({ foo: true, bar: true }); // => 'foo bar'\n\n// lots of arguments of various types\nclassnames('foo', { bar: true, duck: false }, 'baz', { quux: true }); // => 'foo bar baz quux'\n\n// other falsy values are just ignored\nclassnames(null, false, 'bar', undefined, 0, 1, { baz: null }, ''); // => 'bar 1'\n\n// arrays will be recursively flattened (扁平化) as per the rules above:\nvar arr = ['b', { c: true, d: false }];\nclassnames('a', arr); // => 'a b c'\n\n// if you're in an environment that supports computed (计算) keys (available in es2015 and babel) you can use dynamic class names\nlet buttontype = 'primary';\nclassnames({ [`btn-${buttontype}`]: true });\n\n\n * 比如原生使用内联样式style\n   \n   注意\n   \n   在 jsx中书写css 属性时，必须使用小驼峰：font-size 必须写为 fontsize，且必须为javascript 样式对象\n\n<img style={{ width: '140px', height: '140px' }} />\n\n\n\n# react 事件绑定\n\n如果原生 dom 原生有一个监听事件，我们可以如何操作呢？\n\n方式一：获取 dom原生，添加监听事件:object.onclick=function(){somejavascriptcode}\n\n方式二：在 html原生中，直接绑定 onclick:<element onclick=\"somejavascriptcode\" />\n\n在 react中是如何操作呢？\n\n我们来实现一下 react中的事件监听，这里主要有两点不同\n\nreact事件的命名采用小驼峰式camelcase，而不是纯小写\n\n我们需要通过{}传入一个事件处理函数，这个函数会在事件发生时被执行\n\n\n# this 的绑定问题\n\n在事件执行后，我们可能需要获取当前类的对象中相关的属性，这个时候需要用到this\n\n如果我们这里直接打印this，也会发现它是一个 undefined\n\n为什么是 undefined 呢？\n\n原因是 btnclick函数并不是我们主动调用的，而且当 button发生改变时，react内部调用了 btnclick 函数\n\n而它内部调用时，并不知道要如何绑定正确的 this\n\n如何解决 this 的问题呢？\n\n方案一：bind 给 btnclick 显示绑定 this\n\n<button onclick={this.btnclick.bind(this)}>click</button>\n\n\n方案二：事件监听时传入箭头函数（推荐）\n\n// this 为上一层render() 函数的this\n<button\n    onclick={() => {\n        this.btnclick()\n    }}\n>\n    click\n</button>\n\n\n\n# 事件参数传递\n\n官方文档:向事件处理程序传递参数\n\n在执行事件函数时，有可能我们需要获取一些参数信息：比如 event 对象、其他参数\n\n情况一：获取 event 对象\n\n * 很多时候我们需要拿到 event 对象来做一些事情（比如阻止默认行为）\n\n * 假如我们用不到this，那么直接传入函数就可以获取到 event 对象\n\n            render() {\n                return (\n                    <div>\n                        <div>'hello,world'</div>\n                        <button onclick={this.btnclick}>click</button>\n                    </div>\n                )\n            }\n            btnclick(event) {\n                console.log(event)\n            }\n\n\n情况二：获取更多参数 有更多参数时，我们最好的方式就是通过箭头函数的方式，此时事件对象必须显式的进行传递\n\n<button\n    onclick={event => {\n        this.btnclick(item, index, event)\n    }}\n>\n    click\n</button>\n\n\n当然下面这种方式也是可以的，注意这里不要显式传入event参数,通过 bind 的方式，事件对象会被作为最后一个参数隐式的进行传递\n\n<button onclick={this.btnclick.bind(this, item, index)}>click</button>\n\n\n\n# react 条件渲染\n\n某些情况下，界面的内容会根据不同的情况显示不同的内容，或者决定是否渲染某部分内容：\n\n * 在 vue中，我们会通过指令来控制：比如v-if、v-show\n * 在 react 中，所有的条件判断都和普通的 javascript 代码一致\n\n常见的条件渲染的方式有哪些呢？\n\n 1. 条件判断语句:适合逻辑较多的情况\n\nlet welcome = null\nif (this.state.islogin) {\n    welcome = '欢迎回来'\n} else {\n    welcome = '马上登录'\n}\nreturn <div>{welcome}</div>\n\n\n 2. 三元运算符:适合逻辑比较简单\n\nreturn <div>{this.state.islogin ? '欢迎回来' : '马上登录'}</div>\n\n\n 3. 与运算符&&: 适合如果条件成立，渲染某一个组件；如果条件不成立，什么内容也不渲染；\n\n// ...\nclass app extends react.component {\n    constructor() {\n        super()\n        this.state = {\n            login: true,\n        }\n    }\n    render() {\n        const login = this.state.login\n        return <div>{login && <islogin />}</div>\n    }\n}\n\n\nv-show 的效果:主要是控制 display 属性是否为 none\n\n<h2 style={{ display: islogin ? 'block' : 'false' }}>欢迎回来</h2>\n\n\n\n# react 列表渲染\n\n在 react中并没有像 vue模版语法中的 v-for指令，而且需要我们通过javascript代码的方式组织数据，转成jsx：\n\n在 react 中，展示列表最多的方式就是使用数组的 map高阶函数:\n\nclass app extends react.component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            movie: ['流浪地球', '长津湖', '信条', '肖生客的救赎'],\n        }\n    }\n    render() {\n        return (\n            <div>\n                <ul>\n                    {this.state.movie.map(item => {\n                        return <li>{item}</li>\n                    })}\n                </ul>\n            </div>\n        )\n    }\n}\nreactdom.render(<app />, document.getelementbyid('app'))\n\n\n很多时候我们在展示一个数组中的数据之前，需要先对它进行一些处理：\n\n比如过滤掉一些内容：filter 函数\n\n比如截取数组中的一部分内容：slice 函数",charsets:{cjk:!0},lastUpdated:"2022年07月02日",lastUpdatedTimestamp:1656779298e3},{title:"TS面向对象",frontmatter:{title:"TS面向对象",sidebarDepth:2,readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"前端开发/TypeScript/TS面向对象.md",key:"v-f89e44c8",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/TS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",headers:[{level:2,title:"Object",slug:"object",normalizedTitle:"object",charIndex:2},{level:2,title:"Interface",slug:"interface",normalizedTitle:"interface",charIndex:220},{level:3,title:"可选属性",slug:"可选属性",normalizedTitle:"可选属性",charIndex:581},{level:3,title:"任意属性",slug:"任意属性",normalizedTitle:"任意属性",charIndex:752},{level:3,title:"只读属性",slug:"只读属性",normalizedTitle:"只读属性",charIndex:1857},{level:2,title:"Class",slug:"class",normalizedTitle:"class",charIndex:2271},{level:3,title:"基础概念",slug:"基础概念",normalizedTitle:"基础概念",charIndex:2281},{level:3,title:"Access Modifiers",slug:"access-modifiers",normalizedTitle:"access modifiers",charIndex:2949},{level:3,title:"readonly",slug:"readonly",normalizedTitle:"readonly",charIndex:1896},{level:2,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:2794},{level:2,title:"类的类型",slug:"类的类型",normalizedTitle:"类的类型",charIndex:5398},{level:3,title:"类实现接口",slug:"类实现接口",normalizedTitle:"类实现接口",charIndex:5671},{level:2,title:"Generics",slug:"generics",normalizedTitle:"generics",charIndex:6516},{level:3,title:"简单的例子",slug:"简单的例子",normalizedTitle:"简单的例子",charIndex:6588},{level:2,title:"多个类型参",slug:"多个类型参",normalizedTitle:"多个类型参",charIndex:7603},{level:2,title:"泛型约束",slug:"泛型约束",normalizedTitle:"泛型约束",charIndex:7787},{level:2,title:"泛型接口",slug:"泛型接口",normalizedTitle:"泛型接口",charIndex:8975},{level:2,title:"泛型类",slug:"泛型类",normalizedTitle:"泛型类",charIndex:9968},{level:2,title:"泛型参数的默认类型",slug:"泛型参数的默认类型",normalizedTitle:"泛型参数的默认类型",charIndex:10215}],headersStr:"Object Interface 可选属性 任意属性 只读属性 Class 基础概念 Access Modifiers readonly 抽象类 类的类型 类实现接口 Generics 简单的例子 多个类型参 泛型约束 泛型接口 泛型类 泛型参数的默认类型",content:"# Object\n\n在 ts 中对象的定义不是key to value 键值对，而是 key to type 键类型对\n\nconst person: {\n    name: string\n    age: number\n} = {\n    name: 'frank',\n    age: 14,\n}\n// 上面的定义等价于：\nconst person2 = {\n    name: 'zhang',\n    age: 13,\n}\n\n\n\n# Interface\n\n在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型\n\n在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）\n\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述:\n\ninterface IPoint {\n    X: number\n    Y: number\n}\nconst p1: IPoint = {\n    X: 1,\n    Y: 2,\n}\n\n\n定义的变量比接口少了一些属性是不允许的,多一些属性也是不允许的。可见，赋值的时候，变量的形状必须和接口的形状保持一致\n\n\n# 可选属性\n\n有时我们希望不要完全匹配一个形状，那么可以用可选属性：\n\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom'\n};\n\n\n可选属性的含义是该属性可以不存在。这时仍然不允许添加未定义的属性\n\n\n# 任意属性\n\n有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\n\ninterface Person {\n    name: string;\n    age?: number;\n  // 索引签名\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n\n\n使用 [propName: string] 定义了任意属性取 string 类型的值。\n\n需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：\n\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.\n// index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Index signatures are incompatible.\n//     Type 'string | number' is not assignable to type 'string'.\n//       Type 'number' is not assignable to type 'string'.\n\n\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\n\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n\n\n\n# 只读属性\n\n有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：\n\n\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    id: 89757,\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 9527;\n// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\n\n\n上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n\n\n# Class\n\n\n# 基础概念\n\n * 类（Class）：定义了一件事物的抽象特点，包含它的属性和方法\n * 对象（Object）：类的实例，通过 new 生成\n * 面向对象（OOP）的三大特性：封装、继承、多态\n * 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据\n * 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性\n * 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat\n * 存取器（getter & setter）：用以改变属性的读取和赋值行为\n * 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法\n * 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n * 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口\n\n\n# Access Modifiers\n\nTypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。\n\n * public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\n * private 修饰的属性或方法是私有的，不能在声明它的类的外部访问\n * protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的\n\ninterface IPoint {\n    X: number\n    Y: number\n    drawPoint: () => void\n    getDistances: (p: IPoint) => number\n}\nclass Point implements IPoint {\n    constructor(private _x: number, private _y: number) {}\n    drawPoint() {\n        console.log('x：' + this._x, 'y:' + this._y)\n    }\n    getDistances(p: IPoint) {\n        return Math.sqrt((p.X - this._x) ** 2 + (p.Y - this._y) ** 2)\n    }\n    get X() {\n        return this._x\n    }\n    set X(value: number) {\n        if (value < 0) throw new Error('x不能小于0')\n        this._x = value\n    }\n    get Y() {\n        return this._y\n    }\n    set Y(value: number) {\n        if (value < 0) throw new Error('y不能小于0')\n        this._y = value\n    }\n}\n\nconst p1 = new Point(0, -1)\nconst p2 = new Point(0, 2)\n\n\n\n\n# readonly\n\nreadonly 只读属性关键字\n\nclass Animal {\n  readonly name;\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nlet a = new Animal('Jack');\nconsole.log(a.name); // Jack\na.name = 'Tom';\n\n// index.ts(10,3): TS2540: Cannot assign to 'name' because it is a read-only property.\n\n\n注意如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。\n\nclass Animal {\n   constructor(public readonly name) {\n    this.name = name;\n  }\n}\n\n\n\n# 抽象类\n\nabstract 用于定义抽象类和其中的抽象方法。\n\n什么是抽象类？\n\n首先，抽象类是不允许被实例化的：\n\nabstract class Animal {\n  constructor(pubilc name) {\n    this.name = name;\n  }\n   abstract sayHi();\n}\n\nlet a = new Animal('Jack');\n\n// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'.\n\n\n上面的例子中，我们定义了一个抽象类 Animal，并且定义了一个抽象方法 sayHi。在实例化抽象类的时候报错了。\n\n其次，抽象类中的抽象方法必须被子类实现：\n\nabstract class Animal {\n  constructor(public name) {\n    this.name = name;\n  }\n   abstract sayHi();\n}\n\nclass Cat extends Animal {\n  eat() {\n    console.log(`${this.name} is eating.`);\n  }\n}\n\nlet cat = new Cat('Tom');\n\n// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'.\n\n\n上面的例子中，我们定义了一个类 Cat 继承了抽象类 Animal，但是没有实现抽象方法 sayHi，所以编译报错了。\n\n下面是一个正确使用抽象类的例子：\n\nabstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\n\nclass Cat extends Animal {\n  public sayHi() {\n    console.log(`Meow, My name is ${this.name}`);\n  }\n}\n\nlet cat = new Cat('Tom');\n\n\n\n# 类的类型\n\n给类加上 TypeScript 的类型很简单，与接口类似：\n\nclass Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  sayHi(): string {\n    return `My name is ${this.name}`;\n  }\n}\n\nlet a: Animal = new Animal('Jack');\nconsole.log(a.sayHi()); // My name is Jack\n\n\n\n# 类实现接口\n\n实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。\n\n举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：\n\ninterface Alarm {\n    alert(): void;\n}\n\nclass Door {\n}\n\nclass SecurityDoor extends Door implements Alarm {\n    alert() {\n        console.log('SecurityDoor alert');\n    }\n}\n\nclass Car implements Alarm {\n    alert() {\n        console.log('Car alert');\n    }\n}\n\n\n一个类可以实现多个接口：\n\ninterface Alarm {\n    alert(): void;\n}\n\ninterface Light {\n    lightOn(): void;\n    lightOff(): void;\n}\n\nclass Car implements Alarm, Light {\n    alert() {\n        console.log('Car alert');\n    }\n    lightOn() {\n        console.log('Car light on');\n    }\n    lightOff() {\n        console.log('Car light off');\n    }\n}\n\n\n\n# Generics\n\n泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。\n\n\n# 简单的例子\n\n首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：\n\nfunction createArray(length: number, value: any): Array<any> {\n    let result = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n\n\n上例中，我们使用了数组泛型来定义返回值的类型。\n\n这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：\n\nArray<any> 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 value 的类型。\n\n这时候，泛型就派上用场了：\n\nfunction createArray<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray<string>(3, 'x'); // ['x', 'x', 'x']\n\n\n上例中，我们在函数名后添加了 <T>，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array<T> 中即可使用了。\n\n接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来：\n\nfunction createArray<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n\n\n\n# 多个类型参\n\n定义泛型的时候，可以一次定义多个类型参数：\n\nfunction swap<T, U>(tuple: [T, U]): [U, T] {\n    return [tuple[1], tuple[0]];\n}\n\nswap([7, 'seven']); // ['seven', 7]\n\n\n上例中，我们定义了一个 swap 函数，用来交换输入的元组。\n\n\n# 泛型约束\n\n在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：\n\nfunction loggingIdentity<T>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n\n// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'T'.\n\n\n上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。\n\n这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是泛型约束：\n\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n\n\n上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。\n\n此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了：\n\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n\nloggingIdentity(7);\n\n// index.ts(10,17): error TS2345: Argument of type '7' is not assignable to parameter of type 'Lengthwise'.\n\n\n多个类型参数之间也可以互相约束：\n\nfunction copyFields<T extends U, U>(target: T, source: U): T {\n    for (let id in source) {\n        target[id] = (<T>source)[id];\n    }\n    return target;\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ncopyFields(x, { b: 10, d: 20 });\n\n\n上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。\n\n\n# 泛型接口\n\n可以使用接口的方式来定义一个函数需要符合的形状：\n\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n    return source.search(subString) !== -1;\n}\n\n\n当然也可以使用含有泛型的接口来定义函数的形状：\n\ninterface CreateArrayFunc {\n    <T>(length: number, value: T): Array<T>;\n}\n\nlet createArray: CreateArrayFunc;\ncreateArray = function<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n\n\n进一步，我们可以把泛型参数提前到接口名上：\n\ninterface CreateArrayFunc<T> {\n    (length: number, value: T): Array<T>;\n}\n\nlet createArray: CreateArrayFunc<any>;\ncreateArray = function<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n\n\n注意，此时在使用泛型接口的时候，需要定义泛型的类型。\n\n\n# 泛型类\n\n与泛型接口类似，泛型也可以用于类的类型定义中：\n\nclass GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) { return x + y; };\n\n\n\n# 泛型参数的默认类型\n\n在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。\n\nfunction createArray<T = string>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n",normalizedContent:"# object\n\n在 ts 中对象的定义不是key to value 键值对，而是 key to type 键类型对\n\nconst person: {\n    name: string\n    age: number\n} = {\n    name: 'frank',\n    age: 14,\n}\n// 上面的定义等价于：\nconst person2 = {\n    name: 'zhang',\n    age: 13,\n}\n\n\n\n# interface\n\n在 typescript 中，我们使用接口（interfaces）来定义对象的类型\n\n在面向对象语言中，接口（interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）\n\ntypescript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（shape）」进行描述:\n\ninterface ipoint {\n    x: number\n    y: number\n}\nconst p1: ipoint = {\n    x: 1,\n    y: 2,\n}\n\n\n定义的变量比接口少了一些属性是不允许的,多一些属性也是不允许的。可见，赋值的时候，变量的形状必须和接口的形状保持一致\n\n\n# 可选属性\n\n有时我们希望不要完全匹配一个形状，那么可以用可选属性：\n\ninterface person {\n    name: string;\n    age?: number;\n}\n\nlet tom: person = {\n    name: 'tom'\n};\n\n\n可选属性的含义是该属性可以不存在。这时仍然不允许添加未定义的属性\n\n\n# 任意属性\n\n有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\n\ninterface person {\n    name: string;\n    age?: number;\n  // 索引签名\n    [propname: string]: any;\n}\n\nlet tom: person = {\n    name: 'tom',\n    gender: 'male'\n};\n\n\n使用 [propname: string] 定义了任意属性取 string 类型的值。\n\n需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：\n\ninterface person {\n    name: string;\n    age?: number;\n    [propname: string]: string;\n}\n\nlet tom: person = {\n    name: 'tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(3,5): error ts2411: property 'age' of type 'number' is not assignable to string index type 'string'.\n// index.ts(7,5): error ts2322: type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'person'.\n//   index signatures are incompatible.\n//     type 'string | number' is not assignable to type 'string'.\n//       type 'number' is not assignable to type 'string'.\n\n\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\n\ninterface person {\n    name: string;\n    age?: number;\n    [propname: string]: string | number;\n}\n\nlet tom: person = {\n    name: 'tom',\n    age: 25,\n    gender: 'male'\n};\n\n\n\n\n# 只读属性\n\n有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：\n\n\ninterface person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propname: string]: any;\n}\n\nlet tom: person = {\n    id: 89757,\n    name: 'tom',\n    gender: 'male'\n};\n\ntom.id = 9527;\n// index.ts(14,5): error ts2540: cannot assign to 'id' because it is a constant or a read-only property.\n\n\n上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n\n\n# class\n\n\n# 基础概念\n\n * 类（class）：定义了一件事物的抽象特点，包含它的属性和方法\n * 对象（object）：类的实例，通过 new 生成\n * 面向对象（oop）的三大特性：封装、继承、多态\n * 封装（encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据\n * 继承（inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性\n * 多态（polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 cat 和 dog 都继承自 animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 cat 还是 dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat\n * 存取器（getter & setter）：用以改变属性的读取和赋值行为\n * 修饰符（modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法\n * 抽象类（abstract class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n * 接口（interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口\n\n\n# access modifiers\n\ntypescript 可以使用三种访问修饰符（access modifiers），分别是 public、private 和 protected。\n\n * public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\n * private 修饰的属性或方法是私有的，不能在声明它的类的外部访问\n * protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的\n\ninterface ipoint {\n    x: number\n    y: number\n    drawpoint: () => void\n    getdistances: (p: ipoint) => number\n}\nclass point implements ipoint {\n    constructor(private _x: number, private _y: number) {}\n    drawpoint() {\n        console.log('x：' + this._x, 'y:' + this._y)\n    }\n    getdistances(p: ipoint) {\n        return math.sqrt((p.x - this._x) ** 2 + (p.y - this._y) ** 2)\n    }\n    get x() {\n        return this._x\n    }\n    set x(value: number) {\n        if (value < 0) throw new error('x不能小于0')\n        this._x = value\n    }\n    get y() {\n        return this._y\n    }\n    set y(value: number) {\n        if (value < 0) throw new error('y不能小于0')\n        this._y = value\n    }\n}\n\nconst p1 = new point(0, -1)\nconst p2 = new point(0, 2)\n\n\n\n\n# readonly\n\nreadonly 只读属性关键字\n\nclass animal {\n  readonly name;\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nlet a = new animal('jack');\nconsole.log(a.name); // jack\na.name = 'tom';\n\n// index.ts(10,3): ts2540: cannot assign to 'name' because it is a read-only property.\n\n\n注意如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。\n\nclass animal {\n   constructor(public readonly name) {\n    this.name = name;\n  }\n}\n\n\n\n# 抽象类\n\nabstract 用于定义抽象类和其中的抽象方法。\n\n什么是抽象类？\n\n首先，抽象类是不允许被实例化的：\n\nabstract class animal {\n  constructor(pubilc name) {\n    this.name = name;\n  }\n   abstract sayhi();\n}\n\nlet a = new animal('jack');\n\n// index.ts(9,11): error ts2511: cannot create an instance of the abstract class 'animal'.\n\n\n上面的例子中，我们定义了一个抽象类 animal，并且定义了一个抽象方法 sayhi。在实例化抽象类的时候报错了。\n\n其次，抽象类中的抽象方法必须被子类实现：\n\nabstract class animal {\n  constructor(public name) {\n    this.name = name;\n  }\n   abstract sayhi();\n}\n\nclass cat extends animal {\n  eat() {\n    console.log(`${this.name} is eating.`);\n  }\n}\n\nlet cat = new cat('tom');\n\n// index.ts(9,7): error ts2515: non-abstract class 'cat' does not implement inherited abstract member 'sayhi' from class 'animal'.\n\n\n上面的例子中，我们定义了一个类 cat 继承了抽象类 animal，但是没有实现抽象方法 sayhi，所以编译报错了。\n\n下面是一个正确使用抽象类的例子：\n\nabstract class animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayhi();\n}\n\nclass cat extends animal {\n  public sayhi() {\n    console.log(`meow, my name is ${this.name}`);\n  }\n}\n\nlet cat = new cat('tom');\n\n\n\n# 类的类型\n\n给类加上 typescript 的类型很简单，与接口类似：\n\nclass animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  sayhi(): string {\n    return `my name is ${this.name}`;\n  }\n}\n\nlet a: animal = new animal('jack');\nconsole.log(a.sayhi()); // my name is jack\n\n\n\n# 类实现接口\n\n实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。\n\n举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：\n\ninterface alarm {\n    alert(): void;\n}\n\nclass door {\n}\n\nclass securitydoor extends door implements alarm {\n    alert() {\n        console.log('securitydoor alert');\n    }\n}\n\nclass car implements alarm {\n    alert() {\n        console.log('car alert');\n    }\n}\n\n\n一个类可以实现多个接口：\n\ninterface alarm {\n    alert(): void;\n}\n\ninterface light {\n    lighton(): void;\n    lightoff(): void;\n}\n\nclass car implements alarm, light {\n    alert() {\n        console.log('car alert');\n    }\n    lighton() {\n        console.log('car light on');\n    }\n    lightoff() {\n        console.log('car light off');\n    }\n}\n\n\n\n# generics\n\n泛型（generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。\n\n\n# 简单的例子\n\n首先，我们来实现一个函数 createarray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：\n\nfunction createarray(length: number, value: any): array<any> {\n    let result = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreatearray(3, 'x'); // ['x', 'x', 'x']\n\n\n上例中，我们使用了数组泛型来定义返回值的类型。\n\n这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：\n\narray<any> 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 value 的类型。\n\n这时候，泛型就派上用场了：\n\nfunction createarray<t>(length: number, value: t): array<t> {\n    let result: t[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreatearray<string>(3, 'x'); // ['x', 'x', 'x']\n\n\n上例中，我们在函数名后添加了 <t>，其中 t 用来指代任意输入的类型，在后面的输入 value: t 和输出 array<t> 中即可使用了。\n\n接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来：\n\nfunction createarray<t>(length: number, value: t): array<t> {\n    let result: t[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreatearray(3, 'x'); // ['x', 'x', 'x']\n\n\n\n# 多个类型参\n\n定义泛型的时候，可以一次定义多个类型参数：\n\nfunction swap<t, u>(tuple: [t, u]): [u, t] {\n    return [tuple[1], tuple[0]];\n}\n\nswap([7, 'seven']); // ['seven', 7]\n\n\n上例中，我们定义了一个 swap 函数，用来交换输入的元组。\n\n\n# 泛型约束\n\n在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：\n\nfunction loggingidentity<t>(arg: t): t {\n    console.log(arg.length);\n    return arg;\n}\n\n// index.ts(2,19): error ts2339: property 'length' does not exist on type 't'.\n\n\n上例中，泛型 t 不一定包含属性 length，所以编译的时候报错了。\n\n这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是泛型约束：\n\ninterface lengthwise {\n    length: number;\n}\n\nfunction loggingidentity<t extends lengthwise>(arg: t): t {\n    console.log(arg.length);\n    return arg;\n}\n\n\n上例中，我们使用了 extends 约束了泛型 t 必须符合接口 lengthwise 的形状，也就是必须包含 length 属性。\n\n此时如果调用 loggingidentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了：\n\ninterface lengthwise {\n    length: number;\n}\n\nfunction loggingidentity<t extends lengthwise>(arg: t): t {\n    console.log(arg.length);\n    return arg;\n}\n\nloggingidentity(7);\n\n// index.ts(10,17): error ts2345: argument of type '7' is not assignable to parameter of type 'lengthwise'.\n\n\n多个类型参数之间也可以互相约束：\n\nfunction copyfields<t extends u, u>(target: t, source: u): t {\n    for (let id in source) {\n        target[id] = (<t>source)[id];\n    }\n    return target;\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ncopyfields(x, { b: 10, d: 20 });\n\n\n上例中，我们使用了两个类型参数，其中要求 t 继承 u，这样就保证了 u 上不会出现 t 中不存在的字段。\n\n\n# 泛型接口\n\n可以使用接口的方式来定义一个函数需要符合的形状：\n\ninterface searchfunc {\n  (source: string, substring: string): boolean;\n}\n\nlet mysearch: searchfunc;\nmysearch = function(source: string, substring: string) {\n    return source.search(substring) !== -1;\n}\n\n\n当然也可以使用含有泛型的接口来定义函数的形状：\n\ninterface createarrayfunc {\n    <t>(length: number, value: t): array<t>;\n}\n\nlet createarray: createarrayfunc;\ncreatearray = function<t>(length: number, value: t): array<t> {\n    let result: t[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreatearray(3, 'x'); // ['x', 'x', 'x']\n\n\n进一步，我们可以把泛型参数提前到接口名上：\n\ninterface createarrayfunc<t> {\n    (length: number, value: t): array<t>;\n}\n\nlet createarray: createarrayfunc<any>;\ncreatearray = function<t>(length: number, value: t): array<t> {\n    let result: t[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreatearray(3, 'x'); // ['x', 'x', 'x']\n\n\n注意，此时在使用泛型接口的时候，需要定义泛型的类型。\n\n\n# 泛型类\n\n与泛型接口类似，泛型也可以用于类的类型定义中：\n\nclass genericnumber<t> {\n    zerovalue: t;\n    add: (x: t, y: t) => t;\n}\n\nlet mygenericnumber = new genericnumber<number>();\nmygenericnumber.zerovalue = 0;\nmygenericnumber.add = function(x, y) { return x + y; };\n\n\n\n# 泛型参数的默认类型\n\n在 typescript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。\n\nfunction createarray<t = string>(length: number, value: t): array<t> {\n    let result: t[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n",charsets:{cjk:!0},lastUpdated:"2022年05月24日",lastUpdatedTimestamp:1653404643e3},{title:"React-router",frontmatter:{title:"React-router",date:"2022/05/21 20:40:39",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React-router.html",relativePath:"前端开发/前端框架/React/React-router.md",key:"v-6eeb162e",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React-router.html",headers:[{level:2,title:"路由的由来",slug:"路由的由来",normalizedTitle:"路由的由来",charIndex:2},{level:3,title:"阶段一：后端路由阶段",slug:"阶段一-后端路由阶段",normalizedTitle:"阶段一：后端路由阶段",charIndex:184},{level:3,title:"阶段二：前后端分离阶段",slug:"阶段二-前后端分离阶段",normalizedTitle:"阶段二：前后端分离阶段",charIndex:722},{level:3,title:"阶段三：单页面富应用SPA",slug:"阶段三-单页面富应用spa",normalizedTitle:"阶段三：单页面富应用spa",charIndex:1113},{level:2,title:"前端路由的原理",slug:"前端路由的原理",normalizedTitle:"前端路由的原理",charIndex:1430},{level:3,title:"URL的hash",slug:"url的hash",normalizedTitle:"url的hash",charIndex:1510},{level:3,title:"HTML5的history",slug:"html5的history",normalizedTitle:"html5的history",charIndex:2566},{level:2,title:"react-router",slug:"react-router",normalizedTitle:"react-router",charIndex:3878},{level:2,title:"Router的基本使用",slug:"router的基本使用",normalizedTitle:"router的基本使用",charIndex:4287},{level:2,title:"NavLink的使用",slug:"navlink的使用",normalizedTitle:"navlink的使用",charIndex:5297},{level:2,title:"Switch的作用",slug:"switch的作用",normalizedTitle:"switch的作用",charIndex:5560},{level:2,title:"Redirect",slug:"redirect",normalizedTitle:"redirect",charIndex:6366},{level:2,title:"路由的嵌套",slug:"路由的嵌套",normalizedTitle:"路由的嵌套",charIndex:6982},{level:2,title:"手动路由跳转",slug:"手动路由跳转",normalizedTitle:"手动路由跳转",charIndex:8025},{level:2,title:"参数传递",slug:"参数传递",normalizedTitle:"参数传递",charIndex:11900},{level:3,title:"动态路由",slug:"动态路由",normalizedTitle:"动态路由",charIndex:11909},{level:3,title:"search传递参数",slug:"search传递参数",normalizedTitle:"search传递参数",charIndex:13842},{level:3,title:"Link中to可以直接传入一个对象",slug:"link中to可以直接传入一个对象",normalizedTitle:"link中to可以直接传入一个对象",charIndex:15859},{level:2,title:"react-router-config",slug:"react-router-config",normalizedTitle:"react-router-config",charIndex:16129},{level:2,title:"🌟🌟🌟React-Router V6",slug:"🌟🌟🌟react-router-v6",normalizedTitle:"🌟🌟🌟react-router v6",charIndex:20536},{level:3,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:20566},{level:3,title:"Component",slug:"component",normalizedTitle:"component",charIndex:4718},{level:3,title:"Hooks",slug:"hooks",normalizedTitle:"hooks",charIndex:24800}],headersStr:"路由的由来 阶段一：后端路由阶段 阶段二：前后端分离阶段 阶段三：单页面富应用SPA 前端路由的原理 URL的hash HTML5的history react-router Router的基本使用 NavLink的使用 Switch的作用 Redirect 路由的嵌套 手动路由跳转 参数传递 动态路由 search传递参数 Link中to可以直接传入一个对象 react-router-config 🌟🌟🌟React-Router V6 概述 Component Hooks",content:"# 路由的由来\n\n路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动 --- 维基百科\n\n路由中有一个非常重要的概念叫路由表.路由表本质上就是一个映射表, 决定了数据包的指向\n\n路由的概念出现最早是在后端路由中实现的，原因是web的发展主要经历了这样一些阶段：\n\n * 后端路由阶段\n * 前后端分离阶段\n * 单页面富应用（SPA）\n\n\n# 阶段一：后端路由阶段\n\n * 早期的网站开发整个HTML页面是由服务器来渲染的：服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示.\n\n * 但是, 一个网站, 这么多页面服务器如何处理呢?\n   \n   * 一个页面有自己对应的网址, 也就是URL.\n   * URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理.\n   * Controller进行各种处理, 最终生成HTML或者数据, 返回给前端.\n   * 这就完成了一个IO操作.\n\n上面的这种操作, 就是后端路由.\n\n * 当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户端.\n * 这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化.\n\n后端路由的缺点:\n\n * 一种情况是整个页面的模块由后端人员来编写和维护的.\n\n * 另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码.\n\n * 而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情.\n\n\n# 阶段二：前后端分离阶段\n\n前端渲染的理解：\n\n * 每次请求涉及到的静态资源都会从静态资源服务器获取\n * 这些资源包括HTML+CSS+JS，然后在前端对这些请求回来的资源进行渲染\n * 需要注意的是，客户端的每一次请求，都会从静态资源服务器请求文件\n * 同时可以看到，和之前的后断路由不同，这时后端只是负责提供API了\n\n前后端分离阶段：\n\n * 随着Ajax的出现, 有了前后端分离的开发模式\n * 后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中\n * 这样做最大的优点就是前后端责任的清晰，后端专注于数据上，前端专注于交互和可视化上\n * 并且当移动端(iOS/Android)出现后，后端不需要进行任何处理，依然使用之前的一套API即可\n * 目前很多的网站依然采用这种模式开发（jQuery开发模式）\n\n\n# 阶段三：单页面富应用SPA\n\n * 单页面富应用的理解：\n   \n   * 单页面富应用的英文是single-page application，简称SPA\n   * 整个Web应用只有实际上只有一个页面，当URL发生改变时，并不会从服务器请求新的静态资源\n   * 而是通过JavaScript监听URL的改变，并且根据URL的不同去渲染新的页面\n\n * 如何可以应用URL和渲染的页面呢？\n   \n   * 前端路由维护着URL和渲染页面的映射关系\n   * 路由可以根据不同的URL，最终让我们的框架（比如Vue、React、Angular）去渲染不同的组件\n   * 最终我们在页面上看到的实际就是渲染的一个个组件页面\n\n\n# 前端路由的原理\n\n前端路由是如何做到URL和内容进行映射呢？监听URL的改变。\n\n * URL发生变化，同时不引起页面的刷新有两个办法：\n   \n   * 通过URL的hash改变URL\n   * 通过HTML5中的history模式修改URL\n\n * 当监听到URL发生变化时，我们可以通过自己判断当前的URL，决定到底渲染什么样的内容\n\n\n# URL的hash\n\nURL的hash也就是锚点(#), 本质上是改变window.location的href属性\n\n我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新\n\n注意：\n\n * hash的优势就是兼容性更好，在老版IE(最低兼容到IE3)中都可以运行\n\n * 但是缺陷是有一个#，显得不像一个真实的路径，或者说有点丑💩\n\n  <body>\n        <div id=\"app\">\n            <a href=\"#/home\">主页</a>\n            <a href=\"#/about\">关于</a>\n            <div id=\"router-view\"></div>\n        </div>\n        <script>\n            const routerViewEl = document.getElementById('router-view')\n            window.addEventListener('hashchange', () => {\n                console.log(location.hash)\n                switch (location.hash) {\n                    case '#/home':\n                        routerViewEl.innerHTML = '首页'\n                        break\n                    case '#/about':\n                        routerViewEl.innerHTML = '关于'\n                        break\n                    default:\n                        routerViewEl.innerHTML = ''\n                }\n            })\n        <\/script>\n    </body>\n\n\n\n# HTML5的history\n\nhistory接口是HTML5新增的, 它有六种模式改变URL而不刷新页面：\n\n * replaceState：替换原来的路径\n * pushState：使用新的路径\n * popState：路径的回退\n * go：向前或向后改变路径\n * forward：向前改变路径\n * back：向后改变路径\n\n  <div id=\"app\">\n    <a href=\"/home\">首页</a>\n    <a href=\"/about\">关于</a>\n\n    <div class=\"router-view\"></div>\n  </div>\n\n  <script>\n    // 1.获取router-view的DOM\n    const routerViewEl = document.getElementsByClassName(\"router-view\")[0];\n\n    // 获取所有的a元素, 自己来监听a元素的改变\n    const aEls = document.getElementsByTagName(\"a\");\n    for (let el of aEls) {\n      el.addEventListener(\"click\", e => {\n        e.preventDefault();\n        const href = el.getAttribute(\"href\");\n        history.pushState({}, \"\", href);\n        urlChange();\n      })\n    }\n\n    // 调用 history.pushState() 或者 history.replaceState() 不会触发 popstate 事件。popstate 事件只会在浏览器某些行为下触发，比如点击后退按钮（或者在 JavaScript 中调用 history.back() 方法）。即，在同一文档的两个历史记录条目之间导航会触发该事件。\n    // 无论是浏览器的前进还是后退都会触发这个popstate事件，所以只能起到一个监听页面变化的作用。\n    window.addEventListener('popstate',urlChange);\n\n    // 监听URL的改变\n    function urlChange() {\n      switch (location.pathname) {\n        case \"/home\":\n          routerViewEl.innerHTML = \"首页\";\n          break;\n        case \"/about\":\n          routerViewEl.innerHTML = \"关于\";\n          break;\n        default:\n          routerViewEl.innerHTML = \"\";\n      }\n    }\n\n  <\/script>\n\n\n\n# react-router\n\n⚠️\n\n这里我使用的版本是版本：V5 ,最新版本是V6\n\n官方文档：\n\nv5\n\nv6\n\n相关文章：\n\nReact-Router v6 完全解读指南 - react-router 篇（万字长文，学懂毕业）\n\n浅谈react-router-dom V6的配置使用\n\n「React进阶」react-router v6 通关指南\n\nReact Router的版本4开始，路由不再集中在一个包中进行管理了：\n\n * react-router是router的核心部分代码\n * react-router-dom是用于浏览器的\n * react-router-native是用于原生应用的\n\n目前我们使用的React Router版本是@5.2.0的版本\n\n安装react-router-dom会自动帮助我们安装react-router的依赖：yarn add react-router-dom\n\n\n# Router的基本使用\n\nreact-router最主要的API是给我们提供的一些组件：\n\n * BrowserRouter或HashRouter\n   \n   * Router中包含了对路径改变的监听，并且会将相应的路径传递给子组件\n   * BrowserRouter使用history模式\n   * HashRouter使用hash模式\n\n * Link和NavLink：\n   \n   * 通常路径的跳转是使用Link组件，最终会被渲染成a元素\n   * NavLink是在Link基础之上增加了一些样式属性\n   * to属性：Link中最重要的属性，用于设置跳转到的路径\n\n * Route：\n   \n   * Route用于路径的匹配\n   * path属性：用于设置匹配到的路径\n   * component属性：设置匹配到路径后，渲染的组件\n   * exact：精准匹配，只有精准匹配到完全一致的路径，才会渲染对应的组件；\n\nimport {Component} from 'react';\nimport {BrowserRouter, Link, Route} from \"react-router-dom\";\nimport Home from \"./pages/home\";\nimport About from \"./pages/about\";\n\nclass App extends Component {\n    render() {\n        return (\n            <div>\n                <BrowserRouter>\n                    <Link to='/'>首页</Link>\n                    <Link to='/about'>关于</Link>\n\n                    <Route exact path='/' component={Home}/>\n                    <Route path='/about' component={About}/>\n\n                </BrowserRouter>\n            </div>\n        );\n    }\n}\n\nexport default App;\n\n\n\n# NavLink的使用\n\n需求：路径选中时，对应的a元素变为红色\n\n这个时候，我们要使用NavLink组件来替代Link组件：\n\n * activeStyle：活跃时（匹配时）的样式\n * activeClassName：活跃时添加的class\n * exact：是否精准匹配\n\n默认的activeClassName：事实上在默认匹配成功时，NavLink就会添加上一个动态的active class，所以我们也可以直接编写样式。当然，如果你担心这个class在其他地方被使用了，出现样式的层叠，也可以自定义class\n\n\n# Switch的作用\n\n我们来看下面的路由规则：\n\n * 当我们匹配到某一个路径时，我们会发现有一些问题\n * 比如/about路径匹配到的同时，/:userid也被匹配到了，并且最后的一个NoMatch组件总是被匹配到\n\n                        <Route exact path='/' component={Home}/>\n                        <Route path='/about' component={About}/>\n                        <Route path='/:userid' component={User}/>\n                        <Route component={NoMatch}/>\n\n\n原因是什么呢？默认情况下，react-router中只要是路径被匹配到的Route对应的组件都会被渲染\n\n但是实际开发中，我们往往希望有一种排他的思想:只要匹配到了第一个，那么后面的就不应该继续匹配了；这个时候我们可以使用Switch来将所有的Route进行包裹即可\n\n                    <Switch>\n                        <Route exact path='/' component={Home}/>\n                        <Route path='/about' component={About}/>\n                        <Route path='/:id' component={User}/>\n                        <Route component={NoMatch}/>\n                    </Switch>\n\n\n\n# Redirect\n\nRedirect用于路由的重定向，当这个组件出现时，就会执行跳转到对应的to路径中：\n\n我们这里使用这个的一个案例：\n\n用户跳转到User界面,但是在User界面有一个isLogin用于记录用户是否登录：\n\n * true：那么显示用户的名称\n\n * false：直接重定向到登录界面\n\n// user.jsx\nimport {Component} from 'react';\nimport {Redirect} from \"react-router-dom\";\n\nclass User extends Component {\n    constructor() {\n        super();\n        this.state = {\n            isLogin: false\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                {\n                    this.state.isLogin ? <h2>用户：Frank</h2> : <Redirect to={'/login'}/>\n                }\n            </div>\n        );\n    }\n}\n\nexport default User;\n\n\n\n# 路由的嵌套\n\n在开发中，路由之间是存在嵌套关系的\n\n这里我们假设about页面中有两个页面内容：\n\n * 商品列表和消息列表\n * 点击不同的链接可以跳转到不同的地方，显示不同的内容\n\nimport {Component} from 'react';\nimport {Link, Switch,Route} from 'react-router-dom'\n\n\nfunction GoodList() {\n    return (\n        <ul>\n            {\n                [1, 2, 3].map(item => {\n                    return <li>{`商品${item}`}</li>\n                })\n            }\n        </ul>\n    )\n}\n\n\nfunction NewsList() {\n    return (\n        <ul>\n            {\n                [1, 2, 3].map(item => {\n                    return <li>{`消息${item}`}</li>\n                })\n            }\n        </ul>\n    )\n}\n\nclass Abouts extends Component {\n    render() {\n        return (\n            <div>\n                <Link to={'/about'}>商品列表</Link>\n                <Link to={'/about/news'}>消息列表</Link>\n\n                <Switch>\n                    <Route exact path={'/about'} component={GoodList}/>\n                    <Route path={'/about/news'} component={NewsList}/>\n                </Switch>\n            </div>\n        );\n    }\n}\n\nexport default Abouts;\n\n\n\n# 手动路由跳转\n\n目前我们实现的跳转主要是通过Link或者NavLink进行跳转的，实际上我们也可以通过JavaScript代码进行跳转\n\n但是通过JavaScript代码进行跳转有一个前提：必须获取到history对象\n\n如何可以获取到history的对象呢？两种方式:\n\n * 如果该组件是通过路由直接跳转过来的，那么可以直接获取history、location、match对象\n\nTIP\n\n * history.push 这个方法会向history栈里面添加一条新记录，这个时候用户点击浏览器的回退按钮可以回到之前的路径。\n\n * history.go 这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)\n\n * history.replace 跟 history.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。\n\nimport {Component} from 'react';\nimport {NavLink, Switch, Route} from 'react-router-dom'\n\nimport styled from \"styled-components\";\n\n\nconst AboutWrapper = styled.div`\n  .about-active {\n    color: orange;\n  }\n`\n\nfunction JoinUs() {\n    return (\n        <div>加入我们：zfhblog.top</div>\n    )\n}\n\nfunction GoodList() {\n    return (\n        <ul>\n            {\n                [1, 2, 3].map(item => {\n                    return <li key={item}>{`商品${item}`}</li>\n                })\n            }\n        </ul>\n    )\n}\n\n\nfunction NewsList() {\n    return (\n        <ul>\n            {\n                [1, 2, 3].map(item => {\n                    return <li key={item}>{`消息${item}`}</li>\n                })\n            }\n        </ul>\n    )\n}\n\nclass Abouts extends Component {\n    render() {\n        return (\n            <div>\n                <AboutWrapper>\n                    <NavLink exact to={'/about'} activeClassName={'about-active'}>商品列表</NavLink>\n                    <NavLink to={'/about/news'} activeClassName={'about-active'}>消息列表</NavLink>\n                    <button onClick={() => {\n                        this.joinUs()\n                    }}>加入我们\n                    </button>\n                </AboutWrapper>\n                <Switch>\n                    <Route exact path={'/about'} component={GoodList}/>\n                    <Route path={'/about/news'} component={NewsList}/>\n                    <Route path={'/about/join'} component={JoinUs}/>\n                </Switch>\n            </div>\n        );\n    }\n\n    joinUs() {\n        this.props.history.push('/about/join')\n    }\n\n    componentDidMount() {\n        console.log(this.props.history)\n    }\n}\n\nexport default Abouts;\n\n\n * 如果该组件是一个普通渲染的组件，那么不可以直接获取history、location、match对象\n\n那么如果普通的组件也希望获取对应的对象属性应该怎么做呢？\n\n前面我们学习过高阶组件，可以在组件中添加想要的属性;react-router也是通过高阶组件为我们的组件添加相关的属性的:\n\n如果我们希望在App组件中获取到history对象，必须满足以下两个条件：\n\n * App组件必须包裹在Router组件之内\n * App组件使用withRouter高阶组件包裹\n\n// app.js\nimport {Component} from 'react';\nimport {NavLink, Route, withRouter} from \"react-router-dom\";\nimport Home from \"./pages/home\";\nimport Abouts from \"./pages/abouts\";\nimport Order from \"./pages/order\";\nimport styled from \"styled-components\";\n\nconst NavLinkWrapper = styled.div`\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n\n  .link {\n    padding-top: 50px;\n    width: 100px;\n    background-color: #f1f1f1;\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n  }\n\n  a {\n    text-decoration: none;\n    margin-right: 20px;\n    font-size: 20px;\n  }\n\n  a.link-active {\n    color: red;\n  }\n`\n\nclass App extends Component {\n    render() {\n        return (\n            <NavLinkWrapper>\n                <div className='link'>\n                    <NavLink exact to='/' activeClassName={'link-active'}>首页</NavLink>\n                    <NavLink to='/about' activeClassName={'link-active'}>关于</NavLink>\n                    <button to='/order' onClick={() => {\n                        this.toOrder()\n                    }}>订单\n                    </button>\n                </div>\n                <Route exact path='/' component={Home}/>\n                <Route path='/about' component={Abouts}/>\n                <Route path='/order' component={Order}/>\n            </NavLinkWrapper>\n        );\n    }\n\n    toOrder() {\n        this.props.history.push('/order')\n    }\n}\n\nexport default withRouter(App);\n// index.js\nReactDOM.render(<BrowserRouter><App/></BrowserRouter>, document.getElementById('root'))\n\n\n\n# 参数传递\n\n\n# 动态路由\n\n动态路由的概念指的是路由中的路径并不会固定：\n\n比如/detail的path对应一个组件Detail。如果我们将path在Route匹配时写成/detail/:id，那么 /detail/abc、/detail/123都可以匹配到该Route，并且进行显示这个匹配规则，我们就称之为动态路由。通常情况下，使用动态路由可以为路由传递参数\n\nimport {Component} from 'react';\nimport {NavLink, Route, withRouter} from \"react-router-dom\";\nimport Home from \"./pages/home\";\nimport Abouts from \"./pages/abouts\";\nimport Order from \"./pages/order\";\nimport styled from \"styled-components\";\n\nconst NavLinkWrapper = styled.div`\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n\n  .link {\n    padding-top: 50px;\n    width: 100px;\n    background-color: #f1f1f1;\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n  }\n\n  a {\n    text-decoration: none;\n    margin-right: 20px;\n    font-size: 20px;\n  }\n\n  a.link-active {\n    color: red;\n  }\n`\n\nclass App extends Component {\n    render() {\n        return (\n            <NavLinkWrapper>\n                <div className='link'>\n                    <NavLink exact to='/' activeClassName={'link-active'}>首页</NavLink>\n                    <NavLink to='/about' activeClassName={'link-active'}>关于</NavLink>\n                    <button to='/order' onClick={() => {\n                        this.toOrder()\n                    }}>订单\n                    </button>\n                </div>\n                <Route exact path='/' component={Home}/>\n                <Route path='/about' component={Abouts}/>\n                <Route path='/order/:id' component={Order}/>\n            </NavLinkWrapper>\n        );\n    }\n\n    toOrder() {\n        this.props.history.push('/order/123')\n    }\n}\n\nexport default withRouter(App);\n// ------------------------------------------\n// order.jsx\n// ------------------------------------------\nimport {Component} from 'react';\n\nclass Order extends Component {\n    render() {\n        return (\n            <div>\n                <h2>订单:{this.props.match.params.id}</h2>\n            </div>\n        );\n    }\n}\n\nexport default Order;\n\n\n\n# search传递参数\n\n// app.js\nimport {Component} from 'react';\nimport {NavLink, Route, withRouter} from \"react-router-dom\";\nimport Home from \"./pages/home\";\nimport Abouts from \"./pages/abouts\";\nimport Order2 from \"./pages/order2\";\nimport styled from \"styled-components\";\n\nconst NavLinkWrapper = styled.div`\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n\n  .link {\n    padding-top: 50px;\n    width: 100px;\n    background-color: #f1f1f1;\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n  }\n\n  a {\n    text-decoration: none;\n    margin-right: 20px;\n    font-size: 20px;\n  }\n\n  a.link-active {\n    color: red;\n  }\n`\n\nclass App extends Component {\n    render() {\n        return (\n            <NavLinkWrapper>\n                <div className='link'>\n                    <NavLink exact to='/' activeClassName={'link-active'}>首页</NavLink>\n                    <NavLink to='/about' activeClassName={'link-active'}>关于</NavLink>\n                    <button to='/order' onClick={() => {\n                        this.toOrder()\n                    }}>订单\n                    </button>\n                </div>\n                <Route exact path='/' component={Home}/>\n                <Route path='/about' component={Abouts}/>\n                <Route path='/order' component={Order2}/>\n            </NavLinkWrapper>\n        );\n    }\n\n    toOrder() {\n        this.props.history.push('/order?id=123&name=frank&test=2&test2=1231231')\n    }\n}\n\nexport default withRouter(App);\n\n\nimport {Component} from 'react';\n\nclass Order2 extends Component {\n    render() {\n        return (\n            <div>\n                <h2>订单:{this.props.match.params.id}</h2>\n            </div>\n        );\n    }\n\n    componentDidMount() {\n        let query = {}\n        const search = this.props.location.search.split('&')\n        search[0] = search[0].split('?')[1]\n        search.forEach(item => {\n            const kv = item.split('=')\n            query[kv[0]] = kv[1]\n        })\n        console.log(query)\n    }\n}\n\nexport default Order2;\n\n\n\n# Link中to可以直接传入一个对象\n\n这个对象有四个属性：\n\n * pathname：跳转的路径\n * state：复杂数据(对象)会传递到location\n * search:查询参数的字符串表示，例如?sort=name\n * Hash:放入 URL 的哈希值，例如#a-hash\n\n                    <NavLink to={{pathname: '/test', state: {name: 'frank', age: 21}}}\n                    >测试</NavLink>\n\n\n\n# react-router-config\n\n目前我们所有的路由定义都是直接使用Route组件，并且添加属性来完成的。 但是这样的方式会让路由变得非常混乱，我们希望将所有的路由配置放到一个地方进行集中管理： 这个时候可以使用react-router-config来完成\n\n 1. 安装react-router-config:yarn add react-router-config\n 2. 配置路由映射的关系数组\n\nimport Home from \"../pages/home\";\nimport Abouts, {GoodList, JoinUs, NewsList} from \"../pages/abouts\";\nimport Order from \"../pages/order\";\n\nconst routes = [\n    {\n        path: '/',\n        exact: true,\n        component: Home\n    },\n    {\n        path: '/about',\n        component: Abouts,\n        routes: [\n            {\n                path: \"/about\",\n                exact: true,\n                component: GoodList,\n            },\n            {\n                path: '/about/news',\n                component: NewsList,\n            },\n            {\n                path: '/about/join',\n                component: JoinUs\n            }\n        ]\n    },\n    {\n        path: '/order',\n        component: Order\n    }\n]\n\nexport default routes\n\n\n 1. 使用renderRoutes函数完成配置\n\nimport {Component} from 'react';\nimport {NavLink, Route, withRouter} from \"react-router-dom\";\n// import Home from \"./pages/home\";\n// import Abouts from \"./pages/abouts\";\n// import Order from \"./pages/order\";\nimport routes from \"./router\";\nimport styled from \"styled-components\";\nimport {renderRoutes} from \"react-router-config\";\n\nconst NavLinkWrapper = styled.div`\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n\n  .link {\n    padding-top: 50px;\n    width: 100px;\n    background-color: #f1f1f1;\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n  }\n\n  a {\n    text-decoration: none;\n    margin-right: 20px;\n    font-size: 20px;\n  }\n\n  a.link-active {\n    color: red;\n  }\n`\n\nclass App extends Component {\n    render() {\n        return (\n            <NavLinkWrapper>\n                <div className='link'>\n                    <NavLink exact to='/' activeClassName={'link-active'}>首页</NavLink>\n                    <NavLink to='/about' activeClassName={'link-active'}>关于</NavLink>\n                    <button  onClick={() => {\n                        this.toOrder()\n                    }}>订单\n                    </button>\n                </div>\n                {/*<Route exact path='/' component={Home}/>*/}\n                {/*<Route path='/about' component={Abouts}/>*/}\n                {/*<Route path='/order' component={Order}/>*/}\n                {renderRoutes(routes)}\n            </NavLinkWrapper>\n        );\n    }\n\n    toOrder() {\n        this.props.history.push('/order')\n    }\n}\n\nexport default withRouter(App);\n\n\nAbouts.jsx:\n\nimport {Component} from 'react';\nimport {NavLink, Switch, Route} from 'react-router-dom'\n\nimport styled from \"styled-components\";\nimport {renderRoutes} from \"react-router-config\";\n\n\nconst AboutWrapper = styled.div`\n  .about-active {\n    color: orange;\n  }\n`\n\nexport function JoinUs() {\n    return (\n        <div>加入我们：zfhblog.top</div>\n    )\n}\n\nexport function GoodList() {\n    return (\n        <ul>\n            {\n                [1, 2, 3].map(item => {\n                    return <li key={item}>{`商品${item}`}</li>\n                })\n            }\n        </ul>\n    )\n}\n\n\nexport function NewsList() {\n    return (\n        <ul>\n            {\n                [1, 2, 3].map(item => {\n                    return <li key={item}>{`消息${item}`}</li>\n                })\n            }\n        </ul>\n    )\n}\n\nclass Abouts extends Component {\n    render() {\n        return (\n            <div>\n                <AboutWrapper>\n                    <NavLink exact to={'/about'} activeClassName={'about-active'}>商品列表</NavLink>\n                    <NavLink to={'/about/news'} activeClassName={'about-active'}>消息列表</NavLink>\n                    <button onClick={() => {\n                        this.joinUs()\n                    }}>加入我们\n                    </button>\n                </AboutWrapper>\n                {/*<Switch>*/}\n                {/*    <Route exact path={'/about'} component={GoodList}/>*/}\n                {/*    <Route path={'/about/news'} component={NewsList}/>*/}\n                {/*    <Route path={'/about/join'} component={JoinUs}/>*/}\n                {/*</Switch>*/}\n                {renderRoutes(this.props.route.routes)}\n            </div>\n        );\n    }\n\n    joinUs() {\n        this.props.history.push('/about/join')\n    }\n\n    componentDidMount() {\n        // console.log(this.props.history)\n        console.log(this.props.route)\n    }\n}\n\nexport default Abouts;\n\n\n\n# 🌟🌟🌟React-Router V6\n\n\n#\n\n\n# 概述\n\n 1. React Router 以三个不同的包发布到 npm 上，它们分别为：\n    \n    1. react-router: 路由的核心库，提供了很多的：组件、钩子。\n    2. react-router-dom: 包含react-router所有内容，并添加一些专门用于 DOM 的组件，例如 <BrowserRouter>等 。\n    3. react-router-native: 包括react-router所有内容，并添加一些专门用于ReactNative的API，例如:<NativeRouter>等。\n\n 2. 与React Router 5.x 版本相比，改变了什么？\n    \n    1. 内置组件的变化：移除<Switch/> ，新增 <Routes/>等。\n    \n    2. 语法的变化：component={About} 变为 element={<About/>}等。\n    \n    3. 新增多个hook：useParams、useNavigate、useMatch等。\n    \n    4. 官方明确推荐函数式组件了！！！\n       \n       ......\n\n\n# Component\n\n# <BrowserRouter>\n\n 1. 说明：<BrowserRouter>用于包裹整个应用。\n\n 2. 示例代码：\n    \n    import React from \"react\";\n    import ReactDOM from \"react-dom\";\n    import { BrowserRouter } from \"react-router-dom\";\n    \n    ReactDOM.render(\n      <BrowserRouter>\n        {/* 整体结构（通常为App组件） */}\n      </BrowserRouter>,root\n    );\n    \n\n# <HashRouter>\n\n 1. 说明：作用与<BrowserRouter>一样，但<HashRouter>修改的是地址栏的hash值。\n 2. 备注：6.x版本中<HashRouter>、<BrowserRouter> 的用法与 5.x 相同。\n\n# <Routes/> 与 <Route/>\n\n 1. v6版本中移出了先前的<Switch>，引入了新的替代者：<Routes>。\n\n 2. <Routes> 和 <Route>要配合使用，且必须要用<Routes>包裹<Route>。\n\n 3. <Route> 相当于一个 if 语句，如果其路径与当前 URL 匹配，则呈现其对应的组件。\n\n 4. <Route caseSensitive> 属性用于指定：匹配时是否区分大小写（默认为 false）。\n\n 5. 当URL发生变化时，<Routes>都会查看其所有子<Route> 元素以找到最佳匹配并呈现组件 。\n\n 6. <Route> 也可以嵌套使用，且可配合useRoutes()配置 “路由表” ，但需要通过 <Outlet> 组件来渲染其子路由。\n\n 7. 示例代码：\n    \n    <Routes>\n        /*path属性用于定义路径，element属性用于定义当前路径所对应的组件*/\n        <Route path=\"/login\" element={<Login />}></Route>\n    \n    \t\t/*用于定义嵌套路由，home是一级路由，对应的路径/home*/\n        <Route path=\"home\" element={<Home />}>\n           /*test1 和 test2 是二级路由,对应的路径是/home/test1 或 /home/test2*/\n          <Route path=\"test1\" element={<Test/>}></Route>\n          <Route path=\"test2\" element={<Test2/>}></Route>\n    \t\t</Route>\n    \t\n    \t\t//Route也可以不写element属性, 这时就是用于展示嵌套的路由 .所对应的路径是/users/xxx\n        <Route path=\"users\">\n           <Route path=\"xxx\" element={<Demo />} />\n        </Route>\n    </Routes>\n    \n\n# <Link>\n\n 1. 作用: 修改URL，且不发送网络请求（路由链接）。\n\n 2. 注意: 外侧需要用<BrowserRouter>或<HashRouter>包裹。\n\n 3. 示例代码：\n    \n    import { Link } from \"react-router-dom\";\n    \n    function Test() {\n      return (\n        <div>\n        \t<Link to=\"/路径\">按钮</Link>\n        </div>\n      );\n    }\n    \n\n# <NavLink>\n\n 1. 作用: 与<Link>组件类似，且可实现导航的“高亮”效果。\n\n 2. 示例代码：\n    \n    // 注意: NavLink默认类名是active，下面是指定自定义的class\n    \n    //自定义样式\n    <NavLink\n        to=\"login\"\n        className={({ isActive }) => {\n            console.log('home', isActive)\n            return isActive ? 'base one' : 'base'\n        }}\n    >login</NavLink>\n    \n    /*\n    \t默认情况下，当Home的子组件匹配成功，Home的导航也会高亮，\n    \t当NavLink上添加了end属性后，若Home的子组件匹配成功，则Home的导航没有高亮效果。\n    */\n    <NavLink to=\"home\" end >home</NavLink>\n    \n\n# <Navigate>\n\n 1. 作用：只要<Navigate>组件被渲染，就会修改路径，切换视图。\n\n 2. replace属性用于控制跳转模式（push 或 replace，默认是push）。\n\n 3. 示例代码：\n    \n    import React,{useState} from 'react'\n    import {Navigate} from 'react-router-dom'\n    \n    export default function Home() {\n    \tconst [sum,setSum] = useState(1)\n    \treturn (\n    \t\t<div>\n    \t\t\t<h3>我是Home的内容</h3>\n    \t\t\t{/* 根据sum的值决定是否切换视图 */}\n    \t\t\t{sum === 1 ? <h4>sum的值为{sum}</h4> : <Navigate to=\"/about\" replace={true}/>}\n    \t\t\t<button onClick={()=>setSum(2)}>点我将sum变为2</button>\n    \t\t</div>\n    \t)\n    }\n    \n\n# <Outlet>\n\n 1. 当<Route>产生嵌套时，渲染其对应的后续子路由。\n\n 2. 示例代码：\n    \n    //根据路由表生成对应的路由规则\n    const element = useRoutes([\n      {\n        path:'/about',\n        element:<About/>\n      },\n      {\n        path:'/home',\n        element:<Home/>,\n        children:[\n          {\n            path:'news',\n            element:<News/>\n          },\n          {\n            path:'message',\n            element:<Message/>,\n          }\n        ]\n      }\n    ])\n    \n    //Home.js\n    import React from 'react'\n    import {NavLink,Outlet} from 'react-router-dom'\n    \n    export default function Home() {\n    \treturn (\n    \t\t<div>\n    \t\t\t<h2>Home组件内容</h2>\n    \t\t\t<div>\n    \t\t\t\t<ul className=\"nav nav-tabs\">\n    \t\t\t\t\t<li>\n    \t\t\t\t\t\t<NavLink className=\"list-group-item\" to=\"news\">News</NavLink>\n    \t\t\t\t\t</li>\n    \t\t\t\t\t<li>\n    \t\t\t\t\t\t<NavLink className=\"list-group-item\" to=\"message\">Message</NavLink>\n    \t\t\t\t\t</li>\n    \t\t\t\t</ul>\n    \t\t\t\t{/* 指定路由组件呈现的位置 */}\n    \t\t\t\t<Outlet />\n    \t\t\t</div>\n    \t\t</div>\n    \t)\n    }\n    \n    \n\n\n# Hooks\n\n# useRoutes()\n\n 1. 作用：根据路由表，动态创建<Routes>和<Route>。\n\n 2. 示例代码：\n    \n    //路由表配置：src/routes/index.js\n    import About from '../pages/About'\n    import Home from '../pages/Home'\n    import {Navigate} from 'react-router-dom'\n    \n    export default [\n    \t{\n    \t\tpath:'/about',\n    \t\telement:<About/>\n    \t},\n    \t{\n    \t\tpath:'/home',\n    \t\telement:<Home/>\n    \t},\n    \t{\n    \t\tpath:'/',\n    \t\telement:<Navigate to=\"/about\"/>\n    \t}\n    ]\n    \n    //App.jsx\n    import React from 'react'\n    import {NavLink,useRoutes} from 'react-router-dom'\n    import routes from './routes'\n    \n    export default function App() {\n    \t//根据路由表生成对应的路由规则\n    \tconst element = useRoutes(routes)\n    \treturn (\n    \t\t<div>\n    \t\t\t......\n          {/* 注册路由 */}\n          {element}\n    \t\t  ......\n    \t\t</div>\n    \t)\n    }\n    \n    \n\n# useNavigate()\n\n 1. 作用：返回一个函数用来实现编程式导航。\n\n 2. 示例代码：\n    \n    import React from 'react'\n    import {useNavigate} from 'react-router-dom'\n    \n    export default function Demo() {\n      const navigate = useNavigate()\n      const handle = () => {\n        //第一种使用方式：指定具体的路径\n        navigate('/login', {\n          replace: false,\n          state: {a:1, b:2}\n        }) \n        //第二种使用方式：传入数值进行前进或后退，类似于5.x中的 history.go()方法\n        navigate(-1)\n      }\n      \n      return (\n        <div>\n          <button onClick={handle}>按钮</button>\n        </div>\n      )\n    }\n    \n\n# useParams()\n\n 1. 作用：回当前匹配路由的params参数，类似于5.x中的match.params。\n\n 2. 示例代码：\n    \n    import React from 'react';\n    import { Routes, Route, useParams } from 'react-router-dom';\n    import User from './pages/User.jsx'\n    \n    function ProfilePage() {\n      // 获取URL中携带过来的params参数\n      let { id } = useParams();\n    }\n    \n    function App() {\n      return (\n        <Routes>\n          <Route path=\"users/:id\" element={<User />}/>\n        </Routes>\n      );\n    }\n    \n\n# useSearchParams()\n\n 1. 作用：用于读取和修改当前位置的 URL 中的查询字符串。\n\n 2. 返回一个包含两个值的数组，内容分别为：当前的seaech参数、更新search的函数。\n\n 3. 示例代码：\n    \n    import React from 'react'\n    import {useSearchParams} from 'react-router-dom'\n    \n    export default function Detail() {\n    \tconst [search,setSearch] = useSearchParams()\n    \tconst id = search.get('id')\n    \tconst title = search.get('title')\n    \tconst content = search.get('content')\n    \treturn (\n    \t\t<ul>\n    \t\t\t<li>\n    \t\t\t\t<button onClick={()=>setSearch('id=008&title=哈哈&content=嘻嘻')}>点我更新一下收到的search参数</button>\n    \t\t\t</li>\n    \t\t\t<li>消息编号：{id}</li>\n    \t\t\t<li>消息标题：{title}</li>\n    \t\t\t<li>消息内容：{content}</li>\n    \t\t</ul>\n    \t)\n    }\n    \n    \n\n# useLocation()\n\n 1. 作用：获取当前 location 信息，对标5.x中的路由组件的location属性。\n\n 2. 示例代码：\n    \n    import React from 'react'\n    import {useLocation} from 'react-router-dom'\n    \n    export default function Detail() {\n    \tconst x = useLocation()\n    \tconsole.log('@',x)\n      // x就是location对象: \n    \t/*\n    \t\t{\n          hash: \"\",\n          key: \"ah9nv6sz\",\n          pathname: \"/login\",\n          search: \"?name=zs&age=18\",\n          state: {a: 1, b: 2}\n        }\n    \t*/\n    \treturn (\n    \t\t<ul>\n    \t\t\t<li>消息编号：{id}</li>\n    \t\t\t<li>消息标题：{title}</li>\n    \t\t\t<li>消息内容：{content}</li>\n    \t\t</ul>\n    \t)\n    }\n    \n      \n    \n    \n    \n\n# useMatch()\n\n 1. 作用：返回当前匹配信息，对标5.x中的路由组件的match属性。\n\n 2. 示例代码：\n    \n    <Route path=\"/login/:page/:pageSize\" element={<Login />}/>\n    <NavLink to=\"/login/1/10\">登录</NavLink>\n    \n    export default function Login() {\n      const match = useMatch('/login/:x/:y')\n      console.log(match) //输出match对象\n      //match对象内容如下：\n      /*\n      \t{\n          params: {x: '1', y: '10'}\n          pathname: \"/LoGin/1/10\"  \n          pathnameBase: \"/LoGin/1/10\"\n          pattern: {\n          \tpath: '/login/:x/:y', \n          \tcaseSensitive: false, \n          \tend: false\n          }\n        }\n      */\n      return (\n      \t<div>\n          <h1>Login</h1>\n        </div>\n      )\n    }\n    \n\n# useInRouterContext()\n\n\t\t作用：如果组件在 `<Router>` 的上下文中呈现，则 `useInRouterContext` 钩子返回 true，否则返回 false。\n\n\n# useNavigationType()\n\n 1. 作用：返回当前的导航类型（用户是如何来到当前页面的）。\n 2. 返回值：POP、PUSH、REPLACE。\n 3. 备注：POP是指在浏览器中直接打开了这个路由组件（刷新页面）。\n\n# useOutlet()\n\n 1. 作用：用来呈现当前组件中渲染的嵌套路由。\n\n 2. 示例代码：\n    \n    const result = useOutlet()\n    console.log(result)\n    // 如果嵌套路由没有挂载,则result为null\n    // 如果嵌套路由已经挂载,则展示嵌套的路由对象\n    \n\n# useResolvedPath()\n\n 1. 作用：给定一个 URL值，解析其中的：path、search、hash值。",normalizedContent:"# 路由的由来\n\n路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动 --- 维基百科\n\n路由中有一个非常重要的概念叫路由表.路由表本质上就是一个映射表, 决定了数据包的指向\n\n路由的概念出现最早是在后端路由中实现的，原因是web的发展主要经历了这样一些阶段：\n\n * 后端路由阶段\n * 前后端分离阶段\n * 单页面富应用（spa）\n\n\n# 阶段一：后端路由阶段\n\n * 早期的网站开发整个html页面是由服务器来渲染的：服务器直接生产渲染好对应的html页面, 返回给客户端进行展示.\n\n * 但是, 一个网站, 这么多页面服务器如何处理呢?\n   \n   * 一个页面有自己对应的网址, 也就是url.\n   * url会发送到服务器, 服务器会通过正则对该url进行匹配, 并且最后交给一个controller进行处理.\n   * controller进行各种处理, 最终生成html或者数据, 返回给前端.\n   * 这就完成了一个io操作.\n\n上面的这种操作, 就是后端路由.\n\n * 当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户端.\n * 这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于seo的优化.\n\n后端路由的缺点:\n\n * 一种情况是整个页面的模块由后端人员来编写和维护的.\n\n * 另一种情况是前端开发人员如果要开发页面, 需要通过php和java等语言来编写页面代码.\n\n * 而且通常情况下html代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情.\n\n\n# 阶段二：前后端分离阶段\n\n前端渲染的理解：\n\n * 每次请求涉及到的静态资源都会从静态资源服务器获取\n * 这些资源包括html+css+js，然后在前端对这些请求回来的资源进行渲染\n * 需要注意的是，客户端的每一次请求，都会从静态资源服务器请求文件\n * 同时可以看到，和之前的后断路由不同，这时后端只是负责提供api了\n\n前后端分离阶段：\n\n * 随着ajax的出现, 有了前后端分离的开发模式\n * 后端只提供api来返回数据，前端通过ajax获取数据，并且可以通过javascript将数据渲染到页面中\n * 这样做最大的优点就是前后端责任的清晰，后端专注于数据上，前端专注于交互和可视化上\n * 并且当移动端(ios/android)出现后，后端不需要进行任何处理，依然使用之前的一套api即可\n * 目前很多的网站依然采用这种模式开发（jquery开发模式）\n\n\n# 阶段三：单页面富应用spa\n\n * 单页面富应用的理解：\n   \n   * 单页面富应用的英文是single-page application，简称spa\n   * 整个web应用只有实际上只有一个页面，当url发生改变时，并不会从服务器请求新的静态资源\n   * 而是通过javascript监听url的改变，并且根据url的不同去渲染新的页面\n\n * 如何可以应用url和渲染的页面呢？\n   \n   * 前端路由维护着url和渲染页面的映射关系\n   * 路由可以根据不同的url，最终让我们的框架（比如vue、react、angular）去渲染不同的组件\n   * 最终我们在页面上看到的实际就是渲染的一个个组件页面\n\n\n# 前端路由的原理\n\n前端路由是如何做到url和内容进行映射呢？监听url的改变。\n\n * url发生变化，同时不引起页面的刷新有两个办法：\n   \n   * 通过url的hash改变url\n   * 通过html5中的history模式修改url\n\n * 当监听到url发生变化时，我们可以通过自己判断当前的url，决定到底渲染什么样的内容\n\n\n# url的hash\n\nurl的hash也就是锚点(#), 本质上是改变window.location的href属性\n\n我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新\n\n注意：\n\n * hash的优势就是兼容性更好，在老版ie(最低兼容到ie3)中都可以运行\n\n * 但是缺陷是有一个#，显得不像一个真实的路径，或者说有点丑💩\n\n  <body>\n        <div id=\"app\">\n            <a href=\"#/home\">主页</a>\n            <a href=\"#/about\">关于</a>\n            <div id=\"router-view\"></div>\n        </div>\n        <script>\n            const routerviewel = document.getelementbyid('router-view')\n            window.addeventlistener('hashchange', () => {\n                console.log(location.hash)\n                switch (location.hash) {\n                    case '#/home':\n                        routerviewel.innerhtml = '首页'\n                        break\n                    case '#/about':\n                        routerviewel.innerhtml = '关于'\n                        break\n                    default:\n                        routerviewel.innerhtml = ''\n                }\n            })\n        <\/script>\n    </body>\n\n\n\n# html5的history\n\nhistory接口是html5新增的, 它有六种模式改变url而不刷新页面：\n\n * replacestate：替换原来的路径\n * pushstate：使用新的路径\n * popstate：路径的回退\n * go：向前或向后改变路径\n * forward：向前改变路径\n * back：向后改变路径\n\n  <div id=\"app\">\n    <a href=\"/home\">首页</a>\n    <a href=\"/about\">关于</a>\n\n    <div class=\"router-view\"></div>\n  </div>\n\n  <script>\n    // 1.获取router-view的dom\n    const routerviewel = document.getelementsbyclassname(\"router-view\")[0];\n\n    // 获取所有的a元素, 自己来监听a元素的改变\n    const aels = document.getelementsbytagname(\"a\");\n    for (let el of aels) {\n      el.addeventlistener(\"click\", e => {\n        e.preventdefault();\n        const href = el.getattribute(\"href\");\n        history.pushstate({}, \"\", href);\n        urlchange();\n      })\n    }\n\n    // 调用 history.pushstate() 或者 history.replacestate() 不会触发 popstate 事件。popstate 事件只会在浏览器某些行为下触发，比如点击后退按钮（或者在 javascript 中调用 history.back() 方法）。即，在同一文档的两个历史记录条目之间导航会触发该事件。\n    // 无论是浏览器的前进还是后退都会触发这个popstate事件，所以只能起到一个监听页面变化的作用。\n    window.addeventlistener('popstate',urlchange);\n\n    // 监听url的改变\n    function urlchange() {\n      switch (location.pathname) {\n        case \"/home\":\n          routerviewel.innerhtml = \"首页\";\n          break;\n        case \"/about\":\n          routerviewel.innerhtml = \"关于\";\n          break;\n        default:\n          routerviewel.innerhtml = \"\";\n      }\n    }\n\n  <\/script>\n\n\n\n# react-router\n\n⚠️\n\n这里我使用的版本是版本：v5 ,最新版本是v6\n\n官方文档：\n\nv5\n\nv6\n\n相关文章：\n\nreact-router v6 完全解读指南 - react-router 篇（万字长文，学懂毕业）\n\n浅谈react-router-dom v6的配置使用\n\n「react进阶」react-router v6 通关指南\n\nreact router的版本4开始，路由不再集中在一个包中进行管理了：\n\n * react-router是router的核心部分代码\n * react-router-dom是用于浏览器的\n * react-router-native是用于原生应用的\n\n目前我们使用的react router版本是@5.2.0的版本\n\n安装react-router-dom会自动帮助我们安装react-router的依赖：yarn add react-router-dom\n\n\n# router的基本使用\n\nreact-router最主要的api是给我们提供的一些组件：\n\n * browserrouter或hashrouter\n   \n   * router中包含了对路径改变的监听，并且会将相应的路径传递给子组件\n   * browserrouter使用history模式\n   * hashrouter使用hash模式\n\n * link和navlink：\n   \n   * 通常路径的跳转是使用link组件，最终会被渲染成a元素\n   * navlink是在link基础之上增加了一些样式属性\n   * to属性：link中最重要的属性，用于设置跳转到的路径\n\n * route：\n   \n   * route用于路径的匹配\n   * path属性：用于设置匹配到的路径\n   * component属性：设置匹配到路径后，渲染的组件\n   * exact：精准匹配，只有精准匹配到完全一致的路径，才会渲染对应的组件；\n\nimport {component} from 'react';\nimport {browserrouter, link, route} from \"react-router-dom\";\nimport home from \"./pages/home\";\nimport about from \"./pages/about\";\n\nclass app extends component {\n    render() {\n        return (\n            <div>\n                <browserrouter>\n                    <link to='/'>首页</link>\n                    <link to='/about'>关于</link>\n\n                    <route exact path='/' component={home}/>\n                    <route path='/about' component={about}/>\n\n                </browserrouter>\n            </div>\n        );\n    }\n}\n\nexport default app;\n\n\n\n# navlink的使用\n\n需求：路径选中时，对应的a元素变为红色\n\n这个时候，我们要使用navlink组件来替代link组件：\n\n * activestyle：活跃时（匹配时）的样式\n * activeclassname：活跃时添加的class\n * exact：是否精准匹配\n\n默认的activeclassname：事实上在默认匹配成功时，navlink就会添加上一个动态的active class，所以我们也可以直接编写样式。当然，如果你担心这个class在其他地方被使用了，出现样式的层叠，也可以自定义class\n\n\n# switch的作用\n\n我们来看下面的路由规则：\n\n * 当我们匹配到某一个路径时，我们会发现有一些问题\n * 比如/about路径匹配到的同时，/:userid也被匹配到了，并且最后的一个nomatch组件总是被匹配到\n\n                        <route exact path='/' component={home}/>\n                        <route path='/about' component={about}/>\n                        <route path='/:userid' component={user}/>\n                        <route component={nomatch}/>\n\n\n原因是什么呢？默认情况下，react-router中只要是路径被匹配到的route对应的组件都会被渲染\n\n但是实际开发中，我们往往希望有一种排他的思想:只要匹配到了第一个，那么后面的就不应该继续匹配了；这个时候我们可以使用switch来将所有的route进行包裹即可\n\n                    <switch>\n                        <route exact path='/' component={home}/>\n                        <route path='/about' component={about}/>\n                        <route path='/:id' component={user}/>\n                        <route component={nomatch}/>\n                    </switch>\n\n\n\n# redirect\n\nredirect用于路由的重定向，当这个组件出现时，就会执行跳转到对应的to路径中：\n\n我们这里使用这个的一个案例：\n\n用户跳转到user界面,但是在user界面有一个islogin用于记录用户是否登录：\n\n * true：那么显示用户的名称\n\n * false：直接重定向到登录界面\n\n// user.jsx\nimport {component} from 'react';\nimport {redirect} from \"react-router-dom\";\n\nclass user extends component {\n    constructor() {\n        super();\n        this.state = {\n            islogin: false\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                {\n                    this.state.islogin ? <h2>用户：frank</h2> : <redirect to={'/login'}/>\n                }\n            </div>\n        );\n    }\n}\n\nexport default user;\n\n\n\n# 路由的嵌套\n\n在开发中，路由之间是存在嵌套关系的\n\n这里我们假设about页面中有两个页面内容：\n\n * 商品列表和消息列表\n * 点击不同的链接可以跳转到不同的地方，显示不同的内容\n\nimport {component} from 'react';\nimport {link, switch,route} from 'react-router-dom'\n\n\nfunction goodlist() {\n    return (\n        <ul>\n            {\n                [1, 2, 3].map(item => {\n                    return <li>{`商品${item}`}</li>\n                })\n            }\n        </ul>\n    )\n}\n\n\nfunction newslist() {\n    return (\n        <ul>\n            {\n                [1, 2, 3].map(item => {\n                    return <li>{`消息${item}`}</li>\n                })\n            }\n        </ul>\n    )\n}\n\nclass abouts extends component {\n    render() {\n        return (\n            <div>\n                <link to={'/about'}>商品列表</link>\n                <link to={'/about/news'}>消息列表</link>\n\n                <switch>\n                    <route exact path={'/about'} component={goodlist}/>\n                    <route path={'/about/news'} component={newslist}/>\n                </switch>\n            </div>\n        );\n    }\n}\n\nexport default abouts;\n\n\n\n# 手动路由跳转\n\n目前我们实现的跳转主要是通过link或者navlink进行跳转的，实际上我们也可以通过javascript代码进行跳转\n\n但是通过javascript代码进行跳转有一个前提：必须获取到history对象\n\n如何可以获取到history的对象呢？两种方式:\n\n * 如果该组件是通过路由直接跳转过来的，那么可以直接获取history、location、match对象\n\ntip\n\n * history.push 这个方法会向history栈里面添加一条新记录，这个时候用户点击浏览器的回退按钮可以回到之前的路径。\n\n * history.go 这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)\n\n * history.replace 跟 history.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。\n\nimport {component} from 'react';\nimport {navlink, switch, route} from 'react-router-dom'\n\nimport styled from \"styled-components\";\n\n\nconst aboutwrapper = styled.div`\n  .about-active {\n    color: orange;\n  }\n`\n\nfunction joinus() {\n    return (\n        <div>加入我们：zfhblog.top</div>\n    )\n}\n\nfunction goodlist() {\n    return (\n        <ul>\n            {\n                [1, 2, 3].map(item => {\n                    return <li key={item}>{`商品${item}`}</li>\n                })\n            }\n        </ul>\n    )\n}\n\n\nfunction newslist() {\n    return (\n        <ul>\n            {\n                [1, 2, 3].map(item => {\n                    return <li key={item}>{`消息${item}`}</li>\n                })\n            }\n        </ul>\n    )\n}\n\nclass abouts extends component {\n    render() {\n        return (\n            <div>\n                <aboutwrapper>\n                    <navlink exact to={'/about'} activeclassname={'about-active'}>商品列表</navlink>\n                    <navlink to={'/about/news'} activeclassname={'about-active'}>消息列表</navlink>\n                    <button onclick={() => {\n                        this.joinus()\n                    }}>加入我们\n                    </button>\n                </aboutwrapper>\n                <switch>\n                    <route exact path={'/about'} component={goodlist}/>\n                    <route path={'/about/news'} component={newslist}/>\n                    <route path={'/about/join'} component={joinus}/>\n                </switch>\n            </div>\n        );\n    }\n\n    joinus() {\n        this.props.history.push('/about/join')\n    }\n\n    componentdidmount() {\n        console.log(this.props.history)\n    }\n}\n\nexport default abouts;\n\n\n * 如果该组件是一个普通渲染的组件，那么不可以直接获取history、location、match对象\n\n那么如果普通的组件也希望获取对应的对象属性应该怎么做呢？\n\n前面我们学习过高阶组件，可以在组件中添加想要的属性;react-router也是通过高阶组件为我们的组件添加相关的属性的:\n\n如果我们希望在app组件中获取到history对象，必须满足以下两个条件：\n\n * app组件必须包裹在router组件之内\n * app组件使用withrouter高阶组件包裹\n\n// app.js\nimport {component} from 'react';\nimport {navlink, route, withrouter} from \"react-router-dom\";\nimport home from \"./pages/home\";\nimport abouts from \"./pages/abouts\";\nimport order from \"./pages/order\";\nimport styled from \"styled-components\";\n\nconst navlinkwrapper = styled.div`\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n\n  .link {\n    padding-top: 50px;\n    width: 100px;\n    background-color: #f1f1f1;\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n  }\n\n  a {\n    text-decoration: none;\n    margin-right: 20px;\n    font-size: 20px;\n  }\n\n  a.link-active {\n    color: red;\n  }\n`\n\nclass app extends component {\n    render() {\n        return (\n            <navlinkwrapper>\n                <div classname='link'>\n                    <navlink exact to='/' activeclassname={'link-active'}>首页</navlink>\n                    <navlink to='/about' activeclassname={'link-active'}>关于</navlink>\n                    <button to='/order' onclick={() => {\n                        this.toorder()\n                    }}>订单\n                    </button>\n                </div>\n                <route exact path='/' component={home}/>\n                <route path='/about' component={abouts}/>\n                <route path='/order' component={order}/>\n            </navlinkwrapper>\n        );\n    }\n\n    toorder() {\n        this.props.history.push('/order')\n    }\n}\n\nexport default withrouter(app);\n// index.js\nreactdom.render(<browserrouter><app/></browserrouter>, document.getelementbyid('root'))\n\n\n\n# 参数传递\n\n\n# 动态路由\n\n动态路由的概念指的是路由中的路径并不会固定：\n\n比如/detail的path对应一个组件detail。如果我们将path在route匹配时写成/detail/:id，那么 /detail/abc、/detail/123都可以匹配到该route，并且进行显示这个匹配规则，我们就称之为动态路由。通常情况下，使用动态路由可以为路由传递参数\n\nimport {component} from 'react';\nimport {navlink, route, withrouter} from \"react-router-dom\";\nimport home from \"./pages/home\";\nimport abouts from \"./pages/abouts\";\nimport order from \"./pages/order\";\nimport styled from \"styled-components\";\n\nconst navlinkwrapper = styled.div`\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n\n  .link {\n    padding-top: 50px;\n    width: 100px;\n    background-color: #f1f1f1;\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n  }\n\n  a {\n    text-decoration: none;\n    margin-right: 20px;\n    font-size: 20px;\n  }\n\n  a.link-active {\n    color: red;\n  }\n`\n\nclass app extends component {\n    render() {\n        return (\n            <navlinkwrapper>\n                <div classname='link'>\n                    <navlink exact to='/' activeclassname={'link-active'}>首页</navlink>\n                    <navlink to='/about' activeclassname={'link-active'}>关于</navlink>\n                    <button to='/order' onclick={() => {\n                        this.toorder()\n                    }}>订单\n                    </button>\n                </div>\n                <route exact path='/' component={home}/>\n                <route path='/about' component={abouts}/>\n                <route path='/order/:id' component={order}/>\n            </navlinkwrapper>\n        );\n    }\n\n    toorder() {\n        this.props.history.push('/order/123')\n    }\n}\n\nexport default withrouter(app);\n// ------------------------------------------\n// order.jsx\n// ------------------------------------------\nimport {component} from 'react';\n\nclass order extends component {\n    render() {\n        return (\n            <div>\n                <h2>订单:{this.props.match.params.id}</h2>\n            </div>\n        );\n    }\n}\n\nexport default order;\n\n\n\n# search传递参数\n\n// app.js\nimport {component} from 'react';\nimport {navlink, route, withrouter} from \"react-router-dom\";\nimport home from \"./pages/home\";\nimport abouts from \"./pages/abouts\";\nimport order2 from \"./pages/order2\";\nimport styled from \"styled-components\";\n\nconst navlinkwrapper = styled.div`\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n\n  .link {\n    padding-top: 50px;\n    width: 100px;\n    background-color: #f1f1f1;\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n  }\n\n  a {\n    text-decoration: none;\n    margin-right: 20px;\n    font-size: 20px;\n  }\n\n  a.link-active {\n    color: red;\n  }\n`\n\nclass app extends component {\n    render() {\n        return (\n            <navlinkwrapper>\n                <div classname='link'>\n                    <navlink exact to='/' activeclassname={'link-active'}>首页</navlink>\n                    <navlink to='/about' activeclassname={'link-active'}>关于</navlink>\n                    <button to='/order' onclick={() => {\n                        this.toorder()\n                    }}>订单\n                    </button>\n                </div>\n                <route exact path='/' component={home}/>\n                <route path='/about' component={abouts}/>\n                <route path='/order' component={order2}/>\n            </navlinkwrapper>\n        );\n    }\n\n    toorder() {\n        this.props.history.push('/order?id=123&name=frank&test=2&test2=1231231')\n    }\n}\n\nexport default withrouter(app);\n\n\nimport {component} from 'react';\n\nclass order2 extends component {\n    render() {\n        return (\n            <div>\n                <h2>订单:{this.props.match.params.id}</h2>\n            </div>\n        );\n    }\n\n    componentdidmount() {\n        let query = {}\n        const search = this.props.location.search.split('&')\n        search[0] = search[0].split('?')[1]\n        search.foreach(item => {\n            const kv = item.split('=')\n            query[kv[0]] = kv[1]\n        })\n        console.log(query)\n    }\n}\n\nexport default order2;\n\n\n\n# link中to可以直接传入一个对象\n\n这个对象有四个属性：\n\n * pathname：跳转的路径\n * state：复杂数据(对象)会传递到location\n * search:查询参数的字符串表示，例如?sort=name\n * hash:放入 url 的哈希值，例如#a-hash\n\n                    <navlink to={{pathname: '/test', state: {name: 'frank', age: 21}}}\n                    >测试</navlink>\n\n\n\n# react-router-config\n\n目前我们所有的路由定义都是直接使用route组件，并且添加属性来完成的。 但是这样的方式会让路由变得非常混乱，我们希望将所有的路由配置放到一个地方进行集中管理： 这个时候可以使用react-router-config来完成\n\n 1. 安装react-router-config:yarn add react-router-config\n 2. 配置路由映射的关系数组\n\nimport home from \"../pages/home\";\nimport abouts, {goodlist, joinus, newslist} from \"../pages/abouts\";\nimport order from \"../pages/order\";\n\nconst routes = [\n    {\n        path: '/',\n        exact: true,\n        component: home\n    },\n    {\n        path: '/about',\n        component: abouts,\n        routes: [\n            {\n                path: \"/about\",\n                exact: true,\n                component: goodlist,\n            },\n            {\n                path: '/about/news',\n                component: newslist,\n            },\n            {\n                path: '/about/join',\n                component: joinus\n            }\n        ]\n    },\n    {\n        path: '/order',\n        component: order\n    }\n]\n\nexport default routes\n\n\n 1. 使用renderroutes函数完成配置\n\nimport {component} from 'react';\nimport {navlink, route, withrouter} from \"react-router-dom\";\n// import home from \"./pages/home\";\n// import abouts from \"./pages/abouts\";\n// import order from \"./pages/order\";\nimport routes from \"./router\";\nimport styled from \"styled-components\";\nimport {renderroutes} from \"react-router-config\";\n\nconst navlinkwrapper = styled.div`\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n\n  .link {\n    padding-top: 50px;\n    width: 100px;\n    background-color: #f1f1f1;\n    display: flex;\n    align-items: center;\n    flex-direction: column;\n  }\n\n  a {\n    text-decoration: none;\n    margin-right: 20px;\n    font-size: 20px;\n  }\n\n  a.link-active {\n    color: red;\n  }\n`\n\nclass app extends component {\n    render() {\n        return (\n            <navlinkwrapper>\n                <div classname='link'>\n                    <navlink exact to='/' activeclassname={'link-active'}>首页</navlink>\n                    <navlink to='/about' activeclassname={'link-active'}>关于</navlink>\n                    <button  onclick={() => {\n                        this.toorder()\n                    }}>订单\n                    </button>\n                </div>\n                {/*<route exact path='/' component={home}/>*/}\n                {/*<route path='/about' component={abouts}/>*/}\n                {/*<route path='/order' component={order}/>*/}\n                {renderroutes(routes)}\n            </navlinkwrapper>\n        );\n    }\n\n    toorder() {\n        this.props.history.push('/order')\n    }\n}\n\nexport default withrouter(app);\n\n\nabouts.jsx:\n\nimport {component} from 'react';\nimport {navlink, switch, route} from 'react-router-dom'\n\nimport styled from \"styled-components\";\nimport {renderroutes} from \"react-router-config\";\n\n\nconst aboutwrapper = styled.div`\n  .about-active {\n    color: orange;\n  }\n`\n\nexport function joinus() {\n    return (\n        <div>加入我们：zfhblog.top</div>\n    )\n}\n\nexport function goodlist() {\n    return (\n        <ul>\n            {\n                [1, 2, 3].map(item => {\n                    return <li key={item}>{`商品${item}`}</li>\n                })\n            }\n        </ul>\n    )\n}\n\n\nexport function newslist() {\n    return (\n        <ul>\n            {\n                [1, 2, 3].map(item => {\n                    return <li key={item}>{`消息${item}`}</li>\n                })\n            }\n        </ul>\n    )\n}\n\nclass abouts extends component {\n    render() {\n        return (\n            <div>\n                <aboutwrapper>\n                    <navlink exact to={'/about'} activeclassname={'about-active'}>商品列表</navlink>\n                    <navlink to={'/about/news'} activeclassname={'about-active'}>消息列表</navlink>\n                    <button onclick={() => {\n                        this.joinus()\n                    }}>加入我们\n                    </button>\n                </aboutwrapper>\n                {/*<switch>*/}\n                {/*    <route exact path={'/about'} component={goodlist}/>*/}\n                {/*    <route path={'/about/news'} component={newslist}/>*/}\n                {/*    <route path={'/about/join'} component={joinus}/>*/}\n                {/*</switch>*/}\n                {renderroutes(this.props.route.routes)}\n            </div>\n        );\n    }\n\n    joinus() {\n        this.props.history.push('/about/join')\n    }\n\n    componentdidmount() {\n        // console.log(this.props.history)\n        console.log(this.props.route)\n    }\n}\n\nexport default abouts;\n\n\n\n# 🌟🌟🌟react-router v6\n\n\n#\n\n\n# 概述\n\n 1. react router 以三个不同的包发布到 npm 上，它们分别为：\n    \n    1. react-router: 路由的核心库，提供了很多的：组件、钩子。\n    2. react-router-dom: 包含react-router所有内容，并添加一些专门用于 dom 的组件，例如 <browserrouter>等 。\n    3. react-router-native: 包括react-router所有内容，并添加一些专门用于reactnative的api，例如:<nativerouter>等。\n\n 2. 与react router 5.x 版本相比，改变了什么？\n    \n    1. 内置组件的变化：移除<switch/> ，新增 <routes/>等。\n    \n    2. 语法的变化：component={about} 变为 element={<about/>}等。\n    \n    3. 新增多个hook：useparams、usenavigate、usematch等。\n    \n    4. 官方明确推荐函数式组件了！！！\n       \n       ......\n\n\n# component\n\n# <browserrouter>\n\n 1. 说明：<browserrouter>用于包裹整个应用。\n\n 2. 示例代码：\n    \n    import react from \"react\";\n    import reactdom from \"react-dom\";\n    import { browserrouter } from \"react-router-dom\";\n    \n    reactdom.render(\n      <browserrouter>\n        {/* 整体结构（通常为app组件） */}\n      </browserrouter>,root\n    );\n    \n\n# <hashrouter>\n\n 1. 说明：作用与<browserrouter>一样，但<hashrouter>修改的是地址栏的hash值。\n 2. 备注：6.x版本中<hashrouter>、<browserrouter> 的用法与 5.x 相同。\n\n# <routes/> 与 <route/>\n\n 1. v6版本中移出了先前的<switch>，引入了新的替代者：<routes>。\n\n 2. <routes> 和 <route>要配合使用，且必须要用<routes>包裹<route>。\n\n 3. <route> 相当于一个 if 语句，如果其路径与当前 url 匹配，则呈现其对应的组件。\n\n 4. <route casesensitive> 属性用于指定：匹配时是否区分大小写（默认为 false）。\n\n 5. 当url发生变化时，<routes>都会查看其所有子<route> 元素以找到最佳匹配并呈现组件 。\n\n 6. <route> 也可以嵌套使用，且可配合useroutes()配置 “路由表” ，但需要通过 <outlet> 组件来渲染其子路由。\n\n 7. 示例代码：\n    \n    <routes>\n        /*path属性用于定义路径，element属性用于定义当前路径所对应的组件*/\n        <route path=\"/login\" element={<login />}></route>\n    \n    \t\t/*用于定义嵌套路由，home是一级路由，对应的路径/home*/\n        <route path=\"home\" element={<home />}>\n           /*test1 和 test2 是二级路由,对应的路径是/home/test1 或 /home/test2*/\n          <route path=\"test1\" element={<test/>}></route>\n          <route path=\"test2\" element={<test2/>}></route>\n    \t\t</route>\n    \t\n    \t\t//route也可以不写element属性, 这时就是用于展示嵌套的路由 .所对应的路径是/users/xxx\n        <route path=\"users\">\n           <route path=\"xxx\" element={<demo />} />\n        </route>\n    </routes>\n    \n\n# <link>\n\n 1. 作用: 修改url，且不发送网络请求（路由链接）。\n\n 2. 注意: 外侧需要用<browserrouter>或<hashrouter>包裹。\n\n 3. 示例代码：\n    \n    import { link } from \"react-router-dom\";\n    \n    function test() {\n      return (\n        <div>\n        \t<link to=\"/路径\">按钮</link>\n        </div>\n      );\n    }\n    \n\n# <navlink>\n\n 1. 作用: 与<link>组件类似，且可实现导航的“高亮”效果。\n\n 2. 示例代码：\n    \n    // 注意: navlink默认类名是active，下面是指定自定义的class\n    \n    //自定义样式\n    <navlink\n        to=\"login\"\n        classname={({ isactive }) => {\n            console.log('home', isactive)\n            return isactive ? 'base one' : 'base'\n        }}\n    >login</navlink>\n    \n    /*\n    \t默认情况下，当home的子组件匹配成功，home的导航也会高亮，\n    \t当navlink上添加了end属性后，若home的子组件匹配成功，则home的导航没有高亮效果。\n    */\n    <navlink to=\"home\" end >home</navlink>\n    \n\n# <navigate>\n\n 1. 作用：只要<navigate>组件被渲染，就会修改路径，切换视图。\n\n 2. replace属性用于控制跳转模式（push 或 replace，默认是push）。\n\n 3. 示例代码：\n    \n    import react,{usestate} from 'react'\n    import {navigate} from 'react-router-dom'\n    \n    export default function home() {\n    \tconst [sum,setsum] = usestate(1)\n    \treturn (\n    \t\t<div>\n    \t\t\t<h3>我是home的内容</h3>\n    \t\t\t{/* 根据sum的值决定是否切换视图 */}\n    \t\t\t{sum === 1 ? <h4>sum的值为{sum}</h4> : <navigate to=\"/about\" replace={true}/>}\n    \t\t\t<button onclick={()=>setsum(2)}>点我将sum变为2</button>\n    \t\t</div>\n    \t)\n    }\n    \n\n# <outlet>\n\n 1. 当<route>产生嵌套时，渲染其对应的后续子路由。\n\n 2. 示例代码：\n    \n    //根据路由表生成对应的路由规则\n    const element = useroutes([\n      {\n        path:'/about',\n        element:<about/>\n      },\n      {\n        path:'/home',\n        element:<home/>,\n        children:[\n          {\n            path:'news',\n            element:<news/>\n          },\n          {\n            path:'message',\n            element:<message/>,\n          }\n        ]\n      }\n    ])\n    \n    //home.js\n    import react from 'react'\n    import {navlink,outlet} from 'react-router-dom'\n    \n    export default function home() {\n    \treturn (\n    \t\t<div>\n    \t\t\t<h2>home组件内容</h2>\n    \t\t\t<div>\n    \t\t\t\t<ul classname=\"nav nav-tabs\">\n    \t\t\t\t\t<li>\n    \t\t\t\t\t\t<navlink classname=\"list-group-item\" to=\"news\">news</navlink>\n    \t\t\t\t\t</li>\n    \t\t\t\t\t<li>\n    \t\t\t\t\t\t<navlink classname=\"list-group-item\" to=\"message\">message</navlink>\n    \t\t\t\t\t</li>\n    \t\t\t\t</ul>\n    \t\t\t\t{/* 指定路由组件呈现的位置 */}\n    \t\t\t\t<outlet />\n    \t\t\t</div>\n    \t\t</div>\n    \t)\n    }\n    \n    \n\n\n# hooks\n\n# useroutes()\n\n 1. 作用：根据路由表，动态创建<routes>和<route>。\n\n 2. 示例代码：\n    \n    //路由表配置：src/routes/index.js\n    import about from '../pages/about'\n    import home from '../pages/home'\n    import {navigate} from 'react-router-dom'\n    \n    export default [\n    \t{\n    \t\tpath:'/about',\n    \t\telement:<about/>\n    \t},\n    \t{\n    \t\tpath:'/home',\n    \t\telement:<home/>\n    \t},\n    \t{\n    \t\tpath:'/',\n    \t\telement:<navigate to=\"/about\"/>\n    \t}\n    ]\n    \n    //app.jsx\n    import react from 'react'\n    import {navlink,useroutes} from 'react-router-dom'\n    import routes from './routes'\n    \n    export default function app() {\n    \t//根据路由表生成对应的路由规则\n    \tconst element = useroutes(routes)\n    \treturn (\n    \t\t<div>\n    \t\t\t......\n          {/* 注册路由 */}\n          {element}\n    \t\t  ......\n    \t\t</div>\n    \t)\n    }\n    \n    \n\n# usenavigate()\n\n 1. 作用：返回一个函数用来实现编程式导航。\n\n 2. 示例代码：\n    \n    import react from 'react'\n    import {usenavigate} from 'react-router-dom'\n    \n    export default function demo() {\n      const navigate = usenavigate()\n      const handle = () => {\n        //第一种使用方式：指定具体的路径\n        navigate('/login', {\n          replace: false,\n          state: {a:1, b:2}\n        }) \n        //第二种使用方式：传入数值进行前进或后退，类似于5.x中的 history.go()方法\n        navigate(-1)\n      }\n      \n      return (\n        <div>\n          <button onclick={handle}>按钮</button>\n        </div>\n      )\n    }\n    \n\n# useparams()\n\n 1. 作用：回当前匹配路由的params参数，类似于5.x中的match.params。\n\n 2. 示例代码：\n    \n    import react from 'react';\n    import { routes, route, useparams } from 'react-router-dom';\n    import user from './pages/user.jsx'\n    \n    function profilepage() {\n      // 获取url中携带过来的params参数\n      let { id } = useparams();\n    }\n    \n    function app() {\n      return (\n        <routes>\n          <route path=\"users/:id\" element={<user />}/>\n        </routes>\n      );\n    }\n    \n\n# usesearchparams()\n\n 1. 作用：用于读取和修改当前位置的 url 中的查询字符串。\n\n 2. 返回一个包含两个值的数组，内容分别为：当前的seaech参数、更新search的函数。\n\n 3. 示例代码：\n    \n    import react from 'react'\n    import {usesearchparams} from 'react-router-dom'\n    \n    export default function detail() {\n    \tconst [search,setsearch] = usesearchparams()\n    \tconst id = search.get('id')\n    \tconst title = search.get('title')\n    \tconst content = search.get('content')\n    \treturn (\n    \t\t<ul>\n    \t\t\t<li>\n    \t\t\t\t<button onclick={()=>setsearch('id=008&title=哈哈&content=嘻嘻')}>点我更新一下收到的search参数</button>\n    \t\t\t</li>\n    \t\t\t<li>消息编号：{id}</li>\n    \t\t\t<li>消息标题：{title}</li>\n    \t\t\t<li>消息内容：{content}</li>\n    \t\t</ul>\n    \t)\n    }\n    \n    \n\n# uselocation()\n\n 1. 作用：获取当前 location 信息，对标5.x中的路由组件的location属性。\n\n 2. 示例代码：\n    \n    import react from 'react'\n    import {uselocation} from 'react-router-dom'\n    \n    export default function detail() {\n    \tconst x = uselocation()\n    \tconsole.log('@',x)\n      // x就是location对象: \n    \t/*\n    \t\t{\n          hash: \"\",\n          key: \"ah9nv6sz\",\n          pathname: \"/login\",\n          search: \"?name=zs&age=18\",\n          state: {a: 1, b: 2}\n        }\n    \t*/\n    \treturn (\n    \t\t<ul>\n    \t\t\t<li>消息编号：{id}</li>\n    \t\t\t<li>消息标题：{title}</li>\n    \t\t\t<li>消息内容：{content}</li>\n    \t\t</ul>\n    \t)\n    }\n    \n      \n    \n    \n    \n\n# usematch()\n\n 1. 作用：返回当前匹配信息，对标5.x中的路由组件的match属性。\n\n 2. 示例代码：\n    \n    <route path=\"/login/:page/:pagesize\" element={<login />}/>\n    <navlink to=\"/login/1/10\">登录</navlink>\n    \n    export default function login() {\n      const match = usematch('/login/:x/:y')\n      console.log(match) //输出match对象\n      //match对象内容如下：\n      /*\n      \t{\n          params: {x: '1', y: '10'}\n          pathname: \"/login/1/10\"  \n          pathnamebase: \"/login/1/10\"\n          pattern: {\n          \tpath: '/login/:x/:y', \n          \tcasesensitive: false, \n          \tend: false\n          }\n        }\n      */\n      return (\n      \t<div>\n          <h1>login</h1>\n        </div>\n      )\n    }\n    \n\n# useinroutercontext()\n\n\t\t作用：如果组件在 `<router>` 的上下文中呈现，则 `useinroutercontext` 钩子返回 true，否则返回 false。\n\n\n# usenavigationtype()\n\n 1. 作用：返回当前的导航类型（用户是如何来到当前页面的）。\n 2. 返回值：pop、push、replace。\n 3. 备注：pop是指在浏览器中直接打开了这个路由组件（刷新页面）。\n\n# useoutlet()\n\n 1. 作用：用来呈现当前组件中渲染的嵌套路由。\n\n 2. 示例代码：\n    \n    const result = useoutlet()\n    console.log(result)\n    // 如果嵌套路由没有挂载,则result为null\n    // 如果嵌套路由已经挂载,则展示嵌套的路由对象\n    \n\n# useresolvedpath()\n\n 1. 作用：给定一个 url值，解析其中的：path、search、hash值。",charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"React Hook",frontmatter:{title:"React Hook",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/ReactHook.html",relativePath:"前端开发/前端框架/React/ReactHook.md",key:"v-18f59fc6",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/ReactHook.html",headers:[{level:2,title:"Class 组件存在的问题",slug:"class-组件存在的问题",normalizedTitle:"class 组件存在的问题",charIndex:2},{level:2,title:"为什么需要 Hook？",slug:"为什么需要-hook",normalizedTitle:"为什么需要 hook？",charIndex:658},{level:2,title:"Hook 的出现",slug:"hook-的出现",normalizedTitle:"hook 的出现",charIndex:1166},{level:2,title:"Hook 规则",slug:"hook-规则",normalizedTitle:"hook 规则",charIndex:1279},{level:2,title:"useState",slug:"usestate",normalizedTitle:"usestate",charIndex:1440},{level:3,title:"函数式更新",slug:"函数式更新",normalizedTitle:"函数式更新",charIndex:2775},{level:2,title:"useEffect",slug:"useeffect",normalizedTitle:"useeffect",charIndex:3330},{level:3,title:"需要清除 Effect",slug:"需要清除-effect",normalizedTitle:"需要清除 effect",charIndex:4058},{level:3,title:"使用多个 Effect",slug:"使用多个-effect",normalizedTitle:"使用多个 effect",charIndex:4768},{level:3,title:"Effect 性能优化",slug:"effect-性能优化",normalizedTitle:"effect 性能优化",charIndex:4861},{level:2,title:"useContext",slug:"usecontext",normalizedTitle:"usecontext",charIndex:6004},{level:2,title:"useReducer",slug:"usereducer",normalizedTitle:"usereducer",charIndex:7178},{level:2,title:"useCallback",slug:"usecallback",normalizedTitle:"usecallback",charIndex:7415},{level:2,title:"useMemo",slug:"usememo",normalizedTitle:"usememo",charIndex:9450},{level:3,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:9740},{level:2,title:"useRef",slug:"useref",normalizedTitle:"useref",charIndex:10554},{level:2,title:"useImperativeHandle",slug:"useimperativehandle",normalizedTitle:"useimperativehandle",charIndex:11642},{level:2,title:"useLayoutEffect",slug:"uselayouteffect",normalizedTitle:"uselayouteffect",charIndex:12588},{level:2,title:"自定义 Hook",slug:"自定义-hook",normalizedTitle:"自定义 hook",charIndex:1389},{level:3,title:"案例 1:所有的组件在创建和销毁时都进行打印",slug:"案例-1-所有的组件在创建和销毁时都进行打印",normalizedTitle:"案例 1:所有的组件在创建和销毁时都进行打印",charIndex:13463},{level:3,title:"案例 2:Context 的共享",slug:"案例-2-context-的共享",normalizedTitle:"案例 2:context 的共享",charIndex:14409},{level:3,title:"案例 2:获取滚动位置",slug:"案例-2-获取滚动位置",normalizedTitle:"案例 2:获取滚动位置",charIndex:14793},{level:3,title:"案例 3：localStorage 存储",slug:"案例-3-localstorage-存储",normalizedTitle:"案例 3：localstorage 存储",charIndex:15557},{level:2,title:"redux hooks",slug:"redux-hooks",normalizedTitle:"redux hooks",charIndex:15927}],headersStr:"Class 组件存在的问题 为什么需要 Hook？ Hook 的出现 Hook 规则 useState 函数式更新 useEffect 需要清除 Effect 使用多个 Effect Effect 性能优化 useContext useReducer useCallback useMemo 使用场景 useRef useImperativeHandle useLayoutEffect 自定义 Hook 案例 1:所有的组件在创建和销毁时都进行打印 案例 2:Context 的共享 案例 2:获取滚动位置 案例 3：localStorage 存储 redux hooks",content:"# Class 组件存在的问题\n\n 1. 复杂组件变得难以理解：\n    \n    我们在最初编写一个 class 组件时，往往逻辑比较简单，并不会非常复杂。但是随着业务的增多，我们的 class 组件会变得越来越复杂\n    \n    比如 componentDidMount 中，可能就会包含大量的逻辑代码：包括网络请求、一些事件的监听（还需要在 componentWillUnmount 中移除）\n    \n    而对于这样的 class 实际上非常难以拆分：因为它们的逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度\n\n 2. 难以理解的 class：\n    \n    很多人发现学习 ES6 的 class 是学习 React 的一个障碍\n    \n    比如在 class 中，我们必须搞清楚 this 的指向到底是谁\n\n 3. 实现组件状态逻辑复用很难:\n    \n    在前面为了组件状态逻辑复用我们需要通过高阶组件或 render props(🔎 详情见 react 组件化)\n    \n    像我们之前学习的 redux 中 connect 或者 react-router 中的 withRouter，这些高阶组件设计的目的就是为了状态的复用\n    \n    或者类似于 Provider、Consumer 来共享一些状态，但是多次使用 Consumer 时，我们的代码就会存在很多嵌套\n    \n    这些代码让我们不管是编写和设计上来说，都变得非常困难\n\n\n# 为什么需要 Hook？\n\nHook 是 React 16.8 的新增特性，它可以让我们在不编写 class 的情况下使用 state 以及其他的 React 特性（比如生命周期）\n\n我们先来思考一下 class 组件相对于函数式组件有什么优势？比较常见的是下面的优势：\n\n * class 组件可以定义自己的 state，用来保存组件自己内部的状态；函数式组件不可以，因为函数每次调用都会产生新的临时变量；\n\n * class 组件有自己的生命周期，我们可以在对应的生命周期中完成自己的逻辑；比如在 componentDidMount 中发送网络请求，并且该生命周期函数只会执行一次；函数式组件在学习 hooks 之前，如果在函数中发送网络请求，意味着每次重新渲染都会重新发送一次网络请求；\n\n * class 组件可以在状态改变时只会重新执行 render 函数以及我们希望重新调用的生命周期函数 componentDidUpdate 等函数式组件在重新渲染时，整个函数都会被执行，似乎没有什么地方可以只让它们调用一次；\n\n所以，在 Hook 出现之前，对于上面这些情况我们通常都会编写 class 组件\n\n\n# Hook 的出现\n\nHook 可以让我们在不编写 class 的情况下使用 state 以及其他的 React 特性\n\nHook 的出现基本可以代替我们之前所有使用 class 组件的地方（除了一些非常不常用的场景）\n\n\n# Hook 规则\n\n 1. 只在最顶层使用 Hook。不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层以及任何 return 之前调用他们\n\n 2. 只在 React 函数（函数组件，自定义 Hook）中调用 Hook，不要在普通的 JavaScript 函数中调用 Hook\n\n\n# useState\n\nuseState 来自 react，需要从 react 中导入，它是一个 hook\n\n * 参数：初始化值\n * 返回值：数组，包含两个元素\n   * 元素一：当前状态的值（第一调用为初始化值）\n   * 元素二：设置状态值的函数\n\nuseState 会帮助我们定义一个 state 变量，useState 是一种新方法，它与 class 里面的 this.state 提供的功能完全相同。一般来说，在函数退出后变量就会”消失”，而 state 中的变量会被 React 保留\n\nuseState 接受唯一一个参数，在第一次组件被调用时使用来作为初始化值\n\nuseState 是一个数组，我们可以通过数组的解构，来完成赋值会非常方便\n\nimport { useState } from 'react'\n\nexport default function App() {\n    const [friends, setFriends] = useState([\n        {\n            name: 'frank',\n            age: 10,\n        },\n        {\n            name: 'zhang',\n            age: 123,\n        },\n    ])\n\n    function addAge(index) {\n        const newFriends = [...friends]\n        newFriends[index].age += 1\n        setFriends(newFriends)\n    }\n\n    return (\n        <div>\n            <ul>\n                {friends.map((item, index) => {\n                    return (\n                        <li key={index}>\n                            {item.name},{item.age},\n                            <button\n                                onClick={e => {\n                                    addAge(index)\n                                }}\n                            >\n                                age+1\n                            </button>\n                        </li>\n                    )\n                })}\n            </ul>\n        </div>\n    )\n}\n\n\n\n# 函数式更新\n\n如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 setState 的两种用法：\n\nfunction Counter({ initialCount }) {\n    const [count, setCount] = useState(initialCount)\n    return (\n        <>\n            Count: {count}\n            <button onClick={() => setCount(initialCount)}>Reset</button>\n            <button onClick={() => setCount(prevCount => prevCount - 1)}>\n                -\n            </button>\n            <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>\n        </>\n    )\n}\n\n\n\n# useEffect\n\nuseEffect 要求我们传入一个回调函数，默认情况下，无论是第一次渲染之后，还是每次 DOM 更新之后，都会执行这个回调函数\n\nuseEffect可以看作是 componentDidMount,componentDidUpdate , componentWillUnmount 这三个函数的组合\n\nimport { useEffect, useState } from 'react'\n\nexport default () => {\n    const [count, setCount] = useState(1)\n    useEffect(() => {\n        // 网页标题和count同步\n        // 如果采用class组件实现相同的功能\n        // 需要在componentDidMount,componentDidUpdate 两个生命周期函数中，\n        // 编写相同的逻辑代码\n        document.title = count\n    })\n    return (\n        <div>\n            {count}\n            <button\n                onClick={() => {\n                    setCount(prevCount => prevCount + 1)\n                }}\n            >\n                +1\n            </button>\n        </div>\n    )\n}\n\n\n\n# 需要清除 Effect\n\n在 class 组件的编写过程中，某些副作用的代码，我们需要 componentWillUnmount 中进行清除，比如我们之前的事件总线或 Redux 中手动调用 subscribe，都需要在 componentWillUnmount 有对应的取消订阅\n\nuseEffect 传入的回调函数 A 本身可以有一个返回值，这个返回值是另外一个回调函数 B，如此可以将添加和移除订阅的逻辑放在一起。React 会在组件更新和卸载的时候执行清除操作\n\nreact 中文文档此处翻译会让人产生误解\n\nWhen exactly(究竟) does React clean up an effect? React performs(执行) the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React also cleans up effects from the previous render before running the effects next time.\n\nsummary :react performs the cleanup when the componrnt unmount and update\n\nuseEffect(() => {\n    // ,....\n    return () => {\n        // cleanup\n    }\n})\n\n\n\n# 使用多个 Effect\n\nHook 允许我们按照代码的用途分离它们， 而不是像生命周期函数那样,React 将按照 effect 声明的顺序依次调用组件中的每一个 effect\n\n\n# Effect 性能优化\n\n默认情况下，useEffect 的回调函数会在每次渲染时都重新执行，但是这会导致两个问题\n\n某些代码我们只是希望执行一次即可，类似于 componentDidMount 和 componentWillUnmount 中完成的事情（比如网 络请求、订阅和取消订阅）\n\n另外，多次执行也会导致一定的性能问题\n\n我们如何决定 useEffect 在什么时候应该执行和什么时候不应该执行呢？\n\nuseEffect 实际上有两个参数：\n\n * 参数一：执行的回调函数\n * 参数二：一个数组;其中存放的元素发生变化时，effect 会重新执行；如果数组中有多个元素，即使只有一个元素发生变化，React 也会执行 effect。\n\n如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会随时间变化并且在 effect 中使用的变量（同时满足这两个条件），否则你的代码会引用到先前渲染中的旧变量，如下面的代码所示：\n\nimport { useEffect, useState } from 'react'\n\nexport default () => {\n    const [count, setCount] = useState(1)\n    const [login, setLogin] = useState(false)\n    useEffect(() => {\n        console.log(`count增加了`, count)\n        console.log(login) //  看这里 输出有问题\n    }, [count])\n    useEffect(() => {\n        console.log('第二个effect')\n    }, [login])\n    return (\n        <div>\n            {count}\n            <button onClick={event => setCount(count + 1)}>+</button>\n            <button onClick={event => setLogin(!login)}>\n                {login ? '已登陆' : '未登录'}\n            </button>\n        </div>\n    )\n}\n\n\n如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行\n\n\n# useContext\n\n在之前的开发中，我们要在组件中使用共享的 Context 有两种方式：\n\n * 类组件可以通过 类名.contextType = MyContext 方式，在类中获取 context\n * 多个 Context 或者在函数式组件中通过 MyContext.Consumer 方式共享 context；\n\n但是多个 Context 共享时的方式会存在大量的嵌套\n\nContext Hook 允许我们通过 Hook 来直接获取某个 Context 的值:\n\nimport React, { Component, useContext, useEffect } from 'react'\n\nconst MyContext = React.createContext()\nconst MyContext2 = React.createContext()\n\nfunction User() {\n    //  useContext 的参数必须是 context 对象本身\n    const user = useContext(MyContext)\n    const user2 = useContext(MyContext2)\n    useEffect(() => {\n        console.log(user, user2)\n    })\n    return (\n        <div>\n            {user.age},{user.name}\n        </div>\n    )\n}\n\nexport default class App extends Component {\n    constructor() {\n        super()\n        this.state = {\n            name: 'frank',\n            age: 123,\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <MyContext.Provider value={this.state}>\n                    <MyContext2.Provider value={{ name: 'frank123' }}>\n                        <User />\n                    </MyContext2.Provider>\n                </MyContext.Provider>\n            </div>\n        )\n    }\n}\n\n\n\n# useReducer\n\nuseReducer 仅仅是 useState 的一种替代方案：\n\n * 在某些场景下，如果 state 的处理逻辑比较复杂，我们可以通过 useReducer 来对其进行拆分\n * 或者这次修改的 state 需要依赖之前的 state 时，也可以使用\n\n不同组件之间数据是不会共享的，它们只是使用了相同的 counterReducer 的函数而已；所以，useReducer 只是 useState 的一种替代品，并不能替代 Redux\n\n\n# useCallback\n\nuseCallback 实际的目的是为了进行性能的优化。\n\n如何进行性能的优化呢？\n\n * useCallback 会返回一个函数的 memoized（记忆的） 值\n * 在依赖不变的情况下，多次定义的时候，返回的值是相同的\n\n通常使用 useCallback 的目的是不希望子组件进行多次渲染，并不是为了函数进行缓存\n\n 1. 使用 useCallback 定义一个函数不会带来性能的优化\n\nimport { useState, useCallback } from 'react'\n\nexport default () => {\n    console.log('app渲染了！')\n    const [count, setCount] = useState(0)\n    const add1 = () => {\n        console.log('执行add---1')\n        setCount(count + 1)\n    }\n    //重新渲染，依然存在函数创建的过程\n    const add2 = useCallback(() => {\n        console.log('执行add---2')\n        setCount(count + 1)\n    }, [count])\n    return (\n        <div>\n            <h1>{count}</h1>\n\n            <button\n                onClick={() => {\n                    add1()\n                }}\n            >\n                add1\n            </button>\n            <button\n                onClick={() => {\n                    add2()\n                }}\n            >\n                add2\n            </button>\n        </div>\n    )\n}\n\n\n 2. 使用 useCallback 定义一个函数传递给子组件会带来性能的优化\n\nimport { useState, memo, useCallback } from 'react'\n\nconst MemoButton = memo(function Abutton(props) {\n    console.log('Abutton已渲染,,,' + props.title)\n    return (\n        <div>\n            <button onClick={props.add}>add1</button>\n        </div>\n    )\n})\n\nexport default () => {\n    console.log('app渲染了！')\n    const [count, setCount] = useState(0)\n    const [login, setLogin] = useState(false)\n    const add1 = () => {\n        console.log('执行add---1')\n        setCount(count + 1)\n    }\n    const add2 = useCallback(() => {\n        console.log('执行add---2')\n        setCount(count + 1)\n    }, [count])\n    return (\n        <div>\n            <h1>{count}</h1>\n            <MemoButton title={'add1'} add={add1} />\n            //\n            count不发生变化，每次传入的add函数都是同一个，加上memo带来了性能优化\n            <MemoButton title={'add2'} add={add2} />\n            <button\n                onClick={() => {\n                    setLogin(!login)\n                }}\n            >\n                切换\n            </button>\n        </div>\n    )\n}\n\n\n\n# useMemo\n\nTIP\n\nuseMemo 和 useCallBack 的区别是 useMemo 是基于函数的返回值进行优化，返回值可以是对象，一个值，一个函数；useCallBack 则只能基于函数进行优化\n\nuseMemo 实际的目的也是为了进行性能的优化\n\n如何进行性能的优化呢？\n\n * useMemo 返回的也是一个 memoized（记忆的） 值\n\n * 在依赖不变的情况下，多次定义的时候，返回的值是相同的\n\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b])\n\n\n\n# 使用场景\n\n进行大量的计算操作，是否有必须要每次渲染时都重新计算\n\nimport { useMemo, useState } from 'react'\n\nfunction bigNum(count) {\n    console.log(`bigNum重新计算`)\n    let total = 0\n    for (let i = 0; i < count; i++) {\n        total += i\n    }\n    return total\n}\nexport default () => {\n    const [count, setCount] = useState(0)\n    const [login, setLogin] = useState(false)\n\n    const total = useMemo(() => bigNum(count), [count])\n    return (\n        <div>\n            <h2>{total}</h2>\n            <button\n                onClick={() => {\n                    setCount(count + 1)\n                }}\n            >\n                +\n            </button>\n            <button\n                onClick={() => {\n                    setLogin(!login)\n                }}\n            >\n                切换\n            </button>\n        </div>\n    )\n}\n\n\n\n# useRef\n\nuseRef 返回一个 ref 对象，返回的 ref 对象再组件的整个生命周期保持不变。\n\n最常用的 ref 是两种用法：\n\n * 用法一：引入 DOM（或者组件，但是需要是 class 组件）元素\n * 用法二：保存一个数据，这个对象在整个生命周期中可以保存不变\n\n案例：\n\n * 案例一：引用 DOM\n\nimport { useRef } from 'react'\n\nexport default () => {\n    const titleRef = useRef()\n    const inputRef = useRef()\n    const changeDOM = () => {\n        inputRef.current.focus()\n        titleRef.current.innerHTML = 'hello,sb'\n    }\n    return (\n        <div>\n            <input type=\"text\" ref={inputRef} />\n            <h2 ref={titleRef}>hello,html!</h2>\n            <button onClick={changeDOM}>changeDOM</button>\n        </div>\n    )\n}\n\n\n * 案例二：使用 ref 保存上一次的某一个值\n\nimport { useEffect, useRef, useState } from 'react'\n\nexport default () => {\n    const [count, setCount] = useState(0)\n    const numRef = useRef(count)\n    useEffect(() => {\n        numRef.current = count\n    }, [count])\n    const add = () => {\n        setCount(count + 10)\n    }\n    return (\n        <div>\n            <h2>上一次的值：{numRef.current}</h2>\n            <h2>这一次的值：{count}</h2>\n            <button onClick={add}>+10</button>\n        </div>\n    )\n}\n\n\n\n# useImperativeHandle\n\n通过 forwardRef 可以将 ref 转发到子组件,子组件拿到父组件中创建的 ref，绑定到自己的某一个元素中\n\nforwardRef 的做法本身没有什么问题，但是我们是将子组件的 DOM 直接暴露给了父组件：\n\n * 直接暴露给父组件带来的问题是某些情况的不可控\n\n * 父组件可以拿到 DOM 后进行任意的操作\n\n通过 useImperativeHandle 可以值暴露固定的操作：\n\n * 通过 useImperativeHandle，将传入的 ref 和 useImperativeHandle 第二个参数返回的对象绑定到了一起\n * 所以在父组件中，使用 inputRef.current 时，实际上使用的是返回的对象\n\nimport { forwardRef, useImperativeHandle, useRef } from 'react'\n\nconst Input = forwardRef((_, ref) => {\n    const inputRef = useRef()\n    useImperativeHandle(ref, () => ({\n        focus: () => {\n            inputRef.current.focus()\n        },\n    }))\n    return <input type=\"text\" ref={inputRef} />\n})\n\nexport default () => {\n    const TitleRef = useRef()\n    const ChangeDOM = () => {\n        TitleRef.current.focus()\n        console.log(TitleRef)\n    }\n    return (\n        <div>\n            <Input ref={TitleRef} />\n            <button onClick={ChangeDOM}>changeDOM</button>\n        </div>\n    )\n}\n\n\n\n# useLayoutEffect\n\nuseLayoutEffect看起来和 useEffect 非常的相似，事实上他们也只有一点区别而已：\n\n * useEffect 会在渲染的内容更新到 DOM 上后执行，不会阻塞 DOM 的更新\n\n * useLayoutEffect 会在渲染的内容更新到 DOM 上之前执行，会阻塞 DOM 的更新\n\n\n\n如果我们希望在某些操作发生之后再更新 DOM，那么应该将这个操作放到 useLayoutEffect：\n\nimport { useEffect, useLayoutEffect, useState } from 'react'\n\nexport default () => {\n    const [count, setCount] = useState(10)\n    // 使用useEffecrt,出现闪屏\n    // 实际上useLayoutEffect用的并不多\n    useLayoutEffect(() => {\n        if (count === 0) {\n            setCount(Math.random())\n        }\n    }, [count])\n    return (\n        <div>\n            {count}\n            <button\n                onClick={() => {\n                    setCount(0)\n                }}\n            >\n                改数字\n            </button>\n        </div>\n    )\n}\n\n\n一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect\n\n\n# 自定义 Hook\n\n自定义 Hook 本质上只是一种函数代码逻辑的抽取，严格意义上来说，它本身并不算 React 的特性\n\n\n# 案例 1:所有的组件在创建和销毁时都进行打印\n\n组件被创建：打印 组件被创建了；组件被销毁：打印 组件被销毁了\n\nimport { useEffect, useState } from 'react'\n\nconst Com1 = () => {\n    usePrintLog('com1')\n    return <h2>Com1</h2>\n}\n\nconst Com2 = () => {\n    usePrintLog('com2')\n    return <h2>Com2</h2>\n}\n\nconst Com3 = () => {\n    usePrintLog('com3')\n    return <h2>Com3</h2>\n}\n\nexport default () => {\n    const [display, setdisplay] = useState(true)\n    return (\n        <div>\n            {display ? <Com1 /> : <h2>Com1销毁</h2>}\n            {display ? <Com2 /> : <h2>Com2销毁</h2>}\n            {display ? <Com3 /> : <h2>Com3销毁</h2>}\n            <button\n                onClick={() => {\n                    setdisplay(!display)\n                }}\n            >\n                display?\n            </button>\n        </div>\n    )\n}\n\nconst usePrintLog = name => {\n    useEffect(() => {\n        console.log(`${name}创建了`)\n        return () => {\n            console.log(`${name}销毁了`)\n        }\n    }, [])\n}\n\n\n\n# 案例 2:Context 的共享\n\nimport { userContext } from '../11_useHook_共享context/app'\nimport { useContext } from 'react'\n\n// 自定义Hook\nexport default function useUserContext() {\n    const user = useContext(userContext)\n    return [user]\n}\n\n\n// 在组件中使用\nconst User = () => {\n    const [user] = useUserContext()\n    return (\n        <div>\n            <h2>{user.name}</h2>\n        </div>\n    )\n}\n\n\n\n# 案例 2:获取滚动位置\n\nimport { useEffect, useState } from 'react'\n\nfunction useScrollPosition() {\n    const [scrollPosition, setScrollPosition] = useState(0)\n    const handleScroll = () => {\n        setScrollPosition(window.scrollY)\n    }\n    useEffect(() => {\n        window.addEventListener('scroll', handleScroll)\n        return () => {\n            window.removeEventListener('scroll', handleScroll)\n        }\n    }, [])\n    return scrollPosition\n}\n\nexport default useScrollPosition\n\n\nimport useScrollPosition from './Hook/useScrollPosition'\n\nexport default () => {\n    const scrollPositon = useScrollPosition()\n    return (\n        <div style={{ height: '2000px' }}>\n            <h2 style={{ position: 'fixed' }}>当前滚动位置：{scrollPositon}</h2>\n        </div>\n    )\n}\n\n\n\n# 案例 3：localStorage 存储\n\nimport { useEffect, useState } from 'react'\n\nconst useLocalStorage = key => {\n    const [data, setData] = useState(() => {\n        return JSON.parse(window.localStorage.getItem(key))\n    })\n    useEffect(() => {\n        localStorage.setItem(key, JSON.stringify(data))\n    }, [data])\n    return [data, setData]\n}\nexport default useLocalStorage\n\n\n\n# redux hooks\n\n使用 useSelector、useDispatch 等 HooksApi 替代 connect\n\nuseSelector 的作用是将 state 映射到组件中:\n\n * 参数一：将 state 映射到需要的数据中\n\n * 参数二：可以进行比较来决定是否组件重新渲染（可以传入 react-redux 中的 shallowEqual 函数进行浅层比较）\n\nuseSelector 默认会比较我们返回的两个对象是否相等，如何比较呢？ const refEquality = (a, b) => a === b,也就是我们必须返回两个完全相等的对象才可以不引起重新渲染（这一点真的很坑。connect是会对mapStateToProps返回的对象进行浅层比较的）\n\n什么是浅层比较？\n\n// a simple implementation of the shallowCompare.\n// only compares the first level properties and hence shallow.\n// state updates(theoretically) if this function returns true.\nfunction shallowCompare(newObj, prevObj) {\n    for (key in newObj) {\n        if (newObj[key] !== prevObj[key]) return true\n    }\n    return false\n}\n//\nvar game_item = {\n    game: 'football',\n    first_world_cup: '1930',\n    teams: {\n        North_America: 1,\n        South_America: 4,\n        Europe: 8,\n    },\n}\n// Case 1:\n// if this be the object passed to setState\nvar updated_game_item1 = {\n    game: 'football',\n    first_world_cup: '1930',\n    teams: {\n        North_America: 1,\n        South_America: 4,\n        Europe: 8,\n    },\n}\n\nconsole.log(shallowCompare(updated_game_item1, game_item)) // false\n\n\nuseDispatch 非常简单，就是直接获取 dispatch 函数，之后在组件中直接使用即可\n\nusedispatch 的坑\n\n注意如果在 useEffect 中使用 dispatch，请将 dispatch 添加在依赖项数组中，否则可能会引起该组件的不停渲染，原因未知\n\n    useEffect(() => {\n      // 这里是利用redux-thunk发送网络请求\n            dispatch(getBannerDataAction())\n        }, [dispatch]\n    )\n\n\nimport React from 'react'\nimport { createStore } from 'redux'\nimport { Provider, useSelector, useDispatch } from 'react-redux'\n\nconst initialState = { num: 0 }\n\nconst reducer = (state = initialState, action) => {\n    switch (action.type) {\n        case 'decrement':\n            return { ...state, num: state.num - 1 }\n        case 'increment':\n            return { ...state, num: state.num + 1 }\n        default:\n            return state\n    }\n}\n\nconst store = createStore(reducer)\n\nconst ComponentUseReactRedux = () => {\n    return (\n        <div>\n            <h2>ComponentUseReactRedux</h2>\n            <Provider store={store}>\n                <ChildComponentUseReactRedux />\n            </Provider>\n        </div>\n    )\n}\n\nconst ChildComponentUseReactRedux = () => {\n    const num = useSelector(state => state.num)\n    const dispatch = useDispatch()\n    return (\n        <div>\n            <h3>Using useSelector, useDispatch</h3>\n            Number: {num}\n            <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n            <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n        </div>\n    )\n}\n\nexport default ComponentUseReactRedux\n",normalizedContent:"# class 组件存在的问题\n\n 1. 复杂组件变得难以理解：\n    \n    我们在最初编写一个 class 组件时，往往逻辑比较简单，并不会非常复杂。但是随着业务的增多，我们的 class 组件会变得越来越复杂\n    \n    比如 componentdidmount 中，可能就会包含大量的逻辑代码：包括网络请求、一些事件的监听（还需要在 componentwillunmount 中移除）\n    \n    而对于这样的 class 实际上非常难以拆分：因为它们的逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度\n\n 2. 难以理解的 class：\n    \n    很多人发现学习 es6 的 class 是学习 react 的一个障碍\n    \n    比如在 class 中，我们必须搞清楚 this 的指向到底是谁\n\n 3. 实现组件状态逻辑复用很难:\n    \n    在前面为了组件状态逻辑复用我们需要通过高阶组件或 render props(🔎 详情见 react 组件化)\n    \n    像我们之前学习的 redux 中 connect 或者 react-router 中的 withrouter，这些高阶组件设计的目的就是为了状态的复用\n    \n    或者类似于 provider、consumer 来共享一些状态，但是多次使用 consumer 时，我们的代码就会存在很多嵌套\n    \n    这些代码让我们不管是编写和设计上来说，都变得非常困难\n\n\n# 为什么需要 hook？\n\nhook 是 react 16.8 的新增特性，它可以让我们在不编写 class 的情况下使用 state 以及其他的 react 特性（比如生命周期）\n\n我们先来思考一下 class 组件相对于函数式组件有什么优势？比较常见的是下面的优势：\n\n * class 组件可以定义自己的 state，用来保存组件自己内部的状态；函数式组件不可以，因为函数每次调用都会产生新的临时变量；\n\n * class 组件有自己的生命周期，我们可以在对应的生命周期中完成自己的逻辑；比如在 componentdidmount 中发送网络请求，并且该生命周期函数只会执行一次；函数式组件在学习 hooks 之前，如果在函数中发送网络请求，意味着每次重新渲染都会重新发送一次网络请求；\n\n * class 组件可以在状态改变时只会重新执行 render 函数以及我们希望重新调用的生命周期函数 componentdidupdate 等函数式组件在重新渲染时，整个函数都会被执行，似乎没有什么地方可以只让它们调用一次；\n\n所以，在 hook 出现之前，对于上面这些情况我们通常都会编写 class 组件\n\n\n# hook 的出现\n\nhook 可以让我们在不编写 class 的情况下使用 state 以及其他的 react 特性\n\nhook 的出现基本可以代替我们之前所有使用 class 组件的地方（除了一些非常不常用的场景）\n\n\n# hook 规则\n\n 1. 只在最顶层使用 hook。不要在循环，条件或嵌套函数中调用 hook， 确保总是在你的 react 函数的最顶层以及任何 return 之前调用他们\n\n 2. 只在 react 函数（函数组件，自定义 hook）中调用 hook，不要在普通的 javascript 函数中调用 hook\n\n\n# usestate\n\nusestate 来自 react，需要从 react 中导入，它是一个 hook\n\n * 参数：初始化值\n * 返回值：数组，包含两个元素\n   * 元素一：当前状态的值（第一调用为初始化值）\n   * 元素二：设置状态值的函数\n\nusestate 会帮助我们定义一个 state 变量，usestate 是一种新方法，它与 class 里面的 this.state 提供的功能完全相同。一般来说，在函数退出后变量就会”消失”，而 state 中的变量会被 react 保留\n\nusestate 接受唯一一个参数，在第一次组件被调用时使用来作为初始化值\n\nusestate 是一个数组，我们可以通过数组的解构，来完成赋值会非常方便\n\nimport { usestate } from 'react'\n\nexport default function app() {\n    const [friends, setfriends] = usestate([\n        {\n            name: 'frank',\n            age: 10,\n        },\n        {\n            name: 'zhang',\n            age: 123,\n        },\n    ])\n\n    function addage(index) {\n        const newfriends = [...friends]\n        newfriends[index].age += 1\n        setfriends(newfriends)\n    }\n\n    return (\n        <div>\n            <ul>\n                {friends.map((item, index) => {\n                    return (\n                        <li key={index}>\n                            {item.name},{item.age},\n                            <button\n                                onclick={e => {\n                                    addage(index)\n                                }}\n                            >\n                                age+1\n                            </button>\n                        </li>\n                    )\n                })}\n            </ul>\n        </div>\n    )\n}\n\n\n\n# 函数式更新\n\n如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setstate。该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 setstate 的两种用法：\n\nfunction counter({ initialcount }) {\n    const [count, setcount] = usestate(initialcount)\n    return (\n        <>\n            count: {count}\n            <button onclick={() => setcount(initialcount)}>reset</button>\n            <button onclick={() => setcount(prevcount => prevcount - 1)}>\n                -\n            </button>\n            <button onclick={() => setcount(prevcount => prevcount + 1)}>+</button>\n        </>\n    )\n}\n\n\n\n# useeffect\n\nuseeffect 要求我们传入一个回调函数，默认情况下，无论是第一次渲染之后，还是每次 dom 更新之后，都会执行这个回调函数\n\nuseeffect可以看作是 componentdidmount,componentdidupdate , componentwillunmount 这三个函数的组合\n\nimport { useeffect, usestate } from 'react'\n\nexport default () => {\n    const [count, setcount] = usestate(1)\n    useeffect(() => {\n        // 网页标题和count同步\n        // 如果采用class组件实现相同的功能\n        // 需要在componentdidmount,componentdidupdate 两个生命周期函数中，\n        // 编写相同的逻辑代码\n        document.title = count\n    })\n    return (\n        <div>\n            {count}\n            <button\n                onclick={() => {\n                    setcount(prevcount => prevcount + 1)\n                }}\n            >\n                +1\n            </button>\n        </div>\n    )\n}\n\n\n\n# 需要清除 effect\n\n在 class 组件的编写过程中，某些副作用的代码，我们需要 componentwillunmount 中进行清除，比如我们之前的事件总线或 redux 中手动调用 subscribe，都需要在 componentwillunmount 有对应的取消订阅\n\nuseeffect 传入的回调函数 a 本身可以有一个返回值，这个返回值是另外一个回调函数 b，如此可以将添加和移除订阅的逻辑放在一起。react 会在组件更新和卸载的时候执行清除操作\n\nreact 中文文档此处翻译会让人产生误解\n\nwhen exactly(究竟) does react clean up an effect? react performs(执行) the cleanup when the component unmounts. however, as we learned earlier, effects run for every render and not just once. this is why react also cleans up effects from the previous render before running the effects next time.\n\nsummary :react performs the cleanup when the componrnt unmount and update\n\nuseeffect(() => {\n    // ,....\n    return () => {\n        // cleanup\n    }\n})\n\n\n\n# 使用多个 effect\n\nhook 允许我们按照代码的用途分离它们， 而不是像生命周期函数那样,react 将按照 effect 声明的顺序依次调用组件中的每一个 effect\n\n\n# effect 性能优化\n\n默认情况下，useeffect 的回调函数会在每次渲染时都重新执行，但是这会导致两个问题\n\n某些代码我们只是希望执行一次即可，类似于 componentdidmount 和 componentwillunmount 中完成的事情（比如网 络请求、订阅和取消订阅）\n\n另外，多次执行也会导致一定的性能问题\n\n我们如何决定 useeffect 在什么时候应该执行和什么时候不应该执行呢？\n\nuseeffect 实际上有两个参数：\n\n * 参数一：执行的回调函数\n * 参数二：一个数组;其中存放的元素发生变化时，effect 会重新执行；如果数组中有多个元素，即使只有一个元素发生变化，react 也会执行 effect。\n\n如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会随时间变化并且在 effect 中使用的变量（同时满足这两个条件），否则你的代码会引用到先前渲染中的旧变量，如下面的代码所示：\n\nimport { useeffect, usestate } from 'react'\n\nexport default () => {\n    const [count, setcount] = usestate(1)\n    const [login, setlogin] = usestate(false)\n    useeffect(() => {\n        console.log(`count增加了`, count)\n        console.log(login) //  看这里 输出有问题\n    }, [count])\n    useeffect(() => {\n        console.log('第二个effect')\n    }, [login])\n    return (\n        <div>\n            {count}\n            <button onclick={event => setcount(count + 1)}>+</button>\n            <button onclick={event => setlogin(!login)}>\n                {login ? '已登陆' : '未登录'}\n            </button>\n        </div>\n    )\n}\n\n\n如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 react 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行\n\n\n# usecontext\n\n在之前的开发中，我们要在组件中使用共享的 context 有两种方式：\n\n * 类组件可以通过 类名.contexttype = mycontext 方式，在类中获取 context\n * 多个 context 或者在函数式组件中通过 mycontext.consumer 方式共享 context；\n\n但是多个 context 共享时的方式会存在大量的嵌套\n\ncontext hook 允许我们通过 hook 来直接获取某个 context 的值:\n\nimport react, { component, usecontext, useeffect } from 'react'\n\nconst mycontext = react.createcontext()\nconst mycontext2 = react.createcontext()\n\nfunction user() {\n    //  usecontext 的参数必须是 context 对象本身\n    const user = usecontext(mycontext)\n    const user2 = usecontext(mycontext2)\n    useeffect(() => {\n        console.log(user, user2)\n    })\n    return (\n        <div>\n            {user.age},{user.name}\n        </div>\n    )\n}\n\nexport default class app extends component {\n    constructor() {\n        super()\n        this.state = {\n            name: 'frank',\n            age: 123,\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <mycontext.provider value={this.state}>\n                    <mycontext2.provider value={{ name: 'frank123' }}>\n                        <user />\n                    </mycontext2.provider>\n                </mycontext.provider>\n            </div>\n        )\n    }\n}\n\n\n\n# usereducer\n\nusereducer 仅仅是 usestate 的一种替代方案：\n\n * 在某些场景下，如果 state 的处理逻辑比较复杂，我们可以通过 usereducer 来对其进行拆分\n * 或者这次修改的 state 需要依赖之前的 state 时，也可以使用\n\n不同组件之间数据是不会共享的，它们只是使用了相同的 counterreducer 的函数而已；所以，usereducer 只是 usestate 的一种替代品，并不能替代 redux\n\n\n# usecallback\n\nusecallback 实际的目的是为了进行性能的优化。\n\n如何进行性能的优化呢？\n\n * usecallback 会返回一个函数的 memoized（记忆的） 值\n * 在依赖不变的情况下，多次定义的时候，返回的值是相同的\n\n通常使用 usecallback 的目的是不希望子组件进行多次渲染，并不是为了函数进行缓存\n\n 1. 使用 usecallback 定义一个函数不会带来性能的优化\n\nimport { usestate, usecallback } from 'react'\n\nexport default () => {\n    console.log('app渲染了！')\n    const [count, setcount] = usestate(0)\n    const add1 = () => {\n        console.log('执行add---1')\n        setcount(count + 1)\n    }\n    //重新渲染，依然存在函数创建的过程\n    const add2 = usecallback(() => {\n        console.log('执行add---2')\n        setcount(count + 1)\n    }, [count])\n    return (\n        <div>\n            <h1>{count}</h1>\n\n            <button\n                onclick={() => {\n                    add1()\n                }}\n            >\n                add1\n            </button>\n            <button\n                onclick={() => {\n                    add2()\n                }}\n            >\n                add2\n            </button>\n        </div>\n    )\n}\n\n\n 2. 使用 usecallback 定义一个函数传递给子组件会带来性能的优化\n\nimport { usestate, memo, usecallback } from 'react'\n\nconst memobutton = memo(function abutton(props) {\n    console.log('abutton已渲染,,,' + props.title)\n    return (\n        <div>\n            <button onclick={props.add}>add1</button>\n        </div>\n    )\n})\n\nexport default () => {\n    console.log('app渲染了！')\n    const [count, setcount] = usestate(0)\n    const [login, setlogin] = usestate(false)\n    const add1 = () => {\n        console.log('执行add---1')\n        setcount(count + 1)\n    }\n    const add2 = usecallback(() => {\n        console.log('执行add---2')\n        setcount(count + 1)\n    }, [count])\n    return (\n        <div>\n            <h1>{count}</h1>\n            <memobutton title={'add1'} add={add1} />\n            //\n            count不发生变化，每次传入的add函数都是同一个，加上memo带来了性能优化\n            <memobutton title={'add2'} add={add2} />\n            <button\n                onclick={() => {\n                    setlogin(!login)\n                }}\n            >\n                切换\n            </button>\n        </div>\n    )\n}\n\n\n\n# usememo\n\ntip\n\nusememo 和 usecallback 的区别是 usememo 是基于函数的返回值进行优化，返回值可以是对象，一个值，一个函数；usecallback 则只能基于函数进行优化\n\nusememo 实际的目的也是为了进行性能的优化\n\n如何进行性能的优化呢？\n\n * usememo 返回的也是一个 memoized（记忆的） 值\n\n * 在依赖不变的情况下，多次定义的时候，返回的值是相同的\n\nconst memoizedvalue = usememo(() => computeexpensivevalue(a, b), [a, b])\n\n\n\n# 使用场景\n\n进行大量的计算操作，是否有必须要每次渲染时都重新计算\n\nimport { usememo, usestate } from 'react'\n\nfunction bignum(count) {\n    console.log(`bignum重新计算`)\n    let total = 0\n    for (let i = 0; i < count; i++) {\n        total += i\n    }\n    return total\n}\nexport default () => {\n    const [count, setcount] = usestate(0)\n    const [login, setlogin] = usestate(false)\n\n    const total = usememo(() => bignum(count), [count])\n    return (\n        <div>\n            <h2>{total}</h2>\n            <button\n                onclick={() => {\n                    setcount(count + 1)\n                }}\n            >\n                +\n            </button>\n            <button\n                onclick={() => {\n                    setlogin(!login)\n                }}\n            >\n                切换\n            </button>\n        </div>\n    )\n}\n\n\n\n# useref\n\nuseref 返回一个 ref 对象，返回的 ref 对象再组件的整个生命周期保持不变。\n\n最常用的 ref 是两种用法：\n\n * 用法一：引入 dom（或者组件，但是需要是 class 组件）元素\n * 用法二：保存一个数据，这个对象在整个生命周期中可以保存不变\n\n案例：\n\n * 案例一：引用 dom\n\nimport { useref } from 'react'\n\nexport default () => {\n    const titleref = useref()\n    const inputref = useref()\n    const changedom = () => {\n        inputref.current.focus()\n        titleref.current.innerhtml = 'hello,sb'\n    }\n    return (\n        <div>\n            <input type=\"text\" ref={inputref} />\n            <h2 ref={titleref}>hello,html!</h2>\n            <button onclick={changedom}>changedom</button>\n        </div>\n    )\n}\n\n\n * 案例二：使用 ref 保存上一次的某一个值\n\nimport { useeffect, useref, usestate } from 'react'\n\nexport default () => {\n    const [count, setcount] = usestate(0)\n    const numref = useref(count)\n    useeffect(() => {\n        numref.current = count\n    }, [count])\n    const add = () => {\n        setcount(count + 10)\n    }\n    return (\n        <div>\n            <h2>上一次的值：{numref.current}</h2>\n            <h2>这一次的值：{count}</h2>\n            <button onclick={add}>+10</button>\n        </div>\n    )\n}\n\n\n\n# useimperativehandle\n\n通过 forwardref 可以将 ref 转发到子组件,子组件拿到父组件中创建的 ref，绑定到自己的某一个元素中\n\nforwardref 的做法本身没有什么问题，但是我们是将子组件的 dom 直接暴露给了父组件：\n\n * 直接暴露给父组件带来的问题是某些情况的不可控\n\n * 父组件可以拿到 dom 后进行任意的操作\n\n通过 useimperativehandle 可以值暴露固定的操作：\n\n * 通过 useimperativehandle，将传入的 ref 和 useimperativehandle 第二个参数返回的对象绑定到了一起\n * 所以在父组件中，使用 inputref.current 时，实际上使用的是返回的对象\n\nimport { forwardref, useimperativehandle, useref } from 'react'\n\nconst input = forwardref((_, ref) => {\n    const inputref = useref()\n    useimperativehandle(ref, () => ({\n        focus: () => {\n            inputref.current.focus()\n        },\n    }))\n    return <input type=\"text\" ref={inputref} />\n})\n\nexport default () => {\n    const titleref = useref()\n    const changedom = () => {\n        titleref.current.focus()\n        console.log(titleref)\n    }\n    return (\n        <div>\n            <input ref={titleref} />\n            <button onclick={changedom}>changedom</button>\n        </div>\n    )\n}\n\n\n\n# uselayouteffect\n\nuselayouteffect看起来和 useeffect 非常的相似，事实上他们也只有一点区别而已：\n\n * useeffect 会在渲染的内容更新到 dom 上后执行，不会阻塞 dom 的更新\n\n * uselayouteffect 会在渲染的内容更新到 dom 上之前执行，会阻塞 dom 的更新\n\n\n\n如果我们希望在某些操作发生之后再更新 dom，那么应该将这个操作放到 uselayouteffect：\n\nimport { useeffect, uselayouteffect, usestate } from 'react'\n\nexport default () => {\n    const [count, setcount] = usestate(10)\n    // 使用useeffecrt,出现闪屏\n    // 实际上uselayouteffect用的并不多\n    uselayouteffect(() => {\n        if (count === 0) {\n            setcount(math.random())\n        }\n    }, [count])\n    return (\n        <div>\n            {count}\n            <button\n                onclick={() => {\n                    setcount(0)\n                }}\n            >\n                改数字\n            </button>\n        </div>\n    )\n}\n\n\n一开始先用 useeffect，只有当它出问题的时候再尝试使用 uselayouteffect\n\n\n# 自定义 hook\n\n自定义 hook 本质上只是一种函数代码逻辑的抽取，严格意义上来说，它本身并不算 react 的特性\n\n\n# 案例 1:所有的组件在创建和销毁时都进行打印\n\n组件被创建：打印 组件被创建了；组件被销毁：打印 组件被销毁了\n\nimport { useeffect, usestate } from 'react'\n\nconst com1 = () => {\n    useprintlog('com1')\n    return <h2>com1</h2>\n}\n\nconst com2 = () => {\n    useprintlog('com2')\n    return <h2>com2</h2>\n}\n\nconst com3 = () => {\n    useprintlog('com3')\n    return <h2>com3</h2>\n}\n\nexport default () => {\n    const [display, setdisplay] = usestate(true)\n    return (\n        <div>\n            {display ? <com1 /> : <h2>com1销毁</h2>}\n            {display ? <com2 /> : <h2>com2销毁</h2>}\n            {display ? <com3 /> : <h2>com3销毁</h2>}\n            <button\n                onclick={() => {\n                    setdisplay(!display)\n                }}\n            >\n                display?\n            </button>\n        </div>\n    )\n}\n\nconst useprintlog = name => {\n    useeffect(() => {\n        console.log(`${name}创建了`)\n        return () => {\n            console.log(`${name}销毁了`)\n        }\n    }, [])\n}\n\n\n\n# 案例 2:context 的共享\n\nimport { usercontext } from '../11_usehook_共享context/app'\nimport { usecontext } from 'react'\n\n// 自定义hook\nexport default function useusercontext() {\n    const user = usecontext(usercontext)\n    return [user]\n}\n\n\n// 在组件中使用\nconst user = () => {\n    const [user] = useusercontext()\n    return (\n        <div>\n            <h2>{user.name}</h2>\n        </div>\n    )\n}\n\n\n\n# 案例 2:获取滚动位置\n\nimport { useeffect, usestate } from 'react'\n\nfunction usescrollposition() {\n    const [scrollposition, setscrollposition] = usestate(0)\n    const handlescroll = () => {\n        setscrollposition(window.scrolly)\n    }\n    useeffect(() => {\n        window.addeventlistener('scroll', handlescroll)\n        return () => {\n            window.removeeventlistener('scroll', handlescroll)\n        }\n    }, [])\n    return scrollposition\n}\n\nexport default usescrollposition\n\n\nimport usescrollposition from './hook/usescrollposition'\n\nexport default () => {\n    const scrollpositon = usescrollposition()\n    return (\n        <div style={{ height: '2000px' }}>\n            <h2 style={{ position: 'fixed' }}>当前滚动位置：{scrollpositon}</h2>\n        </div>\n    )\n}\n\n\n\n# 案例 3：localstorage 存储\n\nimport { useeffect, usestate } from 'react'\n\nconst uselocalstorage = key => {\n    const [data, setdata] = usestate(() => {\n        return json.parse(window.localstorage.getitem(key))\n    })\n    useeffect(() => {\n        localstorage.setitem(key, json.stringify(data))\n    }, [data])\n    return [data, setdata]\n}\nexport default uselocalstorage\n\n\n\n# redux hooks\n\n使用 useselector、usedispatch 等 hooksapi 替代 connect\n\nuseselector 的作用是将 state 映射到组件中:\n\n * 参数一：将 state 映射到需要的数据中\n\n * 参数二：可以进行比较来决定是否组件重新渲染（可以传入 react-redux 中的 shallowequal 函数进行浅层比较）\n\nuseselector 默认会比较我们返回的两个对象是否相等，如何比较呢？ const refequality = (a, b) => a === b,也就是我们必须返回两个完全相等的对象才可以不引起重新渲染（这一点真的很坑。connect是会对mapstatetoprops返回的对象进行浅层比较的）\n\n什么是浅层比较？\n\n// a simple implementation of the shallowcompare.\n// only compares the first level properties and hence shallow.\n// state updates(theoretically) if this function returns true.\nfunction shallowcompare(newobj, prevobj) {\n    for (key in newobj) {\n        if (newobj[key] !== prevobj[key]) return true\n    }\n    return false\n}\n//\nvar game_item = {\n    game: 'football',\n    first_world_cup: '1930',\n    teams: {\n        north_america: 1,\n        south_america: 4,\n        europe: 8,\n    },\n}\n// case 1:\n// if this be the object passed to setstate\nvar updated_game_item1 = {\n    game: 'football',\n    first_world_cup: '1930',\n    teams: {\n        north_america: 1,\n        south_america: 4,\n        europe: 8,\n    },\n}\n\nconsole.log(shallowcompare(updated_game_item1, game_item)) // false\n\n\nusedispatch 非常简单，就是直接获取 dispatch 函数，之后在组件中直接使用即可\n\nusedispatch 的坑\n\n注意如果在 useeffect 中使用 dispatch，请将 dispatch 添加在依赖项数组中，否则可能会引起该组件的不停渲染，原因未知\n\n    useeffect(() => {\n      // 这里是利用redux-thunk发送网络请求\n            dispatch(getbannerdataaction())\n        }, [dispatch]\n    )\n\n\nimport react from 'react'\nimport { createstore } from 'redux'\nimport { provider, useselector, usedispatch } from 'react-redux'\n\nconst initialstate = { num: 0 }\n\nconst reducer = (state = initialstate, action) => {\n    switch (action.type) {\n        case 'decrement':\n            return { ...state, num: state.num - 1 }\n        case 'increment':\n            return { ...state, num: state.num + 1 }\n        default:\n            return state\n    }\n}\n\nconst store = createstore(reducer)\n\nconst componentusereactredux = () => {\n    return (\n        <div>\n            <h2>componentusereactredux</h2>\n            <provider store={store}>\n                <childcomponentusereactredux />\n            </provider>\n        </div>\n    )\n}\n\nconst childcomponentusereactredux = () => {\n    const num = useselector(state => state.num)\n    const dispatch = usedispatch()\n    return (\n        <div>\n            <h3>using useselector, usedispatch</h3>\n            number: {num}\n            <button onclick={() => dispatch({ type: 'increment' })}>+</button>\n            <button onclick={() => dispatch({ type: 'decrement' })}>-</button>\n        </div>\n    )\n}\n\nexport default componentusereactredux\n",charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"React与TypeScript",frontmatter:{title:"React与TypeScript",date:"2022/05/24 22:38:46",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%8ETypeScript.html",relativePath:"前端开发/前端框架/React/React与TypeScript.md",key:"v-0b0e011c",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%8ETypeScript.html",headers:[{level:2,title:"开发环境配置",slug:"开发环境配置",normalizedTitle:"开发环境配置",charIndex:2},{level:3,title:"使用 create-react-app 创建 react+ts 项目",slug:"使用-create-react-app-创建-react-ts-项目",normalizedTitle:"使用 create-react-app 创建 react+ts 项目",charIndex:13},{level:2,title:"tsconfig.json",slug:"tsconfig-json",normalizedTitle:"tsconfig.json",charIndex:104}],headersStr:"开发环境配置 使用 create-react-app 创建 react+ts 项目 tsconfig.json",content:"# 开发环境配置\n\n\n# 使用 create-react-app 创建 react+ts 项目\n\nnpx create-react-app my-app --template typescript\n\n\n\n# tsconfig.json",normalizedContent:"# 开发环境配置\n\n\n# 使用 create-react-app 创建 react+ts 项目\n\nnpx create-react-app my-app --template typescript\n\n\n\n# tsconfig.json",charsets:{cjk:!0},lastUpdated:"2022年06月05日",lastUpdatedTimestamp:1654439564e3},{title:"React中axios",frontmatter:{title:"React中axios",date:"2022/05/18 18:25:09",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%ADaxios.html",relativePath:"前端开发/前端框架/React/React中axios.md",key:"v-1d8ccd1e",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%ADaxios.html",headers:[{level:2,title:"为什么不是...?",slug:"为什么不是",normalizedTitle:"为什么不是...?",charIndex:34},{level:2,title:"为什么是 Axios？",slug:"为什么是-axios",normalizedTitle:"为什么是 axios？",charIndex:135},{level:2,title:"Axios 的基本使用",slug:"axios-的基本使用",normalizedTitle:"axios 的基本使用",charIndex:190},{level:3,title:"发送请求",slug:"发送请求",normalizedTitle:"发送请求",charIndex:206},{level:3,title:"配置信息",slug:"配置信息",normalizedTitle:"配置信息",charIndex:1317},{level:3,title:"拦截器",slug:"拦截器",normalizedTitle:"拦截器",charIndex:1387},{level:2,title:"axios 库的二次封装",slug:"axios-库的二次封装",normalizedTitle:"axios 库的二次封装",charIndex:1906},{level:3,title:"为什么要封装？",slug:"为什么要封装",normalizedTitle:"为什么要封装？",charIndex:1923},{level:3,title:"axios 二次封装",slug:"axios-二次封装",normalizedTitle:"axios 二次封装",charIndex:2230}],headersStr:"为什么不是...? 为什么是 Axios？ Axios 的基本使用 发送请求 配置信息 拦截器 axios 库的二次封装 为什么要封装？ axios 二次封装",content:"官方文档\n\nReact 系列十三 - axios 库的使用\n\n\n# 为什么不是...?\n\n 1. Jquery-ajax:没什么好说的\n 2. Fetch API：Fetch 是一个 low-level（底层）的 API，没有帮助你封装好各种各样的功能 和实现\n\n\n# 为什么是 Axios？\n\nVue 作者也是推荐在 vue 中使用 axios(尤大说好就是好 👌)\n\n\n# Axios 的基本使用\n\n\n# 发送请求\n\nreact 一般在componentDidMount生命周期函数中发生网络请求\n\n🌰 例子：\n\nimport { PureComponent } from 'react'\nimport axios from 'axios'\n\nexport default class App extends PureComponent {\n    constructor() {\n        super()\n        this.state = {\n            res: {},\n        }\n    }\n    render() {\n        return <div>url:{this.state.res.url}</div>\n    }\n    async componentDidMount() {\n        const res = await axios.get('https://httpbin.org/get')\n        this.setState({\n            res: res.data,\n        })\n    }\n}\n\n\n * 发送 get 请求\n * 发送 post 请求\n * 多个请求的合并\n\nconst request1 = axios.get('https://httpbin.org/get', {\n    params: { name: 'why', age: 18 },\n})\nconst request2 = axios.post('https://httpbin.org/post', {\n    name: 'kobe',\n    age: 40,\n})\naxios\n    .all([request1, request2])\n    .then(([res1, res2]) => {\n        console.log(res1, res2)\n    })\n    .catch(err => {\n        console.log(err)\n    })\n\n\n * 使用 async、await 发送请求\n\nasync componentDidMount() {\n    const result = await axios.get(\"https://httpbin.org/get\", {\n      params: {\n        name: \"kobe\",\n        age: 40\n      }\n    })\n    console.log(result);\n  }\n\n\n\n# 配置信息\n\n * 优先是请求的 config 参数配置\n * 其次是实例的 default 中的配置\n * 最后是创建实例时的配置\n\n\n# 拦截器\n\naxios.interceptors.request.use(config => {\n  // 1.发送网络请求时，在页面中添加一个loading组件作为动画；\n\n  // 2.某些网络请求要求用户必须登录，可以在请求中判断是否携带了token，没有携带token直接跳转到login页面；\n\n  // 3.对某些请求参数进行序列化；\n  return config;\n}, err => {\n  return err;\n})\n\naxios.interceptors.response.use(response => {\n  return response.data;\n}, err => {\n  if (err && err.response) {\n    switch (err.response.status) {\n      case400:\n        err.message = \"请求错误\";\n        break;\n      case401:\n        err.message = \"未授权访问\";\n        break;\n    }\n  }\n  return err;\n})\n\n\n\n# axios 库的二次封装\n\n\n# 为什么要封装？\n\n为什么我们要对 axios 进行二次封装呢？\n\n * 默认情况下我们是可以直接使用 axios 来进行开发的；\n * 但是我们考虑一个问题，假如有 100 多处中都直接依赖 axios，突然间有一天 axios 出现了重大 bug，并且该库已经不再维护，这个时候你如何处理呢？\n * 大多数情况下我们会寻找一个新的网络请求库或者自己进行二次封装；\n * 但是有 100 多处都依赖了 axios，方便我们进行修改吗？我们所有依赖 axios 库的地方都需要进行修改\n * 如果是自己进行了二次封装，并且暴露一套自己的 API:只需要重新封装另一个网络请求库(只需要修改一个 js 文件)\n\n\n# axios 二次封装\n\n创建一个 service 文件夹（其他名字都可以），用于存放所有的网络请求相关的内容。\n\n创建文件 config.js，用于存放一些配置信息：\n\nReact 使用.env.*进行环境部署\n\nexport const TIMEOUT = 5000\n\nconst devBaseURL = 'https://httpbin.org'\nconst proBaseURL = 'https://production.org'\nconsole.log(process.env.NODE_ENV)\nexport const baseURL =\n    process.env.NODE_ENV === 'development' ? devBaseURL : proBaseURL\n\n\n创建 request.js，用于封装请求对象：\n\nimport axios from 'axios'\n\nimport { TIMEOUT, baseURL } from './config'\n\nconst instance = axios.create({\n    timeout: TIMEOUT,\n    baseURL: baseURL,\n})\n\naxios.interceptors.request.use(\n    config => {\n        // 1.发送网络请求时，在页面中添加一个loading组件作为动画；\n\n        // 2.某些网络请求要求用户必须登录，可以在请求中判断是否携带了token，没有携带token直接跳转到login页面；\n\n        // 3.对某些请求参数进行序列化；\n        return config\n    },\n    err => {\n        return err\n    }\n)\n\ninstance.interceptors.response.use(\n    response => {\n        return response.data\n    },\n    err => {\n        if (err && err.response) {\n            switch (err.response.status) {\n                case 400:\n                    err.message = '请求错误'\n                    break\n                case 401:\n                    err.message = '未授权访问'\n                    break\n            }\n        }\n        return err\n    }\n)\n\nexport default instance\n\n\n测试：\n\nequest({\n    url: '/get',\n    params: {\n        name: 'why',\n        age: 18,\n    },\n})\n    .then(console.log)\n    .catch(console.error)\n\nrequest({\n    url: '/post',\n    method: 'post',\n    data: {\n        name: 'kobe',\n        age: 40,\n    },\n})\n    .then(console.log)\n    .catch(console.error)\n",normalizedContent:"官方文档\n\nreact 系列十三 - axios 库的使用\n\n\n# 为什么不是...?\n\n 1. jquery-ajax:没什么好说的\n 2. fetch api：fetch 是一个 low-level（底层）的 api，没有帮助你封装好各种各样的功能 和实现\n\n\n# 为什么是 axios？\n\nvue 作者也是推荐在 vue 中使用 axios(尤大说好就是好 👌)\n\n\n# axios 的基本使用\n\n\n# 发送请求\n\nreact 一般在componentdidmount生命周期函数中发生网络请求\n\n🌰 例子：\n\nimport { purecomponent } from 'react'\nimport axios from 'axios'\n\nexport default class app extends purecomponent {\n    constructor() {\n        super()\n        this.state = {\n            res: {},\n        }\n    }\n    render() {\n        return <div>url:{this.state.res.url}</div>\n    }\n    async componentdidmount() {\n        const res = await axios.get('https://httpbin.org/get')\n        this.setstate({\n            res: res.data,\n        })\n    }\n}\n\n\n * 发送 get 请求\n * 发送 post 请求\n * 多个请求的合并\n\nconst request1 = axios.get('https://httpbin.org/get', {\n    params: { name: 'why', age: 18 },\n})\nconst request2 = axios.post('https://httpbin.org/post', {\n    name: 'kobe',\n    age: 40,\n})\naxios\n    .all([request1, request2])\n    .then(([res1, res2]) => {\n        console.log(res1, res2)\n    })\n    .catch(err => {\n        console.log(err)\n    })\n\n\n * 使用 async、await 发送请求\n\nasync componentdidmount() {\n    const result = await axios.get(\"https://httpbin.org/get\", {\n      params: {\n        name: \"kobe\",\n        age: 40\n      }\n    })\n    console.log(result);\n  }\n\n\n\n# 配置信息\n\n * 优先是请求的 config 参数配置\n * 其次是实例的 default 中的配置\n * 最后是创建实例时的配置\n\n\n# 拦截器\n\naxios.interceptors.request.use(config => {\n  // 1.发送网络请求时，在页面中添加一个loading组件作为动画；\n\n  // 2.某些网络请求要求用户必须登录，可以在请求中判断是否携带了token，没有携带token直接跳转到login页面；\n\n  // 3.对某些请求参数进行序列化；\n  return config;\n}, err => {\n  return err;\n})\n\naxios.interceptors.response.use(response => {\n  return response.data;\n}, err => {\n  if (err && err.response) {\n    switch (err.response.status) {\n      case400:\n        err.message = \"请求错误\";\n        break;\n      case401:\n        err.message = \"未授权访问\";\n        break;\n    }\n  }\n  return err;\n})\n\n\n\n# axios 库的二次封装\n\n\n# 为什么要封装？\n\n为什么我们要对 axios 进行二次封装呢？\n\n * 默认情况下我们是可以直接使用 axios 来进行开发的；\n * 但是我们考虑一个问题，假如有 100 多处中都直接依赖 axios，突然间有一天 axios 出现了重大 bug，并且该库已经不再维护，这个时候你如何处理呢？\n * 大多数情况下我们会寻找一个新的网络请求库或者自己进行二次封装；\n * 但是有 100 多处都依赖了 axios，方便我们进行修改吗？我们所有依赖 axios 库的地方都需要进行修改\n * 如果是自己进行了二次封装，并且暴露一套自己的 api:只需要重新封装另一个网络请求库(只需要修改一个 js 文件)\n\n\n# axios 二次封装\n\n创建一个 service 文件夹（其他名字都可以），用于存放所有的网络请求相关的内容。\n\n创建文件 config.js，用于存放一些配置信息：\n\nreact 使用.env.*进行环境部署\n\nexport const timeout = 5000\n\nconst devbaseurl = 'https://httpbin.org'\nconst probaseurl = 'https://production.org'\nconsole.log(process.env.node_env)\nexport const baseurl =\n    process.env.node_env === 'development' ? devbaseurl : probaseurl\n\n\n创建 request.js，用于封装请求对象：\n\nimport axios from 'axios'\n\nimport { timeout, baseurl } from './config'\n\nconst instance = axios.create({\n    timeout: timeout,\n    baseurl: baseurl,\n})\n\naxios.interceptors.request.use(\n    config => {\n        // 1.发送网络请求时，在页面中添加一个loading组件作为动画；\n\n        // 2.某些网络请求要求用户必须登录，可以在请求中判断是否携带了token，没有携带token直接跳转到login页面；\n\n        // 3.对某些请求参数进行序列化；\n        return config\n    },\n    err => {\n        return err\n    }\n)\n\ninstance.interceptors.response.use(\n    response => {\n        return response.data\n    },\n    err => {\n        if (err && err.response) {\n            switch (err.response.status) {\n                case 400:\n                    err.message = '请求错误'\n                    break\n                case 401:\n                    err.message = '未授权访问'\n                    break\n            }\n        }\n        return err\n    }\n)\n\nexport default instance\n\n\n测试：\n\nequest({\n    url: '/get',\n    params: {\n        name: 'why',\n        age: 18,\n    },\n})\n    .then(console.log)\n    .catch(console.error)\n\nrequest({\n    url: '/post',\n    method: 'post',\n    data: {\n        name: 'kobe',\n        age: 40,\n    },\n})\n    .then(console.log)\n    .catch(console.error)\n",charsets:{cjk:!0},lastUpdated:"2022年05月20日",lastUpdatedTimestamp:1653057444e3},{title:"React中的CSS",frontmatter:{title:"React中的CSS",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%AD%E7%9A%84CSS.html",relativePath:"前端开发/前端框架/React/React中的CSS.md",key:"v-78a84160",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E4%B8%AD%E7%9A%84CSS.html",headers:[{level:2,title:"内联样式",slug:"内联样式",normalizedTitle:"内联样式",charIndex:120},{level:2,title:"普通的css",slug:"普通的css",normalizedTitle:"普通的css",charIndex:369},{level:2,title:"css modules",slug:"css-modules",normalizedTitle:"css modules",charIndex:552},{level:2,title:"CSS in JS",slug:"css-in-js",normalizedTitle:"css in js",charIndex:994},{level:2,title:"styled-components的基本使用",slug:"styled-components的基本使用",normalizedTitle:"styled-components的基本使用",charIndex:1348},{level:3,title:"props、attrs属性",slug:"props、attrs属性",normalizedTitle:"props、attrs属性",charIndex:1813},{level:3,title:"styled高级特性",slug:"styled高级特性",normalizedTitle:"styled高级特性",charIndex:2684}],headersStr:"内联样式 普通的css css modules CSS in JS styled-components的基本使用 props、attrs属性 styled高级特性",content:'事实上，css一直是React的痛点，也是被很多开发者吐槽、诟病的一个点\n\n在这一点上，Vue做的要确实要好于React\n\n相比而言，React官方并没有给出在React中统一的样式风格\n\n以下介绍几种React中的CSS解决方案\n\n\n# 内联样式\n\n内联样式是官方推荐的一种css样式的写法：\n\n * style 接受一个采用小驼峰命名属性的 JavaScript 对象，而不是 CSS 字符串\n * 并且可以引用state中的状态来设置相关的样式；\n\n内联样式的优点:\n\n * 内联样式, 样式之间不会有冲突\n * 可以动态获取当前state中的状态\n\n内联样式的缺点：\n\n * 写法上都需要使用驼峰标识\n * 某些样式没有提示\n * 大量的样式, 代码混乱\n * 某些样式无法编写(比如伪类/伪元素)\n\n所以官方依然是希望内联样式和普通的css来结合编写\n\n\n# 普通的css\n\n普通的css我们通常会编写到一个单独的文件，之后再进行引入\n\n这样的编写方式和普通的网页开发中编写方式是一致的\n\n组件化开发中我们总是希望组件是一个独立的模块，即便是样式也只是在自己内部生效，不会相互影响。但是普通的css都属于全局的css，样式之间会相互影响\n\n这种编写方式最大的问题是样式之间会相互层叠掉\n\n\n# css modules\n\nn css modules并不是React特有的解决方案，而是所有使用了类似于webpack配置的环境下都可以使用的\n\nReact的脚手架已经内置了css modules的配置：.css/.less/.scss 等样式文件都修改成 .module.css/.module.less/.module.scss ，之后就可以引用并且进行使用了\n\ncss modules确实解决了局部作用域的问题，也是很多人喜欢在React中使用的一种方案\n\n但是这种方案也有自己的缺陷：\n\n * 引用的类名，不能使用连接符(.home-title)，在JavaScript中是不识别的\n * 所有的className都必须使用{style.className} 的形式来编写\n * 不方便动态来修改某些样式，依然需要使用内联样式的方式\n\n如果你觉得上面的缺陷还算OK，那么你在开发中完全可以选择使用css modules来编写，并且也是在React中很受欢迎的一种方式\n\n\n# CSS in JS\n\n“CSS-in-JS” 是指一种模式，其中 CSS 由 JavaScript 生成而不是在外部文件中定义；注意此功能并不是 React 的一部分，而是由第三方库提供。 React 对样式如何定义并没有明确态度\n\nReact的思想中认为逻辑本身和UI是无法分离的，所以才会有了JSX的语法。样式呢？样式也是属于UI的一部分。 事实上CSS-in-JS的模式就是一种将样式（CSS）也写入到JavaScript中的方式，并且可以方便的使用JavaScript的状态。所以React有被人称之为 All in JS\n\nstyled-components是社区最流行的CSS-in-JS库\n\n安装styled-components：yarn add styled-components\n\n\n# styled-components的基本使用\n\nstyled-components的本质是通过函数的调 用，最终创建出一个组件：\n\n * 这个组件会被自动添加上一个不重复的 class\n * styled-components会给该class添加相关的样式\n\n另外，它支持类似于CSS预处理器一样的特性：\n\n * 支持样式嵌套，如嵌套后代选择器\n\n * 可以通过&符号获取当前元素\n\nconst Panel = styled.div`\n  background-size: cover;\n  background-position: center;\n  background-repeat: no-repeat;\n  flex: 0.5;\n  height: 80vh;\n  border-radius: 50px;\n  margin: 10px;\n  transition: all 300ms ease-in;\n\n  &.active {\n    flex: 5;\n  }\n  `\n\n\n * 使用伪类选择器、伪元素等\n\n\n# props、attrs属性\n\n# props可以穿透\n\nprops可以被传递给styled组件,并映射到组件html结构最外层的标签上\n\n<Panel\n\t\tonClick={this.changeCurrentNum.bind(this, num)}\n    className={classNames({active: this.state.currentNum === num})}\n    key={num}>\n</Panel>\n\n\n * 获取props需要通过${}传入一个插值函数，props会作为该函数的参数,这种方式可以有效的解决动态样式的问题\n\nimport {PureComponent} from "react";\nimport styled from "styled-components";\n\nconst HomeWrapper = styled.div`\n  color: ${props => props.color}\n`\n\nfunction Home() {\n    return (\n        <HomeWrapper color=\'red\'>\n            <h1>我是home组件</h1>\n        </HomeWrapper>\n    )\n}\n\nexport default class App extends PureComponent {\n    render() {\n        return (\n            <div>\n                <Home/>\n            </div>\n        );\n    }\n}\n\n\n# 添加attrs属性\n\nconst Wrapper = styled.div.attrs(\n    {\n        padding-left:props=>props.pleft || \'5px\'\n    }\n)`\n padding-left:${props=>props.pleft}\n`\n\n\n\n# styled高级特性\n\n# 支持样式的继承\n\nconst MainButtion=styled.div`\n\t\t\tcolor:#000;\n\t\t\tfont-size:30px;\n\t\t\tpadding:8px 30px;\n`\nconst MenuButton=styled(MainButton)`\n\t\tbackground-color:red;\n`\n\n\n# styled设置主题\n\nimport {PureComponent} from "react";\n\nimport styled, {ThemeProvider} from "styled-components";\n\nconst HomeWrapper = styled.div`\n  font-size: ${props => props.theme.fontSize};\n  color: ${props => props.theme.color}\n`\n\nconst MenuWrapper = styled.div`\n  font-size: ${props => props.theme.fontSize}\n`\n\nfunction Home() {\n    return (\n        <HomeWrapper>我是home组件</HomeWrapper>\n    )\n}\n\n\nfunction Menu() {\n    return (\n        <MenuWrapper>我是menu组件</MenuWrapper>\n    )\n}\n\nexport default class App extends PureComponent {\n    render() {\n        return (\n            <ThemeProvider theme={{fontSize: "30px", color: \'yellow\'}}>\n                <Home/>\n                <Menu/>\n            </ThemeProvider>\n        );\n    }\n}\n',normalizedContent:'事实上，css一直是react的痛点，也是被很多开发者吐槽、诟病的一个点\n\n在这一点上，vue做的要确实要好于react\n\n相比而言，react官方并没有给出在react中统一的样式风格\n\n以下介绍几种react中的css解决方案\n\n\n# 内联样式\n\n内联样式是官方推荐的一种css样式的写法：\n\n * style 接受一个采用小驼峰命名属性的 javascript 对象，而不是 css 字符串\n * 并且可以引用state中的状态来设置相关的样式；\n\n内联样式的优点:\n\n * 内联样式, 样式之间不会有冲突\n * 可以动态获取当前state中的状态\n\n内联样式的缺点：\n\n * 写法上都需要使用驼峰标识\n * 某些样式没有提示\n * 大量的样式, 代码混乱\n * 某些样式无法编写(比如伪类/伪元素)\n\n所以官方依然是希望内联样式和普通的css来结合编写\n\n\n# 普通的css\n\n普通的css我们通常会编写到一个单独的文件，之后再进行引入\n\n这样的编写方式和普通的网页开发中编写方式是一致的\n\n组件化开发中我们总是希望组件是一个独立的模块，即便是样式也只是在自己内部生效，不会相互影响。但是普通的css都属于全局的css，样式之间会相互影响\n\n这种编写方式最大的问题是样式之间会相互层叠掉\n\n\n# css modules\n\nn css modules并不是react特有的解决方案，而是所有使用了类似于webpack配置的环境下都可以使用的\n\nreact的脚手架已经内置了css modules的配置：.css/.less/.scss 等样式文件都修改成 .module.css/.module.less/.module.scss ，之后就可以引用并且进行使用了\n\ncss modules确实解决了局部作用域的问题，也是很多人喜欢在react中使用的一种方案\n\n但是这种方案也有自己的缺陷：\n\n * 引用的类名，不能使用连接符(.home-title)，在javascript中是不识别的\n * 所有的classname都必须使用{style.classname} 的形式来编写\n * 不方便动态来修改某些样式，依然需要使用内联样式的方式\n\n如果你觉得上面的缺陷还算ok，那么你在开发中完全可以选择使用css modules来编写，并且也是在react中很受欢迎的一种方式\n\n\n# css in js\n\n“css-in-js” 是指一种模式，其中 css 由 javascript 生成而不是在外部文件中定义；注意此功能并不是 react 的一部分，而是由第三方库提供。 react 对样式如何定义并没有明确态度\n\nreact的思想中认为逻辑本身和ui是无法分离的，所以才会有了jsx的语法。样式呢？样式也是属于ui的一部分。 事实上css-in-js的模式就是一种将样式（css）也写入到javascript中的方式，并且可以方便的使用javascript的状态。所以react有被人称之为 all in js\n\nstyled-components是社区最流行的css-in-js库\n\n安装styled-components：yarn add styled-components\n\n\n# styled-components的基本使用\n\nstyled-components的本质是通过函数的调 用，最终创建出一个组件：\n\n * 这个组件会被自动添加上一个不重复的 class\n * styled-components会给该class添加相关的样式\n\n另外，它支持类似于css预处理器一样的特性：\n\n * 支持样式嵌套，如嵌套后代选择器\n\n * 可以通过&符号获取当前元素\n\nconst panel = styled.div`\n  background-size: cover;\n  background-position: center;\n  background-repeat: no-repeat;\n  flex: 0.5;\n  height: 80vh;\n  border-radius: 50px;\n  margin: 10px;\n  transition: all 300ms ease-in;\n\n  &.active {\n    flex: 5;\n  }\n  `\n\n\n * 使用伪类选择器、伪元素等\n\n\n# props、attrs属性\n\n# props可以穿透\n\nprops可以被传递给styled组件,并映射到组件html结构最外层的标签上\n\n<panel\n\t\tonclick={this.changecurrentnum.bind(this, num)}\n    classname={classnames({active: this.state.currentnum === num})}\n    key={num}>\n</panel>\n\n\n * 获取props需要通过${}传入一个插值函数，props会作为该函数的参数,这种方式可以有效的解决动态样式的问题\n\nimport {purecomponent} from "react";\nimport styled from "styled-components";\n\nconst homewrapper = styled.div`\n  color: ${props => props.color}\n`\n\nfunction home() {\n    return (\n        <homewrapper color=\'red\'>\n            <h1>我是home组件</h1>\n        </homewrapper>\n    )\n}\n\nexport default class app extends purecomponent {\n    render() {\n        return (\n            <div>\n                <home/>\n            </div>\n        );\n    }\n}\n\n\n# 添加attrs属性\n\nconst wrapper = styled.div.attrs(\n    {\n        padding-left:props=>props.pleft || \'5px\'\n    }\n)`\n padding-left:${props=>props.pleft}\n`\n\n\n\n# styled高级特性\n\n# 支持样式的继承\n\nconst mainbuttion=styled.div`\n\t\t\tcolor:#000;\n\t\t\tfont-size:30px;\n\t\t\tpadding:8px 30px;\n`\nconst menubutton=styled(mainbutton)`\n\t\tbackground-color:red;\n`\n\n\n# styled设置主题\n\nimport {purecomponent} from "react";\n\nimport styled, {themeprovider} from "styled-components";\n\nconst homewrapper = styled.div`\n  font-size: ${props => props.theme.fontsize};\n  color: ${props => props.theme.color}\n`\n\nconst menuwrapper = styled.div`\n  font-size: ${props => props.theme.fontsize}\n`\n\nfunction home() {\n    return (\n        <homewrapper>我是home组件</homewrapper>\n    )\n}\n\n\nfunction menu() {\n    return (\n        <menuwrapper>我是menu组件</menuwrapper>\n    )\n}\n\nexport default class app extends purecomponent {\n    render() {\n        return (\n            <themeprovider theme={{fontsize: "30px", color: \'yellow\'}}>\n                <home/>\n                <menu/>\n            </themeprovider>\n        );\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2022年05月17日",lastUpdatedTimestamp:1652802362e3},{title:"React好用的库",frontmatter:{title:"React好用的库",date:"2022/05/25 20:18:20",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93.html",relativePath:"前端开发/前端框架/React/React好用的库.md",key:"v-159e0fe2",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BA%93.html",headersStr:null,content:" * 复制文本到剪切板📋:react-copy-to-clipboard,hook版\n\n * 路由跳转动画: react-page-transiton",normalizedContent:" * 复制文本到剪切板📋:react-copy-to-clipboard,hook版\n\n * 路由跳转动画: react-page-transiton",charsets:{cjk:!0},lastUpdated:"2022年06月02日",lastUpdatedTimestamp:1654187025e3},{title:"React的SSR",frontmatter:{title:"React的SSR",date:"2022/06/05 22:19:45",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%9A%84SSR.html",relativePath:"前端开发/前端框架/React/React的SSR.md",key:"v-998970b8",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%9A%84SSR.html",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022年06月05日",lastUpdatedTimestamp:1654439564e3},{title:"React的过渡动画",frontmatter:{title:"React的过渡动画",date:"2022/05/20 22:27:43",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%9A%84%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB.html",relativePath:"前端开发/前端框架/React/React的过渡动画.md",key:"v-f594f93a",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%9A%84%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB.html",headers:[{level:2,title:"react-transition-group",slug:"react-transition-group",normalizedTitle:"react-transition-group",charIndex:33},{level:2,title:"CSSTransition",slug:"csstransition",normalizedTitle:"csstransition",charIndex:378},{level:3,title:"CSSTransition 常见属性",slug:"csstransition-常见属性",normalizedTitle:"csstransition 常见属性",charIndex:621},{level:2,title:"SwitchTransition",slug:"switchtransition",normalizedTitle:"switchtransition",charIndex:1468},{level:2,title:"TransitionGroup",slug:"transitiongroup",normalizedTitle:"transitiongroup",charIndex:5238}],headersStr:"react-transition-group CSSTransition CSSTransition 常见属性 SwitchTransition TransitionGroup",content:"React 系列十四 - React 过渡动画\n\nReact 之 react-transition-group\n\n\n# react-transition-group\n\n在开发中，我们想要给一个组件的显示和消失添加某种过渡动画，可以很好的增加用户体验。\n\n当然，我们可以通过原生的 CSS 来实现这些过渡动画，但是 React 社区为我们提供了 react-transition-group 用来完成过渡动画。\n\nReact 曾为开发者提供过动画插件 react-addons-css-transition-group，后由社区维护，形成了现在的 react-transition-group。\n\n这个库可以帮助我们方便的实现组件的 入场 和 离场 动画，使用时需要进行额外的安装：\n\nyarn add react-transition-group\n\n\n# CSSTransition\n\nCSSTransition 执行过程中，有三个状态：appear、enter、exit；\n\n它们有三种状态，需要定义对应的 CSS 样式：\n\n * 第一类,开始状态：对于的类是-appear、-enter、-exit；\n * 第二类,执行动画：对应的类是-appear-active、-enter-active、-exit-active；\n * 第三类,执行结束：对应的类是-appear-done、-enter-done、-exit-done；\n\n\n# CSSTransition 常见属性\n\n# in\n\n触发进入或者退出状态\n\n * 如果添加了 unmountOnExit，那么该组件会在执行退出动画结束后被移除掉；\n * 当 in 为 true 时，触发进入状态，会添加-enter、-enter-acitve 的 class 开始执行动画，当动画执行结束后，会移除两个 class，并且添加-enter-done 的 class；\n * 当 in 为 false 时，触发退出状态，会添加-exit、-exit-active 的 class 开始执行动画，当动画执行结束后，会移除两个 class，并且添加-enter-done 的 class；\n\n比如说，一个 div 的显示/隐藏动画\n\n 1. div 显示:对应的 class 为 card-enter card-enter-active 动画走完为 card-enter-done\n 2. div 消失:对应的 class 为 card-exit card-exit-active 动画走完为 card-exit-done\n\n# classNames\n\n动画 class 的名称\n\n决定了在编写 css 时，对应的 class 名称：比如 card-enter、card-enter-active、card-enter-done；\n\n# timeout\n\n类添加删除的时间\n\n# appear\n\n是否在初次进入添加动画（需要和 in 同时为 true）\n\n# unmountOnExit\n\n退出后卸载组件(移除 DOM 节点)\n\n# CSSTransition 的钩子函数\n\n主要为了检测动画的执行过程，来完成一些 JavaScript 的操作\n\n * onEnter：在进入动画之前被触发(对应 onExit)\n * onEntering：在应用进入动画时被触发(对应 onExiting)\n * onEntered：在应用进入动画结束后被触发(对应 onEntered)\n\n\n# SwitchTransition\n\nSwitchTransition 可以完成两个组件之间切换的炫酷动画：\n\n * 比如我们有一个按钮需要在 on 和 off 之间切换，我们希望看到 on 先从左侧退出，off 再从右侧进入\n * 这个动画在 vue 中被称之为 vue transition modes(过渡模式)\n * react-transition-group 中使用 SwitchTransition 来实现该动画\n\nSwitchTransition 中主要有一个属性：mode，有两个值\n\n * in-out：表示新组件先进入，旧组件再移除\n * out-in：表示就组件先移除，新组建再进入\n\n如何使用 SwitchTransition 呢？\n\n * SwitchTransition 组件里面要有 CSSTransition 组件，不能直接包裹你想要切换的组件\n * SwitchTransition 里面的 CSSTransition 组件不再像以前那样接受 in 属性来判断元素是何种状态，取而代之的是 key 属性\n\ncoolCode\n\nimport {PureComponent} from \"react\";\nimport {CSSTransition, SwitchTransition} from \"react-transition-group\";\nimport {Card, Avatar} from 'antd';\nimport {EditOutlined, EllipsisOutlined, SettingOutlined} from '@ant-design/icons';\nimport styled from \"styled-components\";\nimport {Button} from 'antd';\n\nconst {Meta} = Card;\n\nconst BtnWrapper = styled.div`\n  text-align: center;\n  width: 100%;\n`\n\nconst CardWrapper = styled.div`\n  height: 100vh;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n\n  .card-enter {\n    opacity: 0;\n    transform: scale(.7);\n  }\n\n  .card-enter-active {\n    opacity: 1;\n    transform: scale(1);\n    transition: all 300ms;\n  }\n\n  .card-exit {\n    opacity: 1;\n    transform: scale(1);\n  }\n\n  .card-exit-active {\n    opacity: 0;\n    transform: scale(.7);\n    transition: all 300ms;\n  }\n\n  .btn-enter {\n    opacity: 0;\n    transform: translateX(100%);\n  }\n\n  .btn-enter-active {\n    opacity: 1;\n    transform: translateX(0);\n    transition: all 1000ms;\n  }\n\n  .btn-exit {\n    opacity: 1;\n    transform: translateX(0)\n  }\n\n  .btn-exit-active {\n    opacity: 0;\n    transform: translateX(-100%);\n    transition: all 1000ms;\n  }\n\n\n\n`\n\n\nexport default class App extends PureComponent {\n    constructor() {\n        super();\n        this.state = {\n            isShow: false\n        }\n    }\n\n    showControl() {\n        this.setState({\n            isShow: !(this.state.isShow),\n        })\n    }\n\n    render() {\n        return (\n            <CardWrapper>\n                <BtnWrapper>\n                    <SwitchTransition mode='out-in'>\n                        <CSSTransition key={this.state.isShow ? 'on' : 'off'} classNames='btn' timeout={1000}>\n                            <Button type=\"primary\" style={{marginBottom: '20px'}}\n                                    onClick={this.showControl.bind(this)}>{this.state.isShow ? '隐藏' : '显示'}</Button>\n                        </CSSTransition>\n                    </SwitchTransition>\n                </BtnWrapper>\n                <CSSTransition in={this.state.isShow} classNames='card' timeout={300} unmountOnExit>\n                    <Card\n                        style={{width: 300}}\n                        cover={\n                            <img\n                                alt=\"example\"\n                                src=\"https://www.runoob.com/wp-content/uploads/2013/07/js-logo.png\"\n                            />\n                        }\n                        actions={[\n                            <SettingOutlined onClick={() => {\n                                console.log('打开设置')\n                            }}/>,\n                            <EditOutlined/>,\n                            <EllipsisOutlined/>,\n                        ]}\n                    >\n                        <Meta\n                            avatar={<Avatar\n                                src=\"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqmVbQu2VMVVpfj2vg9PeXQNw1wy3tn3oZlWyD6O6nTSxkKZkEOX9aDyAMV2fWCm9Ce5GXho5HmsA/132?imageView2/1/w/80/h/80\"/>}\n                            title=\"frank zhang\"\n                            description=\"love fe,love life\"\n                        />\n                    </Card>\n                </CSSTransition>\n            </CardWrapper>\n        );\n    }\n}\n\n\n\n# TransitionGroup\n\n当我们有一组动画时，需要将这些 CSSTransition 放入到一个 TransitionGroup 中来完成动画",normalizedContent:"react 系列十四 - react 过渡动画\n\nreact 之 react-transition-group\n\n\n# react-transition-group\n\n在开发中，我们想要给一个组件的显示和消失添加某种过渡动画，可以很好的增加用户体验。\n\n当然，我们可以通过原生的 css 来实现这些过渡动画，但是 react 社区为我们提供了 react-transition-group 用来完成过渡动画。\n\nreact 曾为开发者提供过动画插件 react-addons-css-transition-group，后由社区维护，形成了现在的 react-transition-group。\n\n这个库可以帮助我们方便的实现组件的 入场 和 离场 动画，使用时需要进行额外的安装：\n\nyarn add react-transition-group\n\n\n# csstransition\n\ncsstransition 执行过程中，有三个状态：appear、enter、exit；\n\n它们有三种状态，需要定义对应的 css 样式：\n\n * 第一类,开始状态：对于的类是-appear、-enter、-exit；\n * 第二类,执行动画：对应的类是-appear-active、-enter-active、-exit-active；\n * 第三类,执行结束：对应的类是-appear-done、-enter-done、-exit-done；\n\n\n# csstransition 常见属性\n\n# in\n\n触发进入或者退出状态\n\n * 如果添加了 unmountonexit，那么该组件会在执行退出动画结束后被移除掉；\n * 当 in 为 true 时，触发进入状态，会添加-enter、-enter-acitve 的 class 开始执行动画，当动画执行结束后，会移除两个 class，并且添加-enter-done 的 class；\n * 当 in 为 false 时，触发退出状态，会添加-exit、-exit-active 的 class 开始执行动画，当动画执行结束后，会移除两个 class，并且添加-enter-done 的 class；\n\n比如说，一个 div 的显示/隐藏动画\n\n 1. div 显示:对应的 class 为 card-enter card-enter-active 动画走完为 card-enter-done\n 2. div 消失:对应的 class 为 card-exit card-exit-active 动画走完为 card-exit-done\n\n# classnames\n\n动画 class 的名称\n\n决定了在编写 css 时，对应的 class 名称：比如 card-enter、card-enter-active、card-enter-done；\n\n# timeout\n\n类添加删除的时间\n\n# appear\n\n是否在初次进入添加动画（需要和 in 同时为 true）\n\n# unmountonexit\n\n退出后卸载组件(移除 dom 节点)\n\n# csstransition 的钩子函数\n\n主要为了检测动画的执行过程，来完成一些 javascript 的操作\n\n * onenter：在进入动画之前被触发(对应 onexit)\n * onentering：在应用进入动画时被触发(对应 onexiting)\n * onentered：在应用进入动画结束后被触发(对应 onentered)\n\n\n# switchtransition\n\nswitchtransition 可以完成两个组件之间切换的炫酷动画：\n\n * 比如我们有一个按钮需要在 on 和 off 之间切换，我们希望看到 on 先从左侧退出，off 再从右侧进入\n * 这个动画在 vue 中被称之为 vue transition modes(过渡模式)\n * react-transition-group 中使用 switchtransition 来实现该动画\n\nswitchtransition 中主要有一个属性：mode，有两个值\n\n * in-out：表示新组件先进入，旧组件再移除\n * out-in：表示就组件先移除，新组建再进入\n\n如何使用 switchtransition 呢？\n\n * switchtransition 组件里面要有 csstransition 组件，不能直接包裹你想要切换的组件\n * switchtransition 里面的 csstransition 组件不再像以前那样接受 in 属性来判断元素是何种状态，取而代之的是 key 属性\n\ncoolcode\n\nimport {purecomponent} from \"react\";\nimport {csstransition, switchtransition} from \"react-transition-group\";\nimport {card, avatar} from 'antd';\nimport {editoutlined, ellipsisoutlined, settingoutlined} from '@ant-design/icons';\nimport styled from \"styled-components\";\nimport {button} from 'antd';\n\nconst {meta} = card;\n\nconst btnwrapper = styled.div`\n  text-align: center;\n  width: 100%;\n`\n\nconst cardwrapper = styled.div`\n  height: 100vh;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n\n  .card-enter {\n    opacity: 0;\n    transform: scale(.7);\n  }\n\n  .card-enter-active {\n    opacity: 1;\n    transform: scale(1);\n    transition: all 300ms;\n  }\n\n  .card-exit {\n    opacity: 1;\n    transform: scale(1);\n  }\n\n  .card-exit-active {\n    opacity: 0;\n    transform: scale(.7);\n    transition: all 300ms;\n  }\n\n  .btn-enter {\n    opacity: 0;\n    transform: translatex(100%);\n  }\n\n  .btn-enter-active {\n    opacity: 1;\n    transform: translatex(0);\n    transition: all 1000ms;\n  }\n\n  .btn-exit {\n    opacity: 1;\n    transform: translatex(0)\n  }\n\n  .btn-exit-active {\n    opacity: 0;\n    transform: translatex(-100%);\n    transition: all 1000ms;\n  }\n\n\n\n`\n\n\nexport default class app extends purecomponent {\n    constructor() {\n        super();\n        this.state = {\n            isshow: false\n        }\n    }\n\n    showcontrol() {\n        this.setstate({\n            isshow: !(this.state.isshow),\n        })\n    }\n\n    render() {\n        return (\n            <cardwrapper>\n                <btnwrapper>\n                    <switchtransition mode='out-in'>\n                        <csstransition key={this.state.isshow ? 'on' : 'off'} classnames='btn' timeout={1000}>\n                            <button type=\"primary\" style={{marginbottom: '20px'}}\n                                    onclick={this.showcontrol.bind(this)}>{this.state.isshow ? '隐藏' : '显示'}</button>\n                        </csstransition>\n                    </switchtransition>\n                </btnwrapper>\n                <csstransition in={this.state.isshow} classnames='card' timeout={300} unmountonexit>\n                    <card\n                        style={{width: 300}}\n                        cover={\n                            <img\n                                alt=\"example\"\n                                src=\"https://www.runoob.com/wp-content/uploads/2013/07/js-logo.png\"\n                            />\n                        }\n                        actions={[\n                            <settingoutlined onclick={() => {\n                                console.log('打开设置')\n                            }}/>,\n                            <editoutlined/>,\n                            <ellipsisoutlined/>,\n                        ]}\n                    >\n                        <meta\n                            avatar={<avatar\n                                src=\"https://thirdwx.qlogo.cn/mmopen/vi_32/dyaiogq83eqmvbqu2vmvvpfj2vg9pexqnw1wy3tn3ozlwyd6o6ntsxkkzkeox9adyamv2fwcm9ce5gxho5hmsa/132?imageview2/1/w/80/h/80\"/>}\n                            title=\"frank zhang\"\n                            description=\"love fe,love life\"\n                        />\n                    </card>\n                </csstransition>\n            </cardwrapper>\n        );\n    }\n}\n\n\n\n# transitiongroup\n\n当我们有一组动画时，需要将这些 csstransition 放入到一个 transitiongroup 中来完成动画",charsets:{cjk:!0},lastUpdated:"2022年05月29日",lastUpdatedTimestamp:1653837709e3},{title:"React组件化开发",frontmatter:{title:"React组件化开发",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html",relativePath:"前端开发/前端框架/React/React组件化开发.md",key:"v-2fd9779b",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html",headers:[{level:2,title:"React 的组件化",slug:"react-的组件化",normalizedTitle:"react 的组件化",charIndex:2},{level:3,title:"类组件",slug:"类组件",normalizedTitle:"类组件",charIndex:392},{level:3,title:"函数组件",slug:"函数组件",normalizedTitle:"函数组件",charIndex:434},{level:2,title:"生命周期",slug:"生命周期",normalizedTitle:"生命周期",charIndex:978},{level:3,title:"生命周期函数",slug:"生命周期函数",normalizedTitle:"生命周期函数",charIndex:996},{level:2,title:"组件的嵌套",slug:"组件的嵌套",normalizedTitle:"组件的嵌套",charIndex:2379},{level:2,title:"组件间的通信",slug:"组件间的通信",normalizedTitle:"组件间的通信",charIndex:2540},{level:3,title:"父组件传递子组件",slug:"父组件传递子组件",normalizedTitle:"父组件传递子组件",charIndex:2551},{level:3,title:"参数 propTypes",slug:"参数-proptypes",normalizedTitle:"参数 proptypes",charIndex:3721},{level:3,title:"子组件传递父组件",slug:"子组件传递父组件",normalizedTitle:"子组件传递父组件",charIndex:6065},{level:3,title:"在 React 中实现 slot",slug:"在-react-中实现-slot",normalizedTitle:"在 react 中实现 slot",charIndex:7108},{level:3,title:"Context(跨组件通信)",slug:"context-跨组件通信",normalizedTitle:"context(跨组件通信)",charIndex:8777},{level:3,title:"全局事件传递",slug:"全局事件传递",normalizedTitle:"全局事件传递",charIndex:14321},{level:2,title:"setState",slug:"setstate",normalizedTitle:"setstate",charIndex:7070},{level:3,title:"为什么使用 SetState",slug:"为什么使用-setstate",normalizedTitle:"为什么使用 setstate",charIndex:15978},{level:3,title:"setState 异步更新",slug:"setstate-异步更新",normalizedTitle:"setstate 异步更新",charIndex:16392},{level:3,title:"如何获取异步的结果",slug:"如何获取异步的结果",normalizedTitle:"如何获取异步的结果",charIndex:17284},{level:3,title:"setState 一定是异步吗?",slug:"setstate-一定是异步吗",normalizedTitle:"setstate 一定是异步吗?",charIndex:17758},{level:3,title:"数据的合并",slug:"数据的合并",normalizedTitle:"数据的合并",charIndex:17886},{level:3,title:"多个state的合并",slug:"多个state的合并",normalizedTitle:"多个state的合并",charIndex:18192},{level:2,title:"React 的更新机制",slug:"react-的更新机制",normalizedTitle:"react 的更新机制",charIndex:18818},{level:2,title:"React 性能优化",slug:"react-性能优化",normalizedTitle:"react 性能优化",charIndex:18985},{level:3,title:"列表中 keys 的作用",slug:"列表中-keys-的作用",normalizedTitle:"列表中 keys 的作用",charIndex:19e3},{level:3,title:"shouldComponentUpdate",slug:"shouldcomponentupdate",normalizedTitle:"shouldcomponentupdate",charIndex:10017},{level:3,title:"PureComponent",slug:"purecomponent",normalizedTitle:"purecomponent",charIndex:10078},{level:3,title:"高阶组件 memo",slug:"高阶组件-memo",normalizedTitle:"高阶组件 memo",charIndex:21263},{level:2,title:"refs",slug:"refs",normalizedTitle:"refs",charIndex:22850},{level:3,title:"ref 的转发",slug:"ref-的转发",normalizedTitle:"ref 的转发",charIndex:23444},{level:2,title:"React 表单处理",slug:"react-表单处理",normalizedTitle:"react 表单处理",charIndex:24110},{level:3,title:"注意点",slug:"注意点",normalizedTitle:"注意点",charIndex:24134},{level:2,title:"高阶组件",slug:"高阶组件",normalizedTitle:"高阶组件",charIndex:21263},{level:3,title:"应用 1:props 的增强",slug:"应用-1-props-的增强",normalizedTitle:"应用 1:props 的增强",charIndex:24365},{level:3,title:"应用 2:渲染判断鉴权",slug:"应用-2-渲染判断鉴权",normalizedTitle:"应用 2:渲染判断鉴权",charIndex:26698},{level:3,title:"应用 3:生命周期劫持",slug:"应用-3-生命周期劫持",normalizedTitle:"应用 3:生命周期劫持",charIndex:26878},{level:3,title:"高阶组件的意义",slug:"高阶组件的意义",normalizedTitle:"高阶组件的意义",charIndex:32936},{level:2,title:"Portals 的使用",slug:"portals-的使用",normalizedTitle:"portals 的使用",charIndex:33326},{level:3,title:"案例：Modal",slug:"案例-modal",normalizedTitle:"案例：modal",charIndex:33532},{level:2,title:"fragment",slug:"fragment",normalizedTitle:"fragment",charIndex:240},{level:2,title:"StrictMode",slug:"strictmode",normalizedTitle:"strictmode",charIndex:34229},{level:3,title:"严格模式检查什么？",slug:"严格模式检查什么",normalizedTitle:"严格模式检查什么？",charIndex:34365},{level:2,title:"render Props",slug:"render-props",normalizedTitle:"render props",charIndex:34756},{level:3,title:"Render props 与 React.PureComponent 同时使用",slug:"render-props-与-react-purecomponent-同时使用",normalizedTitle:"render props 与 react.purecomponent 同时使用",charIndex:36625},{level:3,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:37196}],headersStr:"React 的组件化 类组件 函数组件 生命周期 生命周期函数 组件的嵌套 组件间的通信 父组件传递子组件 参数 propTypes 子组件传递父组件 在 React 中实现 slot Context(跨组件通信) 全局事件传递 setState 为什么使用 SetState setState 异步更新 如何获取异步的结果 setState 一定是异步吗? 数据的合并 多个state的合并 React 的更新机制 React 性能优化 列表中 keys 的作用 shouldComponentUpdate PureComponent 高阶组件 memo refs ref 的转发 React 表单处理 注意点 高阶组件 应用 1:props 的增强 应用 2:渲染判断鉴权 应用 3:生命周期劫持 高阶组件的意义 Portals 的使用 案例：Modal fragment StrictMode 严格模式检查什么？ render Props Render props 与 React.PureComponent 同时使用 解决方案",content:"# React 的组件化\n\nrender 函数的返回值\n\n当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回以下类型之一:\n\n * React元素：\n   * 通常通过 JSX 创建\n   * 例如，<div /> 会被 React 渲染为 DOM 节点，<MyComponent />会被 React 渲染为自定义组件\n   * 无论是 <div /> 还是 <MyComponent /> 均为 React 元素\n * 数组或 fragments: 使得 render 方法可以返回多个元素\n * Portals：可以渲染子节点到不同的 DOM 子树中\n * 字符串或数值类型：它们在 DOM 中会被渲染为文本节点\n * 布尔类型或 null:什么都不渲染\n * 从react17开始render禁止返回undefined\n\n\n# 类组件\n\n类组件的定义有如下要求：\n\n * 组件的名称是大写字符开头（无论类组件还是函数组件）\n * 类组件需要继承自 React.Component\n * 类组件必须实现 render 函数\n\n使用 class 定义一个组件：\n\n * constructor 是可选的，我们通常在 constructor 中初始化一些数据\n * this.state 中维护的就是我们组件内部的数据\n * render() 方法是 class 组件中唯一必须实现的方法\n\nimport { Component } from 'react'\n\nexport default class App extends Component {\n    constructor() {\n        super()\n        this.state = {\n            msg: '我是app组件',\n        }\n    }\n    render() {\n        return <div>{this.state.msg},啊这</div>\n    }\n}\n\n\n\n# 函数组件\n\n函数组件是使用 function 来进行定义的函数，只是这个函数会返回和类组件中 render 函数返回一样的内容。\n\n函数组件有自己的特点（当然，hooks，就不一样了）：\n\n * 没有生命周期，也会被更新并挂载，但是没有生命周期函数\n * 没有 this(组件实例)\n * 没有内部状态state\n\n定义函数组件：\n\nexport default function App() {\n    return <div>我是function组件</div>\n}\n\n\n\n# 生命周期\n\n生命周期是一个抽象的概念，在生命周期的整个过程，分成了很多个阶段:\n\n * 比如装载阶段Mount，组件第一次在 DOM 树中被渲染的过程\n * 比如更新过程Update，组件状态发生变化，重新更新渲染的过程\n * 比如卸载过程Unmount，组件从 DOM 树中被移除的过程\n\nReact 内部为了告诉我们当前处于哪些阶段，会对我们组件内部实现的某些函数进行回调，这些函数就是生命周期函数：\n\n * 比如实现 componentDidMount 函数：组件已经挂载到 DOM上时，就会回调\n * 比如实现componentDidUpdate函数：组件已经发生了更新时，就会回调\n * 比如实现 componentWillUnmount 函数：组件即将被移除时，就会回调\n * 我们可以在这些回调函数中编写自己的逻辑代码，来完成自己的需求功能\n\n我们说到 React 生命周期时，主要谈的是类的生命周期，因为函数式组件是没有生命周期函数的(后面我们可以通过 hooks 来模拟一些生命周期的回调)\n\n\n# 生命周期函数\n\n\n\n# Constructor\n\n如果不初始化 state 或不进行方法绑定，则不需要为 React组件实现构造函数\n\nconstructor 中通常只做两件事情：\n\n * 通过给 this.state赋值对象来初始化内部的 state\n * 为事件绑定实例this：this.xxx.bind(this)\n\n# componentDidMount\n\ncomponentDidMount()会在组件挂载后（插入 DOM 树中）立即调用\n\ncomponentDidMount中通常进行哪里操作呢？\n\n * 依赖于 DOM的操作可以在这里进行\n * 在此处发送网络请求就最好的地方（官方建议）\n * 可以在此处添加一些订阅（会在 componentWillUnmount 取消订阅）\n\n# componentDidUpdate\n\ncomponentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法\n\n * 当组件更新后，可以在此处对 DOM 进行操作\n * 如果你对更新前后的props进行了比较，也可以选择在此处进行网络请求（例如，当 props未发生变化时，则不会执行网络请求）\n\ncomponentDidUpdate(prevProps) {\n  // 典型用法（不要忘记比较 props）：\n  if (this.props.userID !== prevProps.userID) {\n    this.fetchData(this.props.userID);\n  }\n}\n\n\n# componentWillUnmount\n\ncomponentWillUnmount() 会在组件卸载及销毁之前直接调用\n\n * 在此方法中执行必要的清理操作\n * 例如，清除 timer，取消网络请求或清除在 componentDidMount()中创建的订阅等\n\n\n# 组件的嵌套\n\n组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件，再将这些组件组合嵌套在一起，最终形成我们的应用程序\n\n一个简单的组件嵌套的例子 🌰：\n\n\n\nSee the Pen React Components by zhangfanhang (@zhangfanhang) on CodePen.\n\n\n# 组件间的通信\n\n\n# 父组件传递子组件\n\nsuper(props),super()以及不写 super 的区别\n\n * 如果用到了 constructor 就必须写 super(),是用来初始化 this 的\n * 如果你在 constructor 中要使用 this.props,就必须给 super 加参数：super(props)\n * 无论有没有 constructor，在 render 中 this.props 都是可以使用的，这是 React 默认实现的\n * 如果没用到 constructor,是可以不写的；React 会默认添加一个空的 constructor。\n\n父组件在展示子组件，可能会传递一些数据给子组件：\n\n * 父组件通过属性=值的形式来传递给子组件数据；\n * 子组件通过props参数获取父组件传递过来的数据；\n\n父传子:类组件\n\nimport { Component } from 'react'\n\nclass ChildCom extends Component {\n    render() {\n        const { name } = this.props\n        return <div>{`我的名字是${name}`}</div>\n    }\n}\n\nexport default class App extends Component {\n    constructor() {\n        super()\n        this.state = {\n            name: 'frank',\n        }\n    }\n    render() {\n        return (\n            <div>\n                <ChildCom name={this.state.name}></ChildCom>\n            </div>\n        )\n    }\n}\n\n\n父传子:函数组件\n\nimport { Component } from 'react'\n\nfunction ChildCom(props) {\n    const { name } = props\n    return <h2>{`我的名字是${name}`}</h2>\n}\n\nexport default class App extends Component {\n    render() {\n        return (\n            <div>\n                <ChildCom name=\"frank\"></ChildCom>\n            </div>\n        )\n    }\n}\n\n\n\n# 参数 propTypes\n\n对于传递给子组件的数据，有时候我们可能希望进行验证，特别是对于大型项目来说：\n\n当然，如果你项目中集成了 Flow 或者 TypeScript，那么直接就可以进行类型验证；但是，即使我们没有使用 Flow 或者 TypeScript，也可以通过 prop-types 库来进行参数验证；\n\n从 React v15.5开始，React.PropTypes 已移入另一个包中：prop-types 库\n\n更多的验证方式，可以参考官网\n\n * 比如验证数组，并且数组中包含哪些元素；\n * 比如验证对象，并且对象中包含哪些 key 以及 value 是什么类型；\n * 比如某个prop是必须的，使用 requiredFunc: PropTypes.func.isRequired\n\n如果没有传递，我们希望有默认值呢？我们使用 defaultProps就可以了\n\nimport { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nclass ChildCom extends Component {\n    render() {\n        const { name, age } = this.props\n        return <div>{`我的名字是${name},今年${age}岁了`}</div>\n    }\n}\n\nChildCom.propTypes = {\n    name: PropTypes.string.isRequired,\n    age: PropTypes.number.isRequired,\n}\n\nChildCom.defaultProps = {\n    name: 'null',\n    age: 0,\n}\n\nexport default class App extends Component {\n    render() {\n        return (\n            <div>\n                <ChildCom name=\"frank\" age={22}></ChildCom>\n                <ChildCom age={24}></ChildCom>\n                <ChildCom></ChildCom>\n            </div>\n        )\n    }\n}\n\n\n这样写也是可以的\n\nimport { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nclass ChildCom extends Component {\n    static propTypes = {\n        name: PropTypes.string.isRequired,\n        age: PropTypes.number.isRequired,\n    }\n    static defaultProps = {\n        name: 'null',\n        age: 0,\n    }\n    render() {\n        const { name, age } = this.props\n        return <div>{`我的名字是${name},今年${age}岁了`}</div>\n    }\n}\n\nexport default class App extends Component {\n    render() {\n        return (\n            <div>\n                <ChildCom name=\"frank\" age={22}></ChildCom>\n                <ChildCom age={24}></ChildCom>\n                <ChildCom></ChildCom>\n            </div>\n        )\n    }\n}\n\n\n如果你在常规开发中使用函数组件，那你可能需要做一些适当的改动，以保证 PropsTypes应用正常。\n\nexport default function HelloWorldComponent({ name }) {\n    return <div>Hello, {name}</div>\n}\n\n\n如果要添加PropTypes，你可能需要在导出之前以单独声明的一个函数的形式，声明该组件，具体代码如下：\n\nfunction HelloWorldComponent({ name }) {\n    return <div>Hello, {name}</div>\n}\n\nexport default HelloWorldComponent\n\n\n接着，可以直接在 HelloWorldComponent 上添加 PropTypes：\n\nimport PropTypes from 'prop-types'\n\nfunction HelloWorldComponent({ name }) {\n    return <div>Hello, {name}</div>\n}\n\nHelloWorldComponent.propTypes = {\n    name: PropTypes.string,\n}\n\nexport default HelloWorldComponent\n\n\n\n# 子组件传递父组件\n\n在 React中是通过 props传递消息，只是让父组件给子组件传递一个回调函数，在子组件中调用这个函数即可；\n\n子传父\n\nimport React, { Component } from 'react'\n\nclass Ibutton extends Component {\n    constructor() {\n        super()\n        this.state = {\n            age: 22,\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <button\n                    onClick={() => {\n                        this.props.increment(this.state.age)\n                    }}\n                >\n                    传递\n                </button>\n            </div>\n        )\n    }\n}\n\nexport default class App extends Component {\n    constructor() {\n        super()\n        this.state = {\n            age: 0,\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <h1>{this.state.age}</h1>\n                <Ibutton\n                    increment={value => {\n                        this.increment(value)\n                    }}\n                />\n            </div>\n        )\n    }\n\n    increment(value) {\n        this.setState({ age: value })\n    }\n}\n\n\n\n# 在 React 中实现 slot\n\nchildren(即：标签(组件)内的内容)被默认添加到props上，可以通过this.props.children访问，如果存在多个children，那么被添加到props上的是一个children数组\n\nApp.js\n\nimport { Component } from 'react'\n\nimport NavBar from './NavBar'\nimport NavBar2 from './NavBar2'\n\nexport default class App extends Component {\n    render() {\n        return (\n            <div>\n                <NavBar>\n                    <div>aaa</div>\n                    <div>bbb</div>\n                    <div>ccc</div>\n                </NavBar>\n                <NavBar2\n                    leftSlot={<div>aaa</div>}\n                    centerSlot={<div>bbb</div>}\n                    rightSlot={<div>ccc</div>}\n                ></NavBar2>\n            </div>\n        )\n    }\n}\n\n\n第一种方式(这种方式传递过去的 html结构不能混乱)\n\nimport { Component } from 'react'\n\nexport default class NavBar extends Component {\n    render() {\n        const { children } = this.props\n        return (\n            <div className=\"nav\">\n                <div className=\"nav_item nav_left\">{children[0]}</div>\n                <div className=\"nav_item nav_center\">{children[1]}</div>\n                <div className=\"nav_item nav_right\">{children[2]}</div>\n            </div>\n        )\n    }\n}\n\n\n第二种方式(推荐)：\n\nimport { Component } from 'react'\n\nexport default class NavBar extends Component {\n    render() {\n        const { leftSlot, centerSlot, rightSlot } = this.props\n        return (\n            <div className=\"nav\">\n                <div className=\"nav_item nav_left\">{leftSlot}</div>\n                <div className=\"nav_item nav_center\">{centerSlot}</div>\n                <div className=\"nav_item nav_right\">{rightSlot}</div>\n            </div>\n        )\n    }\n}\n\n\n效果图：\n\n\n\n\n# Context(跨组件通信)\n\n知识点扩充：属性展开\n\n官方文档：Context\n\n# Context 应用场景\n\n非父子组件数据的共享：\n\n * 在开发中，比较常见的数据传递方式是通过 props属性自上而下（由父到子）进行传递\n * 但是对于有一些场景：比如一些数据需要在多个组件中进行共享（地区偏好、UI 主题、用户登录状态、用户信息等）\n * 如果我们在顶层的 App 中定义这些信息，之后一层层传递下去，那么对于一些中间层不需要数据的组件来说，是一种冗余的操作\n\n但是，如果层级更多的话，一层层传递是非常麻烦，并且代码是非常冗余的：\n\n * React 提供了一个 API：Context\n * Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props\n * Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言\n\n# Context 相关 API\n\nReact.createContext\n\n * 创建一个需要共享的 Context 对象\n * 当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从离自身最近的那个匹配的 Provider 中读取到当前的 context 值\n * 当组件没有匹配到 Provider 时，其 defaultValue 参数才会生效（只要匹配到就不会生效，即使不传递value）\n\nconst MyContext = React.createContext({ nickName: 'null', level: 0 }//默认值)\n\n\nContext.Provider\n\n * 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context的变化\n * Provider 接收一个 value 属性，传递给消费组件\n * 一个 Provider 可以和多个消费组件有对应关系\n * 多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据(如需使用多个context请使用Context.Consumer)\n * 当 Provider的 value 值发生变化时，它内部的所有消费组件都会重新渲染\n\n    render() {\n        return (\n            <div>\n                <MyContext.Provider value={this.state}>\n                 {/*这是子组件(消费组件)*/}\n                    <List></List>\n                </MyContext.Provider>\n            </div>\n        )\n    }\n\n\n * 从 Provider 到其内部消费组件的传播不受制于 shouldComponentUpdate 函数，因此当消费组件在其祖先组件跳过更新的情况下也能更新:\n\nimport {PureComponent, Component} from 'react'\nimport React from 'react'\n// 创建context对象\nconst MyContext = React.createContext({nickName: 'null', level: 0, color: 'red'})\n\n\nclass List extends Component {\n    render() {\n        console.log('list render')\n        return (\n            <div>\n                <UserInfo/>\n                <ul>\n                    <li>首页</li>\n                    <li>购物车</li>\n                    <li>我的</li>\n                </ul>\n            </div>\n        )\n    }\n\n    // context不受shouldComponentUpdate的控制\n    shouldComponentUpdate(nextProps, nextState) {\n        return false\n    }\n\n}\n\n// userInfo 组件\nclass UserInfo extends Component {\n    render() {\n        console.log('render,userinfo')\n        return (\n            <div>\n                <h1 style={{color: this.context.color}}>{this.context.nickName},等级{this.context.level}</h1>\n            </div>\n        )\n    }\n\n    shouldComponentUpdate(nextProps, nextState) {\n        return false\n    }\n}\n\n// 挂载contextType(这是无法使用多个context的原因)\nUserInfo.contextType = MyContext\n\n\nexport default class App extends Component {\n    constructor() {\n        super()\n        this.state = {nickName: 'frank', level: 1212299, color: 'red'}\n    }\n\n    render() {\n        console.log('app render')\n        return (\n            <div>\n                <MyContext.Provider value={this.state}>\n                    <List/>\n                </MyContext.Provider>\n            </div>\n        )\n    }\n\n    shouldComponentUpdate(nextProps, nextState) {\n        return false\n    }\n}\n\n\n\nClass.contextType\n\n注意\n\n函数式组件无法使用Class.contextType\n\n * 挂载在 class 上的contextType属性会被赋值为一个由 React.createContext() 创建的 Context 对象\n * 这能让你使用 this.context 来消费最近 Context 上的那个值\n * 你可以在任何生命周期中访问到它，包括 render 函数中\n\nUserInfo.contextType = MyContext\n// 这是孙组件\nclass UserInfo extends Component {\n    render() {\n        return (\n            <div>\n                <h2 style={{ color: this.context.color }}>\n                    用户名：{this.context.nickName}\n                </h2>\n                <h2>等级:{this.context.level}</h2>\n            </div>\n        )\n    }\n}\n\n\nContext.Consumer\n\n什么时候使用 Context.Consumer 呢？\n\n * 当使用 value 的组件是一个函数式组件时\n * 或者当组件中需要使用多个 Context 时\n\n这里需要函数作为子元素function as child这种做法；传递给函数的 value 值等价于组件树上方离这个 context 最近的 Provider 提供的 value 值\n\nfunction UserInfo() {\n    return (\n        <MyContext.Consumer>\n            {value => {\n                return (\n                    <div>\n                        <h2>用户名：{value.nickName}</h2>\n                        <h2>等级:{value.level}</h2>\n                    </div>\n                )\n            }}\n        </MyContext.Consumer>\n    )\n}\n\n\n# 多个 Context\n\n具体编码\n\nimport { Component } from 'react'\n\n// 创建context对象\nconst MyContext = React.createContext({ nickName: 'null', level: 0 })\nconst themeContext = React.createContext()\n\nfunction List() {\n    return (\n        <div>\n            <UserInfo></UserInfo>\n            <ul>\n                <li>首页</li>\n                <li>购物车</li>\n                <li>我的</li>\n            </ul>\n        </div>\n    )\n}\n\nfunction UserInfo() {\n    return (\n        <MyContext.Consumer>\n            {value => {\n                return (\n                    <themeContext.Consumer>\n                        {theme => {\n                            return (\n                                <div>\n                                    <h2 style={{ color: theme.color }}>\n                                        用户名：{value.nickName}\n                                    </h2>\n                                    <h2>等级:{value.level}</h2>\n                                </div>\n                            )\n                        }}\n                    </themeContext.Consumer>\n                )\n            }}\n        </MyContext.Consumer>\n    )\n}\n\nexport default class App extends Component {\n    constructor() {\n        super()\n        this.state = {\n            nickName: 'frank',\n            level: 99,\n        }\n    }\n    render() {\n        return (\n            <div>\n                <MyContext.Provider value={this.state}>\n                    <themeContext.Provider value={{ color: 'blue' }}>\n                        <List></List>\n                    </themeContext.Provider>\n                </MyContext.Provider>\n            </div>\n        )\n    }\n}\n\n\n\n# 全局事件传递\n\n前面通过 Context 主要实现的是数据的共享，但是在开发中如果有跨组件之间的事件传递，应该如何操作呢？\n\n * 在 Vue 中我们可以通过 Vue 的实例，快速实现一个事件总线（EventBus），来完成操作\n * 在 React 中，我们可以依赖一个使用较多的库 events 来完成对应的操作\n\n安装：yarn add events\n\nevents 常用的 API：\n\n * 创建 EventEmitter 对象:const eventBus =new EventEmitter()\n * 发出事件：eventBus.emit(\"事件名称\", 参数列表)\n * 监听事件：eventBus.addListener(\"事件名称\", 监听函数)\n * 移除事件：eventBus.removeListener(\"事件名称\", 监听函数)\n\nevents 案例\n\nimport { Component } from 'react'\nimport { EventEmitter } from 'events'\n\nconst eventBus = new EventEmitter()\n\nclass Main extends Component {\n    render() {\n        return (\n            <div>\n                <MainBanner />\n            </div>\n        )\n    }\n}\n\nclass MainBanner extends Component {\n    constructor() {\n        super()\n        this.state = {\n            num: 0,\n        }\n    }\n\n    render() {\n        return <div>{this.state.num}</div>\n    }\n\n    componentDidMount() {\n        eventBus.addListener('helloMainBanner', (num, num2) => {\n            this.setState({\n                num,\n            })\n            console.log(num, num2)\n        })\n    }\n\n    componentWillUnmount() {\n        eventBus.removeListener('helloMainBanner')\n    }\n}\n\nexport default class App extends Component {\n    constructor() {\n        super()\n        this.state = {\n            num: 88888,\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <Main />\n                <button onClick={this.helloMainBanner.bind(this)}>\n                    helloMainBanner\n                </button>\n            </div>\n        )\n    }\n\n    helloMainBanner() {\n        eventBus.emit('helloMainBanner', this.state.num, 123)\n    }\n}\n\n\n\n# setState\n\nsetState API\n\n\n# 为什么使用 SetState\n\n开发中我们并不能直接通过修改 state 的值来让界面发生更新:\n\n * 因为我们修改了 state之后，希望 React 根据最新的 State 来重新渲染界面，但是这种方式的修改 React 并不知道数据发生了变化\n * React 并没有实现类似于 Vue2 中的 Object.defineProperty 或者 Vue3 中的 Proxy的方式来监听数据的变化\n * 我们必须通过 setState 来告知 React 数据已经发生了变化\n\n在组件中并没有实现 setState 的方法，为什么可以调用呢? 原因很简单，setState 方法是从 Component 中继承过来的\n\nComponent.prototype.setState = function (partialState, callback) {\n    // ...\n    // React源🐎\n}\n\n\n\n# setState 异步更新\n\nsetState 的更新是异步的?\n\nimport { Component } from 'react'\n\nexport default class App extends Component {\n    constructor() {\n        super()\n        this.state = {\n            message: 'hello',\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <h2>{this.state.message}</h2>\n                <button onClick={this.handleClick.bind(this)}>改变文本</button>\n            </div>\n        )\n    }\n\n    handleClick() {\n        this.setState({\n            message: 'hello,world',\n        })\n        console.log(this.state.message) // hello\n    }\n}\n\n\n * 最终打印结果是 hello\n * 可见 setState 是异步的操作，我们并不能在执行完 setState 之后立马拿到最新的 state 的结果\n\n为什么 setState 设计为异步呢?\n\n * setState 设计为异步，可以显著的提升性能:如果每次调用 setState 都进行一次更新，那么意味着 render 函数会被频繁调用，界面重新渲染，这样效率是很低的;最好的办法应该是获取到多个更新，之后进行批量更新\n * 如果同步更新了 state，但是还没有执行 render 函数，那么 state 和 props 不能保持同步。state 和 props 不能保持一致性，会在开发中产生很多的问题\n\n\n# 如何获取异步的结果\n\n方式一:setState 的回调\n\n * setState 接受两个参数:第二个参数是一个回调函数，这个回调函数会在更新后会执行\n * 格式如下:setState(partialState, callback)\n\n    handleClick() {\n        this.setState(\n            {\n                message: 'hello,world',\n            },\n            () => {\n                console.log(this.state.message)\n            }\n        )\n\n\n方式二：生命周期函数componentDidUpdate\n\n    componentDidUpdate(prevProps, prevState) {\n        console.log('componentDidUpdate', this.state.message)\n    }\n\n\n\n# setState 一定是异步吗?\n\n扩展阅读：React 合成事件和原生事件的区别\n\n * 在组件生命周期或 React 合成事件中，setState 是异步的\n * 在 setTimeout 或者原生 dom 事件中，setState 是同步的\n\n\n# 数据的合并\n\n当调用setState时，并不会覆盖之前的state,React底层通过Object.assign进行合并\n\n比如：{name:'zhang',age:23},修改age并不会对name造成影响\n\nthis.state={\n  name:\"frank\",\n  age:23\n}\n// 使用setState改变age\nthis.setState({\n  age:24\n})\n// 底层调用：Object.assign({},prevState,partialStatte)\n// 即相当于：\nObject.assign({},{name:'zhang',age:23},{age:24})\n\n\n\n# 多个state的合并\n\n如下代码，count并不会累加,后调用的 setState() 将覆盖同一周期内先调用 setState 的值,因此count只增加 1\n\nthis.setState({\n    count: this.state.count + 1,\n})\nthis.setState({\n    count: this.state.count + 1,\n})\nthis.setState({\n    count: this.state.count + 1,\n})\n//    相当于:\nObject.assign(\n  previousState,\n  {count:this.state.count + 1},\n  {count:this.state.count+ 1},\n  ...\n)\n\n\n如果后续状态取决于当前状态，可以使用updater函数的形式代替：\n\nthis.setState(state => {\n    return {\n        num: state.num + 1,\n    }\n})\nthis.setState(state => {\n    return {\n        num: state.num + 1,\n    }\n})\nthis.setState(state => {\n    return {\n        num: state.num + 1,\n    }\n})\n// +3 \n\n\n\n# React 的更新机制\n\n * react的渲染流程：jsx---\x3e虚拟DOM---\x3e真实DOM\n\n * react的更新流程：\n\nprops/state的改变---\x3erender函数重新执行----\x3e产生新的虚拟 DOM---\x3e新旧虚拟DOM进行diff---\x3e计算出差异进行更新（patch）----\x3e更新到真实的DOM\n\n\n# React 性能优化\n\n\n# 列表中 keys 的作用\n\n在遍历列表时，总是会提示一个警告，让我们加入一个key属性\n\n# 方式一:在最后位置插入数据\n\n这种情况，有无 key 意义并不大\n\n# 方式二:在前面插入数据\n\n<ul>\n<li key='333'>333</li>\n<li key='111'>111</li>\n<li key='222'>222</li>\n</ul>\n\n\n * 这种做法，在没有 key 的情况下，列表中所有的子元素都需要进行修改\n * 当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素,key 为 111 和 222 的元素仅仅进行位移，不需要进行任何的修改;将 key 为 333 的元素插入到最前面的位置即可\n\n# key 的注意事项\n\n * key 应该是唯一的\n * key 不要使用随机数(随机数在下一次 render 时，会重新生成一个数字)\n * 使用 index 作为 key，对性能是没有优化的\n\n\n# shouldComponentUpdate\n\n只要是修改了 App 中的数据，所有的组件都需要重新 render，进行 diff 算法，性能必然是很低的\n\n事实上，很多的组件没有必须要重新 render；它们调用 render 应该有一个前提，就是依赖的数据（state、 props）发生改变时，再调用自己的 render 方法\n\n如何来控制 render 方法是否被调用呢？通过 shouldComponentUpdate 方法即可\n\n该方法有两个参数：\n\n * 参数一：nextProps ，修改之后，最新的 props 属性\n * 参数二：nextState ，修改之后，最新的 state 属性\n\n该方法返回值是一个 boolean 类型：\n\n * 返回值为 true，那么就需要调用 render 方法\n * 返回值为 false，那么就不需要调用 render 方法\n * 默认返回的是 true，也就是只要 state 发生改变，就会调用 render 方法\n\n\n# PureComponent\n\n如果所有的类，我们都需要手动来实现 shouldComponentUpdate，这样做是很麻烦的\n\n我们来设想一下 shouldComponentUpdate 中的各种判断的目的是什么？\n\nprops 或者 state 中的数据是否发生了改变，来决定 shouldComponentUpdate 返回 true 或者 false\n\n事实上 React 已经考虑到了这一点，所以 React 已经默认帮我们实现好了，如何实现呢？ 将 class 继承自 PureComponent\n\nimport { PureComponent } from 'react'\n\nexport default class App extends PureComponent {\n    constructor(props) {\n        super(props)\n        this.state = {\n            movie: ['流浪地球', '长津湖', '信条', '肖生客的救赎'],\n        }\n    }\n\n    // shouldComponentUpdate(nextProps, nextState, nextContext) {\n    //     return nextState.movie !== this.state.movie\n    // }\n\n    render() {\n        return (\n            <div>\n                <ul>\n                    {this.state.movie.map(item => {\n                        return <li>{item}</li>\n                    })}\n                </ul>\n                <button onClick={this.add.bind(this)}>++++</button>\n            </div>\n        )\n    }\n\n    add() {\n      // 直接修改数据\n         this.state.movie.push('奇迹笨小孩')\n        this.setState({\n            movie: this.state.movie,\n        })\n      // 正确做法（新数据替换旧数据）\n        // this.setState({\n        //     movie: [...this.state.movie,'奇迹笨小孩'],\n        // })\n    }\n}\n\n\n当点击按钮时，电影列表并没有更新。问题在于 PureComponent 仅仅会对新老 this.state.movie 的值进行简单的对比。由于代码中 add 方法改变了同一个 movie 数组，使得新老 this.state.movie 比较的其实还是同一个数组。即便实际上数组中的内容已经变了，但是比较结果是相同的。 所以不可变性在 React 中非常重要\n\n\n# 高阶组件 memo\n\n如何让函数组件实现和PureComponent相同的功能呢？此时需要使用一个高阶组件 memo\n\nimport {Component, memo, PureComponent} from 'react'\n\n// header\nconst MemoHeader = memo(function Header() {\n    console.log('header')\n    return <div>这是header</div>\n})\n\n// main\nclass Main extends PureComponent {\n    render() {\n        console.log('main')\n        return (\n            <div>\n                <MainBanner/>\n                <MainProductList/>\n            </div>\n        )\n    }\n}\n\n//  main banner\nfunction MainBanner() {\n    console.log('mainbanner')\n    return <div>轮播图组件</div>\n}\n\n// main productList\nfunction MainProductList() {\n    console.log('mainproductlist')\n    return (\n        <ul>\n            <li>1</li>\n            <li>2</li>\n            <li>3</li>\n        </ul>\n    )\n}\n\n// footer\nfunction Footer() {\n    console.log('footer')\n    return <div>这是footer组件</div>\n}\n\nexport default class App extends Component {\n    constructor() {\n        super()\n        this.state = {\n            num: 0,\n        }\n    }\n\n    render() {\n        console.log('app')\n        return (\n            <div>\n                <MemoHeader/>\n                <Main/>\n                <Footer/>\n                {this.state.num}\n                <button onClick={this.numplus.bind(this)}>num+++</button>\n            </div>\n        )\n    }\n\n    numplus() {\n        this.setState({\n            num: this.state.num + 1,\n        })\n    }\n}\n\n\nheader 组件使用 memo 进行了包裹，而 footer 组件没有\n\n当我们改变 APP 中的 num 的值时，footer 组件重新 render 了，而 header 组件并没有重新 render MainBanner、MainProductList 组件没有使用 memo 进行包裹，为什么也没有重新 render？引文他们的父组件 Main 继承自 PureComponent\n\n\n# refs\n\ndetails\n\n在 React 的开发模式中，通常情况下不需要、也不建议直接操作 DOM，但是某些特殊的情况，确实需要获取到 DOM 进行某些操作\n\n如何创建 refs 来获取对应的 DOM 呢？目前有三种方式：\n\n * 方式一(废弃)：传入字符串，使用时通过 this.refs 传入的字符串格式获取对应的元素\n\n * 方式二(推荐)：传入一个对象,对象是通过 React.createRef() 方式创建出来的；使用时获取到创建的对象其中有一个 current 属性就是对应的元素\n\n * 方式三：传入一个函数，该函数会在 DOM 被挂载时进行回调，这个函数会传入一个元素对象，我们可以自己保存；使用时，直接拿到之前保存的元素对象即可\n\nref 的值根据节点的类型而有所不同：\n\n * 当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性\n\n * 当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性\n\n * 你不能在函数组件上使用 ref 属性，因为他们没有实例。\n\nSee the Pen react-ref by zhangfanhang (@zhangfanhang) on CodePen.\n\n\n# ref 的转发\n\n如果要在函数组件中使用 ref，你可以使用 forwardRef来转发ref\n\n不管怎样，你可以在函数组件内部使用 ref 属性，只要它指向一个 DOM 元素或 class 组件：\n\nDETAILS\n\nimport { createRef, forwardRef, PureComponent } from 'react'\n\nconst EnHome = forwardRef(function Home(props, ref) {\n    return (\n        <div ref={ref}>\n            <h1>我是Home</h1>\n        </div>\n    )\n})\nexport default class App extends PureComponent {\n    constructor() {\n        super()\n        this.myRef = createRef()\n    }\n\n    render() {\n        return (\n            <div>\n                <EnHome ref={this.myRef} copName={'fuck'} />\n            </div>\n        )\n    }\n\n    componentDidMount() {\n        console.log(this.myRef.current)\n    }\n}\n\n\n\n# React 表单处理\n\n官方文档:表单\n\n\n# 注意点\n\n * select:React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性,表示默认选中\n * 处理多个输入官网案例注意 checkbox 的处理逻辑\n\n\n# 高阶组件\n\n * 首先， 高阶组件 本身不是一个组件，而是一个函数；其次，这个函数的参数是一个组件，返回值也是一个组件\n * 高阶组件并不是 React API 的一部分，它是基于 React 的 组合特性而形成的设计模式\n * 用途：\n\n\n# 应用 1:props 的增强\n\n不修改原有代码的情况下，添加新的 props:\n\ncode\n\nimport { PureComponent } from 'react'\n\nfunction enhanceProps(Comp, otherProps) {\n    return props => <Comp {...props} {...otherProps} />\n}\n\nclass Home extends PureComponent {\n    render() {\n        return (\n            <div>\n                昵称：{this.props.nickName},等级：{this.props.level},区域：\n                {this.props.region}\n            </div>\n        )\n    }\n}\n\nclass About extends PureComponent {\n    render() {\n        return (\n            <div>\n                昵称：{this.props.nickName},等级：{this.props.level},区域：\n                {this.props.region}\n            </div>\n        )\n    }\n}\n\nconst EnhanceHome = enhanceProps(Home, { region: 'china' })\nconst EnhanceAbout = enhanceProps(About, { region: 'US' })\n\nexport default class App extends PureComponent {\n    render() {\n        return (\n            <div>\n                <EnhanceHome nickName=\"frank\" level=\"999\" />\n                <EnhanceAbout nickName=\"zhang\" level=\"1\" />\n            </div>\n        )\n    }\n}\n\n\n利用高阶组件来共享 Context:\n\ncode\n\nimport { createContext, PureComponent } from 'react'\n\n//创建context\n\nconst UserContext = createContext()\n\n//定义高阶组件\n\nfunction withUser(Comp) {\n    return props => {\n        return (\n            <UserContext.Consumer>\n                {value => {\n                    return <Comp {...value} {...props} />\n                }}\n            </UserContext.Consumer>\n        )\n    }\n}\n\nclass Home extends PureComponent {\n    render() {\n        return (\n            <div>\n                昵称：{this.props.nickName},等级：{this.props.level},区域：\n                {this.props.region}\n            </div>\n        )\n    }\n}\n\nclass About extends PureComponent {\n    render() {\n        return (\n            <div>\n                昵称：{this.props.nickName},等级：{this.props.level},区域：\n                {this.props.region}\n            </div>\n        )\n    }\n}\n\nconst EnhanceHome = withUser(Home)\nconst EnhanceAbout = withUser(About)\n\nexport default class App extends PureComponent {\n    render() {\n        return (\n            <div>\n                <UserContext.Provider\n                    value={{ nickName: 'frank', level: '999', region: 'CN' }}\n                >\n                    <EnhanceHome />\n                    <EnhanceAbout />\n                </UserContext.Provider>\n            </div>\n        )\n    }\n}\n\n\n\n# 应用 2:渲染判断鉴权\n\n在开发中，我们可能遇到这样的场景：\n\n * 某些页面是必须用户登录成功才能进行进入\n * 如果用户没有登录成功，那么直接跳转到登录页面；\n\n这个时候，我们就可以使用高阶组件来完成鉴权操作：\n\nSee the Pen react-demo by zhangfanhang (@zhangfanhang) on CodePen.\n\n\n# 应用 3:生命周期劫持\n\n利用高阶函数来劫持生命周期，在生命周期中完成自己的逻辑：\n\ncode\n\nimport { PureComponent } from 'react'\n\nfunction handleRenderTime(Cop) {\n    return class RenderTimeCop extends PureComponent {\n        UNSAFE_componentWillMount() {\n            this.beginTime = new Date().getTime()\n        }\n\n        componentDidMount() {\n            this.endTime = new Date().getTime()\n            const renderTime = this.endTime - this.beginTime\n            console.log(this.props.copName + '组件渲染用了' + renderTime + 'ms')\n        }\n\n        // props 转发下层\n        /**\n         * 高阶组件==> 返回 Xxxx  组件 ===> 返回了组件\n         */\n        render() {\n            return <Cop {...this.props} />\n        }\n    }\n}\n\nclass Home extends PureComponent {\n    render() {\n        return (\n            <div>\n                <p>{19999999999999999999999999999999999 * 123}</p>\n                <p>\n                    asdaskdnasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjasndjasndjasndjasnsjdnjnjasn\n                </p>\n            </div>\n        )\n    }\n}\n\nclass About extends PureComponent {\n    constructor() {\n        super()\n        this.state = {\n            table: [\n                {\n                    word: '海底捞',\n                    count: 9816,\n                    user: 8972,\n                },\n                {\n                    word: '成都',\n                    count: 8988,\n                    user: 8437,\n                },\n                {\n                    word: '炭烤',\n                    count: 9876,\n                    user: 7622,\n                },\n                {\n                    word: '常州',\n                    count: 9595,\n                    user: 6981,\n                },\n                {\n                    word: '麦乐鸡',\n                    count: 8136,\n                    user: 5779,\n                },\n                {\n                    word: '上海',\n                    count: 6789,\n                    user: 5677,\n                },\n                {\n                    word: '苏州',\n                    count: 8070,\n                    user: 5261,\n                },\n                {\n                    word: '沈阳',\n                    count: 8266,\n                    user: 4925,\n                },\n                {\n                    word: '大连',\n                    count: 8407,\n                    user: 4819,\n                },\n                {\n                    word: '水果',\n                    count: 6137,\n                    user: 4769,\n                },\n                {\n                    word: '商超',\n                    count: 7251,\n                    user: 4393,\n                },\n                {\n                    word: '面条',\n                    count: 8320,\n                    user: 4188,\n                },\n                {\n                    word: '广州',\n                    count: 6525,\n                    user: 4184,\n                },\n                {\n                    word: '麦当劳',\n                    count: 6927,\n                    user: 3820,\n                },\n                {\n                    word: '杭州',\n                    count: 5505,\n                    user: 3377,\n                },\n                {\n                    word: '呼和浩特',\n                    count: 6687,\n                    user: 2909,\n                },\n                {\n                    word: '重庆',\n                    count: 2973,\n                    user: 2155,\n                },\n                {\n                    word: '济南',\n                    count: 2457,\n                    user: 1691,\n                },\n                {\n                    word: '美食',\n                    count: 6080,\n                    user: 1641,\n                },\n                {\n                    word: '温州',\n                    count: 1899,\n                    user: 1486,\n                },\n                {\n                    word: '麻辣',\n                    count: 3515,\n                    user: 1046,\n                },\n                {\n                    word: '肯德基',\n                    count: 1823,\n                    user: 808,\n                },\n                {\n                    word: '长春',\n                    count: 8549,\n                    user: 806,\n                },\n                {\n                    word: '小龙虾',\n                    count: 2243,\n                    user: 628,\n                },\n                {\n                    word: '全家桶',\n                    count: 1951,\n                    user: 564,\n                },\n                {\n                    word: '拉萨',\n                    count: 699,\n                    user: 548,\n                },\n                {\n                    word: '北京',\n                    count: 4917,\n                    user: 545,\n                },\n                {\n                    word: '鸡腿',\n                    count: 1710,\n                    user: 506,\n                },\n                {\n                    word: '南京',\n                    count: 1709,\n                    user: 458,\n                },\n                {\n                    word: '送药',\n                    count: 5384,\n                    user: 344,\n                },\n                {\n                    word: '跑腿',\n                    count: 1224,\n                    user: 319,\n                },\n            ],\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <ul>\n                    {this.state.table.map(item => {\n                        return <li key={item.user}>{item.word}</li>\n                    })}\n                </ul>\n            </div>\n        )\n    }\n}\n\nconst EnHome = handleRenderTime(Home)\nconst EnAbout = handleRenderTime(About)\n\nexport default class App extends PureComponent {\n    render() {\n        return (\n            <div>\n                <EnHome copName=\"home\" />\n                <EnAbout copName={'about'} />\n            </div>\n        )\n    }\n}\n\n\n\n# 高阶组件的意义\n\n我们会发现利用高阶组件可以针对某些 React 代码进行更加优雅的处理。\n\n其实早期的 React 有提供组件之间的一种复用方式是 mixin，目前已经不再建议使用：\n\n * Mixin 可能会相互依赖，相互耦合，不利于代码维护\n * 不同的 Mixin 中的方法可能会相互冲突\n * Mixin 非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性\n\n当然，HOC 也有自己的一些缺陷：\n\n * HOC 需要在原组件上进行包裹或者嵌套，如果大量使用 HOC，将会产生非常多的嵌套，这让调试变得非常困难；\n * HOC 可以劫持 props，在不遵守约定的情况下也可能造成冲突；\n\nHooks 的出现，是开创性的，它解决了很多 React 之前的存在的问题 比如 this 指向问题、比如 hoc 的嵌套复杂度问题等等\n\n\n# Portals 的使用\n\n某些情况下，我们希望渲染的内容独立于父组件，甚至是独立于当前挂载到的 DOM 元素中（默认都是挂载到 id 为 root 的 DOM 元 素上的）\n\n// createPortal是ReactDOM的API而不是React的API\nrender(){\n  return ReactDOM.createPortal(this.props.children,domName)\n}\n\n\n\n# 案例：Modal\n\n开发一个 Modal 组件，它可以将它的子组件渲染到屏幕的中间位置\n\ncode\n\nimport { PureComponent } from 'react'\nimport { createPortal } from 'react-dom'\n\nfunction Modal(props) {\n    console.log(props)\n    return createPortal(props.children, document.getElementById('modal'))\n}\n\nexport default class App extends PureComponent {\n    render() {\n        return (\n            <div>\n                <Modal>\n                    <div>\n                        <h1>我是傻逼</h1>\n                    </div>\n                </Modal>\n            </div>\n        )\n    }\n}\n\n\n\n# fragment\n\n在之前的开发中，我们总是在一个组件中返回内容时包裹一个 div 元素\n\n使用 Fragment 后，无需向 DOM 添加额外节点\n\nReact 还提供了 Fragment 的短语法\n\n它看起来像空标签<> </>\n\n但是，如果我们需要在 Fragment 中添加 key，那么就不能使用短语法\n\n\n# StrictMode\n\nStrictMode 是一个用来突出显示应用程序中潜在问题的工具\n\n与 Fragment 一样，StrictMode 不会渲染任何可见的 UI；\n\n它为其后代元素触发额外的检查和警告\n\n严格模式检查仅在开发模式下运行；它们不会影响生产构建\n\n\n# 严格模式检查什么？\n\n 1. 识别不安全的生命周期：\n\n 2. 使用过时的 ref API\n\n 3. 使用废弃的 findDOMNode 方法 ： 在之前的 React API 中，可以通过 findDOMNode 来获取 DOM，不过已经不推荐使用\n\n 4. 检查意外的副作用：这个组件的 constructor 会被调用两次（ 这是严格模式下故意进行的操作，让你来查看在这里写的一些逻辑代码被调用多次时，是否会产生一些副作用 在生产环境中，是不会被调用两次的,在react17中console.log只调用一次）\n\n 5. 检测过时的 context API：早期的 Context 是通过 static 属性声明 Context 对象属性，通过 getChildContext 返回 Context 对象等方式来使用 Context 的； 目前这种方式已经不推荐使用\n\n\n# render Props\n\nRenderProps，顾名思义就是将组件的props渲染出来。实际上是让组件的props接收函数，由函数来渲染内容。将通用的逻辑抽象在该组件的内部，然后依据业务逻辑来调用函数（props内渲染内容的函数），从而达到重用逻辑的目的。\n\nimport React from \"react\";\n\nclass Cat extends React.Component {\n    render() {\n        const mouse = this.props.mouse;\n        return (\n            <img\n                src=\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9Ii0xMS41IC0xMC4yMzE3NCAyMyAyMC40NjM0OCI+CiAgPHRpdGxlPlJlYWN0IExvZ288L3RpdGxlPgogIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSIyLjA1IiBmaWxsPSIjNjFkYWZiIi8+CiAgPGcgc3Ryb2tlPSIjNjFkYWZiIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIi8+CiAgICA8ZWxsaXBzZSByeD0iMTEiIHJ5PSI0LjIiIHRyYW5zZm9ybT0icm90YXRlKDYwKSIvPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIiB0cmFuc2Zvcm09InJvdGF0ZSgxMjApIi8+CiAgPC9nPgo8L3N2Zz4K\"\n                style={{width: '100px', height: '100px', position: 'absolute', left: mouse.x, top: mouse.y}}/>\n        );\n    }\n}\n\nclass Mouse extends React.Component {\n    constructor(props) {\n        super(props);\n        this.handleMouseMove = this.handleMouseMove.bind(this);\n        this.state = {x: 0, y: 0};\n    }\n\n\n    handleMouseMove(event) {\n        this.setState({\n            x: event.clientX,\n            y: event.clientY\n        });\n    }\n\n    render() {\n        return (\n            <div style={{height: '100vh'}} onMouseMove={this.handleMouseMove}>\n\n                {/*\n          使用 `render`prop 动态决定要渲染的内容，\n          而不是给出一个 <Mouse> 渲染结果的静态表示\n        */}\n                {this.props.render(this.state)}\n            </div>\n        );\n    }\n}\n\nexport default class MouseTracker extends React.Component {\n    render() {\n        return (\n            <div>\n                <h1>移动鼠标!</h1>\n                <Mouse render={mouse => (\n                    <Cat mouse={mouse}/>\n                )}/>\n            </div>\n        );\n    }\n}\n\n\n\n# Render props 与 React.PureComponent 同时使用\n\n如果在render方法中创建函数，那么使用render prop会抵消使用React.PureComponent带来的优势\n\n因为每次调用render()进行渲染时都会创建一个新的函数，这将导致浅比较props的时候prevProps === nextProps始终为false\n\nclass Mouse extends React.PureComponent {\n  // 与上面相同的代码......\n}\n\nclass MouseTracker extends React.Component {\n  render() {\n    return (\n      <div>\n        <Mouse render={mouse => (\n          <Cat mouse={mouse} />\n        )}/>\n      </div>\n    );\n  }\n}\n\n\n在这个示例中，由于Mouse组件的render prop传输的函数是在render()中定义的，这将导致每次MouseTracker渲染时生成一个新的函数作为Mouse组件的render prop，因而抵消了继承自React.PureComponent的效果\n\n\n# 解决方案\n\n为了解决这一问题，可以定义一个实例方法传给render prop\n\nclass MouseTracker extends React.Component {\n  // 定义为实例方法，当我们在渲染中使用它时，它指的是相同的函数\n  renderTheCat(mouse) {\n    return <Cat mouse={mouse} />;\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Move the mouse around!</h1>\n        <Mouse render={this.renderTheCat} />\n      </div>\n    );\n  }\n}\n",normalizedContent:"# react 的组件化\n\nrender 函数的返回值\n\n当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回以下类型之一:\n\n * react元素：\n   * 通常通过 jsx 创建\n   * 例如，<div /> 会被 react 渲染为 dom 节点，<mycomponent />会被 react 渲染为自定义组件\n   * 无论是 <div /> 还是 <mycomponent /> 均为 react 元素\n * 数组或 fragments: 使得 render 方法可以返回多个元素\n * portals：可以渲染子节点到不同的 dom 子树中\n * 字符串或数值类型：它们在 dom 中会被渲染为文本节点\n * 布尔类型或 null:什么都不渲染\n * 从react17开始render禁止返回undefined\n\n\n# 类组件\n\n类组件的定义有如下要求：\n\n * 组件的名称是大写字符开头（无论类组件还是函数组件）\n * 类组件需要继承自 react.component\n * 类组件必须实现 render 函数\n\n使用 class 定义一个组件：\n\n * constructor 是可选的，我们通常在 constructor 中初始化一些数据\n * this.state 中维护的就是我们组件内部的数据\n * render() 方法是 class 组件中唯一必须实现的方法\n\nimport { component } from 'react'\n\nexport default class app extends component {\n    constructor() {\n        super()\n        this.state = {\n            msg: '我是app组件',\n        }\n    }\n    render() {\n        return <div>{this.state.msg},啊这</div>\n    }\n}\n\n\n\n# 函数组件\n\n函数组件是使用 function 来进行定义的函数，只是这个函数会返回和类组件中 render 函数返回一样的内容。\n\n函数组件有自己的特点（当然，hooks，就不一样了）：\n\n * 没有生命周期，也会被更新并挂载，但是没有生命周期函数\n * 没有 this(组件实例)\n * 没有内部状态state\n\n定义函数组件：\n\nexport default function app() {\n    return <div>我是function组件</div>\n}\n\n\n\n# 生命周期\n\n生命周期是一个抽象的概念，在生命周期的整个过程，分成了很多个阶段:\n\n * 比如装载阶段mount，组件第一次在 dom 树中被渲染的过程\n * 比如更新过程update，组件状态发生变化，重新更新渲染的过程\n * 比如卸载过程unmount，组件从 dom 树中被移除的过程\n\nreact 内部为了告诉我们当前处于哪些阶段，会对我们组件内部实现的某些函数进行回调，这些函数就是生命周期函数：\n\n * 比如实现 componentdidmount 函数：组件已经挂载到 dom上时，就会回调\n * 比如实现componentdidupdate函数：组件已经发生了更新时，就会回调\n * 比如实现 componentwillunmount 函数：组件即将被移除时，就会回调\n * 我们可以在这些回调函数中编写自己的逻辑代码，来完成自己的需求功能\n\n我们说到 react 生命周期时，主要谈的是类的生命周期，因为函数式组件是没有生命周期函数的(后面我们可以通过 hooks 来模拟一些生命周期的回调)\n\n\n# 生命周期函数\n\n\n\n# constructor\n\n如果不初始化 state 或不进行方法绑定，则不需要为 react组件实现构造函数\n\nconstructor 中通常只做两件事情：\n\n * 通过给 this.state赋值对象来初始化内部的 state\n * 为事件绑定实例this：this.xxx.bind(this)\n\n# componentdidmount\n\ncomponentdidmount()会在组件挂载后（插入 dom 树中）立即调用\n\ncomponentdidmount中通常进行哪里操作呢？\n\n * 依赖于 dom的操作可以在这里进行\n * 在此处发送网络请求就最好的地方（官方建议）\n * 可以在此处添加一些订阅（会在 componentwillunmount 取消订阅）\n\n# componentdidupdate\n\ncomponentdidupdate() 会在更新后会被立即调用，首次渲染不会执行此方法\n\n * 当组件更新后，可以在此处对 dom 进行操作\n * 如果你对更新前后的props进行了比较，也可以选择在此处进行网络请求（例如，当 props未发生变化时，则不会执行网络请求）\n\ncomponentdidupdate(prevprops) {\n  // 典型用法（不要忘记比较 props）：\n  if (this.props.userid !== prevprops.userid) {\n    this.fetchdata(this.props.userid);\n  }\n}\n\n\n# componentwillunmount\n\ncomponentwillunmount() 会在组件卸载及销毁之前直接调用\n\n * 在此方法中执行必要的清理操作\n * 例如，清除 timer，取消网络请求或清除在 componentdidmount()中创建的订阅等\n\n\n# 组件的嵌套\n\n组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件，再将这些组件组合嵌套在一起，最终形成我们的应用程序\n\n一个简单的组件嵌套的例子 🌰：\n\n\n\nsee the pen react components by zhangfanhang (@zhangfanhang) on codepen.\n\n\n# 组件间的通信\n\n\n# 父组件传递子组件\n\nsuper(props),super()以及不写 super 的区别\n\n * 如果用到了 constructor 就必须写 super(),是用来初始化 this 的\n * 如果你在 constructor 中要使用 this.props,就必须给 super 加参数：super(props)\n * 无论有没有 constructor，在 render 中 this.props 都是可以使用的，这是 react 默认实现的\n * 如果没用到 constructor,是可以不写的；react 会默认添加一个空的 constructor。\n\n父组件在展示子组件，可能会传递一些数据给子组件：\n\n * 父组件通过属性=值的形式来传递给子组件数据；\n * 子组件通过props参数获取父组件传递过来的数据；\n\n父传子:类组件\n\nimport { component } from 'react'\n\nclass childcom extends component {\n    render() {\n        const { name } = this.props\n        return <div>{`我的名字是${name}`}</div>\n    }\n}\n\nexport default class app extends component {\n    constructor() {\n        super()\n        this.state = {\n            name: 'frank',\n        }\n    }\n    render() {\n        return (\n            <div>\n                <childcom name={this.state.name}></childcom>\n            </div>\n        )\n    }\n}\n\n\n父传子:函数组件\n\nimport { component } from 'react'\n\nfunction childcom(props) {\n    const { name } = props\n    return <h2>{`我的名字是${name}`}</h2>\n}\n\nexport default class app extends component {\n    render() {\n        return (\n            <div>\n                <childcom name=\"frank\"></childcom>\n            </div>\n        )\n    }\n}\n\n\n\n# 参数 proptypes\n\n对于传递给子组件的数据，有时候我们可能希望进行验证，特别是对于大型项目来说：\n\n当然，如果你项目中集成了 flow 或者 typescript，那么直接就可以进行类型验证；但是，即使我们没有使用 flow 或者 typescript，也可以通过 prop-types 库来进行参数验证；\n\n从 react v15.5开始，react.proptypes 已移入另一个包中：prop-types 库\n\n更多的验证方式，可以参考官网\n\n * 比如验证数组，并且数组中包含哪些元素；\n * 比如验证对象，并且对象中包含哪些 key 以及 value 是什么类型；\n * 比如某个prop是必须的，使用 requiredfunc: proptypes.func.isrequired\n\n如果没有传递，我们希望有默认值呢？我们使用 defaultprops就可以了\n\nimport { component } from 'react'\nimport proptypes from 'prop-types'\n\nclass childcom extends component {\n    render() {\n        const { name, age } = this.props\n        return <div>{`我的名字是${name},今年${age}岁了`}</div>\n    }\n}\n\nchildcom.proptypes = {\n    name: proptypes.string.isrequired,\n    age: proptypes.number.isrequired,\n}\n\nchildcom.defaultprops = {\n    name: 'null',\n    age: 0,\n}\n\nexport default class app extends component {\n    render() {\n        return (\n            <div>\n                <childcom name=\"frank\" age={22}></childcom>\n                <childcom age={24}></childcom>\n                <childcom></childcom>\n            </div>\n        )\n    }\n}\n\n\n这样写也是可以的\n\nimport { component } from 'react'\nimport proptypes from 'prop-types'\n\nclass childcom extends component {\n    static proptypes = {\n        name: proptypes.string.isrequired,\n        age: proptypes.number.isrequired,\n    }\n    static defaultprops = {\n        name: 'null',\n        age: 0,\n    }\n    render() {\n        const { name, age } = this.props\n        return <div>{`我的名字是${name},今年${age}岁了`}</div>\n    }\n}\n\nexport default class app extends component {\n    render() {\n        return (\n            <div>\n                <childcom name=\"frank\" age={22}></childcom>\n                <childcom age={24}></childcom>\n                <childcom></childcom>\n            </div>\n        )\n    }\n}\n\n\n如果你在常规开发中使用函数组件，那你可能需要做一些适当的改动，以保证 propstypes应用正常。\n\nexport default function helloworldcomponent({ name }) {\n    return <div>hello, {name}</div>\n}\n\n\n如果要添加proptypes，你可能需要在导出之前以单独声明的一个函数的形式，声明该组件，具体代码如下：\n\nfunction helloworldcomponent({ name }) {\n    return <div>hello, {name}</div>\n}\n\nexport default helloworldcomponent\n\n\n接着，可以直接在 helloworldcomponent 上添加 proptypes：\n\nimport proptypes from 'prop-types'\n\nfunction helloworldcomponent({ name }) {\n    return <div>hello, {name}</div>\n}\n\nhelloworldcomponent.proptypes = {\n    name: proptypes.string,\n}\n\nexport default helloworldcomponent\n\n\n\n# 子组件传递父组件\n\n在 react中是通过 props传递消息，只是让父组件给子组件传递一个回调函数，在子组件中调用这个函数即可；\n\n子传父\n\nimport react, { component } from 'react'\n\nclass ibutton extends component {\n    constructor() {\n        super()\n        this.state = {\n            age: 22,\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <button\n                    onclick={() => {\n                        this.props.increment(this.state.age)\n                    }}\n                >\n                    传递\n                </button>\n            </div>\n        )\n    }\n}\n\nexport default class app extends component {\n    constructor() {\n        super()\n        this.state = {\n            age: 0,\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <h1>{this.state.age}</h1>\n                <ibutton\n                    increment={value => {\n                        this.increment(value)\n                    }}\n                />\n            </div>\n        )\n    }\n\n    increment(value) {\n        this.setstate({ age: value })\n    }\n}\n\n\n\n# 在 react 中实现 slot\n\nchildren(即：标签(组件)内的内容)被默认添加到props上，可以通过this.props.children访问，如果存在多个children，那么被添加到props上的是一个children数组\n\napp.js\n\nimport { component } from 'react'\n\nimport navbar from './navbar'\nimport navbar2 from './navbar2'\n\nexport default class app extends component {\n    render() {\n        return (\n            <div>\n                <navbar>\n                    <div>aaa</div>\n                    <div>bbb</div>\n                    <div>ccc</div>\n                </navbar>\n                <navbar2\n                    leftslot={<div>aaa</div>}\n                    centerslot={<div>bbb</div>}\n                    rightslot={<div>ccc</div>}\n                ></navbar2>\n            </div>\n        )\n    }\n}\n\n\n第一种方式(这种方式传递过去的 html结构不能混乱)\n\nimport { component } from 'react'\n\nexport default class navbar extends component {\n    render() {\n        const { children } = this.props\n        return (\n            <div classname=\"nav\">\n                <div classname=\"nav_item nav_left\">{children[0]}</div>\n                <div classname=\"nav_item nav_center\">{children[1]}</div>\n                <div classname=\"nav_item nav_right\">{children[2]}</div>\n            </div>\n        )\n    }\n}\n\n\n第二种方式(推荐)：\n\nimport { component } from 'react'\n\nexport default class navbar extends component {\n    render() {\n        const { leftslot, centerslot, rightslot } = this.props\n        return (\n            <div classname=\"nav\">\n                <div classname=\"nav_item nav_left\">{leftslot}</div>\n                <div classname=\"nav_item nav_center\">{centerslot}</div>\n                <div classname=\"nav_item nav_right\">{rightslot}</div>\n            </div>\n        )\n    }\n}\n\n\n效果图：\n\n\n\n\n# context(跨组件通信)\n\n知识点扩充：属性展开\n\n官方文档：context\n\n# context 应用场景\n\n非父子组件数据的共享：\n\n * 在开发中，比较常见的数据传递方式是通过 props属性自上而下（由父到子）进行传递\n * 但是对于有一些场景：比如一些数据需要在多个组件中进行共享（地区偏好、ui 主题、用户登录状态、用户信息等）\n * 如果我们在顶层的 app 中定义这些信息，之后一层层传递下去，那么对于一些中间层不需要数据的组件来说，是一种冗余的操作\n\n但是，如果层级更多的话，一层层传递是非常麻烦，并且代码是非常冗余的：\n\n * react 提供了一个 api：context\n * context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props\n * context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言\n\n# context 相关 api\n\nreact.createcontext\n\n * 创建一个需要共享的 context 对象\n * 当 react 渲染一个订阅了这个 context 对象的组件，这个组件会从离自身最近的那个匹配的 provider 中读取到当前的 context 值\n * 当组件没有匹配到 provider 时，其 defaultvalue 参数才会生效（只要匹配到就不会生效，即使不传递value）\n\nconst mycontext = react.createcontext({ nickname: 'null', level: 0 }//默认值)\n\n\ncontext.provider\n\n * 每个 context 对象都会返回一个 provider react 组件，它允许消费组件订阅 context的变化\n * provider 接收一个 value 属性，传递给消费组件\n * 一个 provider 可以和多个消费组件有对应关系\n * 多个 provider 也可以嵌套使用，里层的会覆盖外层的数据(如需使用多个context请使用context.consumer)\n * 当 provider的 value 值发生变化时，它内部的所有消费组件都会重新渲染\n\n    render() {\n        return (\n            <div>\n                <mycontext.provider value={this.state}>\n                 {/*这是子组件(消费组件)*/}\n                    <list></list>\n                </mycontext.provider>\n            </div>\n        )\n    }\n\n\n * 从 provider 到其内部消费组件的传播不受制于 shouldcomponentupdate 函数，因此当消费组件在其祖先组件跳过更新的情况下也能更新:\n\nimport {purecomponent, component} from 'react'\nimport react from 'react'\n// 创建context对象\nconst mycontext = react.createcontext({nickname: 'null', level: 0, color: 'red'})\n\n\nclass list extends component {\n    render() {\n        console.log('list render')\n        return (\n            <div>\n                <userinfo/>\n                <ul>\n                    <li>首页</li>\n                    <li>购物车</li>\n                    <li>我的</li>\n                </ul>\n            </div>\n        )\n    }\n\n    // context不受shouldcomponentupdate的控制\n    shouldcomponentupdate(nextprops, nextstate) {\n        return false\n    }\n\n}\n\n// userinfo 组件\nclass userinfo extends component {\n    render() {\n        console.log('render,userinfo')\n        return (\n            <div>\n                <h1 style={{color: this.context.color}}>{this.context.nickname},等级{this.context.level}</h1>\n            </div>\n        )\n    }\n\n    shouldcomponentupdate(nextprops, nextstate) {\n        return false\n    }\n}\n\n// 挂载contexttype(这是无法使用多个context的原因)\nuserinfo.contexttype = mycontext\n\n\nexport default class app extends component {\n    constructor() {\n        super()\n        this.state = {nickname: 'frank', level: 1212299, color: 'red'}\n    }\n\n    render() {\n        console.log('app render')\n        return (\n            <div>\n                <mycontext.provider value={this.state}>\n                    <list/>\n                </mycontext.provider>\n            </div>\n        )\n    }\n\n    shouldcomponentupdate(nextprops, nextstate) {\n        return false\n    }\n}\n\n\n\nclass.contexttype\n\n注意\n\n函数式组件无法使用class.contexttype\n\n * 挂载在 class 上的contexttype属性会被赋值为一个由 react.createcontext() 创建的 context 对象\n * 这能让你使用 this.context 来消费最近 context 上的那个值\n * 你可以在任何生命周期中访问到它，包括 render 函数中\n\nuserinfo.contexttype = mycontext\n// 这是孙组件\nclass userinfo extends component {\n    render() {\n        return (\n            <div>\n                <h2 style={{ color: this.context.color }}>\n                    用户名：{this.context.nickname}\n                </h2>\n                <h2>等级:{this.context.level}</h2>\n            </div>\n        )\n    }\n}\n\n\ncontext.consumer\n\n什么时候使用 context.consumer 呢？\n\n * 当使用 value 的组件是一个函数式组件时\n * 或者当组件中需要使用多个 context 时\n\n这里需要函数作为子元素function as child这种做法；传递给函数的 value 值等价于组件树上方离这个 context 最近的 provider 提供的 value 值\n\nfunction userinfo() {\n    return (\n        <mycontext.consumer>\n            {value => {\n                return (\n                    <div>\n                        <h2>用户名：{value.nickname}</h2>\n                        <h2>等级:{value.level}</h2>\n                    </div>\n                )\n            }}\n        </mycontext.consumer>\n    )\n}\n\n\n# 多个 context\n\n具体编码\n\nimport { component } from 'react'\n\n// 创建context对象\nconst mycontext = react.createcontext({ nickname: 'null', level: 0 })\nconst themecontext = react.createcontext()\n\nfunction list() {\n    return (\n        <div>\n            <userinfo></userinfo>\n            <ul>\n                <li>首页</li>\n                <li>购物车</li>\n                <li>我的</li>\n            </ul>\n        </div>\n    )\n}\n\nfunction userinfo() {\n    return (\n        <mycontext.consumer>\n            {value => {\n                return (\n                    <themecontext.consumer>\n                        {theme => {\n                            return (\n                                <div>\n                                    <h2 style={{ color: theme.color }}>\n                                        用户名：{value.nickname}\n                                    </h2>\n                                    <h2>等级:{value.level}</h2>\n                                </div>\n                            )\n                        }}\n                    </themecontext.consumer>\n                )\n            }}\n        </mycontext.consumer>\n    )\n}\n\nexport default class app extends component {\n    constructor() {\n        super()\n        this.state = {\n            nickname: 'frank',\n            level: 99,\n        }\n    }\n    render() {\n        return (\n            <div>\n                <mycontext.provider value={this.state}>\n                    <themecontext.provider value={{ color: 'blue' }}>\n                        <list></list>\n                    </themecontext.provider>\n                </mycontext.provider>\n            </div>\n        )\n    }\n}\n\n\n\n# 全局事件传递\n\n前面通过 context 主要实现的是数据的共享，但是在开发中如果有跨组件之间的事件传递，应该如何操作呢？\n\n * 在 vue 中我们可以通过 vue 的实例，快速实现一个事件总线（eventbus），来完成操作\n * 在 react 中，我们可以依赖一个使用较多的库 events 来完成对应的操作\n\n安装：yarn add events\n\nevents 常用的 api：\n\n * 创建 eventemitter 对象:const eventbus =new eventemitter()\n * 发出事件：eventbus.emit(\"事件名称\", 参数列表)\n * 监听事件：eventbus.addlistener(\"事件名称\", 监听函数)\n * 移除事件：eventbus.removelistener(\"事件名称\", 监听函数)\n\nevents 案例\n\nimport { component } from 'react'\nimport { eventemitter } from 'events'\n\nconst eventbus = new eventemitter()\n\nclass main extends component {\n    render() {\n        return (\n            <div>\n                <mainbanner />\n            </div>\n        )\n    }\n}\n\nclass mainbanner extends component {\n    constructor() {\n        super()\n        this.state = {\n            num: 0,\n        }\n    }\n\n    render() {\n        return <div>{this.state.num}</div>\n    }\n\n    componentdidmount() {\n        eventbus.addlistener('hellomainbanner', (num, num2) => {\n            this.setstate({\n                num,\n            })\n            console.log(num, num2)\n        })\n    }\n\n    componentwillunmount() {\n        eventbus.removelistener('hellomainbanner')\n    }\n}\n\nexport default class app extends component {\n    constructor() {\n        super()\n        this.state = {\n            num: 88888,\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <main />\n                <button onclick={this.hellomainbanner.bind(this)}>\n                    hellomainbanner\n                </button>\n            </div>\n        )\n    }\n\n    hellomainbanner() {\n        eventbus.emit('hellomainbanner', this.state.num, 123)\n    }\n}\n\n\n\n# setstate\n\nsetstate api\n\n\n# 为什么使用 setstate\n\n开发中我们并不能直接通过修改 state 的值来让界面发生更新:\n\n * 因为我们修改了 state之后，希望 react 根据最新的 state 来重新渲染界面，但是这种方式的修改 react 并不知道数据发生了变化\n * react 并没有实现类似于 vue2 中的 object.defineproperty 或者 vue3 中的 proxy的方式来监听数据的变化\n * 我们必须通过 setstate 来告知 react 数据已经发生了变化\n\n在组件中并没有实现 setstate 的方法，为什么可以调用呢? 原因很简单，setstate 方法是从 component 中继承过来的\n\ncomponent.prototype.setstate = function (partialstate, callback) {\n    // ...\n    // react源🐎\n}\n\n\n\n# setstate 异步更新\n\nsetstate 的更新是异步的?\n\nimport { component } from 'react'\n\nexport default class app extends component {\n    constructor() {\n        super()\n        this.state = {\n            message: 'hello',\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <h2>{this.state.message}</h2>\n                <button onclick={this.handleclick.bind(this)}>改变文本</button>\n            </div>\n        )\n    }\n\n    handleclick() {\n        this.setstate({\n            message: 'hello,world',\n        })\n        console.log(this.state.message) // hello\n    }\n}\n\n\n * 最终打印结果是 hello\n * 可见 setstate 是异步的操作，我们并不能在执行完 setstate 之后立马拿到最新的 state 的结果\n\n为什么 setstate 设计为异步呢?\n\n * setstate 设计为异步，可以显著的提升性能:如果每次调用 setstate 都进行一次更新，那么意味着 render 函数会被频繁调用，界面重新渲染，这样效率是很低的;最好的办法应该是获取到多个更新，之后进行批量更新\n * 如果同步更新了 state，但是还没有执行 render 函数，那么 state 和 props 不能保持同步。state 和 props 不能保持一致性，会在开发中产生很多的问题\n\n\n# 如何获取异步的结果\n\n方式一:setstate 的回调\n\n * setstate 接受两个参数:第二个参数是一个回调函数，这个回调函数会在更新后会执行\n * 格式如下:setstate(partialstate, callback)\n\n    handleclick() {\n        this.setstate(\n            {\n                message: 'hello,world',\n            },\n            () => {\n                console.log(this.state.message)\n            }\n        )\n\n\n方式二：生命周期函数componentdidupdate\n\n    componentdidupdate(prevprops, prevstate) {\n        console.log('componentdidupdate', this.state.message)\n    }\n\n\n\n# setstate 一定是异步吗?\n\n扩展阅读：react 合成事件和原生事件的区别\n\n * 在组件生命周期或 react 合成事件中，setstate 是异步的\n * 在 settimeout 或者原生 dom 事件中，setstate 是同步的\n\n\n# 数据的合并\n\n当调用setstate时，并不会覆盖之前的state,react底层通过object.assign进行合并\n\n比如：{name:'zhang',age:23},修改age并不会对name造成影响\n\nthis.state={\n  name:\"frank\",\n  age:23\n}\n// 使用setstate改变age\nthis.setstate({\n  age:24\n})\n// 底层调用：object.assign({},prevstate,partialstatte)\n// 即相当于：\nobject.assign({},{name:'zhang',age:23},{age:24})\n\n\n\n# 多个state的合并\n\n如下代码，count并不会累加,后调用的 setstate() 将覆盖同一周期内先调用 setstate 的值,因此count只增加 1\n\nthis.setstate({\n    count: this.state.count + 1,\n})\nthis.setstate({\n    count: this.state.count + 1,\n})\nthis.setstate({\n    count: this.state.count + 1,\n})\n//    相当于:\nobject.assign(\n  previousstate,\n  {count:this.state.count + 1},\n  {count:this.state.count+ 1},\n  ...\n)\n\n\n如果后续状态取决于当前状态，可以使用updater函数的形式代替：\n\nthis.setstate(state => {\n    return {\n        num: state.num + 1,\n    }\n})\nthis.setstate(state => {\n    return {\n        num: state.num + 1,\n    }\n})\nthis.setstate(state => {\n    return {\n        num: state.num + 1,\n    }\n})\n// +3 \n\n\n\n# react 的更新机制\n\n * react的渲染流程：jsx---\x3e虚拟dom---\x3e真实dom\n\n * react的更新流程：\n\nprops/state的改变---\x3erender函数重新执行----\x3e产生新的虚拟 dom---\x3e新旧虚拟dom进行diff---\x3e计算出差异进行更新（patch）----\x3e更新到真实的dom\n\n\n# react 性能优化\n\n\n# 列表中 keys 的作用\n\n在遍历列表时，总是会提示一个警告，让我们加入一个key属性\n\n# 方式一:在最后位置插入数据\n\n这种情况，有无 key 意义并不大\n\n# 方式二:在前面插入数据\n\n<ul>\n<li key='333'>333</li>\n<li key='111'>111</li>\n<li key='222'>222</li>\n</ul>\n\n\n * 这种做法，在没有 key 的情况下，列表中所有的子元素都需要进行修改\n * 当子元素拥有 key 时，react 使用 key 来匹配原有树上的子元素以及最新树上的子元素,key 为 111 和 222 的元素仅仅进行位移，不需要进行任何的修改;将 key 为 333 的元素插入到最前面的位置即可\n\n# key 的注意事项\n\n * key 应该是唯一的\n * key 不要使用随机数(随机数在下一次 render 时，会重新生成一个数字)\n * 使用 index 作为 key，对性能是没有优化的\n\n\n# shouldcomponentupdate\n\n只要是修改了 app 中的数据，所有的组件都需要重新 render，进行 diff 算法，性能必然是很低的\n\n事实上，很多的组件没有必须要重新 render；它们调用 render 应该有一个前提，就是依赖的数据（state、 props）发生改变时，再调用自己的 render 方法\n\n如何来控制 render 方法是否被调用呢？通过 shouldcomponentupdate 方法即可\n\n该方法有两个参数：\n\n * 参数一：nextprops ，修改之后，最新的 props 属性\n * 参数二：nextstate ，修改之后，最新的 state 属性\n\n该方法返回值是一个 boolean 类型：\n\n * 返回值为 true，那么就需要调用 render 方法\n * 返回值为 false，那么就不需要调用 render 方法\n * 默认返回的是 true，也就是只要 state 发生改变，就会调用 render 方法\n\n\n# purecomponent\n\n如果所有的类，我们都需要手动来实现 shouldcomponentupdate，这样做是很麻烦的\n\n我们来设想一下 shouldcomponentupdate 中的各种判断的目的是什么？\n\nprops 或者 state 中的数据是否发生了改变，来决定 shouldcomponentupdate 返回 true 或者 false\n\n事实上 react 已经考虑到了这一点，所以 react 已经默认帮我们实现好了，如何实现呢？ 将 class 继承自 purecomponent\n\nimport { purecomponent } from 'react'\n\nexport default class app extends purecomponent {\n    constructor(props) {\n        super(props)\n        this.state = {\n            movie: ['流浪地球', '长津湖', '信条', '肖生客的救赎'],\n        }\n    }\n\n    // shouldcomponentupdate(nextprops, nextstate, nextcontext) {\n    //     return nextstate.movie !== this.state.movie\n    // }\n\n    render() {\n        return (\n            <div>\n                <ul>\n                    {this.state.movie.map(item => {\n                        return <li>{item}</li>\n                    })}\n                </ul>\n                <button onclick={this.add.bind(this)}>++++</button>\n            </div>\n        )\n    }\n\n    add() {\n      // 直接修改数据\n         this.state.movie.push('奇迹笨小孩')\n        this.setstate({\n            movie: this.state.movie,\n        })\n      // 正确做法（新数据替换旧数据）\n        // this.setstate({\n        //     movie: [...this.state.movie,'奇迹笨小孩'],\n        // })\n    }\n}\n\n\n当点击按钮时，电影列表并没有更新。问题在于 purecomponent 仅仅会对新老 this.state.movie 的值进行简单的对比。由于代码中 add 方法改变了同一个 movie 数组，使得新老 this.state.movie 比较的其实还是同一个数组。即便实际上数组中的内容已经变了，但是比较结果是相同的。 所以不可变性在 react 中非常重要\n\n\n# 高阶组件 memo\n\n如何让函数组件实现和purecomponent相同的功能呢？此时需要使用一个高阶组件 memo\n\nimport {component, memo, purecomponent} from 'react'\n\n// header\nconst memoheader = memo(function header() {\n    console.log('header')\n    return <div>这是header</div>\n})\n\n// main\nclass main extends purecomponent {\n    render() {\n        console.log('main')\n        return (\n            <div>\n                <mainbanner/>\n                <mainproductlist/>\n            </div>\n        )\n    }\n}\n\n//  main banner\nfunction mainbanner() {\n    console.log('mainbanner')\n    return <div>轮播图组件</div>\n}\n\n// main productlist\nfunction mainproductlist() {\n    console.log('mainproductlist')\n    return (\n        <ul>\n            <li>1</li>\n            <li>2</li>\n            <li>3</li>\n        </ul>\n    )\n}\n\n// footer\nfunction footer() {\n    console.log('footer')\n    return <div>这是footer组件</div>\n}\n\nexport default class app extends component {\n    constructor() {\n        super()\n        this.state = {\n            num: 0,\n        }\n    }\n\n    render() {\n        console.log('app')\n        return (\n            <div>\n                <memoheader/>\n                <main/>\n                <footer/>\n                {this.state.num}\n                <button onclick={this.numplus.bind(this)}>num+++</button>\n            </div>\n        )\n    }\n\n    numplus() {\n        this.setstate({\n            num: this.state.num + 1,\n        })\n    }\n}\n\n\nheader 组件使用 memo 进行了包裹，而 footer 组件没有\n\n当我们改变 app 中的 num 的值时，footer 组件重新 render 了，而 header 组件并没有重新 render mainbanner、mainproductlist 组件没有使用 memo 进行包裹，为什么也没有重新 render？引文他们的父组件 main 继承自 purecomponent\n\n\n# refs\n\ndetails\n\n在 react 的开发模式中，通常情况下不需要、也不建议直接操作 dom，但是某些特殊的情况，确实需要获取到 dom 进行某些操作\n\n如何创建 refs 来获取对应的 dom 呢？目前有三种方式：\n\n * 方式一(废弃)：传入字符串，使用时通过 this.refs 传入的字符串格式获取对应的元素\n\n * 方式二(推荐)：传入一个对象,对象是通过 react.createref() 方式创建出来的；使用时获取到创建的对象其中有一个 current 属性就是对应的元素\n\n * 方式三：传入一个函数，该函数会在 dom 被挂载时进行回调，这个函数会传入一个元素对象，我们可以自己保存；使用时，直接拿到之前保存的元素对象即可\n\nref 的值根据节点的类型而有所不同：\n\n * 当 ref 属性用于 html 元素时，构造函数中使用 react.createref() 创建的 ref 接收底层 dom 元素作为其 current 属性\n\n * 当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性\n\n * 你不能在函数组件上使用 ref 属性，因为他们没有实例。\n\nsee the pen react-ref by zhangfanhang (@zhangfanhang) on codepen.\n\n\n# ref 的转发\n\n如果要在函数组件中使用 ref，你可以使用 forwardref来转发ref\n\n不管怎样，你可以在函数组件内部使用 ref 属性，只要它指向一个 dom 元素或 class 组件：\n\ndetails\n\nimport { createref, forwardref, purecomponent } from 'react'\n\nconst enhome = forwardref(function home(props, ref) {\n    return (\n        <div ref={ref}>\n            <h1>我是home</h1>\n        </div>\n    )\n})\nexport default class app extends purecomponent {\n    constructor() {\n        super()\n        this.myref = createref()\n    }\n\n    render() {\n        return (\n            <div>\n                <enhome ref={this.myref} copname={'fuck'} />\n            </div>\n        )\n    }\n\n    componentdidmount() {\n        console.log(this.myref.current)\n    }\n}\n\n\n\n# react 表单处理\n\n官方文档:表单\n\n\n# 注意点\n\n * select:react 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性,表示默认选中\n * 处理多个输入官网案例注意 checkbox 的处理逻辑\n\n\n# 高阶组件\n\n * 首先， 高阶组件 本身不是一个组件，而是一个函数；其次，这个函数的参数是一个组件，返回值也是一个组件\n * 高阶组件并不是 react api 的一部分，它是基于 react 的 组合特性而形成的设计模式\n * 用途：\n\n\n# 应用 1:props 的增强\n\n不修改原有代码的情况下，添加新的 props:\n\ncode\n\nimport { purecomponent } from 'react'\n\nfunction enhanceprops(comp, otherprops) {\n    return props => <comp {...props} {...otherprops} />\n}\n\nclass home extends purecomponent {\n    render() {\n        return (\n            <div>\n                昵称：{this.props.nickname},等级：{this.props.level},区域：\n                {this.props.region}\n            </div>\n        )\n    }\n}\n\nclass about extends purecomponent {\n    render() {\n        return (\n            <div>\n                昵称：{this.props.nickname},等级：{this.props.level},区域：\n                {this.props.region}\n            </div>\n        )\n    }\n}\n\nconst enhancehome = enhanceprops(home, { region: 'china' })\nconst enhanceabout = enhanceprops(about, { region: 'us' })\n\nexport default class app extends purecomponent {\n    render() {\n        return (\n            <div>\n                <enhancehome nickname=\"frank\" level=\"999\" />\n                <enhanceabout nickname=\"zhang\" level=\"1\" />\n            </div>\n        )\n    }\n}\n\n\n利用高阶组件来共享 context:\n\ncode\n\nimport { createcontext, purecomponent } from 'react'\n\n//创建context\n\nconst usercontext = createcontext()\n\n//定义高阶组件\n\nfunction withuser(comp) {\n    return props => {\n        return (\n            <usercontext.consumer>\n                {value => {\n                    return <comp {...value} {...props} />\n                }}\n            </usercontext.consumer>\n        )\n    }\n}\n\nclass home extends purecomponent {\n    render() {\n        return (\n            <div>\n                昵称：{this.props.nickname},等级：{this.props.level},区域：\n                {this.props.region}\n            </div>\n        )\n    }\n}\n\nclass about extends purecomponent {\n    render() {\n        return (\n            <div>\n                昵称：{this.props.nickname},等级：{this.props.level},区域：\n                {this.props.region}\n            </div>\n        )\n    }\n}\n\nconst enhancehome = withuser(home)\nconst enhanceabout = withuser(about)\n\nexport default class app extends purecomponent {\n    render() {\n        return (\n            <div>\n                <usercontext.provider\n                    value={{ nickname: 'frank', level: '999', region: 'cn' }}\n                >\n                    <enhancehome />\n                    <enhanceabout />\n                </usercontext.provider>\n            </div>\n        )\n    }\n}\n\n\n\n# 应用 2:渲染判断鉴权\n\n在开发中，我们可能遇到这样的场景：\n\n * 某些页面是必须用户登录成功才能进行进入\n * 如果用户没有登录成功，那么直接跳转到登录页面；\n\n这个时候，我们就可以使用高阶组件来完成鉴权操作：\n\nsee the pen react-demo by zhangfanhang (@zhangfanhang) on codepen.\n\n\n# 应用 3:生命周期劫持\n\n利用高阶函数来劫持生命周期，在生命周期中完成自己的逻辑：\n\ncode\n\nimport { purecomponent } from 'react'\n\nfunction handlerendertime(cop) {\n    return class rendertimecop extends purecomponent {\n        unsafe_componentwillmount() {\n            this.begintime = new date().gettime()\n        }\n\n        componentdidmount() {\n            this.endtime = new date().gettime()\n            const rendertime = this.endtime - this.begintime\n            console.log(this.props.copname + '组件渲染用了' + rendertime + 'ms')\n        }\n\n        // props 转发下层\n        /**\n         * 高阶组件==> 返回 xxxx  组件 ===> 返回了组件\n         */\n        render() {\n            return <cop {...this.props} />\n        }\n    }\n}\n\nclass home extends purecomponent {\n    render() {\n        return (\n            <div>\n                <p>{19999999999999999999999999999999999 * 123}</p>\n                <p>\n                    asdaskdnasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjaasndjasndjasndjasndjasndjasnsjdnjnjasn\n                </p>\n            </div>\n        )\n    }\n}\n\nclass about extends purecomponent {\n    constructor() {\n        super()\n        this.state = {\n            table: [\n                {\n                    word: '海底捞',\n                    count: 9816,\n                    user: 8972,\n                },\n                {\n                    word: '成都',\n                    count: 8988,\n                    user: 8437,\n                },\n                {\n                    word: '炭烤',\n                    count: 9876,\n                    user: 7622,\n                },\n                {\n                    word: '常州',\n                    count: 9595,\n                    user: 6981,\n                },\n                {\n                    word: '麦乐鸡',\n                    count: 8136,\n                    user: 5779,\n                },\n                {\n                    word: '上海',\n                    count: 6789,\n                    user: 5677,\n                },\n                {\n                    word: '苏州',\n                    count: 8070,\n                    user: 5261,\n                },\n                {\n                    word: '沈阳',\n                    count: 8266,\n                    user: 4925,\n                },\n                {\n                    word: '大连',\n                    count: 8407,\n                    user: 4819,\n                },\n                {\n                    word: '水果',\n                    count: 6137,\n                    user: 4769,\n                },\n                {\n                    word: '商超',\n                    count: 7251,\n                    user: 4393,\n                },\n                {\n                    word: '面条',\n                    count: 8320,\n                    user: 4188,\n                },\n                {\n                    word: '广州',\n                    count: 6525,\n                    user: 4184,\n                },\n                {\n                    word: '麦当劳',\n                    count: 6927,\n                    user: 3820,\n                },\n                {\n                    word: '杭州',\n                    count: 5505,\n                    user: 3377,\n                },\n                {\n                    word: '呼和浩特',\n                    count: 6687,\n                    user: 2909,\n                },\n                {\n                    word: '重庆',\n                    count: 2973,\n                    user: 2155,\n                },\n                {\n                    word: '济南',\n                    count: 2457,\n                    user: 1691,\n                },\n                {\n                    word: '美食',\n                    count: 6080,\n                    user: 1641,\n                },\n                {\n                    word: '温州',\n                    count: 1899,\n                    user: 1486,\n                },\n                {\n                    word: '麻辣',\n                    count: 3515,\n                    user: 1046,\n                },\n                {\n                    word: '肯德基',\n                    count: 1823,\n                    user: 808,\n                },\n                {\n                    word: '长春',\n                    count: 8549,\n                    user: 806,\n                },\n                {\n                    word: '小龙虾',\n                    count: 2243,\n                    user: 628,\n                },\n                {\n                    word: '全家桶',\n                    count: 1951,\n                    user: 564,\n                },\n                {\n                    word: '拉萨',\n                    count: 699,\n                    user: 548,\n                },\n                {\n                    word: '北京',\n                    count: 4917,\n                    user: 545,\n                },\n                {\n                    word: '鸡腿',\n                    count: 1710,\n                    user: 506,\n                },\n                {\n                    word: '南京',\n                    count: 1709,\n                    user: 458,\n                },\n                {\n                    word: '送药',\n                    count: 5384,\n                    user: 344,\n                },\n                {\n                    word: '跑腿',\n                    count: 1224,\n                    user: 319,\n                },\n            ],\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <ul>\n                    {this.state.table.map(item => {\n                        return <li key={item.user}>{item.word}</li>\n                    })}\n                </ul>\n            </div>\n        )\n    }\n}\n\nconst enhome = handlerendertime(home)\nconst enabout = handlerendertime(about)\n\nexport default class app extends purecomponent {\n    render() {\n        return (\n            <div>\n                <enhome copname=\"home\" />\n                <enabout copname={'about'} />\n            </div>\n        )\n    }\n}\n\n\n\n# 高阶组件的意义\n\n我们会发现利用高阶组件可以针对某些 react 代码进行更加优雅的处理。\n\n其实早期的 react 有提供组件之间的一种复用方式是 mixin，目前已经不再建议使用：\n\n * mixin 可能会相互依赖，相互耦合，不利于代码维护\n * 不同的 mixin 中的方法可能会相互冲突\n * mixin 非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性\n\n当然，hoc 也有自己的一些缺陷：\n\n * hoc 需要在原组件上进行包裹或者嵌套，如果大量使用 hoc，将会产生非常多的嵌套，这让调试变得非常困难；\n * hoc 可以劫持 props，在不遵守约定的情况下也可能造成冲突；\n\nhooks 的出现，是开创性的，它解决了很多 react 之前的存在的问题 比如 this 指向问题、比如 hoc 的嵌套复杂度问题等等\n\n\n# portals 的使用\n\n某些情况下，我们希望渲染的内容独立于父组件，甚至是独立于当前挂载到的 dom 元素中（默认都是挂载到 id 为 root 的 dom 元 素上的）\n\n// createportal是reactdom的api而不是react的api\nrender(){\n  return reactdom.createportal(this.props.children,domname)\n}\n\n\n\n# 案例：modal\n\n开发一个 modal 组件，它可以将它的子组件渲染到屏幕的中间位置\n\ncode\n\nimport { purecomponent } from 'react'\nimport { createportal } from 'react-dom'\n\nfunction modal(props) {\n    console.log(props)\n    return createportal(props.children, document.getelementbyid('modal'))\n}\n\nexport default class app extends purecomponent {\n    render() {\n        return (\n            <div>\n                <modal>\n                    <div>\n                        <h1>我是傻逼</h1>\n                    </div>\n                </modal>\n            </div>\n        )\n    }\n}\n\n\n\n# fragment\n\n在之前的开发中，我们总是在一个组件中返回内容时包裹一个 div 元素\n\n使用 fragment 后，无需向 dom 添加额外节点\n\nreact 还提供了 fragment 的短语法\n\n它看起来像空标签<> </>\n\n但是，如果我们需要在 fragment 中添加 key，那么就不能使用短语法\n\n\n# strictmode\n\nstrictmode 是一个用来突出显示应用程序中潜在问题的工具\n\n与 fragment 一样，strictmode 不会渲染任何可见的 ui；\n\n它为其后代元素触发额外的检查和警告\n\n严格模式检查仅在开发模式下运行；它们不会影响生产构建\n\n\n# 严格模式检查什么？\n\n 1. 识别不安全的生命周期：\n\n 2. 使用过时的 ref api\n\n 3. 使用废弃的 finddomnode 方法 ： 在之前的 react api 中，可以通过 finddomnode 来获取 dom，不过已经不推荐使用\n\n 4. 检查意外的副作用：这个组件的 constructor 会被调用两次（ 这是严格模式下故意进行的操作，让你来查看在这里写的一些逻辑代码被调用多次时，是否会产生一些副作用 在生产环境中，是不会被调用两次的,在react17中console.log只调用一次）\n\n 5. 检测过时的 context api：早期的 context 是通过 static 属性声明 context 对象属性，通过 getchildcontext 返回 context 对象等方式来使用 context 的； 目前这种方式已经不推荐使用\n\n\n# render props\n\nrenderprops，顾名思义就是将组件的props渲染出来。实际上是让组件的props接收函数，由函数来渲染内容。将通用的逻辑抽象在该组件的内部，然后依据业务逻辑来调用函数（props内渲染内容的函数），从而达到重用逻辑的目的。\n\nimport react from \"react\";\n\nclass cat extends react.component {\n    render() {\n        const mouse = this.props.mouse;\n        return (\n            <img\n                src=\"data:image/svg+xml;base64,phn2zyb4bwxucz0iahr0cdovl3d3dy53my5vcmcvmjawmc9zdmciihzpzxdcb3g9ii0xms41ic0xmc4ymze3ncaymyaymc40njm0oci+ciagphrpdgxlpljlywn0iexvz288l3rpdgxlpgogidxjaxjjbgugy3g9ijaiign5psiwiibypsiylja1iibmawxspsijnjfkywziii8+ciagpgcgc3ryb2tlpsijnjfkywziiibzdhjva2utd2lkdgg9ijeiigzpbgw9im5vbmuipgogicagpgvsbglwc2ugcng9ijexiibyet0inc4yii8+ciagica8zwxsaxbzzsbyed0imteiihj5psi0ljiiihryyw5zzm9ybt0icm90yxrlkdywksivpgogicagpgvsbglwc2ugcng9ijexiibyet0inc4yiib0cmfuc2zvcm09injvdgf0zsgxmjapii8+ciagpc9npgo8l3n2zz4k\"\n                style={{width: '100px', height: '100px', position: 'absolute', left: mouse.x, top: mouse.y}}/>\n        );\n    }\n}\n\nclass mouse extends react.component {\n    constructor(props) {\n        super(props);\n        this.handlemousemove = this.handlemousemove.bind(this);\n        this.state = {x: 0, y: 0};\n    }\n\n\n    handlemousemove(event) {\n        this.setstate({\n            x: event.clientx,\n            y: event.clienty\n        });\n    }\n\n    render() {\n        return (\n            <div style={{height: '100vh'}} onmousemove={this.handlemousemove}>\n\n                {/*\n          使用 `render`prop 动态决定要渲染的内容，\n          而不是给出一个 <mouse> 渲染结果的静态表示\n        */}\n                {this.props.render(this.state)}\n            </div>\n        );\n    }\n}\n\nexport default class mousetracker extends react.component {\n    render() {\n        return (\n            <div>\n                <h1>移动鼠标!</h1>\n                <mouse render={mouse => (\n                    <cat mouse={mouse}/>\n                )}/>\n            </div>\n        );\n    }\n}\n\n\n\n# render props 与 react.purecomponent 同时使用\n\n如果在render方法中创建函数，那么使用render prop会抵消使用react.purecomponent带来的优势\n\n因为每次调用render()进行渲染时都会创建一个新的函数，这将导致浅比较props的时候prevprops === nextprops始终为false\n\nclass mouse extends react.purecomponent {\n  // 与上面相同的代码......\n}\n\nclass mousetracker extends react.component {\n  render() {\n    return (\n      <div>\n        <mouse render={mouse => (\n          <cat mouse={mouse} />\n        )}/>\n      </div>\n    );\n  }\n}\n\n\n在这个示例中，由于mouse组件的render prop传输的函数是在render()中定义的，这将导致每次mousetracker渲染时生成一个新的函数作为mouse组件的render prop，因而抵消了继承自react.purecomponent的效果\n\n\n# 解决方案\n\n为了解决这一问题，可以定义一个实例方法传给render prop\n\nclass mousetracker extends react.component {\n  // 定义为实例方法，当我们在渲染中使用它时，它指的是相同的函数\n  renderthecat(mouse) {\n    return <cat mouse={mouse} />;\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>move the mouse around!</h1>\n        <mouse render={this.renderthecat} />\n      </div>\n    );\n  }\n}\n",charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"React脚手架",frontmatter:{title:"React脚手架",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E8%84%9A%E6%89%8B%E6%9E%B6.html",relativePath:"前端开发/前端框架/React/React脚手架.md",key:"v-0cd5d1ed",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/React%E8%84%9A%E6%89%8B%E6%9E%B6.html",headers:[{level:2,title:"安装脚手架",slug:"安装脚手架",normalizedTitle:"安装脚手架",charIndex:2},{level:2,title:"创建 React 项目",slug:"创建-react-项目",normalizedTitle:"创建 react 项目",charIndex:45},{level:2,title:"目录结构分析",slug:"目录结构分析",normalizedTitle:"目录结构分析",charIndex:135}],headersStr:"安装脚手架 创建 React 项目 目录结构分析",content:"# 安装脚手架\n\nnpm install -g create-react-app\n\n\n# 创建 React 项目\n\n创建 React 项目的命令如下：\n\n注意：项目名称不能包含大写字母\n\ncreate-react-app 项目名称\n\n运行：yarn start\n\n\n# 目录结构分析\n\n脚手架版本：4.0.3\n\n├── node_modules\n├── public\n│   ├── favicon.ico # 网站或者项目图标\n│   ├── index.html #  首页模板文件。可以在此引入一些静态的资源。\n│   ├── logo192.png #  在manifest.json中使用\n│   ├── logo512.png #  在manifest.json中使用\n│   ├── manifest.json # 和web app配置相关\n│   └── robots.txt # 指定搜索引擎可以或者无法爬取那些文件\n├── src\n│   ├── App.css # App组件相关的样式\n│   ├── App.js # App组件代码\n│   ├── App.test.js # App组件的测试代码文件\n│   ├── index.css # 全局的样式文件\n│   ├── index.js # 整个应用程序的入口文件\n│   ├── logo.svg # logo\n│   ├── reportWebVitals.js # 谷歌新出的关于浏览器性能优化的库。(新增的文件)\n│   └── setupTests.js # 测试初始化文件\n├──.gitignore\n├── package.json\n├── README.md\n└── yarn.lock\n",normalizedContent:"# 安装脚手架\n\nnpm install -g create-react-app\n\n\n# 创建 react 项目\n\n创建 react 项目的命令如下：\n\n注意：项目名称不能包含大写字母\n\ncreate-react-app 项目名称\n\n运行：yarn start\n\n\n# 目录结构分析\n\n脚手架版本：4.0.3\n\n├── node_modules\n├── public\n│   ├── favicon.ico # 网站或者项目图标\n│   ├── index.html #  首页模板文件。可以在此引入一些静态的资源。\n│   ├── logo192.png #  在manifest.json中使用\n│   ├── logo512.png #  在manifest.json中使用\n│   ├── manifest.json # 和web app配置相关\n│   └── robots.txt # 指定搜索引擎可以或者无法爬取那些文件\n├── src\n│   ├── app.css # app组件相关的样式\n│   ├── app.js # app组件代码\n│   ├── app.test.js # app组件的测试代码文件\n│   ├── index.css # 全局的样式文件\n│   ├── index.js # 整个应用程序的入口文件\n│   ├── logo.svg # logo\n│   ├── reportwebvitals.js # 谷歌新出的关于浏览器性能优化的库。(新增的文件)\n│   └── setuptests.js # 测试初始化文件\n├──.gitignore\n├── package.json\n├── readme.md\n└── yarn.lock\n",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"Redux",frontmatter:{title:"Redux",date:"2022/05/26 22:26:52",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/Redux.html",relativePath:"前端开发/前端框架/React/Redux.md",key:"v-f421c146",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/Redux.html",headers:[{level:2,title:"JavaScript 纯函数",slug:"javascript-纯函数",normalizedTitle:"javascript 纯函数",charIndex:2},{level:2,title:"为什么需要redux",slug:"为什么需要redux",normalizedTitle:"为什么需要redux",charIndex:547},{level:2,title:"Redux的核心理念-action",slug:"redux的核心理念-action",normalizedTitle:"redux的核心理念-action",charIndex:1110},{level:2,title:"Redux的核心理念 - reducer",slug:"redux的核心理念-reducer",normalizedTitle:"redux的核心理念 - reducer",charIndex:1300},{level:2,title:"Redux的三大原则",slug:"redux的三大原则",normalizedTitle:"redux的三大原则",charIndex:1428},{level:3,title:"单一数据源",slug:"单一数据源",normalizedTitle:"单一数据源",charIndex:1443},{level:3,title:"State是只读的",slug:"state是只读的",normalizedTitle:"state是只读的",charIndex:1598},{level:3,title:"使用纯函数来执行修改",slug:"使用纯函数来执行修改",normalizedTitle:"使用纯函数来执行修改",charIndex:1789},{level:2,title:"Redux使用流程",slug:"redux使用流程",normalizedTitle:"redux使用流程",charIndex:1953},{level:2,title:"在react项目中使用redux",slug:"在react项目中使用redux",normalizedTitle:"在react项目中使用redux",charIndex:1969},{level:2,title:"redux中异步操作",slug:"redux中异步操作",normalizedTitle:"redux中异步操作",charIndex:6001},{level:3,title:"理解中间件",slug:"理解中间件",normalizedTitle:"理解中间件",charIndex:6222},{level:3,title:"使用redux-thunk",slug:"使用redux-thunk",normalizedTitle:"使用redux-thunk",charIndex:6693},{level:2,title:"redux-devtools",slug:"redux-devtools",normalizedTitle:"redux-devtools",charIndex:7942},{level:2,title:"Redux代码文件拆分",slug:"redux代码文件拆分",normalizedTitle:"redux代码文件拆分",charIndex:8671},{level:2,title:"combineReducers函数",slug:"combinereducers函数",normalizedTitle:"combinereducers函数",charIndex:9429}],headersStr:"JavaScript 纯函数 为什么需要redux Redux的核心理念-action Redux的核心理念 - reducer Redux的三大原则 单一数据源 State是只读的 使用纯函数来执行修改 Redux使用流程 在react项目中使用redux redux中异步操作 理解中间件 使用redux-thunk redux-devtools Redux代码文件拆分 combineReducers函数",content:'# JavaScript 纯函数\n\n函数式编程指北\n\n函数式编程中有一个概念叫纯函数，JavaScript 符合函数式编程的范式，所以也有纯函数的概念\n\n在 React 中，纯函数的概念非常重要，React要求所有组件都必须像纯函数一样保护它们的props不被修改。在 Redux 中也非常重要，所以有必须来回顾一下纯函数。\n\n纯函数的维基百科定义：\n\n在程序设计中，若一个函数符合以下条件，那么这个函数被称为纯函数：\n\n * 此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由 I/O 设备产生的 外部输出无关\n * 该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等\n\n当然上面的定义会过于的晦涩，所以简单总结一下：\n\n * 确定的输入，一定会产生确定的输出\n * 函数在执行过程中，不能产生副作用\n\n为什么纯函数在函数式编程中非常重要呢？\n\n * 因为你可以安心的写和安心的用\n * 你在写的时候保证了函数的纯度，只是但是实现自己的业务逻辑即可，不需要关心传入的内容或者依赖其他的外部变量\n * 你在用的时候，你确定你的输入内容不会被任意篡改，并且自己确定的输入，一定会有确定的输出\n\n\n# 为什么需要redux\n\nJavaScript开发的应用程序，已经变得越来越复杂了：\n\n * JavaScript需要管理的状态越来越多，越来越复杂\n * 这些状态包括服务器返回的数据、缓存数据、用户操作产生的数据等等，也包括一些UI的状态，比如某些元素是否被选中， 是否显示加载动效，当前分页\n\n管理不断变化的state是非常困难的：\n\n * 状态之间相互会存在依赖，一个状态的变化会引起另一个状态的变化，View页面也有可能会引起状态的变化\n * 当应用程序复杂时，state在什么时候，因为什么原因而发生了变化，发生了怎么样的变化，会变得非常难以控制和追踪\n\nReact是在视图层帮助我们解决了DOM的渲染过程，但是State依然是留给我们自己来管理：\n\n * 无论是组件定义自己的state，还是组件之间的通信通过props进行传递；也包括通过Context进行数据之间的共享；\n * React主要负责帮助我们管理视图，state如何维护最终还是我们自己来决定\n\nRedux就是一个帮助我们管理State的容器：Redux是JavaScript的状态容器，提供了可预测的状态管理\n\nRedux除了和React一起使用之外，它也可以和其他界面库一起来使用（比如Vue），并且它非常小（包括依赖在内，只有2kb）\n\n\n# Redux的核心理念-action\n\nRedux要求我们通过action来更新数据：\n\n * 所有数据的变化，必须通过派发（dispatch）action来更新\n\n * action是一个普通的JavaScript对象，用来描述这次更新的type和content\n\n强制使用action的好处是可以清晰的知道数据到底发生了什么样的变化，所有的数据变化都是可跟追、可预测的\n\n\n# Redux的核心理念 - reducer\n\n但是如何将state和action联系在一起呢？答案就是reducer\n\n * reducer是一个纯函数\n * reducer做的事情就是将传入的state和action结合起来生成一个新的state\n\n\n# Redux的三大原则\n\n\n# 单一数据源\n\n * 整个应用程序的state被存储在一颗object tree中，并且这个object tree只存储在一个 store 中\n * Redux并没有强制让我们不能创建多个Store，但是那样做并不利于数据的维护\n * 单一的数据源可以让整个应用程序的state变得方便维护、追踪、修改\n\n\n# State是只读的\n\n * 唯一修改State的方法一定是触发action，不要试图在其他地方通过任何的方式来修改State\n * 这样就确保了View或网络请求都不能直接修改state，它们只能通过action来描述自己想要如何修改state\n * 这样可以保证所有的修改都被集中化处理，并且按照严格的顺序来执行，所以不需要担心race condition（竟态）的问题\n\n\n# 使用纯函数来执行修改\n\n * 通过reducer将 旧state和 actions联系在一起，并且返回一个新的State\n * 随着应用程序的复杂度增加，我们可以将reducer拆分成多个小的reducers，分别操作不同state tree的一部分\n * 但是所有的reducer都应该是纯函数，不能产生任何的副作用\n\n\n# Redux使用流程\n\n\n\n\n# 在react项目中使用redux\n\n 1. 创建store文件夹，创建4个文件：actionCreators.js（创建action的文件），constants.js（定义action名称常量),reducer.js(将aciton和state联系在一起)，index.js(导出创建好的store)\n\n这里实现一个简单的couter案例：\n\nactionCreators.js\n\nimport {JIA_ACTION} from "./constants";\n\nexport function JIAA_ACTION(num) {\n    return {\n        type: JIA_ACTION,\n        num\n    }\n}\n\n\nconstants.js\n\nexport const JIA_ACTION = \'JIA_ACTION\'\n\n\nreducer.js\n\nimport {JIA_ACTION} from "./constants";\n\nconst defaultStore = {\n    counter: 0\n}\n\nexport default function reducer(state = defaultStore, action) {\n    switch (action.type) {\n        case JIA_ACTION:\n            return {...state, counter: action.num + state.counter}\n        default:\n            return state;\n    }\n}\n\n\nindex.js\n\nimport {createStore} from "redux";\nimport reducer from "./reducer";\n\nconst store = createStore(reducer)\n\nexport default store\n\n\n 2. 接着创建utils文件夹，这里编写connect工具函数。创建connect.js(抽象react与redux连接逻辑的工具函数)，context.js(利用context全局共享store)\n\nconnect.js\n\nimport {PureComponent} from "react";\nimport storeContext from \'./context\'\n\nexport default function connect(mapStateToProps, mapDispatchToProps) {\n    return function enhanceHOC(WrapperComponent) {\n        class ReduxConnect extends PureComponent {\n            constructor(props, context) {\n                super(props, context)\n                this.state = {\n                    storeState: context.getState()\n                }\n            }\n\n            render() {\n                return (\n                    <div>\n                        <WrapperComponent\n                            {...this.props}\n                            {...mapStateToProps(this.context.getState())}\n                            {...mapDispatchToProps(this.context.dispatch)}\n                        />\n                    </div>\n                );\n            }\n\n            componentDidMount() {\n                // console.log(this.context)\n                this.unsubscribe = this.context.subscribe(() => {\n                    this.setState({\n                        // { counter:1}\n                        storeState: mapStateToProps(this.context.getState())\n                    })\n                })\n            }\n\n            componentWillUnmount() {\n                this.unsubscribe()\n            }\n        }\n\n        ReduxConnect.contextType = storeContext\n        return ReduxConnect\n    }\n}\n\n\ncontext.js\n\nimport react from \'react\'\n\nconst StoreContext = react.createContext()\n\nexport default StoreContext\n\n\n 3. 在项目index.js文件中引入store，利用StoreContext的Provider组件，让App组件共享store\n\nimport store from \'./redux/store\'\nimport StoreContext from "./redux/utils/context"\nReactDOM.render(<StoreContext.Provider value={store}><App/></StoreContext.Provider>, document.getElementById(\'root\'))\n\n\n 4. 在想要使用store的组件中定义mapStateToProps,mapDispatchToProps。把需要的state和dispatch映射到想要使用store的组件的props中\n\nimport {PureComponent} from "react";\n\nimport connect from "./utils/connect";\n\nimport {JIAA_ACTION} from "./store/actionCreators";\n\nconst mapStateToProps = state => {\n    return {\n        counter: state.counter\n    }\n}\n\nconst mapDispatchToProps = dispatch => {\n    return {\n        add: function () {\n            dispatch(JIAA_ACTION(3))\n        }\n    }\n}\n\n\nconst App = class extends PureComponent {\n    componentDidMount() {\n        console.log(this.props)\n    }\n\n    render() {\n        return (\n            <div>\n                {this.props.counter}\n                <button onClick={() => {\n                    this.props.add()\n                }}>+3\n                </button>\n            </div>\n        );\n    }\n}\n\n\nconst EnApp = connect(mapStateToProps, mapDispatchToProps)(App)\n\nexport default EnApp\n\n\n虽然已经实现了connect、Provider这些帮助我们完成连接redux、react的辅助工具，但是实际上redux官方提供了 react-redux 的库，可以直接在项目中使用，并且实现的逻辑会更加的严谨和高效\n\n 1. 安装：yarn add react-redux\n 2. 在index.js中将Provider组件替换成react-redux中的Provider组件\n\nimport {Provider} from "react-redux";\n\nReactDOM.render(<Provider store={store}><App/></Provider>, document.getElementById(\'root\'))\n\n\n 3. 组件中将connect替换成react-redux中connect\n\nimport {connect} from \'react-redux\'\n\n\n\n# redux中异步操作\n\n事实上，网络请求到的数据也属于我们状态管理的一部分，更好的一种方式应该是将其也交给redux来管理\n\n\n\n但是在redux中如何可以进行异步的操作呢？\n\n * 答案就是使用中间件（Middleware）\n * 学习过Express或Koa框架的童鞋对中间件的概念一定不陌生\n * 在这类框架中，Middleware可以帮助我们在请求和响应之间嵌入一些操作的代码，比如cookie解析、日志记录、文件压缩等操作\n\n\n# 理解中间件\n\nredux也引入了中间件（Middleware）的概念：\n\n * 这个中间件的目的是在dispatch的action和最终达到的reducer之间，扩展一些自己的代码。比如日志记录、调用异步接口、添加代码调试功能等等\n\n * 我们现在要做的事情就是发送异步的网络请求，所以我们可以添加对应的中间件。官网推荐的、包括演示的网络请求的中间件是使用 redux-thunk\n\nredux-thunk是如何做到让我们可以发送异步的请求呢？\n\n * 我们知道，默认情况下的dispatch(action)，action需要是一个JavaScript的对象\n\n * redux-thunk可以让dispatch(action函数)，action可以是一个函数\n\n * 该函数会被调用，并且会传给这个函数一个dispatch函数和getState函数：\n   \n   * dispatch函数用于我们之后再次派发action\n   * getState函数考虑到我们之后的一些操作需要依赖原来的状态，用于让我们可以获取之前的一些状态\n\n\n# 使用redux-thunk\n\n 1. 安装redux-thunk:yarn add redux-thunk\n\n 2. 在创建store时传入应用了middleware的enhance函数\n    \n    * 通过applyMiddleware来结合多个Middleware, 返回一个enhancer\n    * 将enhancer作为第二个参数传入到createStore中\n\nimport thunkMiddleware from \'redux-thunk\'\nconst storeEnhancer = applyMiddleware(thunkMiddleware)\nconst store = createStore(reducer, storeEnhancer)\n\n\n 3. 在actionCreators.js定义一个返回函数的action：\n\n * 注意：这里不是返回一个对象了，而是一个函数\n * 该函数在dispatch之后会被执行\n\nexport function getbannerDataAction() {\n    return (dispath) => {\n        {\n            console.log(\'react-thuck数据接受成功\')\n            axios.get(\'http://123.207.32.32:8000/home/multidata\').then(res => {\n                // console.log(res)\n                // console.log(res.data.data.banner.list)\n                dispath(bannerAction(res.data.data.banner.list))\n            })\n        }\n    }\n} \n\n\n 4. 映射该action的dispatch操作,和相关的store中的state：\n\nconst mapStateToProps = state => {\n    return {\n        banner: state.banner\n    }\n}\nconst mapDispatchToProps = dispatch => {\n    return {\n        getbanner: function () {\n            dispatch(getbannerDataAction())\n        }\n    }\n}\n\n\n 5. 在componentDidMount调用，就可以拿到数据\n\n    componentDidMount() {\n\n        this.props.getbanner()\n\n        console.log(this.props.banner)\n    }\n}\n\n\n\n# redux-devtools\n\n利用这个工具，我们可以知道每次状态是如何被修改的，修改前后的状态变化等等\n\n 1. 在对应的浏览器中安装相关的插件（Chrome浏览器扩展商店中搜索Redux DevTools即可\n 2. 对store的index.js进行改造\n\nimport {createStore, applyMiddleware, compose} from "redux";\nimport reducer from \'./reducer\'\nimport thunkMiddleware from \'redux-thunk\'\n// 应用中间件\nconst storeEnhancer = applyMiddleware(thunkMiddleware)\n// 合并多个enhancer\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(tra) || compose;\n// 官方不推荐createStore 需要使用redux工具包🔧\nconst store = createStore(reducer, composeEnhancers(storeEnhancer))\nexport default store\n\n\n对于基本的redux,只需要添加：\n\n const store = createStore(\n   reducer, /* preloadedState, */\n+  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n );\n\n\n\n# Redux代码文件拆分\n\n随着项目的不断扩大，可能导致store结构越来越复杂，action越来越多。所有有必要对代码结构进行拆分\n\n代码结构如下：\n\n\n\n主目录reducer.js:\n\nimport {counterReducer} from "./counter";\nimport {bannerReducer} from "./banner";\n\nexport default function reducer(state = {}, action) {\n    return {\n        counterInfo: counterReducer(state.counterInfo, action),\n        bannerInfo: bannerReducer(state.bannerInfo, action)\n    }\n}\n\n\nBanner.js\n\nimport {GET_BANNER_DATA} from "./constants";\n// banner默认数据\nconst defaultBannerState = {\n    banner: []\n}\n// banner独有的reducer逻辑\nexport default function bannerReducer(state = defaultBannerState, action) {\n    switch (action.type) {\n        case GET_BANNER_DATA:\n            return {...state, banner: action.banner}\n        default:\n            return state;\n    }\n}\n\n\n\n# combineReducers函数\n\n目前我们合并的方式是通过每次调用reducer函数自己来返回一个新的对象\n\n事实上，redux给我们提供了一个combineReducers函数可以方便的让我们对多个reducer进行合并：\n\nimport {counterReducer} from "./counter";\nimport {bannerReducer} from "./banner";\nimport {combineReducers} from "redux";\n\nconst reducer = combineReducers({\n    counterInfo: counterReducer,\n    bannerInfo: bannerReducer\n})\n\nexport default reducer\n',normalizedContent:'# javascript 纯函数\n\n函数式编程指北\n\n函数式编程中有一个概念叫纯函数，javascript 符合函数式编程的范式，所以也有纯函数的概念\n\n在 react 中，纯函数的概念非常重要，react要求所有组件都必须像纯函数一样保护它们的props不被修改。在 redux 中也非常重要，所以有必须来回顾一下纯函数。\n\n纯函数的维基百科定义：\n\n在程序设计中，若一个函数符合以下条件，那么这个函数被称为纯函数：\n\n * 此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由 i/o 设备产生的 外部输出无关\n * 该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等\n\n当然上面的定义会过于的晦涩，所以简单总结一下：\n\n * 确定的输入，一定会产生确定的输出\n * 函数在执行过程中，不能产生副作用\n\n为什么纯函数在函数式编程中非常重要呢？\n\n * 因为你可以安心的写和安心的用\n * 你在写的时候保证了函数的纯度，只是但是实现自己的业务逻辑即可，不需要关心传入的内容或者依赖其他的外部变量\n * 你在用的时候，你确定你的输入内容不会被任意篡改，并且自己确定的输入，一定会有确定的输出\n\n\n# 为什么需要redux\n\njavascript开发的应用程序，已经变得越来越复杂了：\n\n * javascript需要管理的状态越来越多，越来越复杂\n * 这些状态包括服务器返回的数据、缓存数据、用户操作产生的数据等等，也包括一些ui的状态，比如某些元素是否被选中， 是否显示加载动效，当前分页\n\n管理不断变化的state是非常困难的：\n\n * 状态之间相互会存在依赖，一个状态的变化会引起另一个状态的变化，view页面也有可能会引起状态的变化\n * 当应用程序复杂时，state在什么时候，因为什么原因而发生了变化，发生了怎么样的变化，会变得非常难以控制和追踪\n\nreact是在视图层帮助我们解决了dom的渲染过程，但是state依然是留给我们自己来管理：\n\n * 无论是组件定义自己的state，还是组件之间的通信通过props进行传递；也包括通过context进行数据之间的共享；\n * react主要负责帮助我们管理视图，state如何维护最终还是我们自己来决定\n\nredux就是一个帮助我们管理state的容器：redux是javascript的状态容器，提供了可预测的状态管理\n\nredux除了和react一起使用之外，它也可以和其他界面库一起来使用（比如vue），并且它非常小（包括依赖在内，只有2kb）\n\n\n# redux的核心理念-action\n\nredux要求我们通过action来更新数据：\n\n * 所有数据的变化，必须通过派发（dispatch）action来更新\n\n * action是一个普通的javascript对象，用来描述这次更新的type和content\n\n强制使用action的好处是可以清晰的知道数据到底发生了什么样的变化，所有的数据变化都是可跟追、可预测的\n\n\n# redux的核心理念 - reducer\n\n但是如何将state和action联系在一起呢？答案就是reducer\n\n * reducer是一个纯函数\n * reducer做的事情就是将传入的state和action结合起来生成一个新的state\n\n\n# redux的三大原则\n\n\n# 单一数据源\n\n * 整个应用程序的state被存储在一颗object tree中，并且这个object tree只存储在一个 store 中\n * redux并没有强制让我们不能创建多个store，但是那样做并不利于数据的维护\n * 单一的数据源可以让整个应用程序的state变得方便维护、追踪、修改\n\n\n# state是只读的\n\n * 唯一修改state的方法一定是触发action，不要试图在其他地方通过任何的方式来修改state\n * 这样就确保了view或网络请求都不能直接修改state，它们只能通过action来描述自己想要如何修改state\n * 这样可以保证所有的修改都被集中化处理，并且按照严格的顺序来执行，所以不需要担心race condition（竟态）的问题\n\n\n# 使用纯函数来执行修改\n\n * 通过reducer将 旧state和 actions联系在一起，并且返回一个新的state\n * 随着应用程序的复杂度增加，我们可以将reducer拆分成多个小的reducers，分别操作不同state tree的一部分\n * 但是所有的reducer都应该是纯函数，不能产生任何的副作用\n\n\n# redux使用流程\n\n\n\n\n# 在react项目中使用redux\n\n 1. 创建store文件夹，创建4个文件：actioncreators.js（创建action的文件），constants.js（定义action名称常量),reducer.js(将aciton和state联系在一起)，index.js(导出创建好的store)\n\n这里实现一个简单的couter案例：\n\nactioncreators.js\n\nimport {jia_action} from "./constants";\n\nexport function jiaa_action(num) {\n    return {\n        type: jia_action,\n        num\n    }\n}\n\n\nconstants.js\n\nexport const jia_action = \'jia_action\'\n\n\nreducer.js\n\nimport {jia_action} from "./constants";\n\nconst defaultstore = {\n    counter: 0\n}\n\nexport default function reducer(state = defaultstore, action) {\n    switch (action.type) {\n        case jia_action:\n            return {...state, counter: action.num + state.counter}\n        default:\n            return state;\n    }\n}\n\n\nindex.js\n\nimport {createstore} from "redux";\nimport reducer from "./reducer";\n\nconst store = createstore(reducer)\n\nexport default store\n\n\n 2. 接着创建utils文件夹，这里编写connect工具函数。创建connect.js(抽象react与redux连接逻辑的工具函数)，context.js(利用context全局共享store)\n\nconnect.js\n\nimport {purecomponent} from "react";\nimport storecontext from \'./context\'\n\nexport default function connect(mapstatetoprops, mapdispatchtoprops) {\n    return function enhancehoc(wrappercomponent) {\n        class reduxconnect extends purecomponent {\n            constructor(props, context) {\n                super(props, context)\n                this.state = {\n                    storestate: context.getstate()\n                }\n            }\n\n            render() {\n                return (\n                    <div>\n                        <wrappercomponent\n                            {...this.props}\n                            {...mapstatetoprops(this.context.getstate())}\n                            {...mapdispatchtoprops(this.context.dispatch)}\n                        />\n                    </div>\n                );\n            }\n\n            componentdidmount() {\n                // console.log(this.context)\n                this.unsubscribe = this.context.subscribe(() => {\n                    this.setstate({\n                        // { counter:1}\n                        storestate: mapstatetoprops(this.context.getstate())\n                    })\n                })\n            }\n\n            componentwillunmount() {\n                this.unsubscribe()\n            }\n        }\n\n        reduxconnect.contexttype = storecontext\n        return reduxconnect\n    }\n}\n\n\ncontext.js\n\nimport react from \'react\'\n\nconst storecontext = react.createcontext()\n\nexport default storecontext\n\n\n 3. 在项目index.js文件中引入store，利用storecontext的provider组件，让app组件共享store\n\nimport store from \'./redux/store\'\nimport storecontext from "./redux/utils/context"\nreactdom.render(<storecontext.provider value={store}><app/></storecontext.provider>, document.getelementbyid(\'root\'))\n\n\n 4. 在想要使用store的组件中定义mapstatetoprops,mapdispatchtoprops。把需要的state和dispatch映射到想要使用store的组件的props中\n\nimport {purecomponent} from "react";\n\nimport connect from "./utils/connect";\n\nimport {jiaa_action} from "./store/actioncreators";\n\nconst mapstatetoprops = state => {\n    return {\n        counter: state.counter\n    }\n}\n\nconst mapdispatchtoprops = dispatch => {\n    return {\n        add: function () {\n            dispatch(jiaa_action(3))\n        }\n    }\n}\n\n\nconst app = class extends purecomponent {\n    componentdidmount() {\n        console.log(this.props)\n    }\n\n    render() {\n        return (\n            <div>\n                {this.props.counter}\n                <button onclick={() => {\n                    this.props.add()\n                }}>+3\n                </button>\n            </div>\n        );\n    }\n}\n\n\nconst enapp = connect(mapstatetoprops, mapdispatchtoprops)(app)\n\nexport default enapp\n\n\n虽然已经实现了connect、provider这些帮助我们完成连接redux、react的辅助工具，但是实际上redux官方提供了 react-redux 的库，可以直接在项目中使用，并且实现的逻辑会更加的严谨和高效\n\n 1. 安装：yarn add react-redux\n 2. 在index.js中将provider组件替换成react-redux中的provider组件\n\nimport {provider} from "react-redux";\n\nreactdom.render(<provider store={store}><app/></provider>, document.getelementbyid(\'root\'))\n\n\n 3. 组件中将connect替换成react-redux中connect\n\nimport {connect} from \'react-redux\'\n\n\n\n# redux中异步操作\n\n事实上，网络请求到的数据也属于我们状态管理的一部分，更好的一种方式应该是将其也交给redux来管理\n\n\n\n但是在redux中如何可以进行异步的操作呢？\n\n * 答案就是使用中间件（middleware）\n * 学习过express或koa框架的童鞋对中间件的概念一定不陌生\n * 在这类框架中，middleware可以帮助我们在请求和响应之间嵌入一些操作的代码，比如cookie解析、日志记录、文件压缩等操作\n\n\n# 理解中间件\n\nredux也引入了中间件（middleware）的概念：\n\n * 这个中间件的目的是在dispatch的action和最终达到的reducer之间，扩展一些自己的代码。比如日志记录、调用异步接口、添加代码调试功能等等\n\n * 我们现在要做的事情就是发送异步的网络请求，所以我们可以添加对应的中间件。官网推荐的、包括演示的网络请求的中间件是使用 redux-thunk\n\nredux-thunk是如何做到让我们可以发送异步的请求呢？\n\n * 我们知道，默认情况下的dispatch(action)，action需要是一个javascript的对象\n\n * redux-thunk可以让dispatch(action函数)，action可以是一个函数\n\n * 该函数会被调用，并且会传给这个函数一个dispatch函数和getstate函数：\n   \n   * dispatch函数用于我们之后再次派发action\n   * getstate函数考虑到我们之后的一些操作需要依赖原来的状态，用于让我们可以获取之前的一些状态\n\n\n# 使用redux-thunk\n\n 1. 安装redux-thunk:yarn add redux-thunk\n\n 2. 在创建store时传入应用了middleware的enhance函数\n    \n    * 通过applymiddleware来结合多个middleware, 返回一个enhancer\n    * 将enhancer作为第二个参数传入到createstore中\n\nimport thunkmiddleware from \'redux-thunk\'\nconst storeenhancer = applymiddleware(thunkmiddleware)\nconst store = createstore(reducer, storeenhancer)\n\n\n 3. 在actioncreators.js定义一个返回函数的action：\n\n * 注意：这里不是返回一个对象了，而是一个函数\n * 该函数在dispatch之后会被执行\n\nexport function getbannerdataaction() {\n    return (dispath) => {\n        {\n            console.log(\'react-thuck数据接受成功\')\n            axios.get(\'http://123.207.32.32:8000/home/multidata\').then(res => {\n                // console.log(res)\n                // console.log(res.data.data.banner.list)\n                dispath(banneraction(res.data.data.banner.list))\n            })\n        }\n    }\n} \n\n\n 4. 映射该action的dispatch操作,和相关的store中的state：\n\nconst mapstatetoprops = state => {\n    return {\n        banner: state.banner\n    }\n}\nconst mapdispatchtoprops = dispatch => {\n    return {\n        getbanner: function () {\n            dispatch(getbannerdataaction())\n        }\n    }\n}\n\n\n 5. 在componentdidmount调用，就可以拿到数据\n\n    componentdidmount() {\n\n        this.props.getbanner()\n\n        console.log(this.props.banner)\n    }\n}\n\n\n\n# redux-devtools\n\n利用这个工具，我们可以知道每次状态是如何被修改的，修改前后的状态变化等等\n\n 1. 在对应的浏览器中安装相关的插件（chrome浏览器扩展商店中搜索redux devtools即可\n 2. 对store的index.js进行改造\n\nimport {createstore, applymiddleware, compose} from "redux";\nimport reducer from \'./reducer\'\nimport thunkmiddleware from \'redux-thunk\'\n// 应用中间件\nconst storeenhancer = applymiddleware(thunkmiddleware)\n// 合并多个enhancer\nconst composeenhancers = window.__redux_devtools_extension_compose__(tra) || compose;\n// 官方不推荐createstore 需要使用redux工具包🔧\nconst store = createstore(reducer, composeenhancers(storeenhancer))\nexport default store\n\n\n对于基本的redux,只需要添加：\n\n const store = createstore(\n   reducer, /* preloadedstate, */\n+  window.__redux_devtools_extension__ && window.__redux_devtools_extension__()\n );\n\n\n\n# redux代码文件拆分\n\n随着项目的不断扩大，可能导致store结构越来越复杂，action越来越多。所有有必要对代码结构进行拆分\n\n代码结构如下：\n\n\n\n主目录reducer.js:\n\nimport {counterreducer} from "./counter";\nimport {bannerreducer} from "./banner";\n\nexport default function reducer(state = {}, action) {\n    return {\n        counterinfo: counterreducer(state.counterinfo, action),\n        bannerinfo: bannerreducer(state.bannerinfo, action)\n    }\n}\n\n\nbanner.js\n\nimport {get_banner_data} from "./constants";\n// banner默认数据\nconst defaultbannerstate = {\n    banner: []\n}\n// banner独有的reducer逻辑\nexport default function bannerreducer(state = defaultbannerstate, action) {\n    switch (action.type) {\n        case get_banner_data:\n            return {...state, banner: action.banner}\n        default:\n            return state;\n    }\n}\n\n\n\n# combinereducers函数\n\n目前我们合并的方式是通过每次调用reducer函数自己来返回一个新的对象\n\n事实上，redux给我们提供了一个combinereducers函数可以方便的让我们对多个reducer进行合并：\n\nimport {counterreducer} from "./counter";\nimport {bannerreducer} from "./banner";\nimport {combinereducers} from "redux";\n\nconst reducer = combinereducers({\n    counterinfo: counterreducer,\n    bannerinfo: bannerreducer\n})\n\nexport default reducer\n',charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"Vue2源码全方位深入解析",frontmatter:{title:"Vue2源码全方位深入解析",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue2%E6%BA%90%E7%A0%81%E5%85%A8%E6%96%B9%E4%BD%8D%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90.html",relativePath:"前端开发/前端框架/Vue/Vue2源码全方位深入解析.md",key:"v-3694fad4",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue2%E6%BA%90%E7%A0%81%E5%85%A8%E6%96%B9%E4%BD%8D%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90.html",headers:[{level:2,title:"认识 Flow",slug:"认识-flow",normalizedTitle:"认识 flow",charIndex:2},{level:3,title:"为什么用 Flow",slug:"为什么用-flow",normalizedTitle:"为什么用 flow",charIndex:104},{level:3,title:"Flow 的工作方式",slug:"flow-的工作方式",normalizedTitle:"flow 的工作方式",charIndex:522},{level:3,title:"Flow 在 Vue.js 源码中的应用",slug:"flow-在-vue-js-源码中的应用",normalizedTitle:"flow 在 vue.js 源码中的应用",charIndex:2243},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2870},{level:2,title:"Vue.js 源码目录设计",slug:"vue-js-源码目录设计",normalizedTitle:"vue.js 源码目录设计",charIndex:2982},{level:3,title:"compiler",slug:"compiler",normalizedTitle:"compiler",charIndex:2562},{level:3,title:"core",slug:"core",normalizedTitle:"core",charIndex:3063},{level:3,title:"platform",slug:"platform",normalizedTitle:"platform",charIndex:3090},{level:3,title:"server",slug:"server",normalizedTitle:"server",charIndex:3120},{level:3,title:"sfc",slug:"sfc",normalizedTitle:"sfc",charIndex:3148},{level:3,title:"shared",slug:"shared",normalizedTitle:"shared",charIndex:3180},{level:3,title:"总结",slug:"总结-2",normalizedTitle:"总结",charIndex:2870}],headersStr:"认识 Flow 为什么用 Flow Flow 的工作方式 Flow 在 Vue.js 源码中的应用 总结 Vue.js 源码目录设计 compiler core platform server sfc shared 总结",content:"# 认识 Flow\n\nFlow 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。\n\n\n# 为什么用 Flow\n\nJavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用是很容易就写出非常隐蔽的隐患代码，在编译期甚至看上去都不会报错，但在运行阶段就可能出现各种奇怪的 bug。\n\n类型检查是当前动态类型语言的发展趋势，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。\n\n项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。 Vue.js 在做 2.0 重构的时候，在 ES2015 的基础上，除了 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。之所以选择 Flow，主要是因为 Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力。\n\n\n# Flow 的工作方式\n\n通常类型检查分成 2 种方式：\n\n * 类型推断：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型。\n\n * 类型注释：事先注释好我们期待的类型，Flow 会基于这些注释来判断。\n\n# 类型推断\n\n它不需要任何代码修改即可进行类型检查，最小化开发者的工作量。它不会强制你改变开发习惯，因为它会自动推断出变量的类型。这就是所谓的类型推断，Flow 最重要的特性之一。\n\n通过一个简单例子说明一下：\n\n/*@flow*/\nfunction split(str) {\n    return str.split(' ')\n}\nsplit(11)\n\n\nFlow 检查上述代码后会报错，因为函数 split 期待的参数是字符串，而我们输入了数字。\n\n# 类型注释\n\n如上所述，类型推断是 Flow 最有用的特性之一，不需要编写类型注释就能获取有用的反馈。但在某些特定的场景下，添加类型注释可以提供更好更明确的检查依据。\n\n考虑如下代码：\n\n/*@flow*/\nfunction add(x, y) {\n    return x + y\n}\nadd('Hello', 11)\n\n\nFlow 检查上述代码时检查不出任何错误，因为从语法层面考虑， + 既可以用在字符串上，也可以用在数字上，我们并没有明确指出 add() 的参数必须为数字。\n\n在这种情况下，我们可以借助类型注释来指明期望的类型。类型注释是以冒号 : 开头，可以在函数参数，返回值，变量声明中使用。\n\n如果我们在上段代码中添加类型注释，就会变成如下：\n\n/*@flow*/\nfunction add(x: number, y: number): number {\n    return x + y\n}\nadd('Hello', 11)\n\n\n现在 Flow 就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。\n\n上面的例子是针对函数的类型注释。接下来我们来看看 Flow 能支持的一些常见的类型注释。\n\n# 数组\n\n/*@flow*/\nvar arr: Array<number> = [1, 2, 3]\narr.push('Hello')\n\n\n数组类型注释的格式是 Array<T>，T 表示数组中每项的数据类型。在上述代码中，arr 是每项均为数字的数组。如果我们给这个数组添加了一个字符串，Flow 能检查出错误。\n\n# 类和对象\n\n/*@flow*/\nclass Bar {\n    x: string // x 是字符串\n    y: string | number // y 可以是字符串或者数字\n    z: boolean\n    constructor(x: string, y: string | number) {\n        this.x = x\n        this.y = y\n        this.z = false\n    }\n}\nvar bar: Bar = new Bar('hello', 4)\nvar obj: { a: string, b: number, c: Array<string>, d: Bar } = {\n    a: 'hello',\n    b: 11,\n    c: ['hello', 'world'],\n    d: new Bar('hello', 3),\n}\n\n\n类的类型注释格式如上，可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。这里需要注意的是，属性 y 的类型中间用 | 做间隔，表示 y 的类型即可以是字符串也可以是数字。\n\n对象的注释类型类似于类，需要指定对象属性的类型。\n\n# Null\n\n若想任意类型 T 可以为 null 或者 undefined，只需类似如下写成 ?T 的格式即可。\n\n/*@flow*/\nvar foo: ?string = null\n\n\n此时，foo 可以为字符串，也可以为 null。 目前我们只列举了 Flow 的一些常见的类型注释。如果想了解所有类型注释，请移步 Flow 的官方文档。\n\n\n# Flow 在 Vue.js 源码中的应用\n\n有时候我们想引用第三方库，或者自定义一些类型，但 Flow 并不认识，因此检查的时候会报错。为了解决这类问题，Flow 提出了一个 libdef 的概念，可以用来识别这些第三方库或者是自定义类型，而 Vue.js 也利用了这一特性。 在 Vue.js 的主目录下有 .flowconfig 文件， 它是 Flow 的配置文件，感兴趣的同学可以看官方文档。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。 这里 [libs] 配置的是 flow，表示指定的库定义都在 flow 文件夹内。我们打开这个目录，会发现文件如下：\n\nflow\n├── compiler.js        # 编译相关\n├── component.js       # 组件数据结构\n├── global-api.js      # Global API 结构\n├── modules.js         # 第三方库定义\n├── options.js         # 选项相关\n├── ssr.js             # 服务端渲染相关\n├── vnode.js           # 虚拟 node 相关\n\n\n可以看到，Vue.js 有很多自定义类型的定义，在阅读源码的时候，如果遇到某个类型并想了解它完整的数据结构的时候，可以回来翻阅这些数据结构的定义。\n\n\n# 总结\n\n通过对 Flow 的认识，有助于我们阅读 Vue 的源码，并且这种静态类型检查的方式非常有利于大型项目源码的开发和维护。类似 Flow 的工具还有如 TypeScript，感兴趣的同学也可以自行去了解一下。\n\n\n# Vue.js 源码目录设计\n\nVue.js 的源码都在 src 目录下，其目录结构如下。\n\nsrc\n├── compiler        # 编译相关\n├── core            # 核心代码\n├── platforms       # 不同平台的支持\n├── server          # 服务端渲染\n├── sfc             # .vue 文件解析\n├── shared          # 共享代码\n\n\n\n# compiler\n\ncompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。\n\n编译的工作可以在构建时做（借助 webpack、vue-loader 等辅助插件）；也可以在运行时做，使用包含构建功能的 Vue.js。显然，编译是一项耗性能的工作，所以更推荐前者——离线编译。\n\n\n# core\n\ncore 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。\n\n这里的代码可谓是 Vue.js 的灵魂，也是我们之后需要重点分析的地方。\n\n\n# platform\n\nVue.js 是一个跨平台的 MVVM 框架，它可以跑在 web 上，也可以配合 weex 跑在 native 客户端上。platform 是 Vue.js 的入口，2 个目录代表 2 个主要入口，分别打包成运行在 web 上和 weex 上的 Vue.js。\n\n我们会重点分析 web 入口打包后的 Vue.js，对于 weex 入口打包的 Vue.js，感兴趣的同学可以自行研究。\n\n\n# server\n\nVue.js 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。注意：这部分代码是跑在服务端的 Node.js，不要和跑在浏览器端的 Vue.js 混为一谈。\n\n服务端渲染主要的工作是把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记\"混合\"为客户端上完全交互的应用程序。\n\n\n# sfc\n\n通常我们开发 Vue.js 都会借助 webpack 构建， 然后通过 .vue 单文件来编写组件。\n\n这个目录下的代码逻辑会把 .vue 文件内容解析成一个 JavaScript 的对象。\n\n\n# shared\n\nVue.js 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的 Vue.js 和服务端的 Vue.js 所共享的。\n\n\n# 总结\n\n从 Vue.js 的目录设计可以看到，作者把功能模块拆分的非常清楚，相关的逻辑放在一个独立的目录下维护，并且把复用的代码也抽成一个独立目录。\n\n这样的目录设计让代码的阅读性和可维护性都变强，是非常值得学习和推敲的。",normalizedContent:"# 认识 flow\n\nflow 是 facebook 出品的 javascript 静态类型检查工具。vue.js 的源码利用了 flow 做了静态类型检查，所以了解 flow 有助于我们阅读源码。\n\n\n# 为什么用 flow\n\njavascript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用是很容易就写出非常隐蔽的隐患代码，在编译期甚至看上去都不会报错，但在运行阶段就可能出现各种奇怪的 bug。\n\n类型检查是当前动态类型语言的发展趋势，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 javascript 具有和编写 java 等强类型语言相近的体验。\n\n项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。 vue.js 在做 2.0 重构的时候，在 es2015 的基础上，除了 eslint 保证代码风格之外，也引入了 flow 做静态类型检查。之所以选择 flow，主要是因为 babel 和 eslint 都有对应的 flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力。\n\n\n# flow 的工作方式\n\n通常类型检查分成 2 种方式：\n\n * 类型推断：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型。\n\n * 类型注释：事先注释好我们期待的类型，flow 会基于这些注释来判断。\n\n# 类型推断\n\n它不需要任何代码修改即可进行类型检查，最小化开发者的工作量。它不会强制你改变开发习惯，因为它会自动推断出变量的类型。这就是所谓的类型推断，flow 最重要的特性之一。\n\n通过一个简单例子说明一下：\n\n/*@flow*/\nfunction split(str) {\n    return str.split(' ')\n}\nsplit(11)\n\n\nflow 检查上述代码后会报错，因为函数 split 期待的参数是字符串，而我们输入了数字。\n\n# 类型注释\n\n如上所述，类型推断是 flow 最有用的特性之一，不需要编写类型注释就能获取有用的反馈。但在某些特定的场景下，添加类型注释可以提供更好更明确的检查依据。\n\n考虑如下代码：\n\n/*@flow*/\nfunction add(x, y) {\n    return x + y\n}\nadd('hello', 11)\n\n\nflow 检查上述代码时检查不出任何错误，因为从语法层面考虑， + 既可以用在字符串上，也可以用在数字上，我们并没有明确指出 add() 的参数必须为数字。\n\n在这种情况下，我们可以借助类型注释来指明期望的类型。类型注释是以冒号 : 开头，可以在函数参数，返回值，变量声明中使用。\n\n如果我们在上段代码中添加类型注释，就会变成如下：\n\n/*@flow*/\nfunction add(x: number, y: number): number {\n    return x + y\n}\nadd('hello', 11)\n\n\n现在 flow 就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。\n\n上面的例子是针对函数的类型注释。接下来我们来看看 flow 能支持的一些常见的类型注释。\n\n# 数组\n\n/*@flow*/\nvar arr: array<number> = [1, 2, 3]\narr.push('hello')\n\n\n数组类型注释的格式是 array<t>，t 表示数组中每项的数据类型。在上述代码中，arr 是每项均为数字的数组。如果我们给这个数组添加了一个字符串，flow 能检查出错误。\n\n# 类和对象\n\n/*@flow*/\nclass bar {\n    x: string // x 是字符串\n    y: string | number // y 可以是字符串或者数字\n    z: boolean\n    constructor(x: string, y: string | number) {\n        this.x = x\n        this.y = y\n        this.z = false\n    }\n}\nvar bar: bar = new bar('hello', 4)\nvar obj: { a: string, b: number, c: array<string>, d: bar } = {\n    a: 'hello',\n    b: 11,\n    c: ['hello', 'world'],\n    d: new bar('hello', 3),\n}\n\n\n类的类型注释格式如上，可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。这里需要注意的是，属性 y 的类型中间用 | 做间隔，表示 y 的类型即可以是字符串也可以是数字。\n\n对象的注释类型类似于类，需要指定对象属性的类型。\n\n# null\n\n若想任意类型 t 可以为 null 或者 undefined，只需类似如下写成 ?t 的格式即可。\n\n/*@flow*/\nvar foo: ?string = null\n\n\n此时，foo 可以为字符串，也可以为 null。 目前我们只列举了 flow 的一些常见的类型注释。如果想了解所有类型注释，请移步 flow 的官方文档。\n\n\n# flow 在 vue.js 源码中的应用\n\n有时候我们想引用第三方库，或者自定义一些类型，但 flow 并不认识，因此检查的时候会报错。为了解决这类问题，flow 提出了一个 libdef 的概念，可以用来识别这些第三方库或者是自定义类型，而 vue.js 也利用了这一特性。 在 vue.js 的主目录下有 .flowconfig 文件， 它是 flow 的配置文件，感兴趣的同学可以看官方文档。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。 这里 [libs] 配置的是 flow，表示指定的库定义都在 flow 文件夹内。我们打开这个目录，会发现文件如下：\n\nflow\n├── compiler.js        # 编译相关\n├── component.js       # 组件数据结构\n├── global-api.js      # global api 结构\n├── modules.js         # 第三方库定义\n├── options.js         # 选项相关\n├── ssr.js             # 服务端渲染相关\n├── vnode.js           # 虚拟 node 相关\n\n\n可以看到，vue.js 有很多自定义类型的定义，在阅读源码的时候，如果遇到某个类型并想了解它完整的数据结构的时候，可以回来翻阅这些数据结构的定义。\n\n\n# 总结\n\n通过对 flow 的认识，有助于我们阅读 vue 的源码，并且这种静态类型检查的方式非常有利于大型项目源码的开发和维护。类似 flow 的工具还有如 typescript，感兴趣的同学也可以自行去了解一下。\n\n\n# vue.js 源码目录设计\n\nvue.js 的源码都在 src 目录下，其目录结构如下。\n\nsrc\n├── compiler        # 编译相关\n├── core            # 核心代码\n├── platforms       # 不同平台的支持\n├── server          # 服务端渲染\n├── sfc             # .vue 文件解析\n├── shared          # 共享代码\n\n\n\n# compiler\n\ncompiler 目录包含 vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。\n\n编译的工作可以在构建时做（借助 webpack、vue-loader 等辅助插件）；也可以在运行时做，使用包含构建功能的 vue.js。显然，编译是一项耗性能的工作，所以更推荐前者——离线编译。\n\n\n# core\n\ncore 目录包含了 vue.js 的核心代码，包括内置组件、全局 api 封装，vue 实例化、观察者、虚拟 dom、工具函数等等。\n\n这里的代码可谓是 vue.js 的灵魂，也是我们之后需要重点分析的地方。\n\n\n# platform\n\nvue.js 是一个跨平台的 mvvm 框架，它可以跑在 web 上，也可以配合 weex 跑在 native 客户端上。platform 是 vue.js 的入口，2 个目录代表 2 个主要入口，分别打包成运行在 web 上和 weex 上的 vue.js。\n\n我们会重点分析 web 入口打包后的 vue.js，对于 weex 入口打包的 vue.js，感兴趣的同学可以自行研究。\n\n\n# server\n\nvue.js 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。注意：这部分代码是跑在服务端的 node.js，不要和跑在浏览器端的 vue.js 混为一谈。\n\n服务端渲染主要的工作是把组件渲染为服务器端的 html 字符串，将它们直接发送到浏览器，最后将静态标记\"混合\"为客户端上完全交互的应用程序。\n\n\n# sfc\n\n通常我们开发 vue.js 都会借助 webpack 构建， 然后通过 .vue 单文件来编写组件。\n\n这个目录下的代码逻辑会把 .vue 文件内容解析成一个 javascript 的对象。\n\n\n# shared\n\nvue.js 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的 vue.js 和服务端的 vue.js 所共享的。\n\n\n# 总结\n\n从 vue.js 的目录设计可以看到，作者把功能模块拆分的非常清楚，相关的逻辑放在一个独立的目录下维护，并且把复用的代码也抽成一个独立目录。\n\n这样的目录设计让代码的阅读性和可维护性都变强，是非常值得学习和推敲的。",charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"Vue3",frontmatter:{title:"Vue3",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue3.html",relativePath:"前端开发/前端框架/Vue/Vue3.md",key:"v-fe61dbea",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue3.html",headers:[{level:2,title:"创建 Vue3.0 工程",slug:"创建-vue3-0-工程",normalizedTitle:"创建 vue3.0 工程",charIndex:35},{level:3,title:"使用 vue-cli 创建",slug:"使用-vue-cli-创建",normalizedTitle:"使用 vue-cli 创建",charIndex:52},{level:3,title:"使用 vite 创建",slug:"使用-vite-创建",normalizedTitle:"使用 vite 创建",charIndex:231},{level:3,title:"分析工程结构",slug:"分析工程结构",normalizedTitle:"分析工程结构",charIndex:491},{level:2,title:"常用 Composition API",slug:"常用-composition-api",normalizedTitle:"常用 composition api",charIndex:721},{level:3,title:"拉开序幕的 setup",slug:"拉开序幕的-setup",normalizedTitle:"拉开序幕的 setup",charIndex:761},{level:3,title:"ref 函数",slug:"ref-函数",normalizedTitle:"ref 函数",charIndex:1122},{level:3,title:"reactive 函数",slug:"reactive-函数",normalizedTitle:"reactive 函数",charIndex:1463},{level:2,title:"Vue3.0 中的响应式原理",slug:"vue3-0-中的响应式原理",normalizedTitle:"vue3.0 中的响应式原理",charIndex:1692},{level:3,title:"vue2.x 的响应式",slug:"vue2-x-的响应式",normalizedTitle:"vue2.x 的响应式",charIndex:1711},{level:3,title:"Vue3.0 的响应式",slug:"vue3-0-的响应式",normalizedTitle:"vue3.0 的响应式",charIndex:2015},{level:2,title:"reactive 对比 ref",slug:"reactive-对比-ref",normalizedTitle:"reactive 对比 ref",charIndex:2409},{level:2,title:"setup 的两个注意点",slug:"setup-的两个注意点",normalizedTitle:"setup 的两个注意点",charIndex:2786},{level:2,title:"计算属性与监视",slug:"计算属性与监视",normalizedTitle:"计算属性与监视",charIndex:3316},{level:3,title:"computed 函数",slug:"computed-函数",normalizedTitle:"computed 函数",charIndex:3328},{level:3,title:"watch 函数",slug:"watch-函数",normalizedTitle:"watch 函数",charIndex:3904},{level:3,title:"watchEffect 函数",slug:"watcheffect-函数",normalizedTitle:"watcheffect 函数",charIndex:5178},{level:2,title:"生命周期",slug:"生命周期",normalizedTitle:"生命周期",charIndex:5598},{level:3,title:"Vue2 生命周期",slug:"vue2-生命周期",normalizedTitle:"vue2 生命周期",charIndex:5607},{level:3,title:"Vue3 生命周期",slug:"vue3-生命周期",normalizedTitle:"vue3 生命周期",charIndex:5623},{level:2,title:"自定义 hook 函数",slug:"自定义-hook-函数",normalizedTitle:"自定义 hook 函数",charIndex:6069},{level:2,title:"toRef",slug:"toref",normalizedTitle:"toref",charIndex:6358},{level:2,title:"其它 Composition API",slug:"其它-composition-api",normalizedTitle:"其它 composition api",charIndex:6564},{level:3,title:"shallowReactive 与 shallowRef",slug:"shallowreactive-与-shallowref",normalizedTitle:"shallowreactive 与 shallowref",charIndex:6587},{level:3,title:"readonly 与 shallowReadonly",slug:"readonly-与-shallowreadonly",normalizedTitle:"readonly 与 shallowreadonly",charIndex:6838},{level:3,title:"toRaw 与 markRaw",slug:"toraw-与-markraw",normalizedTitle:"toraw 与 markraw",charIndex:6962},{level:3,title:"customRef",slug:"customref",normalizedTitle:"customref",charIndex:7208},{level:3,title:"provide 与 inject",slug:"provide-与-inject",normalizedTitle:"provide 与 inject",charIndex:8143},{level:3,title:"响应式数据的判断",slug:"响应式数据的判断",normalizedTitle:"响应式数据的判断",charIndex:8590},{level:2,title:"Composition API 的优势",slug:"composition-api-的优势",normalizedTitle:"composition api 的优势",charIndex:8771},{level:3,title:"Options API 存在的问题",slug:"options-api-存在的问题",normalizedTitle:"options api 存在的问题",charIndex:8795},{level:3,title:"Composition API 的优势",slug:"composition-api-的优势-2",normalizedTitle:"composition api 的优势",charIndex:8771},{level:2,title:"新的组件",slug:"新的组件",normalizedTitle:"新的组件",charIndex:8955},{level:3,title:"Fragment",slug:"fragment",normalizedTitle:"fragment",charIndex:8964},{level:3,title:"Teleport",slug:"teleport",normalizedTitle:"teleport",charIndex:9077},{level:3,title:"Suspense",slug:"suspense",normalizedTitle:"suspense",charIndex:9357},{level:2,title:"Vue3 中其他的改变",slug:"vue3-中其他的改变",normalizedTitle:"vue3 中其他的改变",charIndex:10012},{level:3,title:"全局 API 的转移",slug:"全局-api-的转移",normalizedTitle:"全局 api 的转移",charIndex:10028},{level:3,title:"其他改变",slug:"其他改变",normalizedTitle:"其他改变",charIndex:10787},{level:2,title:"挂载全局变量",slug:"挂载全局变量",normalizedTitle:"挂载全局变量",charIndex:11656}],headersStr:"创建 Vue3.0 工程 使用 vue-cli 创建 使用 vite 创建 分析工程结构 常用 Composition API 拉开序幕的 setup ref 函数 reactive 函数 Vue3.0 中的响应式原理 vue2.x 的响应式 Vue3.0 的响应式 reactive 对比 ref setup 的两个注意点 计算属性与监视 computed 函数 watch 函数 watchEffect 函数 生命周期 Vue2 生命周期 Vue3 生命周期 自定义 hook 函数 toRef 其它 Composition API shallowReactive 与 shallowRef readonly 与 shallowReadonly toRaw 与 markRaw customRef provide 与 inject 响应式数据的判断 Composition API 的优势 Options API 存在的问题 Composition API 的优势 新的组件 Fragment Teleport Suspense Vue3 中其他的改变 全局 API 的转移 其他改变 挂载全局变量",content:"注意\n\nvue3 向下兼容 vue2\n\n从 Vue 2 迁移\n\n\n# 创建 Vue3.0 工程\n\n\n# 使用 vue-cli 创建\n\n官方文档\n\n## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上\nvue --version\n## 安装或者升级你的@vue/cli\nnpm install -g @vue/cli\n## 创建\nvue create vue_test\n## 启动\ncd vue_test\nnpm run serve\n\n\n\n# 使用 vite 创建\n\n警告\n\n在 vite 项目中，引入组件时，.vue 不能省略 import xxx from './xxx.vue'\n\nvite 官网\n\n * 什么是 vite？—— 新一代前端构建工具。\n * 优势如下：\n   * 开发环境中，无需打包操作，可快速的冷启动\n   * 轻量快速的热重载\n   * 真正的按需编译，不再等待整个应用编译完成\n\n## 创建vue项目\nnpm create vite@latest my-vue-app -- --template vue\n## 按提示操作\n\n\n\n# 分析工程结构\n\n// main.js\n//引入的不再是Vue构造函数了，引入的是一个名为createApp的工厂函数\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\n//创建应用实例对象——app(类似于之前Vue2中的vm(new Vue())，但app比vm更“轻”)\nconst app = createApp(App)\n\n//挂载\napp.mount('#app')\n\n\n\n# 常用 Composition API\n\nComposition API\n\n\n# 拉开序幕的 setup\n\nVue3.2 新特性：单文件组件 script setup\n\n 1. Vue3.0 中一个新的配置项，值为一个函数\n 2. setup 是所有Composition API（组合 API）“ 表演的舞台 ”\n 3. 组件中所用到的：数据、方法等等，均要配置在 setup 中\n 4. setup 函数返回的对象中的属性、方法, 在模板中均可以直接使用\n 5. 注意,尽量不要与 Vue2.x 配置混用\n    * Vue2.x 配置（data、methods、computed...）中可以访问到setup 中的属性、方法。\n    * 但在 setup 中不能访问到Vue2.x 配置（data、methods、computed...）。\n    * 如果有重名, setup 优先。\n\n\n# ref 函数\n\n * 作用: 定义一个响应式的数据\n * 语法: import {ref} from 'vue' const xxx = ref(initValue)\n * 创建一个包含响应式数据的引用对象\n * JS 中操作数据： xxx.value\n * 模板中读取数据: 不需要.value，直接xxx使用\n * 备注：\n   * 接收的数据可以是：基本类型、也可以是对象类型\n   * 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的\n   * 对象类型的数据：内部 “ 求助 ” 了 Vue3.0 中的一个新函数—— reactive函数，模板中读取：obj.xxx,JS 中读取数据:obj.value.xxx\n\n\n# reactive 函数\n\n * 作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数）\n * 语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy 的实例对象，简称 proxy 对象）\n * reactive 定义的响应式数据是“深层次的”\n * 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作\n * 操作数据与读取数据：均不需要.value\n\n\n# Vue3.0 中的响应式原理\n\n\n# vue2.x 的响应式\n\n * 实现原理：\n   \n   * 对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。\n   \n   * 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。\n     \n     Object.defineProperty(data, 'count', {\n         get() {},\n         set() {},\n     })\n     \n\n * 存在问题：\n   \n   * 新增属性、删除属性, 界面不会更新。\n   * 直接通过下标修改数组, 界面不会自动更新。\n\n\n# Vue3.0 的响应式\n\n * 实现原理:\n   \n   * 通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。\n   \n   * 通过Reflect（反射）: 对源对象的属性进行操作。\n\n * MDN 文档中描述的 Proxy 与 Reflect： Proxy Reflect\n\n理解\n\nObject.defineProperty()如果追加属性重名出错会导致程序终止，那么就需要大量的 try...catch 捕获错误，这对框架的封装就是灾难，而 Reflect 可以拦截 JavaScript 操作的方法，通过返回一个布尔值，说明操作是否成功，失败了也不影响其他代码的执行，也就是返回一个 false,我们可以通过条件语句，失败了抛出错误，成功了执行某些逻辑，而其他代码不受影响，这就是 Vue3 采用Reflect的原因\n\n\n# reactive 对比 ref\n\n * 从定义数据角度对比：\n   * ref 用来定义：基本类型数据。\n   * reactive 用来定义：对象（或数组）类型数据。\n   * 备注：ref 也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。\n * 从原理角度对比：\n   * ref 通过Object.defineProperty()的get与set来实现响应式（数据劫持）。\n   * reactive 通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。\n * 从使用角度对比：\n   * ref 定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。\n   * reactive 定义的数据：操作数据与读取数据：均不需要.value。\n\n\n# setup 的两个注意点\n\n * setup 执行的时机\n   \n   * 在 beforeCreate 之前执行一次，this 是 undefined。\n\n * setup 的参数\n   \n   * props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\n   * context：上下文对象\n     * attrs: 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 this.$attrs。\n     * slots: 收到的插槽内容, 相当于 this.$slots，vue3 尽量使用v-slot:xxx,slot=xxx存在兼容问题\n     * emit: 分发自定义事件的函数, 相当于 this.$emit。\n\nVue2.0 中的`vm.$attrs`\n\n包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=\"$attrs\" 传入内部组件——在创建高级别的组件时非常有用。\n\n\n# 计算属性与监视\n\n\n# computed 函数\n\n * 与 Vue2.x 中 computed 配置功能一致\n\n * 写法\n   \n   import {computed} from 'vue'\n   \n   setup(){\n       ...\n   \t//计算属性——简写\n       let fullName = computed(()=>{\n           return person.firstName + '-' + person.lastName\n       })\n       //计算属性——完整\n       let fullName = computed({\n           get(){\n               return person.firstName + '-' + person.lastName\n           },\n           set(value){\n               const nameArr = value.split('-')\n               person.firstName = nameArr[0]\n               person.lastName = nameArr[1]\n           }\n       })\n   }\n   \n\n\n# watch 函数\n\n * 与 Vue2.x 中 watch 配置功能一致\n\n * 两个小“坑”：\n   \n   * 监视 reactive 定义的响应式数据时：oldValue 无法正确获取、强制开启了深度监视（deep 配置失效）。\n   * 监视 reactive 定义的响应式数据中某个属性时：deep 配置有效。\n   \n   import { watch } from 'vue'\n     setup(){\n   //情况一：监视ref定义的响应式数据\n   watch(sum,(newValue,oldValue)=>{\n   \tconsole.log('sum变化了',newValue,oldValue)\n   },{immediate:true})\n   \n   //情况二：监视多个ref定义的响应式数据\n   watch([sum,msg],(newValue,oldValue)=>{\n   \tconsole.log('sum或msg变化了',newValue,oldValue)\n   })\n   \n   /* 情况三：监视reactive定义的响应式数据\n   \t\t\t若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！\n   \t\t\t若watch监视的是reactive定义的响应式数据，则强制开启了深度监视\n   */\n   watch(person,(newValue,oldValue)=>{\n   \tconsole.log('person变化了',newValue,oldValue)\n   },{immediate:true,deep:false}) //此处的deep配置不再奏效\n   \n   //情况四：监视reactive定义的响应式数据中的某个属性\n   watch(()=>person.job,(newValue,oldValue)=>{\n   \tconsole.log('person的job变化了',newValue,oldValue)\n   },{immediate:true,deep:true})\n   \n   //情况五：监视reactive定义的响应式数据中的某些属性\n   watch([()=>person.job,()=>person.name],(newValue,oldValue)=>{\n   \tconsole.log('person的job变化了',newValue,oldValue)\n   },{immediate:true,deep:true})\n   \n   //特殊情况\n   watch(()=>person.job,(newValue,oldValue)=>{\n       console.log('person的job变化了',newValue,oldValue)\n   },{deep:true}) //此处由于监视的是reactive定义的对象中的某个属性，所以deep配置有效\n   }\n   \n\n\n# watchEffect 函数\n\n * watch 的套路是：既要指明监视的属性，也要指明监视的回调。\n\n * watchEffect 的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n\n * watchEffect 有点像 computed：\n   \n   * 但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n   * 而 watchEffect 更注重的是过程（回调函数的函数体），所以不用写返回值。\n   \n   //watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。\n   watchEffect(() => {\n       const x1 = sum.value\n       const x2 = person.age\n       console.log('watchEffect配置的回调执行了')\n   })\n   \n\n\n# 生命周期\n\n\n# Vue2 生命周期\n\n\n\n\n# Vue3 生命周期\n\n\n\n * Vue3.0 中可以继续使用 Vue2.x 中的生命周期钩子，但有有两个被更名：\n   * beforeDestroy改名为 beforeUnmount\n   * destroyed改名为 unmounted\n * Vue3.0 也提供了 Composition API 形式的生命周期钩子，与 Vue2.x 中钩子对应关系如下：\n   * beforeCreate===>setup()\n   * created=======>setup()\n   * beforeMount ===>onBeforeMount\n   * mounted=======>onMounted\n   * beforeUpdate===>onBeforeUpdate\n   * updated =======>onUpdated\n   * beforeUnmount ==>onBeforeUnmount\n   * unmounted =====>onUnmounted\n\n\n# 自定义 hook 函数\n\n * 什么是 hook？—— 本质是一个函数，把 setup 函数中使用的 Composition API 进行了封装。\n\n * 类似于 vue2.x 中的 mixin。\n\n * 自定义 hook 的优势: 复用代码, 让 setup 中的逻辑更清楚易懂。\n\n// 外部\n// import xxx from 'xxx'\n// 内部\nfunction xxx (){\n  // ....\n\n  return { yyy,zzz }\n}\nsetup(){\n  let {yyy,zzz} =xxx()\n  return {yyy,zzz}\n}\n\n\n\n# toRef\n\n * 作用：创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。\n\n * 语法：const name = toRef(person,'name')\n\n * 应用: 要将响应式对象中的某个属性单独提供给外部使用时。\n\n * 扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：const { name,age }=toRefs(person)\n\n\n# 其它 Composition API\n\n\n# shallowReactive 与 shallowRef\n\n * shallowReactive：只处理对象最外层属性的响应式（浅响应式）。\n\n * shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。\n\n * 什么时候使用?\n   \n   * 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===> shallowReactive。\n   * 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换 ===> shallowRef。\n\n\n# readonly 与 shallowReadonly\n\n * readonly: 让一个响应式数据变为只读的（深只读）。\n * shallowReadonly：让一个响应式数据变为只读的（浅只读）。\n * 应用场景: 不希望数据被修改时。\n\n\n# toRaw 与 markRaw\n\n * toRaw：\n   * 作用：将一个由reactive生成的响应式对象转为普通对象。\n   * 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。\n * markRaw：\n   * 作用：标记一个对象，使其永远不会再成为响应式对象。\n   * 应用场景:\n     1. 有些值不应被设置为响应式的，例如复杂的第三方类库等。\n     2. 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\n\n# customRef\n\n * 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。\n   \n   提示\n   \n   节流第一次有效，防抖反之\n\n * 实现防抖效果：\n   \n   <template>\n   \t<input type=\"text\" v-model=\"keyword\">\n   \t<h3>{{keyword}}</h3>\n   </template>\n   <script>\n   \timport {ref,customRef} from 'vue'\n   \texport default {\n   \t\tname:'Demo',\n   \t\tsetup(){\n   \t\t\t// let keyword = ref('hello') //使用Vue准备好的内置ref\n   \t\t\t//自定义一个myRef\n   \t\t\tfunction myRef(value,delay){\n   \t\t\t\tlet timer\n   \t\t\t\t//通过customRef去实现自定义\n   \t\t\t\treturn customRef((track,trigger)=>{\n   \t\t\t\t\treturn{\n   \t\t\t\t\t\tget(){\n   \t\t\t\t\t\t\ttrack() //告诉Vue这个value值是需要被“追踪”的\n   \t\t\t\t\t\t\treturn value\n   \t\t\t\t\t\t},\n   \t\t\t\t\t\tset(newValue){\n   \t\t\t\t\t\t\tclearTimeout(timer)\n   \t\t\t\t\t\t\ttimer = setTimeout(()=>{\n   \t\t\t\t\t\t\t\tvalue = newValue\n   \t\t\t\t\t\t\t\ttrigger() //告诉Vue去更新界面\n   \t\t\t\t\t\t\t},delay)\n   \t\t\t\t\t\t}\n   \t\t\t\t\t}\n   \t\t\t\t})\n   \t\t\t}\n   \t\t\tlet keyword = myRef('hello',500) //使用程序员自定义的ref\n   \t\t\treturn {\n   \t\t\t\tkeyword\n   \t\t\t}\n   \t\t}\n   \t}\n   <\/script>\n   \n\n\n# provide 与 inject\n\n * 作用：实现祖与后代组件间通信\n\n * 套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\n\n * 具体写法：\n   \n   1. 祖组件中：\n\nimport { provide } from 'vue'\n     setup(){\n     \t......\n         let car = reactive({name:'奔驰',price:'40万'})\n         provide('car',car)\n         ......\n     }\n\n\n 2. 后代组件中：\n\nimport { inject } from 'vue'\n\n     setup(props,context){\n     \t......\n         const car = inject('car')\n         return {car}\n     \t......\n     }\n\n\n\n# 响应式数据的判断\n\n * isRef: 检查一个值是否为一个 ref 对象\n * isReactive: 检查一个对象是否是由 reactive 创建的响应式代理\n * isReadonly: 检查一个对象是否是由 readonly 创建的只读代理\n * isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\n\n\n# Composition API 的优势\n\n\n# Options API 存在的问题\n\n使用传统 OptionsAPI 中，新增或者修改一个需求，就需要分别在 data，methods，computed 里修改 。\n\n\n\n\n\n\n# Composition API 的优势\n\n我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。\n\n\n\n\n\n\n# 新的组件\n\n\n# Fragment\n\n * 在 Vue2 中: 组件必须有一个根标签\n * 在 Vue3 中: 组件可以没有根标签, 内部会将多个标签包含在一个 Fragment 虚拟元素中\n * 好处: 减少标签层级, 减小内存占用\n\n\n# Teleport\n\n * 什么是 Teleport？—— Teleport 是一种能够将我们的组件 html 结构移动到指定位置的技术。\n   \n   <teleport to=\"移动位置\">\n   \t<div v-if=\"isShow\" class=\"mask\">\n   \t\t<div class=\"dialog\">\n   \t\t\t<h3>我是一个弹窗</h3>\n   \t\t\t<button @click=\"isShow = false\">关闭弹窗</button>\n   \t\t</div>\n   \t</div>\n   </teleport>\n   \n\n\n# Suspense\n\n * 等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n\n * 使用步骤：\n   \n   * 异步引入组件\n     \n     import { defineAsyncComponent } from 'vue'\n     const Child = defineAsyncComponent(() =>\n         import('./components/Child.vue')\n     )\n     \n   \n   * 使用Suspense包裹组件，并配置好default 与 fallback\n     \n     <template>\n         <div class=\"app\">\n             <h3>我是App组件</h3>\n             <Suspense>\n                 <template v-slot:default>\n                     <Child />\n                 </template>\n                 <template v-slot:fallback>\n                     <h3>加载中.....</h3>\n                 </template>\n             </Suspense>\n         </div>\n     </template>\n     \n\n\n# Vue3 中其他的改变\n\n\n# 全局 API 的转移\n\n * Vue 2.x 有许多全局 API 和配置。\n   \n   * 例如：注册全局组件、注册全局指令等。\n     \n     //注册全局组件\n     Vue.component('MyButton', {\n       data: () => ({\n         count: 0\n       }),\n       template: '<button @click=\"count++\">Clicked {{ count }} times.</button>'\n     })\n     \n     //注册全局指令\n     Vue.directive('focus', {\n       inserted: el => el.focus()\n     }\n     \n\n * Vue3.0 中对这些 API 做出了调整：\n   \n   * 将全局的 API，即：Vue.xxx调整到应用实例（app）上\n\n2.X 全局 API（VUE）            3.X 实例 API (APP)\nVue.config.xxxx            app.config.xxxx\nVue.config.productionTip   移除\nVue.component              app.component\nVue.directive              app.directive\nVue.mixin                  app.mixin\nVue.use                    app.use\nVue.prototype              app.config.globalProperties\n\n:::\n\n\n# 其他改变\n\n * data 选项应始终被声明为一个函数\n\n * 过度类名的更改：\n   \n   * Vue2.x 写法\n     \n     .v-enter,\n     .v-leave-to {\n         opacity: 0;\n     }\n     .v-leave,\n     .v-enter-to {\n         opacity: 1;\n     }\n     \n   \n   * Vue3.x 写法\n     \n     .v-enter-from,\n     .v-leave-to {\n         opacity: 0;\n     }\n     \n     .v-leave-from,\n     .v-enter-to {\n         opacity: 1;\n     }\n     \n\n * 移除keyCode 作为 v-on 的修饰符，同时也不再支持config.keyCodes(按键别名，依赖 keyCode，兼容性差)\n\n * 移除v-on.native修饰符\n   \n   * 父组件中绑定事件\n     \n     <my-component\n         v-on:close=\"handleComponentEvent\"\n         v-on:click=\"handleNativeClickEvent\"\n     />\n     \n   \n   * 子组件中声明自定义事件\n     \n     <script>\n       export default {\n         emits: ['close']\n       }\n     <\/script>\n     \n\n * 移除过滤器（filter）\n   \n   注意\n   \n   过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。\n\n * ......\n\n\n# 挂载全局变量\n\n在vue3的setup中使用getCurrentInstanceAPI获取全局对象,通过getCurrentInstance方法获取上下文，这里的proxy就相当于this\n\napp.config.globalProperties.xxx=xxx  // main.js\n\n\nimport {getCurrentInstance} from 'vue'\nconst {proxy}=getCurrentInstance()\n",normalizedContent:"注意\n\nvue3 向下兼容 vue2\n\n从 vue 2 迁移\n\n\n# 创建 vue3.0 工程\n\n\n# 使用 vue-cli 创建\n\n官方文档\n\n## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上\nvue --version\n## 安装或者升级你的@vue/cli\nnpm install -g @vue/cli\n## 创建\nvue create vue_test\n## 启动\ncd vue_test\nnpm run serve\n\n\n\n# 使用 vite 创建\n\n警告\n\n在 vite 项目中，引入组件时，.vue 不能省略 import xxx from './xxx.vue'\n\nvite 官网\n\n * 什么是 vite？—— 新一代前端构建工具。\n * 优势如下：\n   * 开发环境中，无需打包操作，可快速的冷启动\n   * 轻量快速的热重载\n   * 真正的按需编译，不再等待整个应用编译完成\n\n## 创建vue项目\nnpm create vite@latest my-vue-app -- --template vue\n## 按提示操作\n\n\n\n# 分析工程结构\n\n// main.js\n//引入的不再是vue构造函数了，引入的是一个名为createapp的工厂函数\nimport { createapp } from 'vue'\nimport app from './app.vue'\n\n//创建应用实例对象——app(类似于之前vue2中的vm(new vue())，但app比vm更“轻”)\nconst app = createapp(app)\n\n//挂载\napp.mount('#app')\n\n\n\n# 常用 composition api\n\ncomposition api\n\n\n# 拉开序幕的 setup\n\nvue3.2 新特性：单文件组件 script setup\n\n 1. vue3.0 中一个新的配置项，值为一个函数\n 2. setup 是所有composition api（组合 api）“ 表演的舞台 ”\n 3. 组件中所用到的：数据、方法等等，均要配置在 setup 中\n 4. setup 函数返回的对象中的属性、方法, 在模板中均可以直接使用\n 5. 注意,尽量不要与 vue2.x 配置混用\n    * vue2.x 配置（data、methods、computed...）中可以访问到setup 中的属性、方法。\n    * 但在 setup 中不能访问到vue2.x 配置（data、methods、computed...）。\n    * 如果有重名, setup 优先。\n\n\n# ref 函数\n\n * 作用: 定义一个响应式的数据\n * 语法: import {ref} from 'vue' const xxx = ref(initvalue)\n * 创建一个包含响应式数据的引用对象\n * js 中操作数据： xxx.value\n * 模板中读取数据: 不需要.value，直接xxx使用\n * 备注：\n   * 接收的数据可以是：基本类型、也可以是对象类型\n   * 基本类型的数据：响应式依然是靠object.defineproperty()的get与set完成的\n   * 对象类型的数据：内部 “ 求助 ” 了 vue3.0 中的一个新函数—— reactive函数，模板中读取：obj.xxx,js 中读取数据:obj.value.xxx\n\n\n# reactive 函数\n\n * 作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数）\n * 语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（proxy 的实例对象，简称 proxy 对象）\n * reactive 定义的响应式数据是“深层次的”\n * 内部基于 es6 的 proxy 实现，通过代理对象操作源对象内部数据进行操作\n * 操作数据与读取数据：均不需要.value\n\n\n# vue3.0 中的响应式原理\n\n\n# vue2.x 的响应式\n\n * 实现原理：\n   \n   * 对象类型：通过object.defineproperty()对属性的读取、修改进行拦截（数据劫持）。\n   \n   * 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。\n     \n     object.defineproperty(data, 'count', {\n         get() {},\n         set() {},\n     })\n     \n\n * 存在问题：\n   \n   * 新增属性、删除属性, 界面不会更新。\n   * 直接通过下标修改数组, 界面不会自动更新。\n\n\n# vue3.0 的响应式\n\n * 实现原理:\n   \n   * 通过proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。\n   \n   * 通过reflect（反射）: 对源对象的属性进行操作。\n\n * mdn 文档中描述的 proxy 与 reflect： proxy reflect\n\n理解\n\nobject.defineproperty()如果追加属性重名出错会导致程序终止，那么就需要大量的 try...catch 捕获错误，这对框架的封装就是灾难，而 reflect 可以拦截 javascript 操作的方法，通过返回一个布尔值，说明操作是否成功，失败了也不影响其他代码的执行，也就是返回一个 false,我们可以通过条件语句，失败了抛出错误，成功了执行某些逻辑，而其他代码不受影响，这就是 vue3 采用reflect的原因\n\n\n# reactive 对比 ref\n\n * 从定义数据角度对比：\n   * ref 用来定义：基本类型数据。\n   * reactive 用来定义：对象（或数组）类型数据。\n   * 备注：ref 也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。\n * 从原理角度对比：\n   * ref 通过object.defineproperty()的get与set来实现响应式（数据劫持）。\n   * reactive 通过使用proxy来实现响应式（数据劫持）, 并通过reflect操作源对象内部的数据。\n * 从使用角度对比：\n   * ref 定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。\n   * reactive 定义的数据：操作数据与读取数据：均不需要.value。\n\n\n# setup 的两个注意点\n\n * setup 执行的时机\n   \n   * 在 beforecreate 之前执行一次，this 是 undefined。\n\n * setup 的参数\n   \n   * props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\n   * context：上下文对象\n     * attrs: 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 this.$attrs。\n     * slots: 收到的插槽内容, 相当于 this.$slots，vue3 尽量使用v-slot:xxx,slot=xxx存在兼容问题\n     * emit: 分发自定义事件的函数, 相当于 this.$emit。\n\nvue2.0 中的`vm.$attrs`\n\n包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=\"$attrs\" 传入内部组件——在创建高级别的组件时非常有用。\n\n\n# 计算属性与监视\n\n\n# computed 函数\n\n * 与 vue2.x 中 computed 配置功能一致\n\n * 写法\n   \n   import {computed} from 'vue'\n   \n   setup(){\n       ...\n   \t//计算属性——简写\n       let fullname = computed(()=>{\n           return person.firstname + '-' + person.lastname\n       })\n       //计算属性——完整\n       let fullname = computed({\n           get(){\n               return person.firstname + '-' + person.lastname\n           },\n           set(value){\n               const namearr = value.split('-')\n               person.firstname = namearr[0]\n               person.lastname = namearr[1]\n           }\n       })\n   }\n   \n\n\n# watch 函数\n\n * 与 vue2.x 中 watch 配置功能一致\n\n * 两个小“坑”：\n   \n   * 监视 reactive 定义的响应式数据时：oldvalue 无法正确获取、强制开启了深度监视（deep 配置失效）。\n   * 监视 reactive 定义的响应式数据中某个属性时：deep 配置有效。\n   \n   import { watch } from 'vue'\n     setup(){\n   //情况一：监视ref定义的响应式数据\n   watch(sum,(newvalue,oldvalue)=>{\n   \tconsole.log('sum变化了',newvalue,oldvalue)\n   },{immediate:true})\n   \n   //情况二：监视多个ref定义的响应式数据\n   watch([sum,msg],(newvalue,oldvalue)=>{\n   \tconsole.log('sum或msg变化了',newvalue,oldvalue)\n   })\n   \n   /* 情况三：监视reactive定义的响应式数据\n   \t\t\t若watch监视的是reactive定义的响应式数据，则无法正确获得oldvalue！！\n   \t\t\t若watch监视的是reactive定义的响应式数据，则强制开启了深度监视\n   */\n   watch(person,(newvalue,oldvalue)=>{\n   \tconsole.log('person变化了',newvalue,oldvalue)\n   },{immediate:true,deep:false}) //此处的deep配置不再奏效\n   \n   //情况四：监视reactive定义的响应式数据中的某个属性\n   watch(()=>person.job,(newvalue,oldvalue)=>{\n   \tconsole.log('person的job变化了',newvalue,oldvalue)\n   },{immediate:true,deep:true})\n   \n   //情况五：监视reactive定义的响应式数据中的某些属性\n   watch([()=>person.job,()=>person.name],(newvalue,oldvalue)=>{\n   \tconsole.log('person的job变化了',newvalue,oldvalue)\n   },{immediate:true,deep:true})\n   \n   //特殊情况\n   watch(()=>person.job,(newvalue,oldvalue)=>{\n       console.log('person的job变化了',newvalue,oldvalue)\n   },{deep:true}) //此处由于监视的是reactive定义的对象中的某个属性，所以deep配置有效\n   }\n   \n\n\n# watcheffect 函数\n\n * watch 的套路是：既要指明监视的属性，也要指明监视的回调。\n\n * watcheffect 的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n\n * watcheffect 有点像 computed：\n   \n   * 但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n   * 而 watcheffect 更注重的是过程（回调函数的函数体），所以不用写返回值。\n   \n   //watcheffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。\n   watcheffect(() => {\n       const x1 = sum.value\n       const x2 = person.age\n       console.log('watcheffect配置的回调执行了')\n   })\n   \n\n\n# 生命周期\n\n\n# vue2 生命周期\n\n\n\n\n# vue3 生命周期\n\n\n\n * vue3.0 中可以继续使用 vue2.x 中的生命周期钩子，但有有两个被更名：\n   * beforedestroy改名为 beforeunmount\n   * destroyed改名为 unmounted\n * vue3.0 也提供了 composition api 形式的生命周期钩子，与 vue2.x 中钩子对应关系如下：\n   * beforecreate===>setup()\n   * created=======>setup()\n   * beforemount ===>onbeforemount\n   * mounted=======>onmounted\n   * beforeupdate===>onbeforeupdate\n   * updated =======>onupdated\n   * beforeunmount ==>onbeforeunmount\n   * unmounted =====>onunmounted\n\n\n# 自定义 hook 函数\n\n * 什么是 hook？—— 本质是一个函数，把 setup 函数中使用的 composition api 进行了封装。\n\n * 类似于 vue2.x 中的 mixin。\n\n * 自定义 hook 的优势: 复用代码, 让 setup 中的逻辑更清楚易懂。\n\n// 外部\n// import xxx from 'xxx'\n// 内部\nfunction xxx (){\n  // ....\n\n  return { yyy,zzz }\n}\nsetup(){\n  let {yyy,zzz} =xxx()\n  return {yyy,zzz}\n}\n\n\n\n# toref\n\n * 作用：创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。\n\n * 语法：const name = toref(person,'name')\n\n * 应用: 要将响应式对象中的某个属性单独提供给外部使用时。\n\n * 扩展：torefs 与toref功能一致，但可以批量创建多个 ref 对象，语法：const { name,age }=torefs(person)\n\n\n# 其它 composition api\n\n\n# shallowreactive 与 shallowref\n\n * shallowreactive：只处理对象最外层属性的响应式（浅响应式）。\n\n * shallowref：只处理基本数据类型的响应式, 不进行对象的响应式处理。\n\n * 什么时候使用?\n   \n   * 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===> shallowreactive。\n   * 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换 ===> shallowref。\n\n\n# readonly 与 shallowreadonly\n\n * readonly: 让一个响应式数据变为只读的（深只读）。\n * shallowreadonly：让一个响应式数据变为只读的（浅只读）。\n * 应用场景: 不希望数据被修改时。\n\n\n# toraw 与 markraw\n\n * toraw：\n   * 作用：将一个由reactive生成的响应式对象转为普通对象。\n   * 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。\n * markraw：\n   * 作用：标记一个对象，使其永远不会再成为响应式对象。\n   * 应用场景:\n     1. 有些值不应被设置为响应式的，例如复杂的第三方类库等。\n     2. 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\n\n# customref\n\n * 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。\n   \n   提示\n   \n   节流第一次有效，防抖反之\n\n * 实现防抖效果：\n   \n   <template>\n   \t<input type=\"text\" v-model=\"keyword\">\n   \t<h3>{{keyword}}</h3>\n   </template>\n   <script>\n   \timport {ref,customref} from 'vue'\n   \texport default {\n   \t\tname:'demo',\n   \t\tsetup(){\n   \t\t\t// let keyword = ref('hello') //使用vue准备好的内置ref\n   \t\t\t//自定义一个myref\n   \t\t\tfunction myref(value,delay){\n   \t\t\t\tlet timer\n   \t\t\t\t//通过customref去实现自定义\n   \t\t\t\treturn customref((track,trigger)=>{\n   \t\t\t\t\treturn{\n   \t\t\t\t\t\tget(){\n   \t\t\t\t\t\t\ttrack() //告诉vue这个value值是需要被“追踪”的\n   \t\t\t\t\t\t\treturn value\n   \t\t\t\t\t\t},\n   \t\t\t\t\t\tset(newvalue){\n   \t\t\t\t\t\t\tcleartimeout(timer)\n   \t\t\t\t\t\t\ttimer = settimeout(()=>{\n   \t\t\t\t\t\t\t\tvalue = newvalue\n   \t\t\t\t\t\t\t\ttrigger() //告诉vue去更新界面\n   \t\t\t\t\t\t\t},delay)\n   \t\t\t\t\t\t}\n   \t\t\t\t\t}\n   \t\t\t\t})\n   \t\t\t}\n   \t\t\tlet keyword = myref('hello',500) //使用程序员自定义的ref\n   \t\t\treturn {\n   \t\t\t\tkeyword\n   \t\t\t}\n   \t\t}\n   \t}\n   <\/script>\n   \n\n\n# provide 与 inject\n\n * 作用：实现祖与后代组件间通信\n\n * 套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\n\n * 具体写法：\n   \n   1. 祖组件中：\n\nimport { provide } from 'vue'\n     setup(){\n     \t......\n         let car = reactive({name:'奔驰',price:'40万'})\n         provide('car',car)\n         ......\n     }\n\n\n 2. 后代组件中：\n\nimport { inject } from 'vue'\n\n     setup(props,context){\n     \t......\n         const car = inject('car')\n         return {car}\n     \t......\n     }\n\n\n\n# 响应式数据的判断\n\n * isref: 检查一个值是否为一个 ref 对象\n * isreactive: 检查一个对象是否是由 reactive 创建的响应式代理\n * isreadonly: 检查一个对象是否是由 readonly 创建的只读代理\n * isproxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\n\n\n# composition api 的优势\n\n\n# options api 存在的问题\n\n使用传统 optionsapi 中，新增或者修改一个需求，就需要分别在 data，methods，computed 里修改 。\n\n\n\n\n\n\n# composition api 的优势\n\n我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。\n\n\n\n\n\n\n# 新的组件\n\n\n# fragment\n\n * 在 vue2 中: 组件必须有一个根标签\n * 在 vue3 中: 组件可以没有根标签, 内部会将多个标签包含在一个 fragment 虚拟元素中\n * 好处: 减少标签层级, 减小内存占用\n\n\n# teleport\n\n * 什么是 teleport？—— teleport 是一种能够将我们的组件 html 结构移动到指定位置的技术。\n   \n   <teleport to=\"移动位置\">\n   \t<div v-if=\"isshow\" class=\"mask\">\n   \t\t<div class=\"dialog\">\n   \t\t\t<h3>我是一个弹窗</h3>\n   \t\t\t<button @click=\"isshow = false\">关闭弹窗</button>\n   \t\t</div>\n   \t</div>\n   </teleport>\n   \n\n\n# suspense\n\n * 等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n\n * 使用步骤：\n   \n   * 异步引入组件\n     \n     import { defineasynccomponent } from 'vue'\n     const child = defineasynccomponent(() =>\n         import('./components/child.vue')\n     )\n     \n   \n   * 使用suspense包裹组件，并配置好default 与 fallback\n     \n     <template>\n         <div class=\"app\">\n             <h3>我是app组件</h3>\n             <suspense>\n                 <template v-slot:default>\n                     <child />\n                 </template>\n                 <template v-slot:fallback>\n                     <h3>加载中.....</h3>\n                 </template>\n             </suspense>\n         </div>\n     </template>\n     \n\n\n# vue3 中其他的改变\n\n\n# 全局 api 的转移\n\n * vue 2.x 有许多全局 api 和配置。\n   \n   * 例如：注册全局组件、注册全局指令等。\n     \n     //注册全局组件\n     vue.component('mybutton', {\n       data: () => ({\n         count: 0\n       }),\n       template: '<button @click=\"count++\">clicked {{ count }} times.</button>'\n     })\n     \n     //注册全局指令\n     vue.directive('focus', {\n       inserted: el => el.focus()\n     }\n     \n\n * vue3.0 中对这些 api 做出了调整：\n   \n   * 将全局的 api，即：vue.xxx调整到应用实例（app）上\n\n2.x 全局 api（vue）            3.x 实例 api (app)\nvue.config.xxxx            app.config.xxxx\nvue.config.productiontip   移除\nvue.component              app.component\nvue.directive              app.directive\nvue.mixin                  app.mixin\nvue.use                    app.use\nvue.prototype              app.config.globalproperties\n\n:::\n\n\n# 其他改变\n\n * data 选项应始终被声明为一个函数\n\n * 过度类名的更改：\n   \n   * vue2.x 写法\n     \n     .v-enter,\n     .v-leave-to {\n         opacity: 0;\n     }\n     .v-leave,\n     .v-enter-to {\n         opacity: 1;\n     }\n     \n   \n   * vue3.x 写法\n     \n     .v-enter-from,\n     .v-leave-to {\n         opacity: 0;\n     }\n     \n     .v-leave-from,\n     .v-enter-to {\n         opacity: 1;\n     }\n     \n\n * 移除keycode 作为 v-on 的修饰符，同时也不再支持config.keycodes(按键别名，依赖 keycode，兼容性差)\n\n * 移除v-on.native修饰符\n   \n   * 父组件中绑定事件\n     \n     <my-component\n         v-on:close=\"handlecomponentevent\"\n         v-on:click=\"handlenativeclickevent\"\n     />\n     \n   \n   * 子组件中声明自定义事件\n     \n     <script>\n       export default {\n         emits: ['close']\n       }\n     <\/script>\n     \n\n * 移除过滤器（filter）\n   \n   注意\n   \n   过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 javascript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。\n\n * ......\n\n\n# 挂载全局变量\n\n在vue3的setup中使用getcurrentinstanceapi获取全局对象,通过getcurrentinstance方法获取上下文，这里的proxy就相当于this\n\napp.config.globalproperties.xxx=xxx  // main.js\n\n\nimport {getcurrentinstance} from 'vue'\nconst {proxy}=getcurrentinstance()\n",charsets:{cjk:!0},lastUpdated:"2022年07月18日",lastUpdatedTimestamp:1658156035e3},{title:"VueRouter",frontmatter:{title:"VueRouter",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/VueRouter.html",relativePath:"前端开发/前端框架/Vue/VueRouter.md",key:"v-078bbb46",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/VueRouter.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:51},{level:3,title:"对 SPA 应用的理解",slug:"对-spa-应用的理解",normalizedTitle:"对 spa 应用的理解",charIndex:207},{level:3,title:"路由分类",slug:"路由分类",normalizedTitle:"路由分类",charIndex:306},{level:2,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:484},{level:3,title:"几个注意点",slug:"几个注意点",normalizedTitle:"几个注意点",charIndex:1468},{level:2,title:"动态路由匹配",slug:"动态路由匹配",normalizedTitle:"动态路由匹配",charIndex:2018},{level:3,title:"响应路由参数的变化",slug:"响应路由参数的变化",normalizedTitle:"响应路由参数的变化",charIndex:2618},{level:3,title:"捕获所有路由或 404 Not found 路由",slug:"捕获所有路由或-404-not-found-路由",normalizedTitle:"捕获所有路由或 404 not found 路由",charIndex:2908},{level:3,title:"路由的 params 参数",slug:"路由的-params-参数",normalizedTitle:"路由的 params 参数",charIndex:3253},{level:3,title:"路由的 query 参数",slug:"路由的-query-参数",normalizedTitle:"路由的 query 参数",charIndex:4083},{level:2,title:"嵌套路由",slug:"嵌套路由",normalizedTitle:"嵌套路由",charIndex:4530},{level:2,title:"编程式的导航",slug:"编程式的导航",normalizedTitle:"编程式的导航",charIndex:5744},{level:2,title:"命名路由",slug:"命名路由",normalizedTitle:"命名路由",charIndex:6535},{level:2,title:"命名视图",slug:"命名视图",normalizedTitle:"命名视图",charIndex:7268},{level:2,title:"路由组件传参",slug:"路由组件传参",normalizedTitle:"路由组件传参",charIndex:7872},{level:3,title:"路由的 props 配置",slug:"路由的-props-配置",normalizedTitle:"路由的 props 配置",charIndex:7979},{level:2,title:"路由器的两种工作模式",slug:"路由器的两种工作模式",normalizedTitle:"路由器的两种工作模式",charIndex:8615},{level:2,title:"导航守卫",slug:"导航守卫",normalizedTitle:"导航守卫",charIndex:9017},{level:2,title:"缓存路由组件",slug:"缓存路由组件",normalizedTitle:"缓存路由组件",charIndex:10657},{level:2,title:"路由懒加载",slug:"路由懒加载",normalizedTitle:"路由懒加载",charIndex:10972},{level:3,title:"把组件按块划分",slug:"把组件按块划分",normalizedTitle:"把组件按块划分",charIndex:11191},{level:2,title:"vue-router 4.x",slug:"vue-router-4-x",normalizedTitle:"vue-router 4.x",charIndex:11636},{level:3,title:"创建",slug:"创建",normalizedTitle:"创建",charIndex:532},{level:2,title:"在 setup 中访问路由和当前路由",slug:"在-setup-中访问路由和当前路由",normalizedTitle:"在 setup 中访问路由和当前路由",charIndex:12620}],headersStr:"简介 对 SPA 应用的理解 路由分类 基本使用 几个注意点 动态路由匹配 响应路由参数的变化 捕获所有路由或 404 Not found 路由 路由的 params 参数 路由的 query 参数 嵌套路由 编程式的导航 命名路由 命名视图 路由组件传参 路由的 props 配置 路由器的两种工作模式 导航守卫 缓存路由组件 路由懒加载 把组件按块划分 vue-router 4.x 创建 在 setup 中访问路由和当前路由",content:"注意\n\n版本：Vue Router 3.x\n\n可能比文档还详细--VueRouter完全指北\n\n\n# 简介\n\nvue-router和vue是深度集成的,用于单页面应用\n\n传统的路由是用一些超链接来实现页面切换和跳转,而vue-router在单页面应用(SPA)中,则是组件之间的切换\n\n其本质就是:建立并管理url和对应组件之间的映射关系\n\n一个路由route就是一组映射关系（key ==>value）\n\n\n# 对 SPA 应用的理解\n\n单页面应用（single page web application ,SPA):整个页面只有一个完整的页面;点击页面中的导航链接不会刷新页面,只会做页面的局部刷新\n\n\n# 路由分类\n\n# 后端路由\n\n(1) 理解：value是function, 用于处理客户端提交的请求\n\n(2) 工作过程：服务器接收到一个请求时, 根据请求路径找到匹配的函数来处理请求, 返回响应数据\n\n# 前端路由\n\n(1) 理解:value 是component，用于展示页面内容\n\n(2) 工作过程：当浏览器的路径改变时, 对应的组件就会显示\n\n\n# 基本使用\n\n 1. 安装vue-router，命令：npm i vue-router\n\n 2. 创建文件：src/router/index.js\n\n//引入Vue核心库\nimport Vue from 'vue'\n//引入VueRouter\nimport VueRouter from 'vue-router'\n//引入路由组件\nimport About from '../components/About'\nimport Home from '../components/Home'\n\nVue.use(Router)\n\n//创建router实例对象，去管理一组一组的路由规则\nconst router = new VueRouter({\n    routes: [\n        {\n            path: '/about',\n            component: About,\n        },\n        {\n            path: '/home',\n            component: Home,\n        },\n    ],\n})\n\n//暴露router\nexport default router\n\n\n 3. 在main.js中创建vm时传入router配置项\n\n  ......\n  //引入router\n  import router from './router'\n  ......\n\n  //创建vm\n  new Vue({\n  \tel:'#app',\n  \trender: h => h(App),\n  \trouter\n  })\n\n\n 4. 实现切换\n    \n    关于/的说明\n    \n    经过本人测试在router-link的to属性路径path前面无论加不加/均可完成跳转，但为了避免造成不必要的困惑，请始终添加/\n    \n    // active-class设置链接激活时使用的CSS类名\n    <router-link active-class=\"active\" to=\"/about\">About</router-link>\n    \n\n 5. 在组件中指定展示位置\n    \n    <router-view></router-view>\n    \n\n\n# 几个注意点\n\nrouter,routes,route 傻傻分不清?\n\n * router:一般指的就是路由实例.如$router\n * routes:指 router 路由实例的 routes API.用来配置多个 route 路由对象\n * route:指的就是路由对象.例如;$route 指的就是当前路由对象.\n\n 1. 路由组件通常存放在views文件夹，一般组件通常存放在components文件夹\n\n 2. 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载\n    \n      mounted() {\n        console.log('about组件被挂载了')\n        console.log(this)\n      },\n      beforeDestroy() {\n        console.log('about组件被销毁了')\n      }}\n    \n\n 3. 每个组件都有自己的$route属性，里面存储着自己的路由信息,可以通过this.$route获取\n\n 4. 整个应用只有一个router（路由实例:路由实例可以包含多个路由对象.它们是父子包含关系），可以通过this.$router属性获取到router实例\n\n\n# 动态路由匹配\n\n我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果：\n\nconst User = {\n    template: '<div>User</div>',\n}\n\nconst router = new VueRouter({\n    routes: [\n        // 动态路径参数 以冒号开头\n        { path: '/user/:id', component: User },\n    ],\n})\n\n\n现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。\n\n一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。\n\n模式                              匹配路径                  $ROUTE.PARAMS\n/user/:username/post/:post_id   /user/evan/post/123   { username: 'evan', post_id: '123' }\n\n\n# 响应路由参数的变化\n\n从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。\n\n复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) $route 对象：\n\nconst User = {\n    template: '...',\n    watch: {\n        $route(to, from) {\n            // 对路由变化作出响应...\n        },\n    },\n}\n\n\n\n# 捕获所有路由或 404 Not found 路由\n\n当我们将path设为*，会匹配所有的路径，比较常见的场景是在 404 页面进行使用\n\n假设此时我们有 3 个页面：index,about,404\n\nconst router = new Router({\n    routes: [\n        { path: '/index', component: Index },\n        { path: '/about', component: About },\n        { path: '*', component: 404 }, //这个意思就是如果浏览器地址栏输入的不是'/index'也不是'/about'，那我就让它跳转到'404'页面\n    ],\n})\n\n\n\n# 路由的 params 参数\n\n 1. 配置路由，声明接收 params 参数\n    \n    {\n    \tpath:'/home',\n    \tcomponent:Home,\n    \tchildren:[\n    \t\t{\n    \t\t\tpath:'news',\n    \t\t\tcomponent:News\n    \t\t},\n    \t\t{\n          path:'message'\n    \t\t\tcomponent:Message,\n    \t\t\tchildren:[\n    \t\t\t\t{\n    \t\t\t\t\tname:'xiangqing',\n    \t\t\t\t\tpath:'detail/:id/:title', //使用占位符声明接收params参数\n    \t\t\t\t\tcomponent:Detail\n    \t\t\t\t}\n    \t\t\t]\n    \t\t}\n    \t]\n    }\n    \n\n 2. 传递参数\n    \n    特别注意\n    \n    路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置;query的话,name和path均可\n    \n    \x3c!-- 跳转并携带params参数，to的字符串写法 --\x3e\n    <router-link to=\"/home/message/detail/666/你好\">跳转</router-link>\n    \n    \x3c!-- 跳转并携带params参数，to的对象写法 --\x3e\n    <router-link :to=\"{name:'xiangqing',params:{id:666,title:'你好'}}\"\n        >跳转</router-link\n    >\n    \n\n 3. 接收参数：\n    \n    $route.params.id\n    $route.params.title\n    \n\n\n# 路由的 query 参数\n\n扩展阅读:params 和 query 的区别\n\nvue router 如何使用 params query 传参，以及有什么区别\n\nVue Router 的 params 和 query 的区别\n\n 1. 传递参数\n    \n    \x3c!-- 跳转并携带query参数，to的字符串写法 --\x3e\n    <router-link :to=\"/home/message/detail?id=666&title=你好\">跳转</router-link>\n    \n    \x3c!-- 跳转并携带query参数，to的对象写法 --\x3e\n    <router-link :to=\"{path:'/home/message/detail',query:{id:666,title:'你好'}}\">跳转</router-link>\n    \n\n 2. 接收参数：\n    \n    $route.query.id\n    $route.query.title\n    \n\n\n# 嵌套路由\n\n嵌套路由的两个要点\n\n * 路由对象中通过children配置子级路由\n\n * 组件内router-view的使用\n\n 1. 配置路由规则，使用children配置项：\n\nroutes: [\n    {\n        path: '/about',\n        component: About,\n    },\n    {\n        path: '/home',\n        component: Home,\n        children: [\n            //通过children配置子级路由\n            {\n                path: 'news', \n              // 此时path等同于'/home/news',子路由会继承父路由的路径.但是不能写成path:'/news'.因为以 / 开头的嵌套路径会被当作根路径,也就是说此时news成了根路径.而不是home.\n                component: News,\n            },\n            {\n             //此处一定不要写：/message\n                path: 'message', \n                component: Message,\n            },\n        ],\n    },\n]\n\n\n注意\n\n如果/home下没有匹配到其他子路由时,home的router-view是什么都不会显示的,如果你想让它显示点什么:可以将home的某一子级路由的path,设为空''. 它所配置的组件就是默认显示的组件\n\n利用重定向解决:重定向其实就是通过路由拦截path,然后替换url跳转到redirect所指定的路由上. 重定向是通过routes 配置来完成，可以给父组件设置重定向到任意子路由，也可以解决一打开什么也没有显示的问题\n\n参考代码\n\n//从 /a 重定向到 /b\nconst router = new VueRouter({\n    routes: [{ path: '/a', redirect: '/b' }],\n})\n\n///从 /a 重定向到 命名为'foo'的路由\nconst router = new VueRouter({\n    routes: [{ path: '/a', redirect: { name: 'foo' } }],\n})\n\n\n 2. 跳转（要写完整路径）：\n    \n    <router-link to=\"/home/news\">News</router-link>\n    <router-link :to=\"{path:'/home/news'}\">News</router-link>\n    \n\n\n# 编程式的导航\n\n 1. 作用：不借助<router-link>实现路由跳转，让路由跳转更加灵活\n\n 2. 具体编码：\n    \n    // 这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。\n    //  当你点击 <router-link> 时，这个方法会在内部调用，所以说，点击 <router-link :to=\"...\"> 等同于调用 router.push(...)\n    // 字符串写法\n    this.$router.push('/home')\n    // 对象写法\n    this.$router.push({\n        name: 'xiangqing',\n        params: {\n            id: xxx,\n            title: xxx,\n        },\n    })\n    // 跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录\n    this.$router.replace({\n        name: 'xiangqing',\n        params: {\n            id: xxx,\n            title: xxx,\n        },\n    })\n    this.$router.forward() //在浏览器记录中前进一步 等同于router.go(1)\n    this.$router.back() //后退一步记录 等同于router.go(-1)\n    this.$router.go() //可前进也可后退 传数字 负数后退几步 正数前进几步\n    \n\n\n# 命名路由\n\n 1. 作用：可以简化路由的跳转\n\n 2. 如何使用\n    \n    1. 给路由命名：\n       \n       {\n       \tpath:'/demo',\n       \tcomponent:Demo,\n       \tchildren:[\n       \t\t{\n       \t\t\tpath:'test',\n       \t\t\tcomponent:Test,\n       \t\t\tchildren:[\n       \t\t\t\t{\n                         name:'hello' //给路由命名\n       \t\t\t\t\tpath:'welcome',\n       \t\t\t\t\tcomponent:Hello,\n       \t\t\t\t}\n       \t\t\t]\n       \t\t}\n       \t]\n       }\n       \n    \n    2. 简化跳转：\n       \n       \x3c!--简化前，需要写完整的路径 --\x3e\n       <router-link to=\"/demo/test/welcome\">跳转</router-link>\n       \n       \x3c!--简化后，直接通过名字跳转 --\x3e\n       <router-link :to=\"{name:'hello'}\">跳转</router-link>\n       \n       \x3c!--简化写法配合传递参数 --\x3e\n       <router-link :to=\"{name:'hello',query:{id:666,title:'你好'}}\">跳转</router-link>\n       \n\n\n# 命名视图\n\n有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default\n\n<router-view class=\"view one\"></router-view>\n<router-view class=\"view two\" name=\"a\"></router-view>\n<router-view class=\"view three\" name=\"b\"></router-view>\n\n\n一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置 (带上 s)：\n\nconst router = new VueRouter({\n    routes: [\n        {\n            path: '/',\n            components: {\n                default: Foo,\n                a: Bar,\n                b: Baz,\n            },\n        },\n    ],\n})\n\n\n\n# 路由组件传参\n\n在组件中使用 $route 会使之与其对应路由形成高度耦合(耦合指的是各个模块依赖程度)，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性,可以使用 props 将组件和路由解耦\n\n\n# 路由的 props 配置\n\n作用：让路由组件更方便的收到参数\n\n{\n\tname:'xiangqing',\n\tpath:'detail/:id',\n\tcomponent:Detail,\n\n\t//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件\n\t// props:{a:900}\n\n\t//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件\n\t// props:true\n\n\t//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件\n\tprops(route){\n\t\treturn {\n\t\t\tid:route.query.id,\n\t\t\ttitle:route.query.title\n\t\t}\n\t}\n}\n\n\n对于包含命名视图的路由，你必须分别为每个命名视图添加 props 选项\n\n    {\n      path: '/user/:id',\n      components: { default: User, sidebar: Sidebar },\n      props: { default: true, sidebar: false }\n    }\n\n\n之后我们就可以在该组件中利用props配置项接收参数，并且可以在任何地方使用该组件，使得该组件更易于重用和测试\n\n\n# 路由器的两种工作模式\n\n 1. 对于一个url来说，什么是hash值？—— #及其后面的内容就是 hash 值\n\n 2. hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器\n\n 3. hash模式：\n    \n    1. 地址中永远带着#号，不美观\n    2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法\n    3. 兼容性较好\n\n 4. history模式：\n    \n    1. 地址干净，美观\n    2. 兼容性和hash模式相比略差\n    3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题\n\n提示\n\nkoa2-connect-history-api-fallback\n\nkoa2的一个中间件，用于处理vue-router使用 history 模式返回index.html，让koa2支持SPA应用程序\n\n\n# 导航守卫\n\n 1. 作用：对路由进行权限控制\n\n 2. 分类：全局守卫、独享守卫、组件内守卫\n\n 3. 全局守卫:\n    \n    //全局前置守卫：初始化时执行、每次路由切换前执行\n    router.beforeEach((to, from, next) => {\n        console.log('beforeEach', to, from)\n        if (to.meta.isAuth) {\n            //判断当前路由是否需要进行权限控制\n            if (localStorage.getItem('school') === 'atguigu') {\n                //权限控制的具体规则\n                next() //放行\n            } else {\n                alert('暂无权限查看')\n                // next({name:'guanyu'})\n            }\n        } else {\n            next() //放行\n        }\n    })\n    \n    //全局后置守卫：初始化时执行、每次路由切换后执行\n    router.afterEach((to, from) => {\n        console.log('afterEach', to, from)\n        if (to.meta.title) {\n            document.title = to.meta.title //修改网页的title\n        } else {\n            document.title = 'vue_test'\n        }\n    })\n    \n\n提示\n\n路由配置的 meta 对象里的信息是路由元信息,我们可以通过在 meta 里设置的状态,来判断是否需要进行登录验证.如果 meta 里的 isAuth 为 true,则需要判断是否已经登录,没登录就跳转到登录页.如果已登录则继续跳转.\n\n\n前面说的 path,params,query 都可以存储信息,作为登录验证的状态标记.的确,它们也可以达到同样的效果.如果是少量单个的验证,使用它们问题不大. 但如果是多个路由都需要进行登录验证呢?path,params,query 是把信息显性地存储在 url 上的.并且多个路径都把一个相同的状态信息加在 url 上.这样就使 url 不再单纯,并且也很不优雅美观. 所以要优雅要隐性地传递信息,就使用 meta 对象吧\n\n 4. 独享守卫:\n    \n    beforeEnter(to,from,next){\n    \tconsole.log('beforeEnter',to,from)\n    \tif(to.meta.isAuth){ //判断当前路由是否需要进行权限控制\n    \t\tif(localStorage.getItem('school') === 'atguigu'){\n    \t\t\tnext()\n    \t\t}else{\n    \t\t\talert('暂无权限查看')\n    \t\t\t// next({name:'guanyu'})\n    \t\t}\n    \t}else{\n    \t\tnext()\n    \t}\n    }\n    \n\n 5. 组件内守卫：\n    \n    //进入守卫：通过路由规则，进入该组件时被调用\n    beforeRouteEnter (to, from, next) {\n    },\n    //离开守卫：通过路由规则，离开该组件时被调用\n    beforeRouteLeave (to, from, next) {\n    }\n    \n\n\n# 缓存路由组件\n\n 1. 作用：让不展示的路由组件保持挂载，不被销毁\n\n 2. 具体编码：\n    \n    // include 缓存那个组件，这里写的是组件名 如果有多个,要写成数组形式\n    <keep-alive include=\"News\">\n        <router-view></ router-view>\n    </keep-alive>\n    \n\n 3. 两个新的生命周期钩子\n\n * 作用：keep-alive 缓存的路由组件所独有的两个钩子，用于捕获路由组件的激活状态\n\n * 具体名字：\n\n 1. activated路由组件被激活时触发\n 2. deactivated路由组件失活时触发\n\n\n# 路由懒加载\n\n当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。\n\n// 将\n// import UserDetails from './views/UserDetails'\n// 替换成\nconst UserDetails = () => import('./views/UserDetails')\n\n\n\n# 把组件按块划分\n\n有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack > 2.4)：\n\nconst UserDetails = () =>\n    import(/* webpackChunkName: \"group-user\" */ './UserDetails.vue')\nconst UserDashboard = () =>\n    import(/* webpackChunkName: \"group-user\" */ './UserDashboard.vue')\nconst UserProfileEdit = () =>\n    import(/* webpackChunkName: \"group-user\" */ './UserProfileEdit.vue')\n\n\nwebpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。\n\n\n# vue-router 4.x\n\n\n# 创建\n\n 1. 创建src/router/index.js\n\nimport {createRouter,createWebHashHistory} from \"vue-router\";\nimport Login from '../views/Login.vue'\nimport Welcome from '../components/Welcome.vue'\nconst routes=[\n    {\n        name:'home',\n        path:'/',\n        redirect:'/welcome',\n        children:[\n            {\n                name:'welcome',\n                path:'/welcome',\n                component:Welcome,\n            }\n        ]\n    },\n    {\n        name:'login',\n        path:'/login',\n        component:Login,\n    }\n]\n\nconst router=createRouter(\n    {\n        routes,\n        // 创建hash路由\n        history: createWebHashHistory()\n    }\n)\n\n\n\nexport default router\n\n\n 2. main.js应用vue-router\n\nimport { createApp } from 'vue'\nimport ElementPlus from 'element-plus'\nimport 'element-plus/dist/index.css'\nimport App from './App.vue'\n//导入router\nimport router from \"./router/index.js\";\nconst app = createApp(App)\n// 应用router\napp.use(ElementPlus).use(router).mount('#app')\n\n\n\n# 在 setup 中访问路由和当前路由\n\n<template>\n  欢迎访问vue3+vite admin\n <el-button @click=\"goLogin()\">去登陆</el-button>\n</template>\n<script setup>\nimport {useRouter,useRoute} from 'vue-router'\n// 路由实例\nconst router=useRouter()\n// 当前路由对象\nconst route=useRoute()\n// 去登陆页面\nconst goLogin=()=>{\n  console.log(route.name)\n  router.push({name:'login'})\n}\n<\/script>\n<style scoped>\n\n</style>\n\n",normalizedContent:"注意\n\n版本：vue router 3.x\n\n可能比文档还详细--vuerouter完全指北\n\n\n# 简介\n\nvue-router和vue是深度集成的,用于单页面应用\n\n传统的路由是用一些超链接来实现页面切换和跳转,而vue-router在单页面应用(spa)中,则是组件之间的切换\n\n其本质就是:建立并管理url和对应组件之间的映射关系\n\n一个路由route就是一组映射关系（key ==>value）\n\n\n# 对 spa 应用的理解\n\n单页面应用（single page web application ,spa):整个页面只有一个完整的页面;点击页面中的导航链接不会刷新页面,只会做页面的局部刷新\n\n\n# 路由分类\n\n# 后端路由\n\n(1) 理解：value是function, 用于处理客户端提交的请求\n\n(2) 工作过程：服务器接收到一个请求时, 根据请求路径找到匹配的函数来处理请求, 返回响应数据\n\n# 前端路由\n\n(1) 理解:value 是component，用于展示页面内容\n\n(2) 工作过程：当浏览器的路径改变时, 对应的组件就会显示\n\n\n# 基本使用\n\n 1. 安装vue-router，命令：npm i vue-router\n\n 2. 创建文件：src/router/index.js\n\n//引入vue核心库\nimport vue from 'vue'\n//引入vuerouter\nimport vuerouter from 'vue-router'\n//引入路由组件\nimport about from '../components/about'\nimport home from '../components/home'\n\nvue.use(router)\n\n//创建router实例对象，去管理一组一组的路由规则\nconst router = new vuerouter({\n    routes: [\n        {\n            path: '/about',\n            component: about,\n        },\n        {\n            path: '/home',\n            component: home,\n        },\n    ],\n})\n\n//暴露router\nexport default router\n\n\n 3. 在main.js中创建vm时传入router配置项\n\n  ......\n  //引入router\n  import router from './router'\n  ......\n\n  //创建vm\n  new vue({\n  \tel:'#app',\n  \trender: h => h(app),\n  \trouter\n  })\n\n\n 4. 实现切换\n    \n    关于/的说明\n    \n    经过本人测试在router-link的to属性路径path前面无论加不加/均可完成跳转，但为了避免造成不必要的困惑，请始终添加/\n    \n    // active-class设置链接激活时使用的css类名\n    <router-link active-class=\"active\" to=\"/about\">about</router-link>\n    \n\n 5. 在组件中指定展示位置\n    \n    <router-view></router-view>\n    \n\n\n# 几个注意点\n\nrouter,routes,route 傻傻分不清?\n\n * router:一般指的就是路由实例.如$router\n * routes:指 router 路由实例的 routes api.用来配置多个 route 路由对象\n * route:指的就是路由对象.例如;$route 指的就是当前路由对象.\n\n 1. 路由组件通常存放在views文件夹，一般组件通常存放在components文件夹\n\n 2. 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载\n    \n      mounted() {\n        console.log('about组件被挂载了')\n        console.log(this)\n      },\n      beforedestroy() {\n        console.log('about组件被销毁了')\n      }}\n    \n\n 3. 每个组件都有自己的$route属性，里面存储着自己的路由信息,可以通过this.$route获取\n\n 4. 整个应用只有一个router（路由实例:路由实例可以包含多个路由对象.它们是父子包含关系），可以通过this.$router属性获取到router实例\n\n\n# 动态路由匹配\n\n我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 user 组件，对于所有 id 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果：\n\nconst user = {\n    template: '<div>user</div>',\n}\n\nconst router = new vuerouter({\n    routes: [\n        // 动态路径参数 以冒号开头\n        { path: '/user/:id', component: user },\n    ],\n})\n\n\n现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。\n\n一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。\n\n模式                              匹配路径                  $route.params\n/user/:username/post/:post_id   /user/evan/post/123   { username: 'evan', post_id: '123' }\n\n\n# 响应路由参数的变化\n\n从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。\n\n复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) $route 对象：\n\nconst user = {\n    template: '...',\n    watch: {\n        $route(to, from) {\n            // 对路由变化作出响应...\n        },\n    },\n}\n\n\n\n# 捕获所有路由或 404 not found 路由\n\n当我们将path设为*，会匹配所有的路径，比较常见的场景是在 404 页面进行使用\n\n假设此时我们有 3 个页面：index,about,404\n\nconst router = new router({\n    routes: [\n        { path: '/index', component: index },\n        { path: '/about', component: about },\n        { path: '*', component: 404 }, //这个意思就是如果浏览器地址栏输入的不是'/index'也不是'/about'，那我就让它跳转到'404'页面\n    ],\n})\n\n\n\n# 路由的 params 参数\n\n 1. 配置路由，声明接收 params 参数\n    \n    {\n    \tpath:'/home',\n    \tcomponent:home,\n    \tchildren:[\n    \t\t{\n    \t\t\tpath:'news',\n    \t\t\tcomponent:news\n    \t\t},\n    \t\t{\n          path:'message'\n    \t\t\tcomponent:message,\n    \t\t\tchildren:[\n    \t\t\t\t{\n    \t\t\t\t\tname:'xiangqing',\n    \t\t\t\t\tpath:'detail/:id/:title', //使用占位符声明接收params参数\n    \t\t\t\t\tcomponent:detail\n    \t\t\t\t}\n    \t\t\t]\n    \t\t}\n    \t]\n    }\n    \n\n 2. 传递参数\n    \n    特别注意\n    \n    路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置;query的话,name和path均可\n    \n    \x3c!-- 跳转并携带params参数，to的字符串写法 --\x3e\n    <router-link to=\"/home/message/detail/666/你好\">跳转</router-link>\n    \n    \x3c!-- 跳转并携带params参数，to的对象写法 --\x3e\n    <router-link :to=\"{name:'xiangqing',params:{id:666,title:'你好'}}\"\n        >跳转</router-link\n    >\n    \n\n 3. 接收参数：\n    \n    $route.params.id\n    $route.params.title\n    \n\n\n# 路由的 query 参数\n\n扩展阅读:params 和 query 的区别\n\nvue router 如何使用 params query 传参，以及有什么区别\n\nvue router 的 params 和 query 的区别\n\n 1. 传递参数\n    \n    \x3c!-- 跳转并携带query参数，to的字符串写法 --\x3e\n    <router-link :to=\"/home/message/detail?id=666&title=你好\">跳转</router-link>\n    \n    \x3c!-- 跳转并携带query参数，to的对象写法 --\x3e\n    <router-link :to=\"{path:'/home/message/detail',query:{id:666,title:'你好'}}\">跳转</router-link>\n    \n\n 2. 接收参数：\n    \n    $route.query.id\n    $route.query.title\n    \n\n\n# 嵌套路由\n\n嵌套路由的两个要点\n\n * 路由对象中通过children配置子级路由\n\n * 组件内router-view的使用\n\n 1. 配置路由规则，使用children配置项：\n\nroutes: [\n    {\n        path: '/about',\n        component: about,\n    },\n    {\n        path: '/home',\n        component: home,\n        children: [\n            //通过children配置子级路由\n            {\n                path: 'news', \n              // 此时path等同于'/home/news',子路由会继承父路由的路径.但是不能写成path:'/news'.因为以 / 开头的嵌套路径会被当作根路径,也就是说此时news成了根路径.而不是home.\n                component: news,\n            },\n            {\n             //此处一定不要写：/message\n                path: 'message', \n                component: message,\n            },\n        ],\n    },\n]\n\n\n注意\n\n如果/home下没有匹配到其他子路由时,home的router-view是什么都不会显示的,如果你想让它显示点什么:可以将home的某一子级路由的path,设为空''. 它所配置的组件就是默认显示的组件\n\n利用重定向解决:重定向其实就是通过路由拦截path,然后替换url跳转到redirect所指定的路由上. 重定向是通过routes 配置来完成，可以给父组件设置重定向到任意子路由，也可以解决一打开什么也没有显示的问题\n\n参考代码\n\n//从 /a 重定向到 /b\nconst router = new vuerouter({\n    routes: [{ path: '/a', redirect: '/b' }],\n})\n\n///从 /a 重定向到 命名为'foo'的路由\nconst router = new vuerouter({\n    routes: [{ path: '/a', redirect: { name: 'foo' } }],\n})\n\n\n 2. 跳转（要写完整路径）：\n    \n    <router-link to=\"/home/news\">news</router-link>\n    <router-link :to=\"{path:'/home/news'}\">news</router-link>\n    \n\n\n# 编程式的导航\n\n 1. 作用：不借助<router-link>实现路由跳转，让路由跳转更加灵活\n\n 2. 具体编码：\n    \n    // 这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 url。\n    //  当你点击 <router-link> 时，这个方法会在内部调用，所以说，点击 <router-link :to=\"...\"> 等同于调用 router.push(...)\n    // 字符串写法\n    this.$router.push('/home')\n    // 对象写法\n    this.$router.push({\n        name: 'xiangqing',\n        params: {\n            id: xxx,\n            title: xxx,\n        },\n    })\n    // 跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录\n    this.$router.replace({\n        name: 'xiangqing',\n        params: {\n            id: xxx,\n            title: xxx,\n        },\n    })\n    this.$router.forward() //在浏览器记录中前进一步 等同于router.go(1)\n    this.$router.back() //后退一步记录 等同于router.go(-1)\n    this.$router.go() //可前进也可后退 传数字 负数后退几步 正数前进几步\n    \n\n\n# 命名路由\n\n 1. 作用：可以简化路由的跳转\n\n 2. 如何使用\n    \n    1. 给路由命名：\n       \n       {\n       \tpath:'/demo',\n       \tcomponent:demo,\n       \tchildren:[\n       \t\t{\n       \t\t\tpath:'test',\n       \t\t\tcomponent:test,\n       \t\t\tchildren:[\n       \t\t\t\t{\n                         name:'hello' //给路由命名\n       \t\t\t\t\tpath:'welcome',\n       \t\t\t\t\tcomponent:hello,\n       \t\t\t\t}\n       \t\t\t]\n       \t\t}\n       \t]\n       }\n       \n    \n    2. 简化跳转：\n       \n       \x3c!--简化前，需要写完整的路径 --\x3e\n       <router-link to=\"/demo/test/welcome\">跳转</router-link>\n       \n       \x3c!--简化后，直接通过名字跳转 --\x3e\n       <router-link :to=\"{name:'hello'}\">跳转</router-link>\n       \n       \x3c!--简化写法配合传递参数 --\x3e\n       <router-link :to=\"{name:'hello',query:{id:666,title:'你好'}}\">跳转</router-link>\n       \n\n\n# 命名视图\n\n有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default\n\n<router-view class=\"view one\"></router-view>\n<router-view class=\"view two\" name=\"a\"></router-view>\n<router-view class=\"view three\" name=\"b\"></router-view>\n\n\n一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置 (带上 s)：\n\nconst router = new vuerouter({\n    routes: [\n        {\n            path: '/',\n            components: {\n                default: foo,\n                a: bar,\n                b: baz,\n            },\n        },\n    ],\n})\n\n\n\n# 路由组件传参\n\n在组件中使用 $route 会使之与其对应路由形成高度耦合(耦合指的是各个模块依赖程度)，从而使组件只能在某些特定的 url 上使用，限制了其灵活性,可以使用 props 将组件和路由解耦\n\n\n# 路由的 props 配置\n\n作用：让路由组件更方便的收到参数\n\n{\n\tname:'xiangqing',\n\tpath:'detail/:id',\n\tcomponent:detail,\n\n\t//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给detail组件\n\t// props:{a:900}\n\n\t//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给detail组件\n\t// props:true\n\n\t//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给detail组件\n\tprops(route){\n\t\treturn {\n\t\t\tid:route.query.id,\n\t\t\ttitle:route.query.title\n\t\t}\n\t}\n}\n\n\n对于包含命名视图的路由，你必须分别为每个命名视图添加 props 选项\n\n    {\n      path: '/user/:id',\n      components: { default: user, sidebar: sidebar },\n      props: { default: true, sidebar: false }\n    }\n\n\n之后我们就可以在该组件中利用props配置项接收参数，并且可以在任何地方使用该组件，使得该组件更易于重用和测试\n\n\n# 路由器的两种工作模式\n\n 1. 对于一个url来说，什么是hash值？—— #及其后面的内容就是 hash 值\n\n 2. hash值不会包含在 http 请求中，即：hash值不会带给服务器\n\n 3. hash模式：\n    \n    1. 地址中永远带着#号，不美观\n    2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法\n    3. 兼容性较好\n\n 4. history模式：\n    \n    1. 地址干净，美观\n    2. 兼容性和hash模式相比略差\n    3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题\n\n提示\n\nkoa2-connect-history-api-fallback\n\nkoa2的一个中间件，用于处理vue-router使用 history 模式返回index.html，让koa2支持spa应用程序\n\n\n# 导航守卫\n\n 1. 作用：对路由进行权限控制\n\n 2. 分类：全局守卫、独享守卫、组件内守卫\n\n 3. 全局守卫:\n    \n    //全局前置守卫：初始化时执行、每次路由切换前执行\n    router.beforeeach((to, from, next) => {\n        console.log('beforeeach', to, from)\n        if (to.meta.isauth) {\n            //判断当前路由是否需要进行权限控制\n            if (localstorage.getitem('school') === 'atguigu') {\n                //权限控制的具体规则\n                next() //放行\n            } else {\n                alert('暂无权限查看')\n                // next({name:'guanyu'})\n            }\n        } else {\n            next() //放行\n        }\n    })\n    \n    //全局后置守卫：初始化时执行、每次路由切换后执行\n    router.aftereach((to, from) => {\n        console.log('aftereach', to, from)\n        if (to.meta.title) {\n            document.title = to.meta.title //修改网页的title\n        } else {\n            document.title = 'vue_test'\n        }\n    })\n    \n\n提示\n\n路由配置的 meta 对象里的信息是路由元信息,我们可以通过在 meta 里设置的状态,来判断是否需要进行登录验证.如果 meta 里的 isauth 为 true,则需要判断是否已经登录,没登录就跳转到登录页.如果已登录则继续跳转.\n\n\n前面说的 path,params,query 都可以存储信息,作为登录验证的状态标记.的确,它们也可以达到同样的效果.如果是少量单个的验证,使用它们问题不大. 但如果是多个路由都需要进行登录验证呢?path,params,query 是把信息显性地存储在 url 上的.并且多个路径都把一个相同的状态信息加在 url 上.这样就使 url 不再单纯,并且也很不优雅美观. 所以要优雅要隐性地传递信息,就使用 meta 对象吧\n\n 4. 独享守卫:\n    \n    beforeenter(to,from,next){\n    \tconsole.log('beforeenter',to,from)\n    \tif(to.meta.isauth){ //判断当前路由是否需要进行权限控制\n    \t\tif(localstorage.getitem('school') === 'atguigu'){\n    \t\t\tnext()\n    \t\t}else{\n    \t\t\talert('暂无权限查看')\n    \t\t\t// next({name:'guanyu'})\n    \t\t}\n    \t}else{\n    \t\tnext()\n    \t}\n    }\n    \n\n 5. 组件内守卫：\n    \n    //进入守卫：通过路由规则，进入该组件时被调用\n    beforerouteenter (to, from, next) {\n    },\n    //离开守卫：通过路由规则，离开该组件时被调用\n    beforerouteleave (to, from, next) {\n    }\n    \n\n\n# 缓存路由组件\n\n 1. 作用：让不展示的路由组件保持挂载，不被销毁\n\n 2. 具体编码：\n    \n    // include 缓存那个组件，这里写的是组件名 如果有多个,要写成数组形式\n    <keep-alive include=\"news\">\n        <router-view></ router-view>\n    </keep-alive>\n    \n\n 3. 两个新的生命周期钩子\n\n * 作用：keep-alive 缓存的路由组件所独有的两个钩子，用于捕获路由组件的激活状态\n\n * 具体名字：\n\n 1. activated路由组件被激活时触发\n 2. deactivated路由组件失活时触发\n\n\n# 路由懒加载\n\n当打包构建应用时，javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。\n\n// 将\n// import userdetails from './views/userdetails'\n// 替换成\nconst userdetails = () => import('./views/userdetails')\n\n\n\n# 把组件按块划分\n\n有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用命名 chunk，一个特殊的注释语法来提供 chunk name (需要 webpack > 2.4)：\n\nconst userdetails = () =>\n    import(/* webpackchunkname: \"group-user\" */ './userdetails.vue')\nconst userdashboard = () =>\n    import(/* webpackchunkname: \"group-user\" */ './userdashboard.vue')\nconst userprofileedit = () =>\n    import(/* webpackchunkname: \"group-user\" */ './userprofileedit.vue')\n\n\nwebpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。\n\n\n# vue-router 4.x\n\n\n# 创建\n\n 1. 创建src/router/index.js\n\nimport {createrouter,createwebhashhistory} from \"vue-router\";\nimport login from '../views/login.vue'\nimport welcome from '../components/welcome.vue'\nconst routes=[\n    {\n        name:'home',\n        path:'/',\n        redirect:'/welcome',\n        children:[\n            {\n                name:'welcome',\n                path:'/welcome',\n                component:welcome,\n            }\n        ]\n    },\n    {\n        name:'login',\n        path:'/login',\n        component:login,\n    }\n]\n\nconst router=createrouter(\n    {\n        routes,\n        // 创建hash路由\n        history: createwebhashhistory()\n    }\n)\n\n\n\nexport default router\n\n\n 2. main.js应用vue-router\n\nimport { createapp } from 'vue'\nimport elementplus from 'element-plus'\nimport 'element-plus/dist/index.css'\nimport app from './app.vue'\n//导入router\nimport router from \"./router/index.js\";\nconst app = createapp(app)\n// 应用router\napp.use(elementplus).use(router).mount('#app')\n\n\n\n# 在 setup 中访问路由和当前路由\n\n<template>\n  欢迎访问vue3+vite admin\n <el-button @click=\"gologin()\">去登陆</el-button>\n</template>\n<script setup>\nimport {userouter,useroute} from 'vue-router'\n// 路由实例\nconst router=userouter()\n// 当前路由对象\nconst route=useroute()\n// 去登陆页面\nconst gologin=()=>{\n  console.log(route.name)\n  router.push({name:'login'})\n}\n<\/script>\n<style scoped>\n\n</style>\n\n",charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"VueX",frontmatter:{title:"VueX",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/VueX.html",relativePath:"前端开发/前端框架/Vue/VueX.md",key:"v-bef5cc7e",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/VueX.html",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:2},{level:2,title:"何时使用",slug:"何时使用",normalizedTitle:"何时使用",charIndex:99},{level:2,title:"VueX 工作原理",slug:"vuex-工作原理",normalizedTitle:"vuex 工作原理",charIndex:121},{level:2,title:"搭建 vuex 环境",slug:"搭建-vuex-环境",normalizedTitle:"搭建 vuex 环境",charIndex:137},{level:2,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:784},{level:2,title:"getters 的使用",slug:"getters-的使用",normalizedTitle:"getters 的使用",charIndex:2057},{level:2,title:"四个 map 方法的使用",slug:"四个-map-方法的使用",normalizedTitle:"四个 map 方法的使用",charIndex:2485},{level:2,title:"模块化+命名空间",slug:"模块化-命名空间",normalizedTitle:"模块化+命名空间",charIndex:3757}],headersStr:"概念 何时使用 VueX 工作原理 搭建 vuex 环境 基本使用 getters 的使用 四个 map 方法的使用 模块化+命名空间",content:"# 概念\n\n在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。\n\n\n# 何时使用\n\n多个组件需要共享数据时\n\n\n# VueX 工作原理\n\n\n\n\n# 搭建 vuex 环境\n\n 1. 创建文件：src/store/index.js\n    \n    //引入Vue核心库\n    import Vue from 'vue'\n    //引入Vuex\n    import Vuex from 'vuex'\n    //应用Vuex插件\n    Vue.use(Vuex)\n    \n    //准备actions对象——响应组件中用户的动作\n    const actions = {}\n    //准备mutations对象——修改state中的数据\n    const mutations = {}\n    //准备state对象——保存具体的数据\n    const state = {}\n    \n    //创建并暴露store\n    export default new Vuex.Store({\n        actions,\n        mutations,\n        state,\n    })\n    \n\n 2. 在main.js中创建 vm 时传入store配置项\n    \n    ......\n    //引入store\n    import store from './store'\n    ......\n    \n    //创建vm\n    new Vue({\n    \tel:'#app',\n    \trender: h => h(App),\n    \tstore\n    })\n    \n\n\n# 基本使用\n\n 1. 初始化数据、配置actions、配置mutations，操作文件store.js\n    \n    //引入Vue核心库\n    import Vue from 'vue'\n    //引入Vuex\n    import Vuex from 'vuex'\n    //引用Vuex\n    Vue.use(Vuex)\n    \n    const actions = {\n        //响应组件中加的动作\n        jia(context, value) {\n            // console.log('actions中的jia被调用了',miniStore,value)\n            context.commit('JIA', value)\n        },\n    }\n    \n    const mutations = {\n        //执行加\n        JIA(state, value) {\n            // console.log('mutations中的JIA被调用了',state,value)\n            state.sum += value\n        },\n    }\n    \n    //初始化数据\n    const state = {\n        sum: 0,\n    }\n    \n    //创建并暴露store\n    export default new Vuex.Store({\n        actions,\n        mutations,\n        state,\n    })\n    \n\n 2. 组件中读取 vuex 中的数据：$store.state.sum\n\n 3. 组件中修改 vuex 中的数据：$store.dispatch('action中的方法名',数据) 或 $store.commit('mutations中的方法名',数据)\n\n备注\n\n若没有网络请求或其他业务逻辑(即单纯的修改 state 中的数据)，组件中也可以越过 actions，即不写dispatch，直接编写commit\n\nAction 类似于 mutation，不同在于：\n\n * Action 提交的是 mutation，而不是直接变更状态。\n\n * Action 可以包含任意异步操作。\n\n 4. 可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload），在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读\n\n// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n// ...\nstore.commit('increment', {\n  amount: 10\n})\n\n\n\n# getters 的使用\n\n 1. 概念：当 state 中的数据需要经过加工后再使用时，可以使用 getters 加工\n    \n    提示\n    \n    getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\n 2. 在store.js中追加getters配置\n    \n    ......\n    \n    const getters = {\n    \tbigSum(state){\n    \t\treturn state.sum * 10\n    \t}\n    }\n    \n    //创建并暴露store\n    export default new Vuex.Store({\n    \t......\n    \tgetters\n    })\n    \n\n 3. 组件中读取数据：$store.getters.bigSum\n\n\n# 四个 map 方法的使用\n\n 1. mapState 方法：用于帮助我们映射state中的数据为计算属性\n    \n    computed: {\n        //借助mapState生成计算属性：he、xuexiao、kemu（对象写法）\n         ...mapState({he:'sum',xuexiao:'school',kemu:'subject'}),\n    \n        //借助mapState生成计算属性：sum、school、subject（数组写法）\n        ...mapState(['sum','school','subject']),\n    },\n    \n\n 2. mapGetters 方法：用于帮助我们映射getters中的数据为计算属性\n    \n    computed: {\n        //借助mapGetters生成计算属性：bigSum（对象写法）\n        ...mapGetters({bigSum:'bigSum'}),\n    \n        //借助mapGetters生成计算属性：bigSum（数组写法）\n        ...mapGetters(['bigSum'])\n    },\n    \n\n 3. mapActions 方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数\n    \n    methods:{\n        //靠mapActions生成：incrementOdd、incrementWait（对象形式）\n        ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'})\n    \n        //靠mapActions生成：jiaOdd、jiaWait（数组形式）\n        ...mapActions(['jiaOdd','jiaWait'])\n    }\n    \n\n 4. mapMutations 方法：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数\n    \n    methods:{\n        //靠mapActions生成：increment、decrement（对象形式）\n        ...mapMutations({increment:'JIA',decrement:'JIAN'}),\n    \n        //靠mapMutations生成：JIA、JIAN（对象形式）\n        ...mapMutations(['JIA','JIAN']),\n    }\n    \n    \n    特别注意\n    \n    mapActions 与 mapMutations 使用时，若需要传递参数需要：在模板 template 中绑定事件时传递好参数，否则参数是事件对象。\n\n\n# 模块化+命名空间\n\n 1. 目的：让代码更好维护，让多种数据分类更加明确。\n\n 2. 修改store.js\n    \n    const countAbout = {\n      namespaced:true,//开启命名空间\n      state:{x:1},\n      mutations: { ... },\n      actions: { ... },\n      getters: {\n        bigSum(state){\n           return state.sum * 10\n        }\n      }\n    }\n    \n    const personAbout = {\n      namespaced:true,//开启命名空间\n      state:{ ... },\n      mutations: { ... },\n      actions: { ... }\n    }\n    \n    const store = new Vuex.Store({\n      modules: {\n        countAbout,\n        personAbout\n      }\n    })\n    \n\n 3. 开启命名空间后，组件中读取 state 数据：\n    \n    //方式一：自己直接读取\n    this.$store.state.personAbout.list\n    //方式二：借助mapState读取：\n    ...mapState('countAbout',['sum','school','subject']),\n    \n\n 4. 开启命名空间后，组件中读取 getters 数据：\n    \n    //方式一：自己直接读取\n    this.$store.getters['personAbout/firstPersonName']\n    //方式二：借助mapGetters读取：\n    ...mapGetters('countAbout',['bigSum'])\n    \n\n 5. 开启命名空间后，组件中调用 dispatch\n    \n    //方式一：自己直接dispatch\n    this.$store.dispatch('personAbout/addPersonWang',person)\n    //方式二：借助mapActions：\n    ...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})\n    \n\n 6. 开启命名空间后，组件中调用 commit\n    \n    //方式一：自己直接commit\n    this.$store.commit('personAbout/ADD_PERSON',person)\n    //方式二：借助mapMutations：\n    ...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}),\n    \n\n 7. 模块化 在store文件夹下，新建count.js,person.js两个文件对应两个命名空间。\n    \n    count.js 代码\n\nexport default {\n    // 开启命名空间 默认为false\n    namespaced: true,\n    state: {\n        sum: 0,\n    },\n    mutations: {\n        ADD(state, value) {\n            state.sum += value\n        },\n        ADDODD(state, value) {\n            state.sum += value\n        },\n        REDUCE(state, value) {\n            state.sum -= value\n        },\n        ADDWAIT(state, value) {\n            state.sum += value\n        },\n    },\n\n    actions: {\n        addOdd(context, value) {\n            if (context.state.sum % 2 !== 0) {\n                context.commit('ADDODD', value)\n            }\n        },\n        addWait(context, value) {\n            setTimeout(() => {\n                context.commit('ADDWAIT', value)\n            }, 2000)\n        },\n    },\n    getters: {\n        tenSum(state) {\n            return state.sum * 10\n        },\n    },\n}\n\n\n::: 在store/index.js中引入\n\n//该文件用于创建Vuex中最为核心的store\nimport Vue from 'vue'\n//引入Vuex\nimport Vuex from 'vuex'\n// 模块化\nimport countOptions from './count'\nimport personOptions from './person'\n//\n//应用Vuex插件\nVue.use(Vuex)\n\n//创建并暴露store\nexport default new Vuex.Store({\n    modules: {\n        countAbout: countOptions,\n        personAbout: personOptions,\n    },\n})\n",normalizedContent:"# 概念\n\n在 vue 中实现集中式状态（数据）管理的一个 vue 插件，对 vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。\n\n\n# 何时使用\n\n多个组件需要共享数据时\n\n\n# vuex 工作原理\n\n\n\n\n# 搭建 vuex 环境\n\n 1. 创建文件：src/store/index.js\n    \n    //引入vue核心库\n    import vue from 'vue'\n    //引入vuex\n    import vuex from 'vuex'\n    //应用vuex插件\n    vue.use(vuex)\n    \n    //准备actions对象——响应组件中用户的动作\n    const actions = {}\n    //准备mutations对象——修改state中的数据\n    const mutations = {}\n    //准备state对象——保存具体的数据\n    const state = {}\n    \n    //创建并暴露store\n    export default new vuex.store({\n        actions,\n        mutations,\n        state,\n    })\n    \n\n 2. 在main.js中创建 vm 时传入store配置项\n    \n    ......\n    //引入store\n    import store from './store'\n    ......\n    \n    //创建vm\n    new vue({\n    \tel:'#app',\n    \trender: h => h(app),\n    \tstore\n    })\n    \n\n\n# 基本使用\n\n 1. 初始化数据、配置actions、配置mutations，操作文件store.js\n    \n    //引入vue核心库\n    import vue from 'vue'\n    //引入vuex\n    import vuex from 'vuex'\n    //引用vuex\n    vue.use(vuex)\n    \n    const actions = {\n        //响应组件中加的动作\n        jia(context, value) {\n            // console.log('actions中的jia被调用了',ministore,value)\n            context.commit('jia', value)\n        },\n    }\n    \n    const mutations = {\n        //执行加\n        jia(state, value) {\n            // console.log('mutations中的jia被调用了',state,value)\n            state.sum += value\n        },\n    }\n    \n    //初始化数据\n    const state = {\n        sum: 0,\n    }\n    \n    //创建并暴露store\n    export default new vuex.store({\n        actions,\n        mutations,\n        state,\n    })\n    \n\n 2. 组件中读取 vuex 中的数据：$store.state.sum\n\n 3. 组件中修改 vuex 中的数据：$store.dispatch('action中的方法名',数据) 或 $store.commit('mutations中的方法名',数据)\n\n备注\n\n若没有网络请求或其他业务逻辑(即单纯的修改 state 中的数据)，组件中也可以越过 actions，即不写dispatch，直接编写commit\n\naction 类似于 mutation，不同在于：\n\n * action 提交的是 mutation，而不是直接变更状态。\n\n * action 可以包含任意异步操作。\n\n 4. 可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload），在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读\n\n// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n// ...\nstore.commit('increment', {\n  amount: 10\n})\n\n\n\n# getters 的使用\n\n 1. 概念：当 state 中的数据需要经过加工后再使用时，可以使用 getters 加工\n    \n    提示\n    \n    getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\n 2. 在store.js中追加getters配置\n    \n    ......\n    \n    const getters = {\n    \tbigsum(state){\n    \t\treturn state.sum * 10\n    \t}\n    }\n    \n    //创建并暴露store\n    export default new vuex.store({\n    \t......\n    \tgetters\n    })\n    \n\n 3. 组件中读取数据：$store.getters.bigsum\n\n\n# 四个 map 方法的使用\n\n 1. mapstate 方法：用于帮助我们映射state中的数据为计算属性\n    \n    computed: {\n        //借助mapstate生成计算属性：he、xuexiao、kemu（对象写法）\n         ...mapstate({he:'sum',xuexiao:'school',kemu:'subject'}),\n    \n        //借助mapstate生成计算属性：sum、school、subject（数组写法）\n        ...mapstate(['sum','school','subject']),\n    },\n    \n\n 2. mapgetters 方法：用于帮助我们映射getters中的数据为计算属性\n    \n    computed: {\n        //借助mapgetters生成计算属性：bigsum（对象写法）\n        ...mapgetters({bigsum:'bigsum'}),\n    \n        //借助mapgetters生成计算属性：bigsum（数组写法）\n        ...mapgetters(['bigsum'])\n    },\n    \n\n 3. mapactions 方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数\n    \n    methods:{\n        //靠mapactions生成：incrementodd、incrementwait（对象形式）\n        ...mapactions({incrementodd:'jiaodd',incrementwait:'jiawait'})\n    \n        //靠mapactions生成：jiaodd、jiawait（数组形式）\n        ...mapactions(['jiaodd','jiawait'])\n    }\n    \n\n 4. mapmutations 方法：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数\n    \n    methods:{\n        //靠mapactions生成：increment、decrement（对象形式）\n        ...mapmutations({increment:'jia',decrement:'jian'}),\n    \n        //靠mapmutations生成：jia、jian（对象形式）\n        ...mapmutations(['jia','jian']),\n    }\n    \n    \n    特别注意\n    \n    mapactions 与 mapmutations 使用时，若需要传递参数需要：在模板 template 中绑定事件时传递好参数，否则参数是事件对象。\n\n\n# 模块化+命名空间\n\n 1. 目的：让代码更好维护，让多种数据分类更加明确。\n\n 2. 修改store.js\n    \n    const countabout = {\n      namespaced:true,//开启命名空间\n      state:{x:1},\n      mutations: { ... },\n      actions: { ... },\n      getters: {\n        bigsum(state){\n           return state.sum * 10\n        }\n      }\n    }\n    \n    const personabout = {\n      namespaced:true,//开启命名空间\n      state:{ ... },\n      mutations: { ... },\n      actions: { ... }\n    }\n    \n    const store = new vuex.store({\n      modules: {\n        countabout,\n        personabout\n      }\n    })\n    \n\n 3. 开启命名空间后，组件中读取 state 数据：\n    \n    //方式一：自己直接读取\n    this.$store.state.personabout.list\n    //方式二：借助mapstate读取：\n    ...mapstate('countabout',['sum','school','subject']),\n    \n\n 4. 开启命名空间后，组件中读取 getters 数据：\n    \n    //方式一：自己直接读取\n    this.$store.getters['personabout/firstpersonname']\n    //方式二：借助mapgetters读取：\n    ...mapgetters('countabout',['bigsum'])\n    \n\n 5. 开启命名空间后，组件中调用 dispatch\n    \n    //方式一：自己直接dispatch\n    this.$store.dispatch('personabout/addpersonwang',person)\n    //方式二：借助mapactions：\n    ...mapactions('countabout',{incrementodd:'jiaodd',incrementwait:'jiawait'})\n    \n\n 6. 开启命名空间后，组件中调用 commit\n    \n    //方式一：自己直接commit\n    this.$store.commit('personabout/add_person',person)\n    //方式二：借助mapmutations：\n    ...mapmutations('countabout',{increment:'jia',decrement:'jian'}),\n    \n\n 7. 模块化 在store文件夹下，新建count.js,person.js两个文件对应两个命名空间。\n    \n    count.js 代码\n\nexport default {\n    // 开启命名空间 默认为false\n    namespaced: true,\n    state: {\n        sum: 0,\n    },\n    mutations: {\n        add(state, value) {\n            state.sum += value\n        },\n        addodd(state, value) {\n            state.sum += value\n        },\n        reduce(state, value) {\n            state.sum -= value\n        },\n        addwait(state, value) {\n            state.sum += value\n        },\n    },\n\n    actions: {\n        addodd(context, value) {\n            if (context.state.sum % 2 !== 0) {\n                context.commit('addodd', value)\n            }\n        },\n        addwait(context, value) {\n            settimeout(() => {\n                context.commit('addwait', value)\n            }, 2000)\n        },\n    },\n    getters: {\n        tensum(state) {\n            return state.sum * 10\n        },\n    },\n}\n\n\n::: 在store/index.js中引入\n\n//该文件用于创建vuex中最为核心的store\nimport vue from 'vue'\n//引入vuex\nimport vuex from 'vuex'\n// 模块化\nimport countoptions from './count'\nimport personoptions from './person'\n//\n//应用vuex插件\nvue.use(vuex)\n\n//创建并暴露store\nexport default new vuex.store({\n    modules: {\n        countabout: countoptions,\n        personabout: personoptions,\n    },\n})\n",charsets:{cjk:!0},lastUpdated:"2022年05月29日",lastUpdatedTimestamp:1653837709e3},{title:"Vue核心",frontmatter:{title:"Vue核心",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue%E6%A0%B8%E5%BF%83.html",relativePath:"前端开发/前端框架/Vue/Vue核心.md",key:"v-c3b1654e",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue%E6%A0%B8%E5%BF%83.html",headers:[{level:2,title:"vue 简介",slug:"vue-简介",normalizedTitle:"vue 简介",charIndex:2},{level:3,title:"vue 的特点",slug:"vue-的特点",normalizedTitle:"vue 的特点",charIndex:125},{level:2,title:"初识 Vue",slug:"初识-vue",normalizedTitle:"初识 vue",charIndex:275},{level:2,title:"模板语法",slug:"模板语法",normalizedTitle:"模板语法",charIndex:1320},{level:3,title:"插值语法",slug:"插值语法",normalizedTitle:"插值语法",charIndex:1329},{level:3,title:"指令语法",slug:"指令语法",normalizedTitle:"指令语法",charIndex:1428},{level:2,title:"数据绑定",slug:"数据绑定",normalizedTitle:"数据绑定",charIndex:1613},{level:2,title:"el 与 data 的两种写法",slug:"el-与-data-的两种写法",normalizedTitle:"el 与 data 的两种写法",charIndex:1705},{level:3,title:"el 有 2 种写法",slug:"el-有-2-种写法",normalizedTitle:"el 有 2 种写法",charIndex:1725},{level:3,title:"data 有 2 种写法",slug:"data-有-2-种写法",normalizedTitle:"data 有 2 种写法",charIndex:1806},{level:2,title:"MVVM 模型",slug:"mvvm-模型",normalizedTitle:"mvvm 模型",charIndex:1952},{level:2,title:"数据代理",slug:"数据代理",normalizedTitle:"数据代理",charIndex:2295},{level:3,title:"Object.defineProperty 方法",slug:"object-defineproperty-方法",normalizedTitle:"object.defineproperty 方法",charIndex:2304},{level:3,title:"何为数据代理",slug:"何为数据代理",normalizedTitle:"何为数据代理",charIndex:2964},{level:3,title:"Vue 中的数据代理",slug:"vue-中的数据代理",normalizedTitle:"vue 中的数据代理",charIndex:3172},{level:2,title:"事件处理",slug:"事件处理",normalizedTitle:"事件处理",charIndex:3404},{level:3,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:3570},{level:3,title:"事件修饰符",slug:"事件修饰符",normalizedTitle:"事件修饰符",charIndex:3862},{level:3,title:"键盘事件",slug:"键盘事件",normalizedTitle:"键盘事件",charIndex:4088},{level:2,title:"计算属性与监视",slug:"计算属性与监视",normalizedTitle:"计算属性与监视",charIndex:4919},{level:3,title:"计算属性-computed",slug:"计算属性-computed",normalizedTitle:"计算属性-computed",charIndex:4931},{level:3,title:"监视属性-watch",slug:"监视属性-watch",normalizedTitle:"监视属性-watch",charIndex:5508},{level:3,title:"watch 对比 computed",slug:"watch-对比-computed",normalizedTitle:"watch 对比 computed",charIndex:6412},{level:2,title:"class 与 style 绑定",slug:"class-与-style-绑定",normalizedTitle:"class 与 style 绑定",charIndex:6456},{level:3,title:"class 样式",slug:"class-样式",normalizedTitle:"class 样式",charIndex:6477},{level:3,title:"style 样式(行内样式)",slug:"style-样式-行内样式",normalizedTitle:"style 样式(行内样式)",charIndex:6961},{level:2,title:"条件渲染",slug:"条件渲染",normalizedTitle:"条件渲染",charIndex:7230},{level:3,title:"v-if",slug:"v-if",normalizedTitle:"v-if",charIndex:7239},{level:3,title:"v-show",slug:"v-show",normalizedTitle:"v-show",charIndex:7386},{level:3,title:"备注",slug:"备注",normalizedTitle:"备注",charIndex:5217},{level:2,title:"列表渲染",slug:"列表渲染",normalizedTitle:"列表渲染",charIndex:7825},{level:3,title:"v-for 指令",slug:"v-for-指令",normalizedTitle:"v-for 指令",charIndex:7834},{level:3,title:"key 的作用和原理",slug:"key-的作用和原理",normalizedTitle:"key 的作用和原理",charIndex:8143},{level:3,title:"列表过滤",slug:"列表过滤",normalizedTitle:"列表过滤",charIndex:8778},{level:3,title:"列表排序",slug:"列表排序",normalizedTitle:"列表排序",charIndex:8992},{level:2,title:"Vue 监视数据的原理",slug:"vue-监视数据的原理",normalizedTitle:"vue 监视数据的原理",charIndex:9068},{level:3,title:"如何监测对象中的数据",slug:"如何监测对象中的数据",normalizedTitle:"如何监测对象中的数据",charIndex:9107},{level:3,title:"如何监测数组中的数据",slug:"如何监测数组中的数据",normalizedTitle:"如何监测数组中的数据",charIndex:10784},{level:2,title:"收集表单数据",slug:"收集表单数据",normalizedTitle:"收集表单数据",charIndex:11445},{level:2,title:"内置指令",slug:"内置指令",normalizedTitle:"内置指令",charIndex:11876},{level:3,title:"v-text",slug:"v-text",normalizedTitle:"v-text",charIndex:12087},{level:3,title:"v-html",slug:"v-html",normalizedTitle:"v-html",charIndex:12160},{level:3,title:"v-cloak",slug:"v-cloak",normalizedTitle:"v-cloak",charIndex:12474},{level:3,title:"v-once",slug:"v-once",normalizedTitle:"v-once",charIndex:12614},{level:3,title:"v-pre",slug:"v-pre",normalizedTitle:"v-pre",charIndex:12695},{level:2,title:"自定义指令",slug:"自定义指令",normalizedTitle:"自定义指令",charIndex:12775},{level:3,title:"定义局部指令",slug:"定义局部指令",normalizedTitle:"定义局部指令",charIndex:12785},{level:3,title:"定义全局指令",slug:"定义全局指令",normalizedTitle:"定义全局指令",charIndex:12891},{level:3,title:"备注",slug:"备注-2",normalizedTitle:"备注",charIndex:5217},{level:2,title:"生命周期",slug:"生命周期",normalizedTitle:"生命周期",charIndex:15269},{level:3,title:"常用的生命周期钩子",slug:"常用的生命周期钩子",normalizedTitle:"常用的生命周期钩子",charIndex:15422},{level:3,title:"关于销毁 Vue 实例",slug:"关于销毁-vue-实例",normalizedTitle:"关于销毁 vue 实例",charIndex:15528},{level:3,title:"关于 beforeCreate 和 created",slug:"关于-beforecreate-和-created",normalizedTitle:"关于 beforecreate 和 created",charIndex:15649},{level:3,title:"理解生命周期,可以这样理解",slug:"理解生命周期-可以这样理解",normalizedTitle:"理解生命周期,可以这样理解",charIndex:15804}],headersStr:"vue 简介 vue 的特点 初识 Vue 模板语法 插值语法 指令语法 数据绑定 el 与 data 的两种写法 el 有 2 种写法 data 有 2 种写法 MVVM 模型 数据代理 Object.defineProperty 方法 何为数据代理 Vue 中的数据代理 事件处理 基本使用 事件修饰符 键盘事件 计算属性与监视 计算属性-computed 监视属性-watch watch 对比 computed class 与 style 绑定 class 样式 style 样式(行内样式) 条件渲染 v-if v-show 备注 列表渲染 v-for 指令 key 的作用和原理 列表过滤 列表排序 Vue 监视数据的原理 如何监测对象中的数据 如何监测数组中的数据 收集表单数据 内置指令 v-text v-html v-cloak v-once v-pre 自定义指令 定义局部指令 定义全局指令 备注 生命周期 常用的生命周期钩子 关于销毁 Vue 实例 关于 beforeCreate 和 created 理解生命周期,可以这样理解",content:'# vue 简介\n\n一套用于构建用户界面的渐进式 JavaScript框架\n\nVue可以自底向上逐层的应用\n\n * 简单应用：只需一个轻量小巧的核心库\n\n * 复杂应用：可以引入各式各样的Vue插件 vue-router,vuex.....\n\n\n# vue 的特点\n\n⭐ 组件化，提高代码复用率。且让代码更好维护\n\n⭐ 声明式编码,无需直接操作DOM(命令式编码关心的是”how to do“，声明式编码关心的是“what to do”，how 的部分由框架完成)\n\n\n\n⭐ 使用虛拟DOM+优秀的Diff算法，尽量复用DOM节点。\n\n\n\n\n\n\n# 初识 Vue\n\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset="UTF-8" />\n        <title>初识Vue</title>\n        \x3c!-- 引入Vue --\x3e\n        <script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.14/vue.min.js"><\/script>\n    </head>\n    <body>\n        <div id="root">\n            <h1>Hello,{{name}}</h1>\n        </div>\n        <script type="text/javascript">\n            //阻止 vue 在启动时生成生产提示。\n            Vue.config.productionTip = false\n            //创建Vue实例\n            new Vue({\n                el: \'#root\',\n                data: {\n                    name: \'world\',\n                },\n            })\n        <\/script>\n    </body>\n</html>\n\n\n 1. 想让Vue工作，就必须创建一个Vue 实例，且要传入一个配置对象\n 2. root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法\n 3. root容器里的代码被称为Vue 模板\n 4. Vue实例和容器是一一对应的\n 5. 真实开发中只有一个Vue实例，并且会配合着组件一起使用\n 6. 双花括号中的xxx要写 js 表达式，且xxx可以自动读取到 data 中的所有属性\n 7. 一旦 data 中的数据发生改变，那么页面中用到该数据的地方也会自动更新\n\n注意区分\n\njs表达式 和 js代码(语句)\n\n 1. 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：\n\n(1). a\n\n(2). a+b\n\n(3). demo(1)\n\n(4). x === y ? \'a\' : \'b\'\n\n 2. js 代码(语句):\n\n(1). if(){}\n\n(2). for(){}\n\n\n# 模板语法\n\n\n# 插值语法\n\n * 功能：用于解析标签体内容。\n * 写法：\n\n{\n    {\n        xxx\n    }\n}\n\n\nxxx 是 js 表达式，且可以直接读取到 data 中的所有属性\n\n\n# 指令语法\n\n注意\n\nVue 中有很多的指令，且形式都是：v-????，此处只是拿 v-bind 举个例子。\n\n * 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。\n * 举例：\n\nv-bind:href="xxx" //或简写为 `:href="xxx"`\n\n\nxxx 同样要写 js 表达式，且可以直接读取到 data 中的所有属性。\n\n\n# 数据绑定\n\n * 单向绑定 v-bind :数据只能从 data 流向页面\n\n * 双向绑定 v-model :数据不仅能从 data 流向页面，还可以从页面流向 data。\n\n\n# el 与 data 的两种写法\n\n\n# el 有 2 种写法\n\n * new Vue时候配置 el 属性\n * 先创建Vue实例，随后再通过vm.$mount(\'#root\')指定 el 的值\n\n\n# data 有 2 种写法\n\n * 对象式\n\ndata: {\n    // ......\n}\n\n\n * 函数式\n\ndata(){\n    return{\n    // ......\n    }\n}\n\n\n如何目前哪种写法都可以，使用脚手架开发时，data 必须使用函数式，否则必会报错。\n\n\n# MVVM 模型\n\n 1. M：模型Model=>data:主要存的是页面中的数据\n 2. V：视图View =>templete:MVVM 中的 View 通过使用模板语法来声明式的将数据渲染进 DOM，当 ViewModel 对 Model 进行更新的时候，会通过数据绑定更新到 View\n 3. VM：视图模型ViewModel=>Vue实例:它是连接 view 和 model 的桥梁。它有两个方向：\n\n * 将 Model 转化成 View，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。\n\n * 将 View 转化成 Model，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。\n\n这两个方向都实现的，我们称之为数据的双向绑定。\n\n\n\n\n# 数据代理\n\n\n# Object.defineProperty 方法\n\n更多细节:Object.defineProperty()\n\nlet number = 18\nlet person = {\n    name: \'张三\',\n    sex: \'男\',\n}\n\nObject.defineProperty(person, \'age\', {\n    // value:18,\n    enumerable: true, //控制属性是否可以枚举(遍历)，默认值是false\n    // writable:true, //控制属性是否可以被修改，默认值是false\n    configurable: true, //当且仅当该属性的 configurable 键值为 true 时,该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除，默认值是false\n\n    //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值\n    get() {\n        console.log(\'有人读取age属性了\')\n        return number\n    },\n\n    //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值\n    set(value) {\n        console.log(\'有人修改了age属性，且值是\', value)\n        number = value\n    },\n})\n\n\n\n# 何为数据代理\n\n通过一个对象代理对另一个对象中属性的操作（读/写）\n\nlet obj = { x: 100 }\nlet obj2 = { y: 200 }\n\nObject.defineProperty(obj2, \'x\', {\n    get() {\n        return obj.x\n    },\n    set(value) {\n        obj.x = value\n    },\n})\n\n\n\n# Vue 中的数据代理\n\n\n\n 1. Vue中的数据代理：通过 vm 对象来代理 data 对象中属性的操作（读/写）\n\n 2. Vue中数据代理的好处：更加方便的操作 data 中的数据\n\n 3. 基本原理：通过 Object.defineProperty()把 data 对象中所有属性添加到 vm 上。为每一个添加到 vm 上的属性，都指定一个 getter/setter。在 getter/setter 内部去操作（读/写）data 中对应的属性。\n\n\n# 事件处理\n\n两个重要的小原则\n\n 1. 所有被 Vue 管理的函数，最好写成普通函数，这样 this 的指向才是 vm 或 组件实例对象。\n 2. 所有不被 Vue 所管理的函数（定时器的回调函数、ajax 的回调函数等、Promise 的回调函数），最好写成箭头函数，这样 this 的指向才是 vm 或 组件实例对象。\n\n\n# 基本使用\n\n 1. \n\nv-on:xxx\n// 或\n@xxx // 简写\n\n\n其中 xxx 是事件名\n\n 2. 事件的回调需要配置在 methods 对象中，最终会在 vm 上\n 3. methods 中配置的函数，不要用箭头函数，否则 this 就不是 vm 了\n 4. methods 中配置的函数，都是被 Vue 所管理的函数，this 的指向是 vm 或 组件实例对象\n 5. \n\n@click="demo"\n@click="demo($event)"\n\n\n上面两种写法效果一致，前者已经默认传入 event 事件对象，后者可以传参；（$event 事件对象占位符）\n\n\n# 事件修饰符\n\n提示\n\n主要记住前三条\n\n修饰符可以连续写：@click.prevent.stop\n\n 1. prevent：阻止默认事件（常用）\n 2. stop：阻止事件冒泡（常用）\n 3. once：事件只触发一次（常用）\n 4. capture：使用事件的捕获模式\n 5. self：只有 event.target(触发此事件最早元素)是当前元素自身时才触发事件\n 6. passive：事件的默认行为立即执行，无需等待事件回调执行完毕\n\n\n# 键盘事件\n\n提示\n\n主要记住第一条，后两条不太会用到\n\n 1. Vue 中常用的按键别名：\n\n * 回车 => enter\n * 删除 => delete (捕获“删除”和“退格”键)\n * 退出 => esc\n * 空格 =>space\n * 换行 =>tab (特殊，必须配合 keydown 才可以正常使用**)\n * 上 =>up\n * 下 =>down\n * 左 =>left\n * 右 => right\n\n<input type="text" placeholder="按下回车提示输入" @keydown.enter="showInfo" />\n\n\n 2. Vue 未提供别名的按键，可以使用按键原始的key值event.key去绑定，但注意要转为kebab-case（短横线命名）\n\n<input\n    type="text"\n    placeholder="按下大小写切换键提示输入"\n    @keydown.caps-lock="showInfo"\n/>\n\n\n 3. 系统修饰键（用法特殊）：ctrl、alt、shift、meta(徽标键)\n\n提示\n\nkeyup:当某个按键被松开，keydown当某个按键被按下\n\n(1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。\n\n(2).配合keydown使用：正常触发事件\n\n 4. 也可以使用keyCode去指定具体的按键\n\n<input type="text" placeholder="按下回车提示输入" @keydown.13="showInfo" />\n\n\n\n\n 5. 键盘事件同样可以连写===>@keydown.ctrl.67（Ctrl + C）\n\n 6. Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\n\nVue.config.keyCodes.huiche = 13 //定义了一个别名按键\n\n\n\n# 计算属性与监视\n\n\n# 计算属性-computed\n\n 1. 定义：要用的属性不存在，要通过已有属性计算得来\n 2. 原理：底层借助了 Objcet.defineproperty 方法提供的 getter和 setter\n 3. get 函数什么时候执行？\n\n * 初次读取时会执行一次\n * 当依赖的数据发生改变时会被再次调用\n\n 4. 优势： methods和计算属性两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是支持缓存。只在依赖数据发生改变时它们才会重新求值。这就意味着只要依赖的数据不改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数，效率更高\n\n 5. 备注：\n\n * 计算属性最终会出现在 vm 上，在模板中直接读取使用即可。\n * 如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变。\n\nSee the Pen vue2-姓名案例_计算属性实现 by zhangfanhang (@zhangfanhang) on CodePen.\n\n 6. 计算属性的简写（计算属性只读不改的前提下）：\n\n\t\t\tcomputed:{\n\t\t\t\tfullName(){\n\t\t\t\t\treturn this.firstName + \'-\' + this.lastName\n\t\t\t\t}\n\t\t\t}\n\n\n\n# 监视属性-watch\n\n 1. 当被监视的属性变化时, 回调函数自动调用, 进行相关操作\n\n 2. 监视的属性必须存在，才能进行监视！！\n\n 3. 监视的两种写法：\n\n(1)new Vue 时传入 watch 配置\n\nSee the Pen vue2-watch案例 by zhangfanhang (@zhangfanhang) on CodePen.\n\n(2)通过 vm.$watch 监视\n\nvm.$watch(\'isHot\', {\n    immediate: true,\n    handler(newValue, oldValue) {\n        console.log(\'isHot被修改了\', newValue, oldValue)\n    },\n})\n\n\n 4. 深度监视\n\n(1)Vue 中的 watch 默认不监测对象内部值的改变,比如 numbers 为对象{a:1,b:2},默认监视 numbers,改变 a,b 的值是不会触发回调函数的\n\n(2)配置 deep:true 可以监测对象内部值改变\n\n\t\t\twatch:{\n\t\t\t\tnumbers:{\n\t\t\t\t\tdeep:true,\n\t\t\t\t\thandler(){\n\t\t\t\t\t\tconsole.log(\'numbers改变了\')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n备注：\n\n(1)Vue 自身可以监测对象内部值的改变，但 Vue 提供的 watch 默认不可以！\n\n(2)使用 watch 时根据数据的具体结构，决定是否采用深度监视。\n\n 5. 监视的简写方式(前提是没有 deep,immediate)：\n\n// 1\nwatch:{\n\tisHot(newValue,oldValue){\nconsole.log(\'isHot被修改了\',newValue,oldValue,this)\n\t\t}\n\t}\n// 2\nvm.$watch(\'isHot\',function(newValue,oldValue){\nconsole.log(\'isHot被修改了\',newValue,oldValue,this)\n\t\t})\n\n\n\n# watch 对比 computed\n\ncomputed 和 watch 的区别\n\n\n# class 与 style 绑定\n\n\n# class 样式\n\n写法:class="xxx" xxx 可以是字符串、对象、数组。\n\n * 字符串写法适用于：类名不确定，要动态获取。\n * 数组写法适用于：要绑定多个样式，个数不确定，名字也不确定。\n * 对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。\n\n\x3c!-- 字符串写法 --\x3e\n<h2 :class="isColor">{{list}}</h2>\n\x3c!-- 这种写法可以规定那个class类名是否生效，可以使用三目运算符进行判断 --\x3e\n<h2 :class=\'isColor?"red":"black"\'>{{list}}</h2>\n\x3c!-- 对象写法 --\x3e\n<h2 :class="{ docker_item: true, \'docker_item-active\': index === currentIndex}">\n    {{list}}\n</h2>\n\x3c!-- 数组写法 --\x3e\n<h2 :class="[\'docker_item\', \'docker_item-active\']">{{list}}</h2>\n\n\n\n# style 样式(行内样式)\n\n * :style="{fontSize: \'30px\'}"(或者这样写:style="{\'font-size\': \'30px\'}")\n\n * 直接绑定到一个样式对象(样式对象的 key 必须是css中的属性)通常更好，这会让模板更清晰：\n\ndata(){\n\treturn{\n\t\tstyleObj:{\n\t\t\tfontSize:\'40px\',\n\t\t\tcolor:\'red\'\n\t\t}\n\t}\n}\n\n\n * :style="[a,b]"其中 a、b 是样式对象，这样可以将多个样式对象应用到同一个元素上。\n\n\n# 条件渲染\n\n\n# v-if\n\n写法：\n\n(1).v-if="表达式"\n\n(2).v-else-if="表达式"\n\n(3).v-else\n\n适用于：切换频率较低的场景\n\n特点：不展示的 DOM 元素直接被移除\n\n注意：v-if 可以和:v-else-if、v-else 一起使用，但要求结构不能被“打断”\n\n\n# v-show\n\n写法：v-show="表达式"\n\n适用于：切换频率较高的场景\n\n特点：不支持 template，不展示的 DOM 元素未被移除，仅仅是使用样式(display:none)隐藏掉\n\n\n# 备注\n\n使用 v-if 的时，元素可能无法获取到，而使用 v-show 一定可以获取到。\n\n如果需要同时控制多个 DOM 元素的隐藏，可以使用 template 占位符，不影响 DOM 结构\n\n<template v-if="true">\n    <div id="box1">\n        <div />\n        <div id="box2">\n            <div />\n            <div id="box3">\n                <div />\n                <template />\n            </div>\n        </div></div\n></template>\n\n\n\n# 列表渲染\n\n\n# v-for 指令\n\n1.用于展示列表数据\n\n2.语法：\n\nv-for="(item, index) in xxx" :key="yyy"\n\n\n3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少,指定 xxx 为一个数字）\n\n特别注意\n\n如果在 template 上进行列表渲染，可能会报错(v-for 可以在 template 使用但是不能使用 key 属性)：\n\n<template> cannot be keyed. Place the key on real elements instead.\n\n原因：vue 不支持在 template 元素上绑定属性。比如这里想绑定 key 属性就不行\n\n\n# key 的作用和原理\n\n面试题\n\nreact、vue 中的 key 有什么作用？（key 的内部原理）\n\n# 虚拟 DOM 中 key 的作用\n\nkey是虚拟DOM对象的标识，当数据发生变化时，Vue会根据 新数据 生成 新的虚拟DOM , 随后Vue进行 新虚拟DOM 与 旧虚拟DOM 的差异比较，比较规则如下：\n\n# 对比规则\n\n 1. 旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key：\n\n①. 若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM\n\n②. 若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM。\n\n 2. 旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key： 创建新的真实 DOM，随后渲染到到页面。\n\n# 用 index 作为 key 可能会引发的问题\n\n①. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实 DOM 更新 ==> 界面效果没问题, 但效率低.(DOM 没办法复用)\n\n②. 如果结构中还包含输入类的 DOM：产生错误 DOM 更新 ==> 界面有问题。\n\n# 开发中如何选择 key?\n\n①. 最好使用每条数据的唯一标识作为 key, 比如 id、手机号、身份证号、学号等唯一值。\n\n②. 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的。\n\n 5. 图示：\n\n\n\n\n\n\n# 列表过滤\n\nArray.prototype.filter()\n\n# watch 实现\n\nSee the Pen vue2-列表过滤-computed实现 by zhangfanhang (@zhangfanhang) on CodePen.\n\n# computed 实现\n\nSee the Pen vue2-姓名案例_计算属性实现 by zhangfanhang (@zhangfanhang) on CodePen.\n\n\n# 列表排序\n\nSee the Pen vue2-列表排序 by zhangfanhang (@zhangfanhang) on CodePen.\n\n\n# Vue 监视数据的原理\n\nvue 会监视 data 中所有层次的数据\n\n\n# 如何监测对象中的数据\n\n通过 setter 实现监视，data 数据一改变，就会引起 vue 重新解析模板。且要在 new Vue 时就传入要监测的数据。\n\n(1).对象中后追加的属性，Vue 默认不做响应式处理\n\n特别注意\n\nVue.set() 和 vm.$set() 不能给 vm 或 vm 的根数据对象 添加属性！！！\n\n(2).如需给后添加的属性做响应式，请使用如下 API：\n\nVue.set(target,propertyName,value) 或 this.$set(target,propertyName,value)\n\n(3). 移除一个响应式对象属性，请使用如下 API：\n\nVue.delete(target,propertyName)或 this.$delete(target,propertyName)\n\n\x3c!-- 模拟一个简单的数据监测_对象 --\x3e\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset="UTF-8" />\n        <title>Document</title>\n    </head>\n    <body>\n        <script type="text/javascript">\n            let data = {\n                name: \'Frank\',\n                address: \'江苏南京\',\n            }\n\n            //创建一个监视的实例对象，用于监视data中属性的变化\n            const obs = new Observer(data)\n            // console.log(obs)\n\n            //准备一个vm实例对象\n            let vm = {}\n            // 加工data,然后赋给vm._data\n            vm._data = data = obs\n\n            function Observer(obj) {\n                //汇总对象中所有的属性形成一个数组\n                const keys = Object.keys(obj)\n                //遍历\n                keys.forEach(k => {\n                    Object.defineProperty(this, k, {\n                        get() {\n                            return obj[k]\n                        },\n                        // 关键 数据劫持\n                        set(val) {\n                            console.log(\n                                `${k}被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了`\n                            )\n                            obj[k] = val\n                        },\n                    })\n                })\n            }\n        <\/script>\n    </body>\n</html>\n\n\nvue 比我们完善\n\nvue 中可以通过 vm.name 直接获取到 name 的值，是因为这里做了数据代理。对象的嵌套 vue 可以处理，我们处理不了。\n\n\n# 如何监测数组中的数据\n\n// persons是一个数组\nthis.persons[0]={...} // 通过数组下标修改数组的项，vue无法监测到。\n\n\n通过包裹数组更新元素的方法实现，本质就是做了两件事：\n\n(1).调用原生对应的方法对数组进行更新。\n\n(2).重新解析模板，进而更新页面。\n\n在 Vue 修改数组中的某个元素一定要用如下方法：\n\n使用这些 API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()=>均是变更方法\n\n非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组\n\n// 左边旧数组\n items =  items.filter(function (item) {\n  return  ...... // 返回一个新数组\n})\n\n\n(2). 新增一个响应式数组元素，请使用如下 API：\n\nVue.set(target,index,value) 或 this.$set(target,index,value)\n\n(3). 移除一个响应式数组元素，请使用如下 API：\n\nVue.delete(target,index)或 this.$delete(target,index)\n\nSee the Pen vue2-数据监视总结 by zhangfanhang (@zhangfanhang) on CodePen.\n\n\n# 收集表单数据\n\n注意\n\n现在不会使用 form 中的 action 提交数据，更多的是使用 ajax\n\n若：input type="text"，则 v-model 收集的是 value 值，用户输入的就是 value 值。\n\n若：input type="radio"，（单选）则 v-model 收集的是 value 值，且要给标签配置 value 值。\n\n若：input type="checkbox"(多选)\n\n 1. 单个复选框，绑定到布尔值\n\n 2. 多个复选框，绑定到同一个数组( value 组成的数组)\n\nselect：绑定到字符串(option 的 value 值)\n\nv-model 的修饰符\n\nlazy：失去焦点再收集数据\n\nnumber：输入字符串转为有效的数字\n\ntrim：输入首尾空格过滤\n\nSee the Pen vue2-数据监视总结 by zhangfanhang (@zhangfanhang) on CodePen.\n\n\n# 内置指令\n\n回顾,之前学过的指令：\n\n * v-bind : 单向绑定解析表达式, 可简写为 :xxx\n * v-model : 双向数据绑定\n * v-for : 遍历数组/对象/字符串\n * v-on : 绑定事件监听, 可简写为@\n * v-if : 条件渲染（动态控制节点是否存存在）\n * v-else : 条件渲染（动态控制节点是否存存在）\n * v-show : 条件渲染 (动态控制节点是否展示)\n\n\n# v-text\n\n 1. 作用：向其所在的节点中渲染文本内容\n 2. 与插值语法的区别：v-text 会替换掉节点中的内容，插值语法则不会\n\n\n# v-html\n\n严重注意:v-html 有安全性问题\n\n(1).在网站上动态渲染任意 HTML 是非常危险的，容易导致XSS 攻击。\n\nXSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。\n\n(2).一定要在可信的内容上使用 v-html，永远不要用在用户提交的内容上！\n\n 1. 作用：向指定节点中渲染包含 html 结构的内容\n\n 2. 与插值语法的区别：\n\n(1).v-html 会替换掉节点中所有的内容，插值语法则不会\n\n(2).v-html 可以识别 html 结构\n\n\n# v-cloak\n\nv-cloak 指令没有值 1.本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删掉 v-cloak 属性。\n\n2.使用 css属性选择器([v-clock]{display:none;})配合 v-cloak 可以解决网速慢时页面展示的问题。\n\n\n# v-once\n\n1.v-once所在节点在初次动态渲染后，就视为静态内容了。\n\n2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。\n\n\n# v-pre\n\nv-pre 指令是没有值的\n\n1.跳过其所在节点的编译过程。\n\n2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。\n\n\n# 自定义指令\n\n\n# 定义局部指令\n\n// 对象式\n new Vue({\n\t directives:{指令名:配置对象}\n })\n//  函数式\n  new Vue({\n directives{指令名:回调函数}\n  })\n\n\n\n# 定义全局指令\n\nVue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数)\n\n配置对象中常用的 3 个回调：\n\n(1).bind：指令与元素成功绑定时调用。\n\n(2).inserted：指令所在元素被插入页面时调用。\n\n(3).update：指令所在模板结构被重新解析时调用。\n\n\n# 备注\n\n1.指令定义时不加 v-，但使用时要加 v-；\n\n2.指令名如果是多个单词，要使用 kebab-case(短横线命名)命名方式，不要用 camelCase(驼峰)命名。\n\ndemo\n\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset="UTF-8" />\n        <title>自定义指令</title>\n        <script type="text/javascript" src="../js/vue.js"><\/script>\n    </head>\n    <body>\n        \x3c!-- 准备好一个容器--\x3e\n        <div id="root">\n            <h2>{{name}}</h2>\n            <h2>当前的n值是：<span v-text="n"></span></h2>\n            \x3c!-- <h2>放大10倍后的n值是：<span v-big-number="n"></span> </h2> --\x3e\n            <h2>放大10倍后的n值是：<span v-big="n"></span></h2>\n            <button @click="n++">点我n+1</button>\n            <hr />\n            <input type="text" v-fbind:value="n" />\n        </div>\n    </body>\n\n    <script type="text/javascript">\n        Vue.config.productionTip = false\n\n        //定义全局指令\n        /* Vue.directive(\'fbind\',{\n\t\t\t//指令与元素成功绑定时（一上来）\n\t\t\tbind(element,binding){\n\t\t\t\telement.value = binding.value\n\t\t\t},\n\t\t\t//指令所在元素被插入页面时\n\t\t\tinserted(element,binding){\n\t\t\t\telement.focus()\n\t\t\t},\n\t\t\t//指令所在的模板被重新解析时\n\t\t\tupdate(element,binding){\n\t\t\t\telement.value = binding.value\n\t\t\t}\n\t\t}) */\n\n        new Vue({\n            el: \'#root\',\n            data: {\n                name: \'尚硅谷\',\n                n: 1,\n            },\n            directives: {\n                //big函数何时会被调用？1.指令与元素成功绑定时（一上来）。2.指令所在的模板被重新解析时。\n                /* \'big-number\'(element,binding){\n\t\t\t\t\t// console.log(\'big\')\n\t\t\t\t\telement.innerText = binding.value * 10\n\t\t\t\t}, */\n                big(element, binding) {\n                    console.log(\'big\', this) //注意此处的this是window\n                    // console.log(\'big\')\n                    element.innerText = binding.value * 10\n                },\n                fbind: {\n                    //指令与元素成功绑定时（一上来）\n                    bind(element, binding) {\n                        element.value = binding.value\n                    },\n                    //指令所在元素被插入页面时\n                    inserted(element, binding) {\n                        element.focus()\n                    },\n                    //指令所在的模板被重新解析时\n                    update(element, binding) {\n                        element.value = binding.value\n                    },\n                },\n            },\n        })\n    <\/script>\n</html>\n\n\n\n# 生命周期\n\n\n\n 1. 又名：生命周期回调函数、生命周期函数、生命周期钩子。\n\n 2. 是什么：Vue 在关键时刻帮我们调用的一些特殊名称的函数。\n\n 3. 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。\n\n 4. 生命周期函数中的 this 指向是vm 或 组件实例对象。\n\n\n# 常用的生命周期钩子\n\n1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等初始化操作。\n\n2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等收尾工作。\n\n\n# 关于销毁 Vue 实例\n\n(1)销毁后借助Vue开发者工具看不到任何信息。\n\n(2)销毁后自定义事件会失效，但原生DOM事件依然有效。\n\n(3)一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。\n\n\n# 关于 beforeCreate 和 created\n\n指的不是vm的创建之前，而是数据监测，数据代理初始化之前。created 指的是它两初始化之后。\n\n因为此时beforeCreate生命周期钩子中this指向vm,如果beforeCreate指的是vm创建之前，vm还没有被创建，它怎么指向vm？\n\n\n# 理解生命周期,可以这样理解\n\n\n人的一生（人的生命周期）：\n将要出生\n（重要）呱呱坠地-》检查身体\n学会说话\n学会走路\n......\n......\n（重要）将要永别-》交代后事\n已经永别\n\nvm的一生（vm的生命周期）：\n将要创建-》调用beforeCreate函数\n创建完毕-》调用created函数\n将要挂载-》调用beforeMount函数\n（重要）挂载完毕-》调用mounted函数====》重要的钩子\n将要更新-》调用beforeUpdate函数\n更新完毕-》调用updated函数\n（重要）将要销毁-》调用beforeDestroy函数====》重要的钩子\n销毁完毕-》调用destoryed函数\n',normalizedContent:'# vue 简介\n\n一套用于构建用户界面的渐进式 javascript框架\n\nvue可以自底向上逐层的应用\n\n * 简单应用：只需一个轻量小巧的核心库\n\n * 复杂应用：可以引入各式各样的vue插件 vue-router,vuex.....\n\n\n# vue 的特点\n\n⭐ 组件化，提高代码复用率。且让代码更好维护\n\n⭐ 声明式编码,无需直接操作dom(命令式编码关心的是”how to do“，声明式编码关心的是“what to do”，how 的部分由框架完成)\n\n\n\n⭐ 使用虛拟dom+优秀的diff算法，尽量复用dom节点。\n\n\n\n\n\n\n# 初识 vue\n\n<!doctype html>\n<html>\n    <head>\n        <meta charset="utf-8" />\n        <title>初识vue</title>\n        \x3c!-- 引入vue --\x3e\n        <script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.14/vue.min.js"><\/script>\n    </head>\n    <body>\n        <div id="root">\n            <h1>hello,{{name}}</h1>\n        </div>\n        <script type="text/javascript">\n            //阻止 vue 在启动时生成生产提示。\n            vue.config.productiontip = false\n            //创建vue实例\n            new vue({\n                el: \'#root\',\n                data: {\n                    name: \'world\',\n                },\n            })\n        <\/script>\n    </body>\n</html>\n\n\n 1. 想让vue工作，就必须创建一个vue 实例，且要传入一个配置对象\n 2. root容器里的代码依然符合html规范，只不过混入了一些特殊的vue语法\n 3. root容器里的代码被称为vue 模板\n 4. vue实例和容器是一一对应的\n 5. 真实开发中只有一个vue实例，并且会配合着组件一起使用\n 6. 双花括号中的xxx要写 js 表达式，且xxx可以自动读取到 data 中的所有属性\n 7. 一旦 data 中的数据发生改变，那么页面中用到该数据的地方也会自动更新\n\n注意区分\n\njs表达式 和 js代码(语句)\n\n 1. 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：\n\n(1). a\n\n(2). a+b\n\n(3). demo(1)\n\n(4). x === y ? \'a\' : \'b\'\n\n 2. js 代码(语句):\n\n(1). if(){}\n\n(2). for(){}\n\n\n# 模板语法\n\n\n# 插值语法\n\n * 功能：用于解析标签体内容。\n * 写法：\n\n{\n    {\n        xxx\n    }\n}\n\n\nxxx 是 js 表达式，且可以直接读取到 data 中的所有属性\n\n\n# 指令语法\n\n注意\n\nvue 中有很多的指令，且形式都是：v-????，此处只是拿 v-bind 举个例子。\n\n * 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。\n * 举例：\n\nv-bind:href="xxx" //或简写为 `:href="xxx"`\n\n\nxxx 同样要写 js 表达式，且可以直接读取到 data 中的所有属性。\n\n\n# 数据绑定\n\n * 单向绑定 v-bind :数据只能从 data 流向页面\n\n * 双向绑定 v-model :数据不仅能从 data 流向页面，还可以从页面流向 data。\n\n\n# el 与 data 的两种写法\n\n\n# el 有 2 种写法\n\n * new vue时候配置 el 属性\n * 先创建vue实例，随后再通过vm.$mount(\'#root\')指定 el 的值\n\n\n# data 有 2 种写法\n\n * 对象式\n\ndata: {\n    // ......\n}\n\n\n * 函数式\n\ndata(){\n    return{\n    // ......\n    }\n}\n\n\n如何目前哪种写法都可以，使用脚手架开发时，data 必须使用函数式，否则必会报错。\n\n\n# mvvm 模型\n\n 1. m：模型model=>data:主要存的是页面中的数据\n 2. v：视图view =>templete:mvvm 中的 view 通过使用模板语法来声明式的将数据渲染进 dom，当 viewmodel 对 model 进行更新的时候，会通过数据绑定更新到 view\n 3. vm：视图模型viewmodel=>vue实例:它是连接 view 和 model 的桥梁。它有两个方向：\n\n * 将 model 转化成 view，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。\n\n * 将 view 转化成 model，即将所看到的页面转化成后端的数据。实现的方式是：dom 事件监听。\n\n这两个方向都实现的，我们称之为数据的双向绑定。\n\n\n\n\n# 数据代理\n\n\n# object.defineproperty 方法\n\n更多细节:object.defineproperty()\n\nlet number = 18\nlet person = {\n    name: \'张三\',\n    sex: \'男\',\n}\n\nobject.defineproperty(person, \'age\', {\n    // value:18,\n    enumerable: true, //控制属性是否可以枚举(遍历)，默认值是false\n    // writable:true, //控制属性是否可以被修改，默认值是false\n    configurable: true, //当且仅当该属性的 configurable 键值为 true 时,该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除，默认值是false\n\n    //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值\n    get() {\n        console.log(\'有人读取age属性了\')\n        return number\n    },\n\n    //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值\n    set(value) {\n        console.log(\'有人修改了age属性，且值是\', value)\n        number = value\n    },\n})\n\n\n\n# 何为数据代理\n\n通过一个对象代理对另一个对象中属性的操作（读/写）\n\nlet obj = { x: 100 }\nlet obj2 = { y: 200 }\n\nobject.defineproperty(obj2, \'x\', {\n    get() {\n        return obj.x\n    },\n    set(value) {\n        obj.x = value\n    },\n})\n\n\n\n# vue 中的数据代理\n\n\n\n 1. vue中的数据代理：通过 vm 对象来代理 data 对象中属性的操作（读/写）\n\n 2. vue中数据代理的好处：更加方便的操作 data 中的数据\n\n 3. 基本原理：通过 object.defineproperty()把 data 对象中所有属性添加到 vm 上。为每一个添加到 vm 上的属性，都指定一个 getter/setter。在 getter/setter 内部去操作（读/写）data 中对应的属性。\n\n\n# 事件处理\n\n两个重要的小原则\n\n 1. 所有被 vue 管理的函数，最好写成普通函数，这样 this 的指向才是 vm 或 组件实例对象。\n 2. 所有不被 vue 所管理的函数（定时器的回调函数、ajax 的回调函数等、promise 的回调函数），最好写成箭头函数，这样 this 的指向才是 vm 或 组件实例对象。\n\n\n# 基本使用\n\n 1. \n\nv-on:xxx\n// 或\n@xxx // 简写\n\n\n其中 xxx 是事件名\n\n 2. 事件的回调需要配置在 methods 对象中，最终会在 vm 上\n 3. methods 中配置的函数，不要用箭头函数，否则 this 就不是 vm 了\n 4. methods 中配置的函数，都是被 vue 所管理的函数，this 的指向是 vm 或 组件实例对象\n 5. \n\n@click="demo"\n@click="demo($event)"\n\n\n上面两种写法效果一致，前者已经默认传入 event 事件对象，后者可以传参；（$event 事件对象占位符）\n\n\n# 事件修饰符\n\n提示\n\n主要记住前三条\n\n修饰符可以连续写：@click.prevent.stop\n\n 1. prevent：阻止默认事件（常用）\n 2. stop：阻止事件冒泡（常用）\n 3. once：事件只触发一次（常用）\n 4. capture：使用事件的捕获模式\n 5. self：只有 event.target(触发此事件最早元素)是当前元素自身时才触发事件\n 6. passive：事件的默认行为立即执行，无需等待事件回调执行完毕\n\n\n# 键盘事件\n\n提示\n\n主要记住第一条，后两条不太会用到\n\n 1. vue 中常用的按键别名：\n\n * 回车 => enter\n * 删除 => delete (捕获“删除”和“退格”键)\n * 退出 => esc\n * 空格 =>space\n * 换行 =>tab (特殊，必须配合 keydown 才可以正常使用**)\n * 上 =>up\n * 下 =>down\n * 左 =>left\n * 右 => right\n\n<input type="text" placeholder="按下回车提示输入" @keydown.enter="showinfo" />\n\n\n 2. vue 未提供别名的按键，可以使用按键原始的key值event.key去绑定，但注意要转为kebab-case（短横线命名）\n\n<input\n    type="text"\n    placeholder="按下大小写切换键提示输入"\n    @keydown.caps-lock="showinfo"\n/>\n\n\n 3. 系统修饰键（用法特殊）：ctrl、alt、shift、meta(徽标键)\n\n提示\n\nkeyup:当某个按键被松开，keydown当某个按键被按下\n\n(1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。\n\n(2).配合keydown使用：正常触发事件\n\n 4. 也可以使用keycode去指定具体的按键\n\n<input type="text" placeholder="按下回车提示输入" @keydown.13="showinfo" />\n\n\n\n\n 5. 键盘事件同样可以连写===>@keydown.ctrl.67（ctrl + c）\n\n 6. vue.config.keycodes.自定义键名 = 键码，可以去定制按键别名\n\nvue.config.keycodes.huiche = 13 //定义了一个别名按键\n\n\n\n# 计算属性与监视\n\n\n# 计算属性-computed\n\n 1. 定义：要用的属性不存在，要通过已有属性计算得来\n 2. 原理：底层借助了 objcet.defineproperty 方法提供的 getter和 setter\n 3. get 函数什么时候执行？\n\n * 初次读取时会执行一次\n * 当依赖的数据发生改变时会被再次调用\n\n 4. 优势： methods和计算属性两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是支持缓存。只在依赖数据发生改变时它们才会重新求值。这就意味着只要依赖的数据不改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数，效率更高\n\n 5. 备注：\n\n * 计算属性最终会出现在 vm 上，在模板中直接读取使用即可。\n * 如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变。\n\nsee the pen vue2-姓名案例_计算属性实现 by zhangfanhang (@zhangfanhang) on codepen.\n\n 6. 计算属性的简写（计算属性只读不改的前提下）：\n\n\t\t\tcomputed:{\n\t\t\t\tfullname(){\n\t\t\t\t\treturn this.firstname + \'-\' + this.lastname\n\t\t\t\t}\n\t\t\t}\n\n\n\n# 监视属性-watch\n\n 1. 当被监视的属性变化时, 回调函数自动调用, 进行相关操作\n\n 2. 监视的属性必须存在，才能进行监视！！\n\n 3. 监视的两种写法：\n\n(1)new vue 时传入 watch 配置\n\nsee the pen vue2-watch案例 by zhangfanhang (@zhangfanhang) on codepen.\n\n(2)通过 vm.$watch 监视\n\nvm.$watch(\'ishot\', {\n    immediate: true,\n    handler(newvalue, oldvalue) {\n        console.log(\'ishot被修改了\', newvalue, oldvalue)\n    },\n})\n\n\n 4. 深度监视\n\n(1)vue 中的 watch 默认不监测对象内部值的改变,比如 numbers 为对象{a:1,b:2},默认监视 numbers,改变 a,b 的值是不会触发回调函数的\n\n(2)配置 deep:true 可以监测对象内部值改变\n\n\t\t\twatch:{\n\t\t\t\tnumbers:{\n\t\t\t\t\tdeep:true,\n\t\t\t\t\thandler(){\n\t\t\t\t\t\tconsole.log(\'numbers改变了\')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n备注：\n\n(1)vue 自身可以监测对象内部值的改变，但 vue 提供的 watch 默认不可以！\n\n(2)使用 watch 时根据数据的具体结构，决定是否采用深度监视。\n\n 5. 监视的简写方式(前提是没有 deep,immediate)：\n\n// 1\nwatch:{\n\tishot(newvalue,oldvalue){\nconsole.log(\'ishot被修改了\',newvalue,oldvalue,this)\n\t\t}\n\t}\n// 2\nvm.$watch(\'ishot\',function(newvalue,oldvalue){\nconsole.log(\'ishot被修改了\',newvalue,oldvalue,this)\n\t\t})\n\n\n\n# watch 对比 computed\n\ncomputed 和 watch 的区别\n\n\n# class 与 style 绑定\n\n\n# class 样式\n\n写法:class="xxx" xxx 可以是字符串、对象、数组。\n\n * 字符串写法适用于：类名不确定，要动态获取。\n * 数组写法适用于：要绑定多个样式，个数不确定，名字也不确定。\n * 对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。\n\n\x3c!-- 字符串写法 --\x3e\n<h2 :class="iscolor">{{list}}</h2>\n\x3c!-- 这种写法可以规定那个class类名是否生效，可以使用三目运算符进行判断 --\x3e\n<h2 :class=\'iscolor?"red":"black"\'>{{list}}</h2>\n\x3c!-- 对象写法 --\x3e\n<h2 :class="{ docker_item: true, \'docker_item-active\': index === currentindex}">\n    {{list}}\n</h2>\n\x3c!-- 数组写法 --\x3e\n<h2 :class="[\'docker_item\', \'docker_item-active\']">{{list}}</h2>\n\n\n\n# style 样式(行内样式)\n\n * :style="{fontsize: \'30px\'}"(或者这样写:style="{\'font-size\': \'30px\'}")\n\n * 直接绑定到一个样式对象(样式对象的 key 必须是css中的属性)通常更好，这会让模板更清晰：\n\ndata(){\n\treturn{\n\t\tstyleobj:{\n\t\t\tfontsize:\'40px\',\n\t\t\tcolor:\'red\'\n\t\t}\n\t}\n}\n\n\n * :style="[a,b]"其中 a、b 是样式对象，这样可以将多个样式对象应用到同一个元素上。\n\n\n# 条件渲染\n\n\n# v-if\n\n写法：\n\n(1).v-if="表达式"\n\n(2).v-else-if="表达式"\n\n(3).v-else\n\n适用于：切换频率较低的场景\n\n特点：不展示的 dom 元素直接被移除\n\n注意：v-if 可以和:v-else-if、v-else 一起使用，但要求结构不能被“打断”\n\n\n# v-show\n\n写法：v-show="表达式"\n\n适用于：切换频率较高的场景\n\n特点：不支持 template，不展示的 dom 元素未被移除，仅仅是使用样式(display:none)隐藏掉\n\n\n# 备注\n\n使用 v-if 的时，元素可能无法获取到，而使用 v-show 一定可以获取到。\n\n如果需要同时控制多个 dom 元素的隐藏，可以使用 template 占位符，不影响 dom 结构\n\n<template v-if="true">\n    <div id="box1">\n        <div />\n        <div id="box2">\n            <div />\n            <div id="box3">\n                <div />\n                <template />\n            </div>\n        </div></div\n></template>\n\n\n\n# 列表渲染\n\n\n# v-for 指令\n\n1.用于展示列表数据\n\n2.语法：\n\nv-for="(item, index) in xxx" :key="yyy"\n\n\n3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少,指定 xxx 为一个数字）\n\n特别注意\n\n如果在 template 上进行列表渲染，可能会报错(v-for 可以在 template 使用但是不能使用 key 属性)：\n\n<template> cannot be keyed. place the key on real elements instead.\n\n原因：vue 不支持在 template 元素上绑定属性。比如这里想绑定 key 属性就不行\n\n\n# key 的作用和原理\n\n面试题\n\nreact、vue 中的 key 有什么作用？（key 的内部原理）\n\n# 虚拟 dom 中 key 的作用\n\nkey是虚拟dom对象的标识，当数据发生变化时，vue会根据 新数据 生成 新的虚拟dom , 随后vue进行 新虚拟dom 与 旧虚拟dom 的差异比较，比较规则如下：\n\n# 对比规则\n\n 1. 旧虚拟 dom 中找到了与新虚拟 dom 相同的 key：\n\n①. 若虚拟 dom 中内容没变, 直接使用之前的真实 dom\n\n②. 若虚拟 dom 中内容变了, 则生成新的真实 dom，随后替换掉页面中之前的真实 dom。\n\n 2. 旧虚拟 dom 中未找到与新虚拟 dom 相同的 key： 创建新的真实 dom，随后渲染到到页面。\n\n# 用 index 作为 key 可能会引发的问题\n\n①. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实 dom 更新 ==> 界面效果没问题, 但效率低.(dom 没办法复用)\n\n②. 如果结构中还包含输入类的 dom：产生错误 dom 更新 ==> 界面有问题。\n\n# 开发中如何选择 key?\n\n①. 最好使用每条数据的唯一标识作为 key, 比如 id、手机号、身份证号、学号等唯一值。\n\n②. 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的。\n\n 5. 图示：\n\n\n\n\n\n\n# 列表过滤\n\narray.prototype.filter()\n\n# watch 实现\n\nsee the pen vue2-列表过滤-computed实现 by zhangfanhang (@zhangfanhang) on codepen.\n\n# computed 实现\n\nsee the pen vue2-姓名案例_计算属性实现 by zhangfanhang (@zhangfanhang) on codepen.\n\n\n# 列表排序\n\nsee the pen vue2-列表排序 by zhangfanhang (@zhangfanhang) on codepen.\n\n\n# vue 监视数据的原理\n\nvue 会监视 data 中所有层次的数据\n\n\n# 如何监测对象中的数据\n\n通过 setter 实现监视，data 数据一改变，就会引起 vue 重新解析模板。且要在 new vue 时就传入要监测的数据。\n\n(1).对象中后追加的属性，vue 默认不做响应式处理\n\n特别注意\n\nvue.set() 和 vm.$set() 不能给 vm 或 vm 的根数据对象 添加属性！！！\n\n(2).如需给后添加的属性做响应式，请使用如下 api：\n\nvue.set(target,propertyname,value) 或 this.$set(target,propertyname,value)\n\n(3). 移除一个响应式对象属性，请使用如下 api：\n\nvue.delete(target,propertyname)或 this.$delete(target,propertyname)\n\n\x3c!-- 模拟一个简单的数据监测_对象 --\x3e\n<!doctype html>\n<html>\n    <head>\n        <meta charset="utf-8" />\n        <title>document</title>\n    </head>\n    <body>\n        <script type="text/javascript">\n            let data = {\n                name: \'frank\',\n                address: \'江苏南京\',\n            }\n\n            //创建一个监视的实例对象，用于监视data中属性的变化\n            const obs = new observer(data)\n            // console.log(obs)\n\n            //准备一个vm实例对象\n            let vm = {}\n            // 加工data,然后赋给vm._data\n            vm._data = data = obs\n\n            function observer(obj) {\n                //汇总对象中所有的属性形成一个数组\n                const keys = object.keys(obj)\n                //遍历\n                keys.foreach(k => {\n                    object.defineproperty(this, k, {\n                        get() {\n                            return obj[k]\n                        },\n                        // 关键 数据劫持\n                        set(val) {\n                            console.log(\n                                `${k}被改了，我要去解析模板，生成虚拟dom.....我要开始忙了`\n                            )\n                            obj[k] = val\n                        },\n                    })\n                })\n            }\n        <\/script>\n    </body>\n</html>\n\n\nvue 比我们完善\n\nvue 中可以通过 vm.name 直接获取到 name 的值，是因为这里做了数据代理。对象的嵌套 vue 可以处理，我们处理不了。\n\n\n# 如何监测数组中的数据\n\n// persons是一个数组\nthis.persons[0]={...} // 通过数组下标修改数组的项，vue无法监测到。\n\n\n通过包裹数组更新元素的方法实现，本质就是做了两件事：\n\n(1).调用原生对应的方法对数组进行更新。\n\n(2).重新解析模板，进而更新页面。\n\n在 vue 修改数组中的某个元素一定要用如下方法：\n\n使用这些 api:push()、pop()、shift()、unshift()、splice()、sort()、reverse()=>均是变更方法\n\n非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组\n\n// 左边旧数组\n items =  items.filter(function (item) {\n  return  ...... // 返回一个新数组\n})\n\n\n(2). 新增一个响应式数组元素，请使用如下 api：\n\nvue.set(target,index,value) 或 this.$set(target,index,value)\n\n(3). 移除一个响应式数组元素，请使用如下 api：\n\nvue.delete(target,index)或 this.$delete(target,index)\n\nsee the pen vue2-数据监视总结 by zhangfanhang (@zhangfanhang) on codepen.\n\n\n# 收集表单数据\n\n注意\n\n现在不会使用 form 中的 action 提交数据，更多的是使用 ajax\n\n若：input type="text"，则 v-model 收集的是 value 值，用户输入的就是 value 值。\n\n若：input type="radio"，（单选）则 v-model 收集的是 value 值，且要给标签配置 value 值。\n\n若：input type="checkbox"(多选)\n\n 1. 单个复选框，绑定到布尔值\n\n 2. 多个复选框，绑定到同一个数组( value 组成的数组)\n\nselect：绑定到字符串(option 的 value 值)\n\nv-model 的修饰符\n\nlazy：失去焦点再收集数据\n\nnumber：输入字符串转为有效的数字\n\ntrim：输入首尾空格过滤\n\nsee the pen vue2-数据监视总结 by zhangfanhang (@zhangfanhang) on codepen.\n\n\n# 内置指令\n\n回顾,之前学过的指令：\n\n * v-bind : 单向绑定解析表达式, 可简写为 :xxx\n * v-model : 双向数据绑定\n * v-for : 遍历数组/对象/字符串\n * v-on : 绑定事件监听, 可简写为@\n * v-if : 条件渲染（动态控制节点是否存存在）\n * v-else : 条件渲染（动态控制节点是否存存在）\n * v-show : 条件渲染 (动态控制节点是否展示)\n\n\n# v-text\n\n 1. 作用：向其所在的节点中渲染文本内容\n 2. 与插值语法的区别：v-text 会替换掉节点中的内容，插值语法则不会\n\n\n# v-html\n\n严重注意:v-html 有安全性问题\n\n(1).在网站上动态渲染任意 html 是非常危险的，容易导致xss 攻击。\n\nxss，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 cookie、sessionid 等，进而危害数据安全。\n\n(2).一定要在可信的内容上使用 v-html，永远不要用在用户提交的内容上！\n\n 1. 作用：向指定节点中渲染包含 html 结构的内容\n\n 2. 与插值语法的区别：\n\n(1).v-html 会替换掉节点中所有的内容，插值语法则不会\n\n(2).v-html 可以识别 html 结构\n\n\n# v-cloak\n\nv-cloak 指令没有值 1.本质是一个特殊属性，vue 实例创建完毕并接管容器后，会删掉 v-cloak 属性。\n\n2.使用 css属性选择器([v-clock]{display:none;})配合 v-cloak 可以解决网速慢时页面展示的问题。\n\n\n# v-once\n\n1.v-once所在节点在初次动态渲染后，就视为静态内容了。\n\n2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。\n\n\n# v-pre\n\nv-pre 指令是没有值的\n\n1.跳过其所在节点的编译过程。\n\n2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。\n\n\n# 自定义指令\n\n\n# 定义局部指令\n\n// 对象式\n new vue({\n\t directives:{指令名:配置对象}\n })\n//  函数式\n  new vue({\n directives{指令名:回调函数}\n  })\n\n\n\n# 定义全局指令\n\nvue.directive(指令名,配置对象) 或 vue.directive(指令名,回调函数)\n\n配置对象中常用的 3 个回调：\n\n(1).bind：指令与元素成功绑定时调用。\n\n(2).inserted：指令所在元素被插入页面时调用。\n\n(3).update：指令所在模板结构被重新解析时调用。\n\n\n# 备注\n\n1.指令定义时不加 v-，但使用时要加 v-；\n\n2.指令名如果是多个单词，要使用 kebab-case(短横线命名)命名方式，不要用 camelcase(驼峰)命名。\n\ndemo\n\n<!doctype html>\n<html>\n    <head>\n        <meta charset="utf-8" />\n        <title>自定义指令</title>\n        <script type="text/javascript" src="../js/vue.js"><\/script>\n    </head>\n    <body>\n        \x3c!-- 准备好一个容器--\x3e\n        <div id="root">\n            <h2>{{name}}</h2>\n            <h2>当前的n值是：<span v-text="n"></span></h2>\n            \x3c!-- <h2>放大10倍后的n值是：<span v-big-number="n"></span> </h2> --\x3e\n            <h2>放大10倍后的n值是：<span v-big="n"></span></h2>\n            <button @click="n++">点我n+1</button>\n            <hr />\n            <input type="text" v-fbind:value="n" />\n        </div>\n    </body>\n\n    <script type="text/javascript">\n        vue.config.productiontip = false\n\n        //定义全局指令\n        /* vue.directive(\'fbind\',{\n\t\t\t//指令与元素成功绑定时（一上来）\n\t\t\tbind(element,binding){\n\t\t\t\telement.value = binding.value\n\t\t\t},\n\t\t\t//指令所在元素被插入页面时\n\t\t\tinserted(element,binding){\n\t\t\t\telement.focus()\n\t\t\t},\n\t\t\t//指令所在的模板被重新解析时\n\t\t\tupdate(element,binding){\n\t\t\t\telement.value = binding.value\n\t\t\t}\n\t\t}) */\n\n        new vue({\n            el: \'#root\',\n            data: {\n                name: \'尚硅谷\',\n                n: 1,\n            },\n            directives: {\n                //big函数何时会被调用？1.指令与元素成功绑定时（一上来）。2.指令所在的模板被重新解析时。\n                /* \'big-number\'(element,binding){\n\t\t\t\t\t// console.log(\'big\')\n\t\t\t\t\telement.innertext = binding.value * 10\n\t\t\t\t}, */\n                big(element, binding) {\n                    console.log(\'big\', this) //注意此处的this是window\n                    // console.log(\'big\')\n                    element.innertext = binding.value * 10\n                },\n                fbind: {\n                    //指令与元素成功绑定时（一上来）\n                    bind(element, binding) {\n                        element.value = binding.value\n                    },\n                    //指令所在元素被插入页面时\n                    inserted(element, binding) {\n                        element.focus()\n                    },\n                    //指令所在的模板被重新解析时\n                    update(element, binding) {\n                        element.value = binding.value\n                    },\n                },\n            },\n        })\n    <\/script>\n</html>\n\n\n\n# 生命周期\n\n\n\n 1. 又名：生命周期回调函数、生命周期函数、生命周期钩子。\n\n 2. 是什么：vue 在关键时刻帮我们调用的一些特殊名称的函数。\n\n 3. 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。\n\n 4. 生命周期函数中的 this 指向是vm 或 组件实例对象。\n\n\n# 常用的生命周期钩子\n\n1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等初始化操作。\n\n2.beforedestroy: 清除定时器、解绑自定义事件、取消订阅消息等收尾工作。\n\n\n# 关于销毁 vue 实例\n\n(1)销毁后借助vue开发者工具看不到任何信息。\n\n(2)销毁后自定义事件会失效，但原生dom事件依然有效。\n\n(3)一般不会在beforedestroy操作数据，因为即便操作数据，也不会再触发更新流程了。\n\n\n# 关于 beforecreate 和 created\n\n指的不是vm的创建之前，而是数据监测，数据代理初始化之前。created 指的是它两初始化之后。\n\n因为此时beforecreate生命周期钩子中this指向vm,如果beforecreate指的是vm创建之前，vm还没有被创建，它怎么指向vm？\n\n\n# 理解生命周期,可以这样理解\n\n\n人的一生（人的生命周期）：\n将要出生\n（重要）呱呱坠地-》检查身体\n学会说话\n学会走路\n......\n......\n（重要）将要永别-》交代后事\n已经永别\n\nvm的一生（vm的生命周期）：\n将要创建-》调用beforecreate函数\n创建完毕-》调用created函数\n将要挂载-》调用beforemount函数\n（重要）挂载完毕-》调用mounted函数====》重要的钩子\n将要更新-》调用beforeupdate函数\n更新完毕-》调用updated函数\n（重要）将要销毁-》调用beforedestroy函数====》重要的钩子\n销毁完毕-》调用destoryed函数\n',charsets:{cjk:!0},lastUpdated:"2022年06月11日",lastUpdatedTimestamp:1654956222e3},{title:"微信小程序",frontmatter:{title:"微信小程序",sidebar:"auto",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html",relativePath:"前端开发/微信小程序.md",key:"v-3092cb6e",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html",headers:[{level:2,title:"小程序文件类型及代码结构介绍",slug:"小程序文件类型及代码结构介绍",normalizedTitle:"小程序文件类型及代码结构介绍",charIndex:2},{level:2,title:"全局配置文件的使用",slug:"全局配置文件的使用",normalizedTitle:"全局配置文件的使用",charIndex:123},{level:2,title:"使用全局配置制作菜单栏",slug:"使用全局配置制作菜单栏",normalizedTitle:"使用全局配置制作菜单栏",charIndex:150},{level:2,title:"页面级别的配置项",slug:"页面级别的配置项",normalizedTitle:"页面级别的配置项",charIndex:174},{level:2,title:"全局逻辑中的生命周期&全局方法及数据的定义及调用方式",slug:"全局逻辑中的生命周期-全局方法及数据的定义及调用方式",normalizedTitle:"全局逻辑中的生命周期&amp;全局方法及数据的定义及调用方式",charIndex:null},{level:2,title:"页面级别的生命周期函数",slug:"页面级别的生命周期函数",normalizedTitle:"页面级别的生命周期函数",charIndex:809},{level:2,title:"页面逻辑层数据的定义及与页面的串联",slug:"页面逻辑层数据的定义及与页面的串联",normalizedTitle:"页面逻辑层数据的定义及与页面的串联",charIndex:1665},{level:2,title:"逻辑层中的 api",slug:"逻辑层中的-api",normalizedTitle:"逻辑层中的 api",charIndex:1779},{level:2,title:"视图层的数据绑定",slug:"视图层的数据绑定",normalizedTitle:"视图层的数据绑定",charIndex:1798},{level:2,title:"视图层循环展示内容",slug:"视图层循环展示内容",normalizedTitle:"视图层循环展示内容",charIndex:1934},{level:2,title:"视图层的代码拆分",slug:"视图层的代码拆分",normalizedTitle:"视图层的代码拆分",charIndex:1982},{level:2,title:"组件&样式",slug:"组件-样式",normalizedTitle:"组件&amp;样式",charIndex:null},{level:2,title:"踩坑备忘",slug:"踩坑备忘",normalizedTitle:"踩坑备忘",charIndex:2135},{level:3,title:"image 组件",slug:"image-组件",normalizedTitle:"image 组件",charIndex:2144},{level:3,title:"swiper 组件",slug:"swiper-组件",normalizedTitle:"swiper 组件",charIndex:2182},{level:3,title:"rpx",slug:"rpx",normalizedTitle:"rpx",charIndex:2102},{level:3,title:"数据绑定",slug:"数据绑定",normalizedTitle:"数据绑定",charIndex:1802},{level:3,title:"text iamge",slug:"text-iamge",normalizedTitle:"text iamge",charIndex:2606},{level:3,title:"远程数据获取",slug:"远程数据获取",normalizedTitle:"远程数据获取",charIndex:2647},{level:3,title:"数据双向绑定",slug:"数据双向绑定",normalizedTitle:"数据双向绑定",charIndex:3e3},{level:3,title:"页面跳转",slug:"页面跳转",normalizedTitle:"页面跳转",charIndex:3044},{level:3,title:"icon 的使用",slug:"icon-的使用",normalizedTitle:"icon 的使用",charIndex:3111},{level:3,title:"页面背景颜色的修改",slug:"页面背景颜色的修改",normalizedTitle:"页面背景颜色的修改",charIndex:3130}],headersStr:"小程序文件类型及代码结构介绍 全局配置文件的使用 使用全局配置制作菜单栏 页面级别的配置项 全局逻辑中的生命周期&全局方法及数据的定义及调用方式 页面级别的生命周期函数 页面逻辑层数据的定义及与页面的串联 逻辑层中的 api 视图层的数据绑定 视图层循环展示内容 视图层的代码拆分 组件&样式 踩坑备忘 image 组件 swiper 组件 rpx 数据绑定 text iamge 远程数据获取 数据双向绑定 页面跳转 icon 的使用 页面背景颜色的修改",content:"# 小程序文件类型及代码结构介绍\n\n一个页面由 4 个文件组成：xx.js,xx.json,xx.wxml,xx.wxss\n\n项目根目录下，也有这样的 3 个文件app.js,app.json,app.wxss，为全局的逻辑，配置，样式\n\n\n# 全局配置文件的使用\n\n全局配置\n\npages\n\n\n# 使用全局配置制作菜单栏\n\ntapbar\n\n\n# 页面级别的配置项\n\n页面配置\n\n\n# 全局逻辑中的生命周期&全局方法及数据的定义及调用方式\n\napp.js:全局生命周期+全局可以调用的方法和数据（页面中使用 getApp()可以拿到 app 实例，可以调用全局方法和数据）\n\n// 创建一个小程序\nApp({\n    // 生命周期函数指的是在某一时刻会自动执行的函数\n    // 在小程序启动的时候，自动执行的函数\n    onLaunch(options) {\n        console.log('onLaunch', options)\n    },\n    // 在小程序重新展示的时候，自动执行的函数\n    onShow(options) {\n        console.log('onShow', options)\n    },\n    // 在小程序取消展示的时候，自动执行的函数\n    onHide() {\n        console.log('onHide')\n    },\n    // 当脚本执行错误时，自动执行的函数\n    onError(msg) {\n        console.log('onError', msg)\n    },\n    //  自定义的全局方法\n    sayHello() {\n        return 'say hello'\n    },\n    // 全局数据，也可以单独列出。\n    globalData: {},\n})\n\n\n\n# 页面级别的生命周期函数\n\nPage({\n    // 在页面运行的某个时刻会自动执行的函数\n    // 是页面被加载到内存里的时候，或者说页面第一次启动的时候\n    onLoad() {\n        console.log('onLoad')\n    },\n    // 是页面被加载到内存里的时候，或者说页面第一次启动的时候\n    // 并且，页面被渲染完成之后自动执行\n    onReady() {\n        console.log('onReady')\n    },\n    // 页面每次被展示的时候自动执行\n    onShow() {\n        console.log('onShow')\n    },\n    // 页面每次被取消展示的时候自动执行\n    onHide() {\n        console.log('onHide')\n    },\n    // 每次下拉刷新时执行\n    onPullDownRefresh() {\n        console.log('onPullDownRefresh')\n    },\n    // 页面到最底部时会自动执行\n    onReachBottom() {\n        console.log('onReachBottom')\n    },\n    // 当你点击分享时自动执行的函数\n    onShareAppMessage() {\n        console.log('onShareAppMessage')\n        return {\n            title: 'share',\n            path: 'pages/index/index',\n        }\n    },\n    // 当页面滚动时自动执行的函数\n    onPageScroll() {\n        console.log('onPageScroll')\n    },\n})\n\n\n\n# 页面逻辑层数据的定义及与页面的串联\n\n * bindtap='xxx' 当用户点击该组件的时候会在该页面对应的Page中找到相应的事件处理函数 事件\n * 改变数据：this.setData({ xxx:xxx, })\n\n\n# 逻辑层中的 api\n\napi\n\n\n# 视图层的数据绑定\n\nwx:if 与 hidden 的区别\n\nwx:if 删除了 DOM，而 hidden 只是做了样式的隐藏， DOM 依然存在\n\n还有不要直接写 xxx=\"false\"，其计算结果是一个字符串 要这样写:\n\nxxx = '{{false}}'\n\n\n\n# 视图层循环展示内容\n\nwx:for wx:key='*this'\n\nblock 占位符\n\n\n# 视图层的代码拆分\n\nimport 和 include 引用\n\n// 如果想在模板中使用外层的数据需要这样写。\n<template is=\"item\" data=\"{{text: 'forbar'}}\" />\n\n\n\n# 组件&样式\n\n组件\n\nrpx 单位\n\nwxcss：默认屏幕宽度为 750rpx\n\n\n# 踩坑备忘\n\n\n# image 组件\n\nimage\n\n注意图片裁剪、缩放的模式mode\n\n\n# swiper 组件\n\nswiper\n\n轮播图直接使用 swpier,其中放置swpier-item\n\n常用配置项：\n\nautoplay = '{{true}}' // 自动播放\ncircular = '{{true}}' // 是否采用衔接滑动\nindicator - dots ='{{true}}' // 是否显示面板指示点\ninterval = '3000' // 自动切换时间间隔\nduration = '1500' // 滑动动画时长\n\n\n⚠️ 注意\n\n以下内容未订正！！！\n\n\n# rpx\n\n素材的页面宽度为 375px,那么在微信小程序中页面的宽度为 750rpx，为两倍的关系，那么在设置样式的时候应该乘以 2 （比如：搜索栏宽度为 340px,微信小程序中就应该设置 680rpx）\n\n\n# 数据绑定\n\n数据绑定\n\n不要直接写 xxx=\"false\"，其计算结果是一个字符串, 要加双括号\n\nxxx={{false}}\n\n\n\n# text iamge\n\ntext 里面直接写 image 标签加载不出来\n\n\n# 远程数据获取\n\n// 获取数据写在onLoad()生命周期函数中\nwx.request({\n    url: 'https://www.fastmock.site/mock/929c195d9002940292c129ee5a38cdf4/mooc/data',\n    success: res => {\n        const {\n            data: { data },\n        } = res\n        const { swiperList, courses } = data\n        this.setData({\n            swiperList,\n            courses,\n        })\n    },\n})\n\n\n\n# 数据双向绑定\n\nmodel:value=\"{{Ivalue}}\n\n简易双向绑定\n\n\n# 页面跳转\n\n标签实现页面跳转 navigator js 实现页面跳转 wx.redirectTo wx.navigateTo\n\n\n# icon 的使用\n\nicon\n\n\n# 页面背景颜色的修改\n\n当我们在微信小程序 json 中设置 backgroundColor 时，实际在电脑的模拟器中根本看不到效果。\n\n这是因为 backgroundColor 指的窗体背景颜色，而不是页面的背景颜色\n\n如果要设置页面背景颜色，得在 wxss 中自定义样式，如下：\n\npage {\n    background-color: #eee;\n}\n",normalizedContent:"# 小程序文件类型及代码结构介绍\n\n一个页面由 4 个文件组成：xx.js,xx.json,xx.wxml,xx.wxss\n\n项目根目录下，也有这样的 3 个文件app.js,app.json,app.wxss，为全局的逻辑，配置，样式\n\n\n# 全局配置文件的使用\n\n全局配置\n\npages\n\n\n# 使用全局配置制作菜单栏\n\ntapbar\n\n\n# 页面级别的配置项\n\n页面配置\n\n\n# 全局逻辑中的生命周期&全局方法及数据的定义及调用方式\n\napp.js:全局生命周期+全局可以调用的方法和数据（页面中使用 getapp()可以拿到 app 实例，可以调用全局方法和数据）\n\n// 创建一个小程序\napp({\n    // 生命周期函数指的是在某一时刻会自动执行的函数\n    // 在小程序启动的时候，自动执行的函数\n    onlaunch(options) {\n        console.log('onlaunch', options)\n    },\n    // 在小程序重新展示的时候，自动执行的函数\n    onshow(options) {\n        console.log('onshow', options)\n    },\n    // 在小程序取消展示的时候，自动执行的函数\n    onhide() {\n        console.log('onhide')\n    },\n    // 当脚本执行错误时，自动执行的函数\n    onerror(msg) {\n        console.log('onerror', msg)\n    },\n    //  自定义的全局方法\n    sayhello() {\n        return 'say hello'\n    },\n    // 全局数据，也可以单独列出。\n    globaldata: {},\n})\n\n\n\n# 页面级别的生命周期函数\n\npage({\n    // 在页面运行的某个时刻会自动执行的函数\n    // 是页面被加载到内存里的时候，或者说页面第一次启动的时候\n    onload() {\n        console.log('onload')\n    },\n    // 是页面被加载到内存里的时候，或者说页面第一次启动的时候\n    // 并且，页面被渲染完成之后自动执行\n    onready() {\n        console.log('onready')\n    },\n    // 页面每次被展示的时候自动执行\n    onshow() {\n        console.log('onshow')\n    },\n    // 页面每次被取消展示的时候自动执行\n    onhide() {\n        console.log('onhide')\n    },\n    // 每次下拉刷新时执行\n    onpulldownrefresh() {\n        console.log('onpulldownrefresh')\n    },\n    // 页面到最底部时会自动执行\n    onreachbottom() {\n        console.log('onreachbottom')\n    },\n    // 当你点击分享时自动执行的函数\n    onshareappmessage() {\n        console.log('onshareappmessage')\n        return {\n            title: 'share',\n            path: 'pages/index/index',\n        }\n    },\n    // 当页面滚动时自动执行的函数\n    onpagescroll() {\n        console.log('onpagescroll')\n    },\n})\n\n\n\n# 页面逻辑层数据的定义及与页面的串联\n\n * bindtap='xxx' 当用户点击该组件的时候会在该页面对应的page中找到相应的事件处理函数 事件\n * 改变数据：this.setdata({ xxx:xxx, })\n\n\n# 逻辑层中的 api\n\napi\n\n\n# 视图层的数据绑定\n\nwx:if 与 hidden 的区别\n\nwx:if 删除了 dom，而 hidden 只是做了样式的隐藏， dom 依然存在\n\n还有不要直接写 xxx=\"false\"，其计算结果是一个字符串 要这样写:\n\nxxx = '{{false}}'\n\n\n\n# 视图层循环展示内容\n\nwx:for wx:key='*this'\n\nblock 占位符\n\n\n# 视图层的代码拆分\n\nimport 和 include 引用\n\n// 如果想在模板中使用外层的数据需要这样写。\n<template is=\"item\" data=\"{{text: 'forbar'}}\" />\n\n\n\n# 组件&样式\n\n组件\n\nrpx 单位\n\nwxcss：默认屏幕宽度为 750rpx\n\n\n# 踩坑备忘\n\n\n# image 组件\n\nimage\n\n注意图片裁剪、缩放的模式mode\n\n\n# swiper 组件\n\nswiper\n\n轮播图直接使用 swpier,其中放置swpier-item\n\n常用配置项：\n\nautoplay = '{{true}}' // 自动播放\ncircular = '{{true}}' // 是否采用衔接滑动\nindicator - dots ='{{true}}' // 是否显示面板指示点\ninterval = '3000' // 自动切换时间间隔\nduration = '1500' // 滑动动画时长\n\n\n⚠️ 注意\n\n以下内容未订正！！！\n\n\n# rpx\n\n素材的页面宽度为 375px,那么在微信小程序中页面的宽度为 750rpx，为两倍的关系，那么在设置样式的时候应该乘以 2 （比如：搜索栏宽度为 340px,微信小程序中就应该设置 680rpx）\n\n\n# 数据绑定\n\n数据绑定\n\n不要直接写 xxx=\"false\"，其计算结果是一个字符串, 要加双括号\n\nxxx={{false}}\n\n\n\n# text iamge\n\ntext 里面直接写 image 标签加载不出来\n\n\n# 远程数据获取\n\n// 获取数据写在onload()生命周期函数中\nwx.request({\n    url: 'https://www.fastmock.site/mock/929c195d9002940292c129ee5a38cdf4/mooc/data',\n    success: res => {\n        const {\n            data: { data },\n        } = res\n        const { swiperlist, courses } = data\n        this.setdata({\n            swiperlist,\n            courses,\n        })\n    },\n})\n\n\n\n# 数据双向绑定\n\nmodel:value=\"{{ivalue}}\n\n简易双向绑定\n\n\n# 页面跳转\n\n标签实现页面跳转 navigator js 实现页面跳转 wx.redirectto wx.navigateto\n\n\n# icon 的使用\n\nicon\n\n\n# 页面背景颜色的修改\n\n当我们在微信小程序 json 中设置 backgroundcolor 时，实际在电脑的模拟器中根本看不到效果。\n\n这是因为 backgroundcolor 指的窗体背景颜色，而不是页面的背景颜色\n\n如果要设置页面背景颜色，得在 wxss 中自定义样式，如下：\n\npage {\n    background-color: #eee;\n}\n",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"Vue组件化编程",frontmatter:{title:"Vue组件化编程",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B.html",relativePath:"前端开发/前端框架/Vue/Vue组件化编程.md",key:"v-187547cf",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B.html",headers:[{level:2,title:"几个概念",slug:"几个概念",normalizedTitle:"几个概念",charIndex:37},{level:3,title:"模块",slug:"模块",normalizedTitle:"模块",charIndex:46},{level:3,title:"组件",slug:"组件",normalizedTitle:"组件",charIndex:134},{level:3,title:"模块化",slug:"模块化",normalizedTitle:"模块化",charIndex:230},{level:3,title:"组件化",slug:"组件化",normalizedTitle:"组件化",charIndex:274},{level:2,title:"组件",slug:"组件-2",normalizedTitle:"组件",charIndex:134},{level:3,title:"组件的几个注意点",slug:"组件的几个注意点",normalizedTitle:"组件的几个注意点",charIndex:2402},{level:3,title:"组件的嵌套",slug:"组件的嵌套",normalizedTitle:"组件的嵌套",charIndex:2721},{level:3,title:"VueComponent 构造函数",slug:"vuecomponent-构造函数",normalizedTitle:"vuecomponent 构造函数",charIndex:4613},{level:2,title:"vue 脚手架",slug:"vue-脚手架",normalizedTitle:"vue 脚手架",charIndex:5410},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:390},{level:3,title:"脚手架文件结构",slug:"脚手架文件结构",normalizedTitle:"脚手架文件结构",charIndex:5504},{level:2,title:"render 函数",slug:"render-函数",normalizedTitle:"render 函数",charIndex:5900},{level:2,title:"vue.config.js 配置文件",slug:"vue-config-js-配置文件",normalizedTitle:"vue.config.js 配置文件",charIndex:6163},{level:2,title:"ref 属性",slug:"ref-属性",normalizedTitle:"ref 属性",charIndex:6300},{level:2,title:"props 配置项",slug:"props-配置项",normalizedTitle:"props 配置项",charIndex:6493},{level:2,title:"mixin 混入",slug:"mixin-混入",normalizedTitle:"mixin 混入",charIndex:6999},{level:2,title:"插件",slug:"插件",normalizedTitle:"插件",charIndex:7254},{level:2,title:"scoped 样式",slug:"scoped-样式",normalizedTitle:"scoped 样式",charIndex:7702},{level:2,title:"总结 TodoList 案例",slug:"总结-todolist-案例",normalizedTitle:"总结 todolist 案例",charIndex:7761},{level:2,title:"webStorage",slug:"webstorage",normalizedTitle:"webstorage",charIndex:8322},{level:2,title:"组件的自定义事件",slug:"组件的自定义事件",normalizedTitle:"组件的自定义事件",charIndex:8987},{level:2,title:"全局事件总线（GlobalEventBus）",slug:"全局事件总线-globaleventbus",normalizedTitle:"全局事件总线（globaleventbus）",charIndex:9774},{level:2,title:"消息订阅与发布（pubsub）",slug:"消息订阅与发布-pubsub",normalizedTitle:"消息订阅与发布（pubsub）",charIndex:10491},{level:2,title:"nextTick",slug:"nexttick",normalizedTitle:"nexttick",charIndex:11319},{level:2,title:"Vue 封装的过度与动画",slug:"vue-封装的过度与动画",normalizedTitle:"vue 封装的过度与动画",charIndex:11455},{level:2,title:"vue 脚手架配置代理",slug:"vue-脚手架配置代理",normalizedTitle:"vue 脚手架配置代理",charIndex:12851},{level:3,title:"方法一",slug:"方法一",normalizedTitle:"方法一",charIndex:12867},{level:3,title:"方法二",slug:"方法二",normalizedTitle:"方法二",charIndex:13081},{level:2,title:"插槽",slug:"插槽",normalizedTitle:"插槽",charIndex:13846},{level:3,title:"默认插槽",slug:"默认插槽",normalizedTitle:"默认插槽",charIndex:14180},{level:3,title:"具名插槽",slug:"具名插槽",normalizedTitle:"具名插槽",charIndex:13881},{level:3,title:"作用域插槽",slug:"作用域插槽",normalizedTitle:"作用域插槽",charIndex:13886},{level:2,title:"inheritAttrs + $attrs + $listeners",slug:"inheritattrs-attrs-listeners",normalizedTitle:"inheritattrs + $attrs + $listeners",charIndex:18422},{level:2,title:"挂载全局变量",slug:"挂载全局变量",normalizedTitle:"挂载全局变量",charIndex:19168}],headersStr:"几个概念 模块 组件 模块化 组件化 组件 组件的几个注意点 组件的嵌套 VueComponent 构造函数 vue 脚手架 使用 脚手架文件结构 render 函数 vue.config.js 配置文件 ref 属性 props 配置项 mixin 混入 插件 scoped 样式 总结 TodoList 案例 webStorage 组件的自定义事件 全局事件总线（GlobalEventBus） 消息订阅与发布（pubsub） nextTick Vue 封装的过度与动画 vue 脚手架配置代理 方法一 方法二 插槽 默认插槽 具名插槽 作用域插槽 inheritAttrs + $attrs + $listeners 挂载全局变量",content:'传统方式的缺点\n\n传统方式编写应用，依赖关系混乱，代码复用率不高\n\n\n# 几个概念\n\n\n# 模块\n\n向外提供特定功能的 js 程序，一般就是一个 js 文件\n\n为什么？js 文件很多很复杂。\n\n作用：可以复用 js，简化 js 的编写，提高 js 的运行效率\n\n\n# 组件\n\n实现应用中局部功能的代码（(html,css,js)和资源(mp3,mp4,字体....)的集合\n\n为什么？一个界面的功能很复杂\n\n作用：复用编码，简化项目编码，提高运行效率\n\n\n# 模块化\n\n当应用中的 js 都以模块来编写的，那这个应用就是一个模块化的应用。\n\n\n# 组件化\n\n当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用。\n\n\n# 组件\n\n提示\n\n非单文件组件和单文件组件的区别：“非单文件组件一个文件中包含有 n 个组件，单文件组件一个文件只包含一个组件“\n\nVue 中使用组件的步骤：\n\n 1. 定义组件(创建组件)\n\n 2. 注册组件\n\n 3. 使用组件(写组件标签)\n\n如何定义一个组件？\n\n使用 Vue.extend(options)创建，其中 options 和 new Vue(options)时传入的那个 options几乎一样，但也有点区别；\n\n区别如下：\n\n1.el不要写，为什么？ ——— 最终所有的组件都要经过一个 vm 的管理，由 vm 中的 el 决定服务哪个容器\n\n2.data 必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。\n\n备注：使用 template 可以配置组件结构\n\n如何注册组件？\n\n 1. 局部注册：靠 new Vue 的时候传入 components 选项\n\n 2. 全局注册：靠 Vue.component(\'组件名\',组件)\n\n编写组件标签：\n\n<school></school>\n\n\n一个例子：\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>非单文件组件基本使用</title>\n        <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    </head>\n    <body>\n        <div id="root">\n            {{msg}}\n            <hello></hello>\n        </div>\n        <div id="root2">\n            {{msg2}}\n            <hello></hello>\n        </div>\n\n        <script type="text/javascript">\n            Vue.config.productionTip = false\n            const hello = Vue.extend({\n                name: \'hello\',\n                template: `<div>hello!\n            <button @click=\'alertHello\'>点我点我</button>\n            </div>\n        `,\n                methods: {\n                    alertHello() {\n                        alert(\'hello\')\n                    },\n                },\n            })\n            // 全局注册\n            Vue.component(\'hello\', hello)\n            new Vue({\n                el: \'#root\',\n                //  components:{\n                //     //  局部注册\n                //      hello:hello\n                //  },\n                data() {\n                    return {\n                        msg: \'frank你好！\',\n                    }\n                },\n            })\n            new Vue({\n                el: \'#root2\',\n                data() {\n                    return {\n                        msg2: \'alex你好！\',\n                    }\n                },\n            })\n        <\/script>\n    </body>\n</html>\n\n\n\n# 组件的几个注意点\n\n1.关于组件名:\n\n第一种写法(kebab-case命名)：my-school\n\n第二种写法(CamelCase 命名)：MySchool,在模板中一样可以使用my-school这种写法\n\n备注：\n\n(1).组件名尽可能回避 HTML 中已有的元素名称，例如：h2、H2 都不行。\n\n(2).可以使用 name 配置项指定组件在开发者工具中呈现的名字。\n\n2.关于组件标签:\n\n第一种写法：<school></school>\n\n第二种写法：<school/>\n\n3.一个简写方式：\n\nconst school = Vue.extend(options) 可简写为：const school = options\n\n\n# 组件的嵌套\n\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset="UTF-8" />\n        <title>组件的嵌套</title>\n        \x3c!-- 引入Vue --\x3e\n        <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    </head>\n    <body>\n        \x3c!-- 准备好一个容器--\x3e\n        <div id="root"></div>\n    </body>\n\n    <script type="text/javascript">\n        Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。\n\n        //定义student组件\n        const student = Vue.extend({\n            name: \'student\',\n            template: `\n\t\t\t\t<div>\n\t\t\t\t\t<h2>学生姓名：{{name}}</h2>\t\n\t\t\t\t\t<h2>学生年龄：{{age}}</h2>\t\n\t\t\t\t</div>\n\t\t\t`,\n            data() {\n                return {\n                    name: \'frank\',\n                    age: 18,\n                }\n            },\n        })\n\n        //定义school组件\n        const school = Vue.extend({\n            name: \'school\',\n            template: `\n\t\t\t\t<div>\n\t\t\t\t\t<h2>学校名称：{{name}}</h2>\t\n\t\t\t\t\t<h2>学校地址：{{address}}</h2>\t\n\t\t\t\t\t<student></student>\n\t\t\t\t</div>\n\t\t\t`,\n            data() {\n                return {\n                    name: \'SNUT\',\n                    address: \'HAN ZHONG\',\n                }\n            },\n            //注册组件（局部）\n            components: {\n                student,\n            },\n        })\n\n        //定义hello组件\n        const hello = Vue.extend({\n            template: `<h1>{{msg}}</h1>`,\n            data() {\n                return {\n                    msg: \'欢迎来到SNUT学习！\',\n                }\n            },\n        })\n\n        //定义app组件\n        const app = Vue.extend({\n            template: `\n\t\t\t\t<div>\t\n\t\t\t\t\t<hello></hello>\n\t\t\t\t\t<school></school>\n\t\t\t\t</div>\n\t\t\t`,\n            components: {\n                school,\n                hello,\n            },\n        })\n\n        //创建vm\n        new Vue({\n            template: \'<app></app>\',\n            el: \'#root\',\n            //注册组件（局部）\n            components: { app },\n        })\n    <\/script>\n</html>\n\n\n\n# VueComponent 构造函数\n\n1.school 组件本质是一个名为 VueComponent 的构造函数，且不是程序员定义的，是 Vue.extend 生成的\n\n2.我们只需要写<school/>或<school></school>，Vue 解析时会帮我们创建 school 组件的实例对象，即 Vue 帮我们执行的：new VueComponent(options)。\n\n3.特别注意：每次调用 Vue.extend，返回的都是一个全新的 VueComponent\n\n// Vue.extend源码\nVue.extend = function (extendOptions) {\n    // ......\n    var Sub = function VueComponent(options) {\n        this._init(options)\n    }\n    // ......\n    return Sub\n}\n\n\n4.关于this 指向：\n\n(1).组件配置中：\n\ndata 函数、methods 中的函数、watch 中的函数、computed 中的函数 它们的 this 均是VueComponent实例对象\n\n(2).new Vue(options)配置中：\n\ndata函数、methods中的函数、watch中的函数、computed 中的函数 它们的 this 均是Vue实例对象\n\n5.VueComponent的实例对象，以后简称 vc（也可称之为：组件实例对象）。Vue 的实例对象，简称 vm。\n\n一个重要的内置关系\n\n\n\n1.一个重要的内置关系：VueComponent.prototype.__proto__=== Vue.prototype\n\n2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue 原型上的属性、方法。\n\n\n# vue 脚手架\n\n注意\n\n最新版本 4.x\n\n\n# 使用\n\n 1. 全局安装 vue 脚手架:npm i -g @vue/cli\n\n 2. 创建项目:vue create xxx\n\n\n# 脚手架文件结构\n\n\t├── node_modules\n\t├── public\n\t│   ├── favicon.ico: 页签图标\n\t│   └── index.html: 主页面\n\t├── src\n\t│   ├── assets: 存放静态资源\n\t│   │   └── logo.png\n\t│   │── component: 存放组件\n\t│   │   └── HelloWorld.vue\n\t│   │── App.vue: 汇总所有组件\n\t│   │── main.js: 入口文件\n\t├── .gitignore: git版本管制忽略的配置\n\t├── babel.config.js: babel的配置文件\n\t├── package.json: 应用包配置文件\n\t├── README.md: 应用描述文件\n\t├── package-lock.json：包版本控制文件\n\n\n\n# render 函数\n\nvue 工程中的main.js中的render函数\n\n 1. vue.js 与 vue.runtime.xxx.js 的区别：\n\n(1).vue.js 是完整版的 Vue，包含：核心功能+模板解析器。\n\n(2).vue.runtime.xxx.js 是运行版的 Vue，只包含：核心功能；没有模板解析器。\n\n 2. 因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用 template 配置项，需要使用render函数接收到的createElement函数去指定具体内容。\n\n\n# vue.config.js 配置文件\n\n 1. 使用vue inspect > output.js可以查看到 Vue 脚手架的默认配置。\n 2. 使用 vue.config.js 可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh\n\n\n# ref 属性\n\n 1. 被用来给元素或子组件注册引用信息（id 的替代者）\n 2. 应用在 html 标签上获取的是真实 DOM 元素，应用在组件标签上是组件实例对象（vc）\n 3. 使用方式：\n    1. 打标识：<h1 ref="xxx">.....</h1> 或 <School ref="xxx"></School>\n    2. 获取：this.$refs.xxx\n\n\n# props 配置项\n\n 1. 功能：让组件接收外部传过来的数据\n\n 2. 传递数据：<Demo name="xxx"/>\n\n 3. 接收数据：\n    \n    1. 第一种方式（只接收）：```props:[\'name\'] ```\n    \n    2. 第二种方式（限制类型）：```props:{name:String}```\n    \n    3. 第三种方式（限制类型、限制必要性、指定默认值）：\n    \n        ```js\n        props:{\n        \tname:{\n        \ttype:String, //类型\n        \trequired:true, //必要性\n        \tdefault:\'老王\' //默认值\n        \t}\n        }\n        ```\n    \n    \n    注意\n    \n    props 是只读的，Vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制 props 的内容到 data 中一份，然后去修改 data 中的数据。\n\n\n# mixin 混入\n\n 1. 功能：可以把多个组件共用的配置提取成一个混入对象\n\n 2. 使用方式：\n    \n    第一步在 js 文件中定义混合：\n    \n    export default {\n        data(){....},\n        methods:{....}\n        ....\n    }\n    \n    \n    第二步使用混入：\n    \n    在 mian.js 中全局混入：Vue.mixin(xxx) 在组件中局部混入：mixins:[xxx]\n\n\n# 插件\n\n 1. 功能：用于增强 Vue\n\n 2. 本质：包含 install 方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据。\n\n 3. 定义插件： xxx.js\n\n\texport default{\n\t\tinstall(Vue, options) {\n        // 1. 添加全局过滤器\n        Vue.filter(....)\n\n        // 2. 添加全局指令\n        Vue.directive(....)\n\n        // 3. 配置全局混入(合)\n        Vue.mixin(....)\n\n        // 4. 添加实例方法\n        Vue.prototype.$myMethod = function () {...}\n        Vue.prototype.$myProperty = xxxx\n    }\n\t}\n\n\n 4. 使用插件：Vue.use(xxx)\n\n\n# scoped 样式\n\n 1. 作用：让样式在局部生效，防止冲突。\n 2. 写法：<style scoped>\n\n\n# 总结 TodoList 案例\n\n 1. 组件化编码流程：\n\n(1).拆分静态组件：组件要按照功能点拆分，命名不要与 html 元素冲突。\n\n(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：\n\n1).一个组件在用：放在组件自身即可。\n\n​2). 一些组件在用：放在他们共同的父组件上（这种行为被称为状态提升）\n\n\n(3).实现交互：从绑定事件开始。\n\n 2. props 适用于：\n    \n    (1).父组件 ==> 子组件 通信\n    \n    (2).子组件 ==> 父组件 通信（要求父先给子一个函数）\n\n 3. 使用 v-model 时要切记：v-model 绑定的值不能是 props 传过来的值，因为 props 是不可以修改的！\n\n 4. props 传过来的若是对象类型的值，修改对象中的属性时 Vue 不会报错，但不推荐这样做。\n\n 5. oninput 事件类似于 onchange 事件。不同之处在于 oninput 事件在元素值发生变化是立即触发， onchange 在元素失去焦点时触发。另外一点不同是 onchange 事件也可以作用于 <keygen> 和 <select> 元素。\n\n * oninput 事件\n * onchange 事件\n\n\n# webStorage\n\n 1. 存储内容大小一般支持 5MB 左右（不同浏览器可能还不一样）\n\n 2. 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。\n\n 3. 相关 API：\n    \n    1. xxxxxStorage.setItem(\'key\', \'value\'); 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n    \n    2. xxxxxStorage.getItem(\'person\');\n       \n       该方法接受一个键名作为参数，返回键名对应的值。\n    \n    3. xxxxxStorage.removeItem(\'key\');\n       \n       该方法接受一个键名作为参数，并把该键名从存储中删除。\n    \n    4. xxxxxStorage.clear()\n       \n       该方法会清空存储中的所有数据。\n\n 4. 备注：\n    \n    1. SessionStorage 存储的内容会随着浏览器窗口关闭而消失。\n    2. LocalStorage存储的内容，需要手动清除才会消失。\n    3. xxxxxStorage.getItem(xxx)如果 xxx 对应的 value 获取不到，那么 getItem的返回值是 null。\n    4. JSON.parse(null)的结果依然是 null。\n\n\n# 组件的自定义事件\n\n 1. 一种组件间通信的方式，适用于：子组件 ===> 父组件\n\n 2. 使用场景：A 是父组件，B 是子组件，B 想给 A 传数据，那么就要在 A 中给 B 绑定自定义事件（事件的回调在 A 中）。\n\n 3. 绑定自定义事件：\n    \n    1. 第一种方式，在父组件中：<Demo @getData="getData"/> 或 <Demo v-on:getData="getData"/>\n    \n    2. 第二种方式，在父组件中：\n\n;<Child ref="demo" />\n// ......\nexport default {\n    methods: {\n        getData(data) {\n            console.log(data)\n        },\n    },\n    mounted() {\n        this.$refs.Child.$on(\'getData\', this.getData)\n    },\n}\n\n\n 3. 触发自定义事件：this.$emit(\'atguigu\',数据)\n\n 4. 若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。\n\n 5. 解绑自定义事件this.$off(\'atguigu\');解绑多个自定义事件this.$off([\'atguigu\',\'demo\']);解绑所有的自定义事件：this.$off()\n\n 6. 组件上也可以绑定原生 DOM事件，需要使用native修饰符。\n\n 7. 注意：通过this.$refs.xxx.$on(\'atguigu\',回调)绑定自定义事件时，回调要么配置在 methods 中，要么用箭头函数，否则 this指向会出问题(该回调中的 this 指向触发自定义事件的组件实例对象)\n\n\n# 全局事件总线（GlobalEventBus）\n\n实现全局事件总线的前提\n\n * 所有组件都可以看到\n * 可以调用$on,$off,$emit\n\n 1. 一种组件间通信的方式，适用于任意组件间通信。\n\n 2. 安装全局事件总线：\n\n// main.js\nnew Vue({\n    // ......\n    beforeCreate() {\n        Vue.prototype.$bus = this //安装全局事件总线，$bus 就是当前应用的 vm\n    },\n    // ......\n})\n\n\n 3. 使用事件总线：\n    \n    1. 接收数据：A 组件想接收数据，则在 A 组件中给$bus 绑定自定义事件，事件的回调留在 A 组件自身。\n    \n    2. 提供数据：this.$bus.$emit(\'xxxx\',数据)\n    \n    3. 最好在beforeDestroy 钩子中，用 $off 去解绑当前组件所用到的事件。\n\nexport default {\n    // ......\n    methods: {\n        getData(data) {\n            console.log(data)\n        },\n    },\n    mounted() {\n        // 给bus绑定自定义事件\n        this.$bus.$on(\'getData\', this.getData)\n    },\n    beforeDestroy() {\n        this.$bus.$off(\'getData\')\n    },\n}\n\n\n\n# 消息订阅与发布（pubsub）\n\n警告\n\n经本人测试 订阅消息数据参数只能有一个 如果存在多个参数 请将参数包装成对象传递\n\n最好在 beforeDestroy 钩子中，用pubsub.unsubscribe(this.pid)去取消订阅。\n\n 1. 一种组件间通信的方式，适用于任意组件间通信。\n\n 2. 使用步骤：\n    \n    1. 安装 pubsub：npm i pubsub-js\n    \n    2. 引入: import pubsub from \'pubsub-js\'\n    \n    3. 接收数据（订阅消息）：A 组件想接收数据，则在 A 组件中订阅消息，订阅的回调留在 A 组件自身。\n    \n    4. 提供数据(发布消息)：pubsub.publish(\'消息名\',数据)\n\nexport default {\n    // 接受数据\n    methods: {\n        sub(msgName, data) {\n            // 如果不想接收msgName(消息的名字),可以使用"_"占位\n            console.log(msgName, data)\n        },\n    },\n    mounted() {\n        this.pid = pubsub.subscribe(\'getData\', this.sub) //订阅消息\n    },\n    //   取消订阅\n    beforeDestroy() {\n        pubsub.unsubscribe(this.pid)\n    },\n}\n\n\n// 发布数据\nexport default {\n    methods: {\n        pub() {\n            pubsub.publish(\'getData\', \'数据\')\n        },\n    },\n}\n\n\n\n# nextTick\n\n 1. 语法：this.$nextTick(回调函数)\n 2. 作用：在下一次 DOM 更新结束后执行其指定的回调。\n 3. 什么时候用：当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 nextTick 所指定的回调函数中执行。\n\n\n# Vue 封装的过度与动画\n\n官方文档\n\n 1. 作用：在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名。\n\n 2. 写法：\n    \n    1. 准备好样式(class)：\n       \n       * 元素进入的样式：\n         1. v-enter：进入的起点\n         2. v-enter-active：进入过程中\n         3. v-enter-to：进入的终点\n       * 元素离开的样式：\n         1. v-leave：离开的起点\n         2. v-leave-active：离开过程中\n         3. v-leave-to：离开的终点\n    \n    2. 使用<transition>包裹要过度的元素，并配置 name 属性：\n\n提示\n\n给 transition 加上 name 属性 xxx,就需要将类名 v-...改成 xxx-...\n\n对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <transition>，则 v- 是这些类名的默认前缀。如果你使用了 <transition name="my-transition">，那么 v-enter 会替换为 my-transition-enter\n\n<transition name="hello">\n    <h1 v-show="isShow">你好啊！</h1>\n</transition>\n\n\n 3. 备注：若有多个元素需要过度，则需要使用：<transition-group>，且每个元素都要指定key值。\n\n 4. 可以通过 appear attribute 设置节点在初始渲染的过渡\n\n<transition appear>\n  \x3c!-- ... --\x3e\n</transition>\n\n\n 5. 使用第三方动画库 animate.css\n\nanimate.css是强大的跨平台的预设 css3 动画库\n\n安装:npm install animate.css --save\n\n引入:import "animate.css"\n\n使用第三方动画库需要通过以下 attribute 来自定义过渡类名\n\n * enter-class\n * enter-active-class\n * enter-to-class (2.1.8+)\n * leave-class\n * leave-active-class\n * leave-to-class (2.1.8+)\n\n一个栗子:\n\n<transition-group\n    appear\n    // 必须\n    name="animate__animated animate__bounce"\n    // 自定义过渡类名\n    enter-active-class="animate__swing"\n    leave-active-class="animate__backOutUp"\n>\n    <h1 v-show="!isShow" key="1">\n        你好啊！\n    </h1>\n    <h1 v-show="isShow" key="2">\n        尚硅谷！\n    </h1>\n</transition-group>\n\n\n\n# vue 脚手架配置代理\n\n\n# 方法一\n\n在 vue.config.js 中添加如下配置：\n\ndevServer: {\n    proxy: \'http://localhost:5000\'\n}\n\n\n说明：\n\n 1. 优点：配置简单，请求资源时直接发给前端（8080）即可。\n 2. 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。\n 3. 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）\n\n\n# 方法二\n\n编写 vue.config.js 配置具体代理规则：\n\nmodule.exports = {\n    devServer: {\n        proxy: {\n            \'/api1\': {\n                // 匹配所有以 \'/api1\'开头的请求路径\n                target: \'http://localhost:5000\', // 代理目标的基础路径\n                changeOrigin: true,\n                pathRewrite: { \'^/api1\': \'\' },\n            },\n            \'/api2\': {\n                // 匹配所有以 \'/api2\'开头的请求路径\n                target: \'http://localhost:5001\', // 代理目标的基础路径\n                changeOrigin: true,\n                pathRewrite: { \'^/api2\': \'\' },\n            },\n        },\n    },\n}\n/*\n   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000\n   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080\n   changeOrigin默认值为true\n*/\n\n\n说明：\n\n 1. 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。\n 2. 缺点：配置略微繁琐，请求资源时必须加前缀。\n\n\n# 插槽\n\n官方文档:插槽\n\n废弃的语法\n\n在 Vue 2.6.0 中，为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除的 API，在接下来所有的 2.x 版本中 slot 和 slot-scope attribute 仍会被支持，但已经被官方废弃且不会出现在 Vue 3 中。\n\n 1. 作用：让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于 父组件 ===> 子组件;父级模板里的所有内容都是在父级作用域中编译的,子模板里的所有内容都是在子作用域中编译的，也就说插槽可以访问父组件中的数据，但不能访问子组件中的数据\n\n 2. 分类：默认插槽、具名插槽、作用域插槽\n\n\n# 默认插槽\n\n\x3c!-- 父组件中： --\x3e\n<Category>\n    <div>this is a div</div>\n</Category>\n\n\x3c!-- 子组件中： --\x3e\n<template>\n    <div>\n        \x3c!-- 定义插槽 --\x3e\n        <slot>插槽默认内容</slot>\n    </div>\n</template>\n\n\n\n# 具名插槽\n\n一个不带 name 的 <slot> 出口会带有隐含的名字:default\n\nv-slot一般只能定义在template上 注：特殊情况见作用域插槽\n\n\x3c!-- 父组件中： --\x3e\n<template>\n    <div id="app">\n        <HelloWorld>\n            <template v-slot:header><div>this is header</div> </template>\n            \x3c!-- 默认插槽：任何没有被包裹在带有 v-slot 的 <template> 中的内容都会被视为默认插槽的内容。 --\x3e\n            <div>this is default</div>\n            \x3c!-- 如果你希望更明确一些，仍然可以在一个 <template> 中包裹默认插槽的内容 --\x3e\n            \x3c!-- <template v-slot:default><div>this is default</div></template> --\x3e\n            <template v-slot:main><div>this is main</div></template>\n            <template v-slot:footer><div>this is footer</div></template>\n        </HelloWorld>\n    </div>\n</template>\n\x3c!-- 子组件中： --\x3e\n<template>\n    <div>\n        \x3c!-- 定义插槽 --\x3e\n        <slot></slot>\n        <slot name="header">插槽默认内容</slot>\n        <slot name="main"> 插槽默认内容</slot>\n        <slot name="footer">插槽默认内容</slot>\n    </div>\n</template>\n\n\n使用“#“缩写\n\n\x3c!-- 父组件中： --\x3e\n<HelloWorld>\n    <template #header><div>this is header</div> </template>\n    <template #main><div>this is main</div></template>\n    <template #footer><div>this is footer</div></template>\n</HelloWorld>\n\x3c!-- 子组件中： --\x3e\n<template>\n    <div>\n        \x3c!-- 定义插槽 --\x3e\n        <slot name="header">插槽默认内容</slot>\n        <slot name="main"> 插槽默认内容</slot>\n        <slot name="footer">插槽默认内容</slot>\n    </div>\n</template>\n\n\n\n# 作用域插槽\n\n 1. 理解：数据定义在子组件，父组件想要访问定义在子组件中的数据\n\n 2. v-slot只能添加在 <template>的例外情况：当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样就可以把 v-slot 直接用在组件上:\n\n\x3c!--  `v-slot` 直接用在组件上 --\x3e\n<current-user v-slot:default="slotProps">\n    {{ slotProps.userName }}\n</current-user>\n\n\x3c!-- 就像假定未指明的内容对应默认插槽一样，不带参数的 v-slot 被假定对应默认插槽 --\x3e\n<current-user v-slot="slotProps"> {{ slotProps.userName }} </current-user>\n\n\x3c!-- 默认插槽的缩写语法(上面👆的写法)不能和具名插槽混用，无效会导致警告 --\x3e\n\x3c!-- 所以只要出现多个插槽，请始终为所有的插槽使用完整的基于 `<template>` 的语法 --\x3e\n\n\n 3. 使用“#“缩写\n\n和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：\n\n\x3c!-- 这样会触发一个警告 --\x3e\n<current-user #="slotProps"> {{ slotProps.userName }} </current-user>\n\n\n如果使用缩写的话，必须始终明确插槽名：\n\n<current-user #default="slotProps"> {{ slotProps.userName }} </current-user>\n\n\n 4. 具体编码（games数据在Category组件中， 父组件通过插槽能够访问Category子组件中才有的数据）：\n\n\x3c!-- 父组件中 --\x3e\n<template>\n    <div id="app">\n        <img alt="Vue logo" src="./assets/logo.png" />\n        \x3c!-- 特殊情况，被提供的内容只有默认插槽 --\x3e\n        <HelloWorld v-slot="slotProps">\n            <h2>{{ slotProps.msg }}</h2></HelloWorld\n        >\n    </div>\n</template>\n\n\x3c!-- 子组件中： --\x3e\n<template>\n    <div class="hello">\n        <slot :msg="msg"></slot>\n    </div>\n</template>\n\n<script>\n    export default {\n        name: \'HelloWorld\',\n        data() {\n            return {\n                msg: \'frank chang is handsome man\',\n            }\n        },\n    }\n<\/script>\n\n\n 5. 解构插槽 Prop\n\n适用情况:插槽提供了多个 prop 的时候\n\n\x3c!-- 父组件 --\x3e\n<template>\n    <div id="app">\n        <img alt="Vue logo" src="./assets/logo.png" />\n        <HelloWorld v-slot="{ user, msg }">\n            <h2>{{ user.name }}</h2>\n            <h3>{{ msg }}</h3>\n        </HelloWorld>\n    </div>\n</template>\n\x3c!-- 子组件 --\x3e\n<template>\n    <div class="hello">\n        <slot :user="user" :msg="msg"></slot>\n    </div>\n</template>\n<script>\n    export default {\n        name: \'HelloWorld\',\n        data() {\n            return {\n                user: { name: \'frank\', age: 18 },\n                msg: \'frank is a man\',\n            }\n        },\n    }\n<\/script>\n\n\n定义后备内容，用于插槽 `prop` 是 `undefined `的情形\n\n\x3c!-- 父组件 --\x3e\n<template>\n    <div id="app">\n        <img alt="Vue logo" src="./assets/logo.png" />\n        <HelloWorld\n            v-slot="{ user={name:\'not a found\' age:\'null\'}, msg=\'not a found\' }"\n        >\n            <h2>{{ user.name}},{{user.age }}</h2>\n            <h3>{{ msg }}</h3>\n        </HelloWorld>\n    </div>\n</template>\n\x3c!-- 子组件 --\x3e\n<template>\n    <div class="hello">\n        <slot :user="user" :msg="msg"></slot>\n    </div>\n</template>\n<script>\n    export default {\n        name: \'HelloWorld\',\n        data() {\n            return {\n                user: { name: \'frank\', age: 18 },\n                msg: \'frank is a man\',\n            }\n        },\n    }\n<\/script>\n\n\n\n# inheritAttrs + $attrs + $listeners\n\n * inheritAttrs\n\n当我们在使用组件时，为其传递的参数要在组件的props中进行定义，才能够使用。如果没有定义，则这个属性会作为这个 DOM 结构根节点的attribute被渲染。\n\n1.当设置inheritAttrs: true（默认）时，子组件的顶层标签元素中会渲染出父组件传递过来的且未在 props 中定义的属性\n\n2.当设置inheritAttrs: false时，子组件的顶层标签元素中不会渲染出父组件传递过来的且未在 props 中定义的属性\n\n * $attrs\n\n$attrs 是一个内置属性，指父组件传递的、除了自己定义的 props 属性之外的所有属性。\n\n * $listeners(在 Vue 3 中已被移除,事件监听器现在是 $attrs 的一部分)\n\n$listeners 包含了作用在这个组件上所有的监听器，即父组件绑定的全部监听事件，通过 v-on="$listeners"，可以将这些事件绑定给它自己的子组件。\n\n * $attrs + $listeners实现爷孙组件事件通信\n   \n   * 爷传孙：把想要传给孙组件的数据先传给父组件，在父组件中通过v-bind=\'$attrs\'把数据传给孙子组件,在父组件不要定义 props\n   \n   * 孙传爷：\n     \n     1. 在爷组件中,给父组件绑定自定义事件\n     \n     2. 在父组件中,通过:v-on="$listeners",可以将这些事件绑定给它孙组件(vue3 通过v-bind=$attrs)\n     \n     3. 在孙组件中通过this.$emit触发自定义事件\n\n\n# 挂载全局变量\n\n如果需要设置全局变量，可以通过在 main.js 中，在 Vue 原型上添加属性实现全局变量\n\nVue.prototype.$appName = \'My App\'\n',normalizedContent:'传统方式的缺点\n\n传统方式编写应用，依赖关系混乱，代码复用率不高\n\n\n# 几个概念\n\n\n# 模块\n\n向外提供特定功能的 js 程序，一般就是一个 js 文件\n\n为什么？js 文件很多很复杂。\n\n作用：可以复用 js，简化 js 的编写，提高 js 的运行效率\n\n\n# 组件\n\n实现应用中局部功能的代码（(html,css,js)和资源(mp3,mp4,字体....)的集合\n\n为什么？一个界面的功能很复杂\n\n作用：复用编码，简化项目编码，提高运行效率\n\n\n# 模块化\n\n当应用中的 js 都以模块来编写的，那这个应用就是一个模块化的应用。\n\n\n# 组件化\n\n当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用。\n\n\n# 组件\n\n提示\n\n非单文件组件和单文件组件的区别：“非单文件组件一个文件中包含有 n 个组件，单文件组件一个文件只包含一个组件“\n\nvue 中使用组件的步骤：\n\n 1. 定义组件(创建组件)\n\n 2. 注册组件\n\n 3. 使用组件(写组件标签)\n\n如何定义一个组件？\n\n使用 vue.extend(options)创建，其中 options 和 new vue(options)时传入的那个 options几乎一样，但也有点区别；\n\n区别如下：\n\n1.el不要写，为什么？ ——— 最终所有的组件都要经过一个 vm 的管理，由 vm 中的 el 决定服务哪个容器\n\n2.data 必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。\n\n备注：使用 template 可以配置组件结构\n\n如何注册组件？\n\n 1. 局部注册：靠 new vue 的时候传入 components 选项\n\n 2. 全局注册：靠 vue.component(\'组件名\',组件)\n\n编写组件标签：\n\n<school></school>\n\n\n一个例子：\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <meta http-equiv="x-ua-compatible" content="ie=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>非单文件组件基本使用</title>\n        <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    </head>\n    <body>\n        <div id="root">\n            {{msg}}\n            <hello></hello>\n        </div>\n        <div id="root2">\n            {{msg2}}\n            <hello></hello>\n        </div>\n\n        <script type="text/javascript">\n            vue.config.productiontip = false\n            const hello = vue.extend({\n                name: \'hello\',\n                template: `<div>hello!\n            <button @click=\'alerthello\'>点我点我</button>\n            </div>\n        `,\n                methods: {\n                    alerthello() {\n                        alert(\'hello\')\n                    },\n                },\n            })\n            // 全局注册\n            vue.component(\'hello\', hello)\n            new vue({\n                el: \'#root\',\n                //  components:{\n                //     //  局部注册\n                //      hello:hello\n                //  },\n                data() {\n                    return {\n                        msg: \'frank你好！\',\n                    }\n                },\n            })\n            new vue({\n                el: \'#root2\',\n                data() {\n                    return {\n                        msg2: \'alex你好！\',\n                    }\n                },\n            })\n        <\/script>\n    </body>\n</html>\n\n\n\n# 组件的几个注意点\n\n1.关于组件名:\n\n第一种写法(kebab-case命名)：my-school\n\n第二种写法(camelcase 命名)：myschool,在模板中一样可以使用my-school这种写法\n\n备注：\n\n(1).组件名尽可能回避 html 中已有的元素名称，例如：h2、h2 都不行。\n\n(2).可以使用 name 配置项指定组件在开发者工具中呈现的名字。\n\n2.关于组件标签:\n\n第一种写法：<school></school>\n\n第二种写法：<school/>\n\n3.一个简写方式：\n\nconst school = vue.extend(options) 可简写为：const school = options\n\n\n# 组件的嵌套\n\n<!doctype html>\n<html>\n    <head>\n        <meta charset="utf-8" />\n        <title>组件的嵌套</title>\n        \x3c!-- 引入vue --\x3e\n        <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    </head>\n    <body>\n        \x3c!-- 准备好一个容器--\x3e\n        <div id="root"></div>\n    </body>\n\n    <script type="text/javascript">\n        vue.config.productiontip = false //阻止 vue 在启动时生成生产提示。\n\n        //定义student组件\n        const student = vue.extend({\n            name: \'student\',\n            template: `\n\t\t\t\t<div>\n\t\t\t\t\t<h2>学生姓名：{{name}}</h2>\t\n\t\t\t\t\t<h2>学生年龄：{{age}}</h2>\t\n\t\t\t\t</div>\n\t\t\t`,\n            data() {\n                return {\n                    name: \'frank\',\n                    age: 18,\n                }\n            },\n        })\n\n        //定义school组件\n        const school = vue.extend({\n            name: \'school\',\n            template: `\n\t\t\t\t<div>\n\t\t\t\t\t<h2>学校名称：{{name}}</h2>\t\n\t\t\t\t\t<h2>学校地址：{{address}}</h2>\t\n\t\t\t\t\t<student></student>\n\t\t\t\t</div>\n\t\t\t`,\n            data() {\n                return {\n                    name: \'snut\',\n                    address: \'han zhong\',\n                }\n            },\n            //注册组件（局部）\n            components: {\n                student,\n            },\n        })\n\n        //定义hello组件\n        const hello = vue.extend({\n            template: `<h1>{{msg}}</h1>`,\n            data() {\n                return {\n                    msg: \'欢迎来到snut学习！\',\n                }\n            },\n        })\n\n        //定义app组件\n        const app = vue.extend({\n            template: `\n\t\t\t\t<div>\t\n\t\t\t\t\t<hello></hello>\n\t\t\t\t\t<school></school>\n\t\t\t\t</div>\n\t\t\t`,\n            components: {\n                school,\n                hello,\n            },\n        })\n\n        //创建vm\n        new vue({\n            template: \'<app></app>\',\n            el: \'#root\',\n            //注册组件（局部）\n            components: { app },\n        })\n    <\/script>\n</html>\n\n\n\n# vuecomponent 构造函数\n\n1.school 组件本质是一个名为 vuecomponent 的构造函数，且不是程序员定义的，是 vue.extend 生成的\n\n2.我们只需要写<school/>或<school></school>，vue 解析时会帮我们创建 school 组件的实例对象，即 vue 帮我们执行的：new vuecomponent(options)。\n\n3.特别注意：每次调用 vue.extend，返回的都是一个全新的 vuecomponent\n\n// vue.extend源码\nvue.extend = function (extendoptions) {\n    // ......\n    var sub = function vuecomponent(options) {\n        this._init(options)\n    }\n    // ......\n    return sub\n}\n\n\n4.关于this 指向：\n\n(1).组件配置中：\n\ndata 函数、methods 中的函数、watch 中的函数、computed 中的函数 它们的 this 均是vuecomponent实例对象\n\n(2).new vue(options)配置中：\n\ndata函数、methods中的函数、watch中的函数、computed 中的函数 它们的 this 均是vue实例对象\n\n5.vuecomponent的实例对象，以后简称 vc（也可称之为：组件实例对象）。vue 的实例对象，简称 vm。\n\n一个重要的内置关系\n\n\n\n1.一个重要的内置关系：vuecomponent.prototype.__proto__=== vue.prototype\n\n2.为什么要有这个关系：让组件实例对象（vc）可以访问到 vue 原型上的属性、方法。\n\n\n# vue 脚手架\n\n注意\n\n最新版本 4.x\n\n\n# 使用\n\n 1. 全局安装 vue 脚手架:npm i -g @vue/cli\n\n 2. 创建项目:vue create xxx\n\n\n# 脚手架文件结构\n\n\t├── node_modules\n\t├── public\n\t│   ├── favicon.ico: 页签图标\n\t│   └── index.html: 主页面\n\t├── src\n\t│   ├── assets: 存放静态资源\n\t│   │   └── logo.png\n\t│   │── component: 存放组件\n\t│   │   └── helloworld.vue\n\t│   │── app.vue: 汇总所有组件\n\t│   │── main.js: 入口文件\n\t├── .gitignore: git版本管制忽略的配置\n\t├── babel.config.js: babel的配置文件\n\t├── package.json: 应用包配置文件\n\t├── readme.md: 应用描述文件\n\t├── package-lock.json：包版本控制文件\n\n\n\n# render 函数\n\nvue 工程中的main.js中的render函数\n\n 1. vue.js 与 vue.runtime.xxx.js 的区别：\n\n(1).vue.js 是完整版的 vue，包含：核心功能+模板解析器。\n\n(2).vue.runtime.xxx.js 是运行版的 vue，只包含：核心功能；没有模板解析器。\n\n 2. 因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用 template 配置项，需要使用render函数接收到的createelement函数去指定具体内容。\n\n\n# vue.config.js 配置文件\n\n 1. 使用vue inspect > output.js可以查看到 vue 脚手架的默认配置。\n 2. 使用 vue.config.js 可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh\n\n\n# ref 属性\n\n 1. 被用来给元素或子组件注册引用信息（id 的替代者）\n 2. 应用在 html 标签上获取的是真实 dom 元素，应用在组件标签上是组件实例对象（vc）\n 3. 使用方式：\n    1. 打标识：<h1 ref="xxx">.....</h1> 或 <school ref="xxx"></school>\n    2. 获取：this.$refs.xxx\n\n\n# props 配置项\n\n 1. 功能：让组件接收外部传过来的数据\n\n 2. 传递数据：<demo name="xxx"/>\n\n 3. 接收数据：\n    \n    1. 第一种方式（只接收）：```props:[\'name\'] ```\n    \n    2. 第二种方式（限制类型）：```props:{name:string}```\n    \n    3. 第三种方式（限制类型、限制必要性、指定默认值）：\n    \n        ```js\n        props:{\n        \tname:{\n        \ttype:string, //类型\n        \trequired:true, //必要性\n        \tdefault:\'老王\' //默认值\n        \t}\n        }\n        ```\n    \n    \n    注意\n    \n    props 是只读的，vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制 props 的内容到 data 中一份，然后去修改 data 中的数据。\n\n\n# mixin 混入\n\n 1. 功能：可以把多个组件共用的配置提取成一个混入对象\n\n 2. 使用方式：\n    \n    第一步在 js 文件中定义混合：\n    \n    export default {\n        data(){....},\n        methods:{....}\n        ....\n    }\n    \n    \n    第二步使用混入：\n    \n    在 mian.js 中全局混入：vue.mixin(xxx) 在组件中局部混入：mixins:[xxx]\n\n\n# 插件\n\n 1. 功能：用于增强 vue\n\n 2. 本质：包含 install 方法的一个对象，install 的第一个参数是 vue，第二个以后的参数是插件使用者传递的数据。\n\n 3. 定义插件： xxx.js\n\n\texport default{\n\t\tinstall(vue, options) {\n        // 1. 添加全局过滤器\n        vue.filter(....)\n\n        // 2. 添加全局指令\n        vue.directive(....)\n\n        // 3. 配置全局混入(合)\n        vue.mixin(....)\n\n        // 4. 添加实例方法\n        vue.prototype.$mymethod = function () {...}\n        vue.prototype.$myproperty = xxxx\n    }\n\t}\n\n\n 4. 使用插件：vue.use(xxx)\n\n\n# scoped 样式\n\n 1. 作用：让样式在局部生效，防止冲突。\n 2. 写法：<style scoped>\n\n\n# 总结 todolist 案例\n\n 1. 组件化编码流程：\n\n(1).拆分静态组件：组件要按照功能点拆分，命名不要与 html 元素冲突。\n\n(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：\n\n1).一个组件在用：放在组件自身即可。\n\n​2). 一些组件在用：放在他们共同的父组件上（这种行为被称为状态提升）\n\n\n(3).实现交互：从绑定事件开始。\n\n 2. props 适用于：\n    \n    (1).父组件 ==> 子组件 通信\n    \n    (2).子组件 ==> 父组件 通信（要求父先给子一个函数）\n\n 3. 使用 v-model 时要切记：v-model 绑定的值不能是 props 传过来的值，因为 props 是不可以修改的！\n\n 4. props 传过来的若是对象类型的值，修改对象中的属性时 vue 不会报错，但不推荐这样做。\n\n 5. oninput 事件类似于 onchange 事件。不同之处在于 oninput 事件在元素值发生变化是立即触发， onchange 在元素失去焦点时触发。另外一点不同是 onchange 事件也可以作用于 <keygen> 和 <select> 元素。\n\n * oninput 事件\n * onchange 事件\n\n\n# webstorage\n\n 1. 存储内容大小一般支持 5mb 左右（不同浏览器可能还不一样）\n\n 2. 浏览器端通过 window.sessionstorage 和 window.localstorage 属性来实现本地存储机制。\n\n 3. 相关 api：\n    \n    1. xxxxxstorage.setitem(\'key\', \'value\'); 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n    \n    2. xxxxxstorage.getitem(\'person\');\n       \n       该方法接受一个键名作为参数，返回键名对应的值。\n    \n    3. xxxxxstorage.removeitem(\'key\');\n       \n       该方法接受一个键名作为参数，并把该键名从存储中删除。\n    \n    4. xxxxxstorage.clear()\n       \n       该方法会清空存储中的所有数据。\n\n 4. 备注：\n    \n    1. sessionstorage 存储的内容会随着浏览器窗口关闭而消失。\n    2. localstorage存储的内容，需要手动清除才会消失。\n    3. xxxxxstorage.getitem(xxx)如果 xxx 对应的 value 获取不到，那么 getitem的返回值是 null。\n    4. json.parse(null)的结果依然是 null。\n\n\n# 组件的自定义事件\n\n 1. 一种组件间通信的方式，适用于：子组件 ===> 父组件\n\n 2. 使用场景：a 是父组件，b 是子组件，b 想给 a 传数据，那么就要在 a 中给 b 绑定自定义事件（事件的回调在 a 中）。\n\n 3. 绑定自定义事件：\n    \n    1. 第一种方式，在父组件中：<demo @getdata="getdata"/> 或 <demo v-on:getdata="getdata"/>\n    \n    2. 第二种方式，在父组件中：\n\n;<child ref="demo" />\n// ......\nexport default {\n    methods: {\n        getdata(data) {\n            console.log(data)\n        },\n    },\n    mounted() {\n        this.$refs.child.$on(\'getdata\', this.getdata)\n    },\n}\n\n\n 3. 触发自定义事件：this.$emit(\'atguigu\',数据)\n\n 4. 若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。\n\n 5. 解绑自定义事件this.$off(\'atguigu\');解绑多个自定义事件this.$off([\'atguigu\',\'demo\']);解绑所有的自定义事件：this.$off()\n\n 6. 组件上也可以绑定原生 dom事件，需要使用native修饰符。\n\n 7. 注意：通过this.$refs.xxx.$on(\'atguigu\',回调)绑定自定义事件时，回调要么配置在 methods 中，要么用箭头函数，否则 this指向会出问题(该回调中的 this 指向触发自定义事件的组件实例对象)\n\n\n# 全局事件总线（globaleventbus）\n\n实现全局事件总线的前提\n\n * 所有组件都可以看到\n * 可以调用$on,$off,$emit\n\n 1. 一种组件间通信的方式，适用于任意组件间通信。\n\n 2. 安装全局事件总线：\n\n// main.js\nnew vue({\n    // ......\n    beforecreate() {\n        vue.prototype.$bus = this //安装全局事件总线，$bus 就是当前应用的 vm\n    },\n    // ......\n})\n\n\n 3. 使用事件总线：\n    \n    1. 接收数据：a 组件想接收数据，则在 a 组件中给$bus 绑定自定义事件，事件的回调留在 a 组件自身。\n    \n    2. 提供数据：this.$bus.$emit(\'xxxx\',数据)\n    \n    3. 最好在beforedestroy 钩子中，用 $off 去解绑当前组件所用到的事件。\n\nexport default {\n    // ......\n    methods: {\n        getdata(data) {\n            console.log(data)\n        },\n    },\n    mounted() {\n        // 给bus绑定自定义事件\n        this.$bus.$on(\'getdata\', this.getdata)\n    },\n    beforedestroy() {\n        this.$bus.$off(\'getdata\')\n    },\n}\n\n\n\n# 消息订阅与发布（pubsub）\n\n警告\n\n经本人测试 订阅消息数据参数只能有一个 如果存在多个参数 请将参数包装成对象传递\n\n最好在 beforedestroy 钩子中，用pubsub.unsubscribe(this.pid)去取消订阅。\n\n 1. 一种组件间通信的方式，适用于任意组件间通信。\n\n 2. 使用步骤：\n    \n    1. 安装 pubsub：npm i pubsub-js\n    \n    2. 引入: import pubsub from \'pubsub-js\'\n    \n    3. 接收数据（订阅消息）：a 组件想接收数据，则在 a 组件中订阅消息，订阅的回调留在 a 组件自身。\n    \n    4. 提供数据(发布消息)：pubsub.publish(\'消息名\',数据)\n\nexport default {\n    // 接受数据\n    methods: {\n        sub(msgname, data) {\n            // 如果不想接收msgname(消息的名字),可以使用"_"占位\n            console.log(msgname, data)\n        },\n    },\n    mounted() {\n        this.pid = pubsub.subscribe(\'getdata\', this.sub) //订阅消息\n    },\n    //   取消订阅\n    beforedestroy() {\n        pubsub.unsubscribe(this.pid)\n    },\n}\n\n\n// 发布数据\nexport default {\n    methods: {\n        pub() {\n            pubsub.publish(\'getdata\', \'数据\')\n        },\n    },\n}\n\n\n\n# nexttick\n\n 1. 语法：this.$nexttick(回调函数)\n 2. 作用：在下一次 dom 更新结束后执行其指定的回调。\n 3. 什么时候用：当改变数据后，要基于更新后的新 dom 进行某些操作时，要在 nexttick 所指定的回调函数中执行。\n\n\n# vue 封装的过度与动画\n\n官方文档\n\n 1. 作用：在插入、更新或移除 dom 元素时，在合适的时候给元素添加样式类名。\n\n 2. 写法：\n    \n    1. 准备好样式(class)：\n       \n       * 元素进入的样式：\n         1. v-enter：进入的起点\n         2. v-enter-active：进入过程中\n         3. v-enter-to：进入的终点\n       * 元素离开的样式：\n         1. v-leave：离开的起点\n         2. v-leave-active：离开过程中\n         3. v-leave-to：离开的终点\n    \n    2. 使用<transition>包裹要过度的元素，并配置 name 属性：\n\n提示\n\n给 transition 加上 name 属性 xxx,就需要将类名 v-...改成 xxx-...\n\n对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <transition>，则 v- 是这些类名的默认前缀。如果你使用了 <transition name="my-transition">，那么 v-enter 会替换为 my-transition-enter\n\n<transition name="hello">\n    <h1 v-show="isshow">你好啊！</h1>\n</transition>\n\n\n 3. 备注：若有多个元素需要过度，则需要使用：<transition-group>，且每个元素都要指定key值。\n\n 4. 可以通过 appear attribute 设置节点在初始渲染的过渡\n\n<transition appear>\n  \x3c!-- ... --\x3e\n</transition>\n\n\n 5. 使用第三方动画库 animate.css\n\nanimate.css是强大的跨平台的预设 css3 动画库\n\n安装:npm install animate.css --save\n\n引入:import "animate.css"\n\n使用第三方动画库需要通过以下 attribute 来自定义过渡类名\n\n * enter-class\n * enter-active-class\n * enter-to-class (2.1.8+)\n * leave-class\n * leave-active-class\n * leave-to-class (2.1.8+)\n\n一个栗子:\n\n<transition-group\n    appear\n    // 必须\n    name="animate__animated animate__bounce"\n    // 自定义过渡类名\n    enter-active-class="animate__swing"\n    leave-active-class="animate__backoutup"\n>\n    <h1 v-show="!isshow" key="1">\n        你好啊！\n    </h1>\n    <h1 v-show="isshow" key="2">\n        尚硅谷！\n    </h1>\n</transition-group>\n\n\n\n# vue 脚手架配置代理\n\n\n# 方法一\n\n在 vue.config.js 中添加如下配置：\n\ndevserver: {\n    proxy: \'http://localhost:5000\'\n}\n\n\n说明：\n\n 1. 优点：配置简单，请求资源时直接发给前端（8080）即可。\n 2. 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。\n 3. 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）\n\n\n# 方法二\n\n编写 vue.config.js 配置具体代理规则：\n\nmodule.exports = {\n    devserver: {\n        proxy: {\n            \'/api1\': {\n                // 匹配所有以 \'/api1\'开头的请求路径\n                target: \'http://localhost:5000\', // 代理目标的基础路径\n                changeorigin: true,\n                pathrewrite: { \'^/api1\': \'\' },\n            },\n            \'/api2\': {\n                // 匹配所有以 \'/api2\'开头的请求路径\n                target: \'http://localhost:5001\', // 代理目标的基础路径\n                changeorigin: true,\n                pathrewrite: { \'^/api2\': \'\' },\n            },\n        },\n    },\n}\n/*\n   changeorigin设置为true时，服务器收到的请求头中的host为：localhost:5000\n   changeorigin设置为false时，服务器收到的请求头中的host为：localhost:8080\n   changeorigin默认值为true\n*/\n\n\n说明：\n\n 1. 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。\n 2. 缺点：配置略微繁琐，请求资源时必须加前缀。\n\n\n# 插槽\n\n官方文档:插槽\n\n废弃的语法\n\n在 vue 2.6.0 中，为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除的 api，在接下来所有的 2.x 版本中 slot 和 slot-scope attribute 仍会被支持，但已经被官方废弃且不会出现在 vue 3 中。\n\n 1. 作用：让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于 父组件 ===> 子组件;父级模板里的所有内容都是在父级作用域中编译的,子模板里的所有内容都是在子作用域中编译的，也就说插槽可以访问父组件中的数据，但不能访问子组件中的数据\n\n 2. 分类：默认插槽、具名插槽、作用域插槽\n\n\n# 默认插槽\n\n\x3c!-- 父组件中： --\x3e\n<category>\n    <div>this is a div</div>\n</category>\n\n\x3c!-- 子组件中： --\x3e\n<template>\n    <div>\n        \x3c!-- 定义插槽 --\x3e\n        <slot>插槽默认内容</slot>\n    </div>\n</template>\n\n\n\n# 具名插槽\n\n一个不带 name 的 <slot> 出口会带有隐含的名字:default\n\nv-slot一般只能定义在template上 注：特殊情况见作用域插槽\n\n\x3c!-- 父组件中： --\x3e\n<template>\n    <div id="app">\n        <helloworld>\n            <template v-slot:header><div>this is header</div> </template>\n            \x3c!-- 默认插槽：任何没有被包裹在带有 v-slot 的 <template> 中的内容都会被视为默认插槽的内容。 --\x3e\n            <div>this is default</div>\n            \x3c!-- 如果你希望更明确一些，仍然可以在一个 <template> 中包裹默认插槽的内容 --\x3e\n            \x3c!-- <template v-slot:default><div>this is default</div></template> --\x3e\n            <template v-slot:main><div>this is main</div></template>\n            <template v-slot:footer><div>this is footer</div></template>\n        </helloworld>\n    </div>\n</template>\n\x3c!-- 子组件中： --\x3e\n<template>\n    <div>\n        \x3c!-- 定义插槽 --\x3e\n        <slot></slot>\n        <slot name="header">插槽默认内容</slot>\n        <slot name="main"> 插槽默认内容</slot>\n        <slot name="footer">插槽默认内容</slot>\n    </div>\n</template>\n\n\n使用“#“缩写\n\n\x3c!-- 父组件中： --\x3e\n<helloworld>\n    <template #header><div>this is header</div> </template>\n    <template #main><div>this is main</div></template>\n    <template #footer><div>this is footer</div></template>\n</helloworld>\n\x3c!-- 子组件中： --\x3e\n<template>\n    <div>\n        \x3c!-- 定义插槽 --\x3e\n        <slot name="header">插槽默认内容</slot>\n        <slot name="main"> 插槽默认内容</slot>\n        <slot name="footer">插槽默认内容</slot>\n    </div>\n</template>\n\n\n\n# 作用域插槽\n\n 1. 理解：数据定义在子组件，父组件想要访问定义在子组件中的数据\n\n 2. v-slot只能添加在 <template>的例外情况：当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样就可以把 v-slot 直接用在组件上:\n\n\x3c!--  `v-slot` 直接用在组件上 --\x3e\n<current-user v-slot:default="slotprops">\n    {{ slotprops.username }}\n</current-user>\n\n\x3c!-- 就像假定未指明的内容对应默认插槽一样，不带参数的 v-slot 被假定对应默认插槽 --\x3e\n<current-user v-slot="slotprops"> {{ slotprops.username }} </current-user>\n\n\x3c!-- 默认插槽的缩写语法(上面👆的写法)不能和具名插槽混用，无效会导致警告 --\x3e\n\x3c!-- 所以只要出现多个插槽，请始终为所有的插槽使用完整的基于 `<template>` 的语法 --\x3e\n\n\n 3. 使用“#“缩写\n\n和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：\n\n\x3c!-- 这样会触发一个警告 --\x3e\n<current-user #="slotprops"> {{ slotprops.username }} </current-user>\n\n\n如果使用缩写的话，必须始终明确插槽名：\n\n<current-user #default="slotprops"> {{ slotprops.username }} </current-user>\n\n\n 4. 具体编码（games数据在category组件中， 父组件通过插槽能够访问category子组件中才有的数据）：\n\n\x3c!-- 父组件中 --\x3e\n<template>\n    <div id="app">\n        <img alt="vue logo" src="./assets/logo.png" />\n        \x3c!-- 特殊情况，被提供的内容只有默认插槽 --\x3e\n        <helloworld v-slot="slotprops">\n            <h2>{{ slotprops.msg }}</h2></helloworld\n        >\n    </div>\n</template>\n\n\x3c!-- 子组件中： --\x3e\n<template>\n    <div class="hello">\n        <slot :msg="msg"></slot>\n    </div>\n</template>\n\n<script>\n    export default {\n        name: \'helloworld\',\n        data() {\n            return {\n                msg: \'frank chang is handsome man\',\n            }\n        },\n    }\n<\/script>\n\n\n 5. 解构插槽 prop\n\n适用情况:插槽提供了多个 prop 的时候\n\n\x3c!-- 父组件 --\x3e\n<template>\n    <div id="app">\n        <img alt="vue logo" src="./assets/logo.png" />\n        <helloworld v-slot="{ user, msg }">\n            <h2>{{ user.name }}</h2>\n            <h3>{{ msg }}</h3>\n        </helloworld>\n    </div>\n</template>\n\x3c!-- 子组件 --\x3e\n<template>\n    <div class="hello">\n        <slot :user="user" :msg="msg"></slot>\n    </div>\n</template>\n<script>\n    export default {\n        name: \'helloworld\',\n        data() {\n            return {\n                user: { name: \'frank\', age: 18 },\n                msg: \'frank is a man\',\n            }\n        },\n    }\n<\/script>\n\n\n定义后备内容，用于插槽 `prop` 是 `undefined `的情形\n\n\x3c!-- 父组件 --\x3e\n<template>\n    <div id="app">\n        <img alt="vue logo" src="./assets/logo.png" />\n        <helloworld\n            v-slot="{ user={name:\'not a found\' age:\'null\'}, msg=\'not a found\' }"\n        >\n            <h2>{{ user.name}},{{user.age }}</h2>\n            <h3>{{ msg }}</h3>\n        </helloworld>\n    </div>\n</template>\n\x3c!-- 子组件 --\x3e\n<template>\n    <div class="hello">\n        <slot :user="user" :msg="msg"></slot>\n    </div>\n</template>\n<script>\n    export default {\n        name: \'helloworld\',\n        data() {\n            return {\n                user: { name: \'frank\', age: 18 },\n                msg: \'frank is a man\',\n            }\n        },\n    }\n<\/script>\n\n\n\n# inheritattrs + $attrs + $listeners\n\n * inheritattrs\n\n当我们在使用组件时，为其传递的参数要在组件的props中进行定义，才能够使用。如果没有定义，则这个属性会作为这个 dom 结构根节点的attribute被渲染。\n\n1.当设置inheritattrs: true（默认）时，子组件的顶层标签元素中会渲染出父组件传递过来的且未在 props 中定义的属性\n\n2.当设置inheritattrs: false时，子组件的顶层标签元素中不会渲染出父组件传递过来的且未在 props 中定义的属性\n\n * $attrs\n\n$attrs 是一个内置属性，指父组件传递的、除了自己定义的 props 属性之外的所有属性。\n\n * $listeners(在 vue 3 中已被移除,事件监听器现在是 $attrs 的一部分)\n\n$listeners 包含了作用在这个组件上所有的监听器，即父组件绑定的全部监听事件，通过 v-on="$listeners"，可以将这些事件绑定给它自己的子组件。\n\n * $attrs + $listeners实现爷孙组件事件通信\n   \n   * 爷传孙：把想要传给孙组件的数据先传给父组件，在父组件中通过v-bind=\'$attrs\'把数据传给孙子组件,在父组件不要定义 props\n   \n   * 孙传爷：\n     \n     1. 在爷组件中,给父组件绑定自定义事件\n     \n     2. 在父组件中,通过:v-on="$listeners",可以将这些事件绑定给它孙组件(vue3 通过v-bind=$attrs)\n     \n     3. 在孙组件中通过this.$emit触发自定义事件\n\n\n# 挂载全局变量\n\n如果需要设置全局变量，可以通过在 main.js 中，在 vue 原型上添加属性实现全局变量\n\nvue.prototype.$appname = \'my app\'\n',charsets:{cjk:!0},lastUpdated:"2022年07月18日",lastUpdatedTimestamp:1658156035e3},{title:"移动Web开发入门",frontmatter:{title:"移动Web开发入门",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8Web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8.html",relativePath:"前端开发/移动开发/移动Web开发入门.md",key:"v-1fdb8159",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/%E7%A7%BB%E5%8A%A8Web%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8.html",headers:[{level:2,title:"移动 Web 开发基础知识",slug:"移动-web-开发基础知识",normalizedTitle:"移动 web 开发基础知识",charIndex:49},{level:3,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:67}],headersStr:"移动 Web 开发基础知识 基本概念",content:"参考文章\n\n作为前端，你应该了解的分辨率/逻辑像素/物理像素/retina 屏知识 🧐\n\n\n# 移动 Web 开发基础知识\n\n\n# 基本概念\n\n# 分辨率\n\n# 分类\n\n * 设备分辨率：适用于电子屏幕,设备分辨率反映了硬件设备处理图像时的效果是否细腻（别名：显示器分辨率，屏幕分辨率，物理分辨率）\n\n提示\n\n显示器分辨率（屏幕分辨率）是指显示器能显示的像素有多少。 由于屏幕上的点、线和面都是由像素组成的，显示器可显示的像素越多，画面就越精细，同样的屏幕区域内能显示的信息也越多。\n\n * 显示分辨率一定的情况下，显示屏越小图像越清晰\n * 显示屏大小固定时，显示分辨率越高图像越清晰\n\n * 图像分辨率：适用于图像/设计稿,图像分辨率指标的高低反映了图像清晰程度\n\n在PC端非 retina屏上,设备分辨率等于图像分辨率\n\n分辨率=画面水平方向的像素值 * 画面垂直方向的像素值\n\n例如，一个屏幕分辨率是 1024×768 =786432 ，也就是说：水平方向上有 1024 个物理像素,垂直方向上有 768 个物理像素\n\n# 单位\n\n分辨率的单位用 屏幕像素密度 来表示（屏幕像素密度，即每英寸屏幕所拥有的像素数，即在一个对角线长度为1英寸的正方形内所拥有的像素数）\n\nPPI: Pixels Per Inch(像素每英寸) 适用于图像分辨率\n\nDPI: Dots Per Inch(点每英寸)适用于设备分辨率\n\nPPI/DPI越大，画面就越细腻。当用于描述显示器设备时 PPI 与 DPI 是同一个概念\n\nPPI/DPI的计算：\n\n\n\n相同的分辨率，更高的 PPI 表现为物理尺寸更小; 物理尺寸相同，较低的 PPI 表现为较低的分辨率\n\n# 像素\n\n逻辑像素-PX(CSS pixels)也叫：设备独立像素、CSS像素:\n\n浏览器内的一切长度都是以 CSS 像素为单位的，CSS 像素的单位是 px，px 是一个相对单位，相对的是设备物理像素(device pixel)，其相对性体现在在同一个设备上或在不同设备之间每 1 个 px 所代表的物理像素是可以变化的\n\nCSS 像素的单位是PX(CSS pixels), 在浏览器中可以通过 screen.width ,screen.height 获取浏览器的逻辑像素\n\n在一般 PC 屏幕上， CSS 的 1px = PC 屏幕的 1 个物理像素\n\nretina 屏幕上， CSS 的 1px = PC 屏幕的 4 个物理像素\n\niphone3 的分辨率是 320*480。 但是从 iphone4 开始，苹果公司推出了的 retina 屏，分辨率提高了一倍，变成 640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍\n\n安卓设备上的一个 css 像素相当于多少个屏幕物理像素，也因设备的不同而不同\n\n用户缩放浏览器也会引起 css 中 px 的变化：\n\n当用户把页面放大一倍，那么 css 中 1px 所代表的物理像素也会增加一倍；\n\n把页面缩小一倍，css 中 1px 所代表的物理像素也会减少一倍\n\n假设我们用 PC 浏览器打开一个页面，浏览器此时的宽度为 800px，页面上同时有一个 400px 宽的块级元素容器。很明显此时块状容器应该占页面的一半。但如果我们把页面放大，放大为 200%，也就是原来的两倍。此时块状容器则横向占满了整个浏览器。但此时我们既没有调整浏览器窗口大小，也没有改变块状元素的 css 宽度，但是它看上去却变大了一倍——这是因为我们把 CSS 像素放大为了原来的两倍.也就是说默认情况下一个 CSS 像素应该是等于一个物理像素的宽度的，但是浏览器的放大操作让一个 CSS 像素等于了两个设备像素宽度。 从上面的例子可以看出，CSS 像素从来都只是一个相对值。\n\n物理像素-DP(device pixels),也叫设备像素、设备物理像素:\n\npt 和 px 的关系\n\npt 和 px 的关系就是—— 1pt 里面有几个像素点。（比如 1pt 里面有 1 个 px，也可以有 2 个，3 个）\n\n设备像素（物理像素），顾名思义，显示屏是由一个个物理像素点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像，屏幕从工厂出来那天起，它上面的物理像素点就固定不变了，单位 pt。\n\n设备屏幕实际拥有的像素点，屏幕的基本单元，是有实体的。\n\n比如 iPhone 6 的屏幕在宽度方向有 750 个物理像素点，高度方向有 1334 个物理像素点，所以 iPhone 6 总共有 750*1334 个物理像素点。\n\n所谓的一倍屏、二倍屏(Retina)、三倍屏，指的是设备以多少物理像素来显示一个 CSS 像素，也就是说，多倍屏以更多更精细的物理像素点来显示一个 CSS 像素点，在普通屏幕下 1 个 CSS 像素对应 1 个物理像素。在 Retina 屏幕下，1 个 CSS 像素对应 4 个物理像素。\n\n\n\n可以发现，在同样的大小下，2dpr 的屏幕时普通屏幕像素点的 4 倍，3dpr 的屏幕时普通屏幕像素点的 9 倍。这就是 retina 屏幕\n\n设备像素比-DPR(device pixels ratio):\n\n设备像素比(dpr 描述的是未缩放状态下，一个方向上物理像素和 CSS 像素的比值)\n\n设备像素比(dpr)是指开发中 1 个 css 像素占用多少设备像素，如 2 代表 1 个 css 像素用 2x2 个设备像素来绘制。\n\n其实在很久以前，CSS 的 1px，屏幕就渲染成 1 个实际的物理像素点，即 DPR=1。\n\n但从 iPhone4 开始， 苹果公司为其产品 mac、iPhone 以及 iPad 的屏幕配置了 Retina 高清屏，在 Retina 屏上，,DPR=2\n\n那 CSS 的 1px 到底等于几个物理像素呢？\n\n把页面放大一倍，那么 CSS 中 1px 所代表的物理像素也会增加一倍； 把页面缩小一倍，CSS 中 1px 所代表的物理像素也会减少一倍。\n\n在某些浏览器中，window.devicePixelRatio 可以获得此比例,即 devicePixelRatio = 设备物理像素 / 逻辑像素。\n\n但是要注意的是，window.devicePixelRatio 在不同的浏览器中还存在些许的兼容性问题",normalizedContent:"参考文章\n\n作为前端，你应该了解的分辨率/逻辑像素/物理像素/retina 屏知识 🧐\n\n\n# 移动 web 开发基础知识\n\n\n# 基本概念\n\n# 分辨率\n\n# 分类\n\n * 设备分辨率：适用于电子屏幕,设备分辨率反映了硬件设备处理图像时的效果是否细腻（别名：显示器分辨率，屏幕分辨率，物理分辨率）\n\n提示\n\n显示器分辨率（屏幕分辨率）是指显示器能显示的像素有多少。 由于屏幕上的点、线和面都是由像素组成的，显示器可显示的像素越多，画面就越精细，同样的屏幕区域内能显示的信息也越多。\n\n * 显示分辨率一定的情况下，显示屏越小图像越清晰\n * 显示屏大小固定时，显示分辨率越高图像越清晰\n\n * 图像分辨率：适用于图像/设计稿,图像分辨率指标的高低反映了图像清晰程度\n\n在pc端非 retina屏上,设备分辨率等于图像分辨率\n\n分辨率=画面水平方向的像素值 * 画面垂直方向的像素值\n\n例如，一个屏幕分辨率是 1024×768 =786432 ，也就是说：水平方向上有 1024 个物理像素,垂直方向上有 768 个物理像素\n\n# 单位\n\n分辨率的单位用 屏幕像素密度 来表示（屏幕像素密度，即每英寸屏幕所拥有的像素数，即在一个对角线长度为1英寸的正方形内所拥有的像素数）\n\nppi: pixels per inch(像素每英寸) 适用于图像分辨率\n\ndpi: dots per inch(点每英寸)适用于设备分辨率\n\nppi/dpi越大，画面就越细腻。当用于描述显示器设备时 ppi 与 dpi 是同一个概念\n\nppi/dpi的计算：\n\n\n\n相同的分辨率，更高的 ppi 表现为物理尺寸更小; 物理尺寸相同，较低的 ppi 表现为较低的分辨率\n\n# 像素\n\n逻辑像素-px(css pixels)也叫：设备独立像素、css像素:\n\n浏览器内的一切长度都是以 css 像素为单位的，css 像素的单位是 px，px 是一个相对单位，相对的是设备物理像素(device pixel)，其相对性体现在在同一个设备上或在不同设备之间每 1 个 px 所代表的物理像素是可以变化的\n\ncss 像素的单位是px(css pixels), 在浏览器中可以通过 screen.width ,screen.height 获取浏览器的逻辑像素\n\n在一般 pc 屏幕上， css 的 1px = pc 屏幕的 1 个物理像素\n\nretina 屏幕上， css 的 1px = pc 屏幕的 4 个物理像素\n\niphone3 的分辨率是 320*480。 但是从 iphone4 开始，苹果公司推出了的 retina 屏，分辨率提高了一倍，变成 640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍\n\n安卓设备上的一个 css 像素相当于多少个屏幕物理像素，也因设备的不同而不同\n\n用户缩放浏览器也会引起 css 中 px 的变化：\n\n当用户把页面放大一倍，那么 css 中 1px 所代表的物理像素也会增加一倍；\n\n把页面缩小一倍，css 中 1px 所代表的物理像素也会减少一倍\n\n假设我们用 pc 浏览器打开一个页面，浏览器此时的宽度为 800px，页面上同时有一个 400px 宽的块级元素容器。很明显此时块状容器应该占页面的一半。但如果我们把页面放大，放大为 200%，也就是原来的两倍。此时块状容器则横向占满了整个浏览器。但此时我们既没有调整浏览器窗口大小，也没有改变块状元素的 css 宽度，但是它看上去却变大了一倍——这是因为我们把 css 像素放大为了原来的两倍.也就是说默认情况下一个 css 像素应该是等于一个物理像素的宽度的，但是浏览器的放大操作让一个 css 像素等于了两个设备像素宽度。 从上面的例子可以看出，css 像素从来都只是一个相对值。\n\n物理像素-dp(device pixels),也叫设备像素、设备物理像素:\n\npt 和 px 的关系\n\npt 和 px 的关系就是—— 1pt 里面有几个像素点。（比如 1pt 里面有 1 个 px，也可以有 2 个，3 个）\n\n设备像素（物理像素），顾名思义，显示屏是由一个个物理像素点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像，屏幕从工厂出来那天起，它上面的物理像素点就固定不变了，单位 pt。\n\n设备屏幕实际拥有的像素点，屏幕的基本单元，是有实体的。\n\n比如 iphone 6 的屏幕在宽度方向有 750 个物理像素点，高度方向有 1334 个物理像素点，所以 iphone 6 总共有 750*1334 个物理像素点。\n\n所谓的一倍屏、二倍屏(retina)、三倍屏，指的是设备以多少物理像素来显示一个 css 像素，也就是说，多倍屏以更多更精细的物理像素点来显示一个 css 像素点，在普通屏幕下 1 个 css 像素对应 1 个物理像素。在 retina 屏幕下，1 个 css 像素对应 4 个物理像素。\n\n\n\n可以发现，在同样的大小下，2dpr 的屏幕时普通屏幕像素点的 4 倍，3dpr 的屏幕时普通屏幕像素点的 9 倍。这就是 retina 屏幕\n\n设备像素比-dpr(device pixels ratio):\n\n设备像素比(dpr 描述的是未缩放状态下，一个方向上物理像素和 css 像素的比值)\n\n设备像素比(dpr)是指开发中 1 个 css 像素占用多少设备像素，如 2 代表 1 个 css 像素用 2x2 个设备像素来绘制。\n\n其实在很久以前，css 的 1px，屏幕就渲染成 1 个实际的物理像素点，即 dpr=1。\n\n但从 iphone4 开始， 苹果公司为其产品 mac、iphone 以及 ipad 的屏幕配置了 retina 高清屏，在 retina 屏上，,dpr=2\n\n那 css 的 1px 到底等于几个物理像素呢？\n\n把页面放大一倍，那么 css 中 1px 所代表的物理像素也会增加一倍； 把页面缩小一倍，css 中 1px 所代表的物理像素也会减少一倍。\n\n在某些浏览器中，window.devicepixelratio 可以获得此比例,即 devicepixelratio = 设备物理像素 / 逻辑像素。\n\n但是要注意的是，window.devicepixelratio 在不同的浏览器中还存在些许的兼容性问题",charsets:{cjk:!0},lastUpdated:"2022年05月14日",lastUpdatedTimestamp:1652539373e3},{title:"JavaScript",frontmatter:{title:"JavaScript",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/JavaScript.html",relativePath:"前端开发/重学前端/JavaScript.md",key:"v-15a2f62d",path:"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF/JavaScript.html",headersStr:null,content:"文档正在编辑中......",normalizedContent:"文档正在编辑中......",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"Html面试题",frontmatter:{title:"Html面试题",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Html%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"前端面试/Html面试题.md",key:"v-2ede98c9",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Html%E9%9D%A2%E8%AF%95%E9%A2%98.html",headers:[{level:2,title:"如何理解 HTML 语义化？",slug:"如何理解-html-语义化",normalizedTitle:"如何理解 html 语义化？",charIndex:2},{level:2,title:"默认情况下，哪些 HTML 元素是块级元素，哪些是内联元素（行内元素）？",slug:"默认情况下-哪些-html-元素是块级元素-哪些是内联元素-行内元素",normalizedTitle:"默认情况下，哪些 html 元素是块级元素，哪些是内联元素（行内元素）？",charIndex:113},{level:3,title:"内联（行内）元素（display:inline）",slug:"内联-行内-元素-display-inline",normalizedTitle:"内联（行内）元素（display:inline）",charIndex:154},{level:3,title:"块级元素（display:block）",slug:"块级元素-display-block",normalizedTitle:"块级元素（display:block）",charIndex:634},{level:2,title:"src 和 href 的区别",slug:"src-和-href-的区别",normalizedTitle:"src 和 href 的区别",charIndex:875},{level:2,title:"script 标签中 defer 和 async 的区别",slug:"script-标签中-defer-和-async-的区别",normalizedTitle:"script 标签中 defer 和 async 的区别",charIndex:1109},{level:2,title:"Doctype 作用？严格模式与混杂模式如何区分？它们有何差异？",slug:"doctype-作用-严格模式与混杂模式如何区分-它们有何差异",normalizedTitle:"doctype 作用？严格模式与混杂模式如何区分？它们有何差异？",charIndex:1507}],headersStr:"如何理解 HTML 语义化？ 默认情况下，哪些 HTML 元素是块级元素，哪些是内联元素（行内元素）？ 内联（行内）元素（display:inline） 块级元素（display:block） src 和 href 的区别 script 标签中 defer 和 async 的区别 Doctype 作用？严格模式与混杂模式如何区分？它们有何差异？",content:"# 如何理解 HTML 语义化？\n\n 1. 代码结构清晰，方便阅读，有利于团队合作开发。\n 2. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。\n 3. 有利于搜索引擎优化（SEO）。\n\n\n# 默认情况下，哪些 HTML 元素是块级元素，哪些是内联元素（行内元素）？\n\n\n# 内联（行内）元素（display:inline）\n\n 1. 可以和其他元素处于一行，不用必须另起一行。\n 2. 元素的高度、宽度及顶部和底部边距不可设置。\n    \n    提示\n    \n    行内元素的 padding-top、 padding-bottom、 margin-top、 margin-bottom 属性设置是无效的;行内元素的 padding-left、 padding-right, margin-left、 margin-botton 属性设置是有效;行内元素的 padding-bottom(经过测试 padding-top 无论设置多大都没有任何效果,而 padding-bottom 在显示效果上确实增加了)从显示的效果上是增加的，但其实设置的是无效的。并不会对他周围的元素产生任何影响。\n\n 3. 元素的宽度就是它包含的文字、图片的宽度。\n\n常见的行级元素有：a、input、span、img、button\n\nimg和表单元素是行内块（display:inline-block），他们既可以设置宽度高度，也能并排显示\n\n\n# 块级元素（display:block）\n\n 1. 每个块级元素都是独自占一行，其后的元素也只能另起一行，两个元素不能共用一行。\n 2. 元素的高度、宽度、行高和顶底边距都是可以设置的。\n 3. 元素的宽度如果不设置的话，默认为父元素的宽度。\n\n常见的块级元素有 div、p、h1...h6、ol、ul、dl、dt、li、table、form\n\n提示\n\n无论是块级元素还是行内元素，height 属性如果不设置，他将自动被内容撑开，如果没有内容，则 height 默认为 0\n\n\n# src 和 href 的区别\n\n * src： 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src 会将其指向的资源下载并应⽤到⽂档内，如请求 js 脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕。\n\n * href： 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的文件时，就会并行下载资源，不会停止对当前⽂档的处理。 常用在 a、link 等标签上。\n\n\n# script 标签中 defer 和 async 的区别\n\n如果没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。\n\n\n\ndefer 和 async 属性都是去异步加载外部的 JS 脚本文件，它们都不会阻塞页面的解析，其区别如下：\n\n 1. 执行顺序： 多个带 async 属性的标签，不能保证加载的顺序；多个带 defer 属性的标签，按照加载顺序执行；\n 2. 脚本是否并行执行：async 属性，表示后续文档的加载和执行与 js 脚本的加载和执行是并行进行的，即异步执行；defer 属性，加载后续文档的过程和 js 脚本的加载(此时仅加载不执行)是并行进行的(异步)，js 脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded 事件触发执行之前。\n\n\n# Doctype 作用？严格模式与混杂模式如何区分？它们有何差异？\n\n参考",normalizedContent:"# 如何理解 html 语义化？\n\n 1. 代码结构清晰，方便阅读，有利于团队合作开发。\n 2. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。\n 3. 有利于搜索引擎优化（seo）。\n\n\n# 默认情况下，哪些 html 元素是块级元素，哪些是内联元素（行内元素）？\n\n\n# 内联（行内）元素（display:inline）\n\n 1. 可以和其他元素处于一行，不用必须另起一行。\n 2. 元素的高度、宽度及顶部和底部边距不可设置。\n    \n    提示\n    \n    行内元素的 padding-top、 padding-bottom、 margin-top、 margin-bottom 属性设置是无效的;行内元素的 padding-left、 padding-right, margin-left、 margin-botton 属性设置是有效;行内元素的 padding-bottom(经过测试 padding-top 无论设置多大都没有任何效果,而 padding-bottom 在显示效果上确实增加了)从显示的效果上是增加的，但其实设置的是无效的。并不会对他周围的元素产生任何影响。\n\n 3. 元素的宽度就是它包含的文字、图片的宽度。\n\n常见的行级元素有：a、input、span、img、button\n\nimg和表单元素是行内块（display:inline-block），他们既可以设置宽度高度，也能并排显示\n\n\n# 块级元素（display:block）\n\n 1. 每个块级元素都是独自占一行，其后的元素也只能另起一行，两个元素不能共用一行。\n 2. 元素的高度、宽度、行高和顶底边距都是可以设置的。\n 3. 元素的宽度如果不设置的话，默认为父元素的宽度。\n\n常见的块级元素有 div、p、h1...h6、ol、ul、dl、dt、li、table、form\n\n提示\n\n无论是块级元素还是行内元素，height 属性如果不设置，他将自动被内容撑开，如果没有内容，则 height 默认为 0\n\n\n# src 和 href 的区别\n\n * src： 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src 会将其指向的资源下载并应⽤到⽂档内，如请求 js 脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕。\n\n * href： 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的文件时，就会并行下载资源，不会停止对当前⽂档的处理。 常用在 a、link 等标签上。\n\n\n# script 标签中 defer 和 async 的区别\n\n如果没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。\n\n\n\ndefer 和 async 属性都是去异步加载外部的 js 脚本文件，它们都不会阻塞页面的解析，其区别如下：\n\n 1. 执行顺序： 多个带 async 属性的标签，不能保证加载的顺序；多个带 defer 属性的标签，按照加载顺序执行；\n 2. 脚本是否并行执行：async 属性，表示后续文档的加载和执行与 js 脚本的加载和执行是并行进行的，即异步执行；defer 属性，加载后续文档的过程和 js 脚本的加载(此时仅加载不执行)是并行进行的(异步)，js 脚本需要等到文档所有元素解析完成之后才执行，domcontentloaded 事件触发执行之前。\n\n\n# doctype 作用？严格模式与混杂模式如何区分？它们有何差异？\n\n参考",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"css面试题",frontmatter:{title:"css面试题",sidebarDepth:2,readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Css%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"前端面试/Css面试题.md",key:"v-1180216e",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Css%E9%9D%A2%E8%AF%95%E9%A2%98.html",headers:[{level:2,title:"盒模型宽度的计算",slug:"盒模型宽度的计算",normalizedTitle:"盒模型宽度的计算",charIndex:2},{level:2,title:"谈谈你对 CSS 盒模型的认识",slug:"谈谈你对-css-盒模型的认识",normalizedTitle:"谈谈你对 css 盒模型的认识",charIndex:1477},{level:2,title:"margin 纵向重叠问题",slug:"margin-纵向重叠问题",normalizedTitle:"margin 纵向重叠问题",charIndex:1848},{level:2,title:"margin 负值问题",slug:"margin-负值问题",normalizedTitle:"margin 负值问题",charIndex:2216},{level:2,title:"BFC 理解与应用",slug:"bfc-理解与应用",normalizedTitle:"bfc 理解与应用",charIndex:2312},{level:2,title:"float 布局：实现圣杯和双飞翼布局",slug:"float-布局-实现圣杯和双飞翼布局",normalizedTitle:"float 布局：实现圣杯和双飞翼布局",charIndex:2515},{level:3,title:"圣杯和双飞翼布局的目的",slug:"圣杯和双飞翼布局的目的",normalizedTitle:"圣杯和双飞翼布局的目的",charIndex:2571},{level:3,title:"技术总结",slug:"技术总结",normalizedTitle:"技术总结",charIndex:2651},{level:3,title:"圣杯布局",slug:"圣杯布局",normalizedTitle:"圣杯布局",charIndex:2545},{level:3,title:"双飞翼布局",slug:"双飞翼布局",normalizedTitle:"双飞翼布局",charIndex:2529},{level:3,title:"两者区别",slug:"两者区别",normalizedTitle:"两者区别",charIndex:3392},{level:2,title:"float 布局：手写 clearfix",slug:"float-布局-手写-clearfix",normalizedTitle:"float 布局：手写 clearfix",charIndex:3469},{level:2,title:"flex 布局",slug:"flex-布局",normalizedTitle:"flex 布局",charIndex:3433},{level:3,title:"实现一个三点的色子",slug:"实现一个三点的色子",normalizedTitle:"实现一个三点的色子",charIndex:3624},{level:2,title:"display:none、visibility:hidden 和 opacity:0 之间的区别？",slug:"display-none、visibility-hidden-和-opacity-0-之间的区别",normalizedTitle:"display:none、visibility:hidden 和 opacity:0 之间的区别？",charIndex:3706},{level:2,title:"居中的实现方式",slug:"居中的实现方式",normalizedTitle:"居中的实现方式",charIndex:3791},{level:3,title:"水平居中",slug:"水平居中",normalizedTitle:"水平居中",charIndex:3831},{level:3,title:"垂直居中",slug:"垂直居中",normalizedTitle:"垂直居中",charIndex:3817},{level:3,title:"垂直水平居中",slug:"垂直水平居中",normalizedTitle:"垂直水平居中",charIndex:4086},{level:2,title:"line-height 如何继承",slug:"line-height-如何继承",normalizedTitle:"line-height 如何继承",charIndex:4369},{level:2,title:"rem",slug:"rem",normalizedTitle:"rem",charIndex:4495},{level:2,title:"用 css 画个三角形",slug:"用-css-画个三角形",normalizedTitle:"用 css 画个三角形",charIndex:4677}],headersStr:"盒模型宽度的计算 谈谈你对 CSS 盒模型的认识 margin 纵向重叠问题 margin 负值问题 BFC 理解与应用 float 布局：实现圣杯和双飞翼布局 圣杯和双飞翼布局的目的 技术总结 圣杯布局 双飞翼布局 两者区别 float 布局：手写 clearfix flex 布局 实现一个三点的色子 display:none、visibility:hidden 和 opacity:0 之间的区别？ 居中的实现方式 水平居中 垂直居中 垂直水平居中 line-height 如何继承 rem 用 css 画个三角形",content:"# 盒模型宽度的计算\n\n    <style>\n        #div1 {\n            width: 100px;\n            padding: 10px;\n            border: 1px solid red;\n            margin: 10px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"div1\"></div>\n</body>\n\n\n请问 div1 的offsetWidth是多大？\n\n答案\n\n122px\n\n如果要让offsetWidth的值等于 100px,怎么做？\n\n答案\n\nbox-sizing:border-box,此时盒子的 width=内容的宽度+左右 padding+左右 border=offsetWidth。所以内容的宽度会变小。\n\n扩展\n\n元素视图属性\n\n * offsetWidth 水平方向 width + 左右 padding + 左右 border-width（边框）\n\n * offsetHeight 垂直方向 height + 上下 padding + 上下 border-width（边框）\n\n * clientWidth 水平方向 width + 左右 padding\n\n * clientHeight 垂直方向 height + 上下 padding\n\n * offsetTop 获取当前元素到 定位父节点 的 top 方向的距离 若祖宗都不符合条件，offsetParent 为body\n\n * offsetLeft 获取当前元素到 定位父节点 的 left 方向的距离 若祖宗都不符合条件，offsetParent 为body\n\n * scrollWidth 元素内容真实的宽度，内容不超出盒子高度时为盒子的 clientWidth\n\n * scrollHeight 元素内容真实的高度，内容不超出盒子高度时为盒子的 clientHeight\n\nWindow 视图属性\n\n * innerWidth 浏览器窗口可视区宽度（不包括浏览器控制台、菜单栏、工具栏）包含滚动条\n * innerHeight 浏览器窗口可视区高度（不包括浏览器控制台、菜单栏、工具栏）包含滚动条\n * outerWidth 浏览器窗口的外部高度 浏览器有非全屏下有边框\n * outerHeight 浏览器窗口的外部宽度 浏览器有非全屏下有边框\n\nDocument 文档视图\n\n * document.documentElement.clientWidth 浏览器窗口可视区宽度（不包括浏览器控制台、菜单栏、工具栏、滚动条）\n * document.documentElement.clientHeight 浏览器窗口可视区高度（不包括浏览器控制台、菜单栏、工具栏、滚动条）\n * document.documentElement.offsetHeight 获取整个文档的高度（包含 body 的 margin）\n * document.body.offsetHeight 获取整个文档的高度（不包含 body 的 margin） -document.documentElement.scrollTop 返回文档的滚动 top 方向的距离（当窗口发生滚动时值改变）\n * document.documentElement.scrollLeft 返回文档的滚动 left 方向的距离（当窗口发生滚动时值改变）\n\n\n# 谈谈你对 CSS 盒模型的认识\n\n标准盒子模型，即 box-sizing content-box，浏览器默认模型，我们所写的 width 和 height 并不是最终盒子的宽高，而是 content 的，盒子的宽高由我们的 content+padding+border 来组成的，但是这样在做项目时可能会遇到小问题，假如我想构建一个 100x100 的盒子大小，但是我发现我写的是 width 和 height 是 100，于是我需要加上 padding 及 border，但是加上去之后，盒子也会相应变大，这就造成改动麻烦。\n\n后面 css3 中提供了 IE 盒子模型，能够直接控制盒子的大小。于是项目中大多数用上了 IE 盒子模型，以及我看过 bootstrap 以及 element-ui 源码中大部分也是用的 IE 盒子模型\n\n\n# margin 纵向重叠问题\n\n   <style>\n        p{\n            font-size:16px;\n            line-height:16px;\n            margin-top: 10px;\n            margin-bottom: 15px;\n        }\n    </style>\n</head>\n<body>\n    <p>aaa</p>\n    <p></p>\n    <p></p>\n    <p></p>\n    <p>bbb</p>\n</body>\n\n\naaa 和 bbb 之间的距离？\n\n答案\n * 相邻元素的 margin-top 和 margin-bottom 会发生重叠\n * 空白内容的 p 也会重叠\n * 所以答案为15px\n\n\n# margin 负值问题\n\n * top，left 为负值，元素向上、向左移动\n * right 负值 右侧元素左移，自身不受影响\n * bottom 负值，下方元素上移，自身不受影响\n\n\n# BFC 理解与应用\n\n * 块级格式化上下文\n * 一块独立渲染区域，内部元素的渲染不会影响边界以外的元素。\n * 形成 BFC 的条件？\n\n 1. float 的值不是 none\n\n 2. positon 的值不是 static 或者 relative\n\n 3. display 的值是 inline-block,flex,或者 inline-flex\n\n 4. overflow:hidden\n\n\n# float 布局：实现圣杯和双飞翼布局\n\n> CSS 布局中圣杯布局与双飞翼布局的实现思路差异在哪里？\n\n\n# 圣杯和双飞翼布局的目的\n\n * 三栏布局，中间一栏最先加载和渲染（内容最重要）\n * 两侧内容固定，中间内容随着宽度自适应\n * 一般用于 PC 网页\n\n\n# 技术总结\n\n * 使用 float 布局\n * 两侧使用 margin 负值，以便和中间内容横向重叠\n * 防止中间内容被两侧覆盖，一个用 padding 一个用 margin\n\n\n# 圣杯布局\n\n特别注意\n\nmin-width 就是页面的最小宽度：要想保证该布局效果正常显示，由于两侧都具有固定的宽度，所以需要给定页面一个最小的宽度，但这并不只是简单的 200+150=350px。回想之前 left 使用了 position: relative，所以就意味着在 center 开始的区域，还存在着一个 left 的宽度。所以页面的最小宽度应该设置为 200+150+200=550px\n\ncss 中，min-width 是用来限制元素的最小宽度，max-width 用来限制元素的最大宽度，也就是说当元素的 width 大于 max-width,或者小于 min-width。就被它们的值所代替，尤其适用于网站的自适应。\n\n理解 css 中 min-width 和 max-width，width 与它们之间的区别联系\n\nSee the Pen 圣杯布局 by zhangfanhang (@zhangfanhang) on CodePen.\n\n\n# 双飞翼布局\n\n注意\n\n由于双飞翼布局没有用到 position:relative 进行定位，所以最小页面宽度应该为 200+150=350px。但是当页面宽度缩小到 350px 附近时，会挤占中间栏的宽度，使得其内容被右侧栏覆盖，因此在设置最小页面宽度时，应该适当增加一些宽度以供中间栏使用\n\nSee the Pen 双飞翼布局 by zhangfanhang (@zhangfanhang) on CodePen.\n\n\n# 两者区别\n\n双飞翼布局比圣杯布局多创建了一个 div，但不用相对布局了,终究还是 flex 布局舒服！（flex 实现,代码见 flex 布局）\n\n\n# float 布局：手写 clearfix\n\n.clearfix:after {\n    content: '';\n    display: table;\n    clear: both;\n}\n/* 兼容ie低版本 */\n.clearfix {\n    *zoom: 1;\n}\n\n\n\n# flex 布局\n\n\n# 实现一个三点的色子\n\nSee the Pen flex-三点的色子 by zhangfanhang (@zhangfanhang) on CodePen.\n\n\n# display:none、visibility:hidden 和 opacity:0 之间的区别？\n\n\n\n扩展：visibility 还有哪些其他的属性值？\n\n\n\n\n# 居中的实现方式\n\n绝对定位+margin auto 垂直居中引发的思考\n\n\n# 水平居中\n\n * inline 元素:text-align:center\n * block 元素：margin: 0 auto（margin:auto）\n * absolute 元素：left:50%+margin-left:-宽度的一半\n * absolute 元素：各个方向为 0，margin:0 auto\n\n\n# 垂直居中\n\n * inline 元素:line-height 的值等于 height 值\n * absolute 元素：top:50%+margin-top:-高度的一半\n * \n\n\n# 垂直水平居中\n\n * absolute 元素：利用 top:50%,left:50%和 margin-top,margin-left (元素尺寸已知可用)\n\n * absolute 元素：利用 top:50%,left:50%和利用 transfrom:translate(-50%,-50%)(元素尺寸不知道也可以用)\n\n * absolute 元素： top,left,bottom,right=0+margin:auto(元素尺寸不知道也可以用)\n\n * flex：align-items:center;justify-content:center;\n\n\n# line-height 如何继承\n\n\n\n * 写具体数值，如 30px，则继承该值（比较好理解），\n * 写比例，如 2/1.5，则继承该比例（比较好理解），\n * 写百分比，如 200%，则继承计算出来的值（考点）\n\nline-height\n\n\n# rem\n\nrem 是一个长度单位，\n\n * px，绝对长度单位，最常用\n * em,相对长度单位，相对于父元素，不常用\n * rem,相对长度单位，相对根元素，常用于响应式布局\n\nhtml {\n    font-size: 100px; // 1rem等于html元素上字体设置的大小\n}\ndiv {\n    font-size: 0.16rem;\n}\n\n\n\n# 用 css 画个三角形\n\n#box {\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-bottom: 100px solid red;\n}\n",normalizedContent:"# 盒模型宽度的计算\n\n    <style>\n        #div1 {\n            width: 100px;\n            padding: 10px;\n            border: 1px solid red;\n            margin: 10px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"div1\"></div>\n</body>\n\n\n请问 div1 的offsetwidth是多大？\n\n答案\n\n122px\n\n如果要让offsetwidth的值等于 100px,怎么做？\n\n答案\n\nbox-sizing:border-box,此时盒子的 width=内容的宽度+左右 padding+左右 border=offsetwidth。所以内容的宽度会变小。\n\n扩展\n\n元素视图属性\n\n * offsetwidth 水平方向 width + 左右 padding + 左右 border-width（边框）\n\n * offsetheight 垂直方向 height + 上下 padding + 上下 border-width（边框）\n\n * clientwidth 水平方向 width + 左右 padding\n\n * clientheight 垂直方向 height + 上下 padding\n\n * offsettop 获取当前元素到 定位父节点 的 top 方向的距离 若祖宗都不符合条件，offsetparent 为body\n\n * offsetleft 获取当前元素到 定位父节点 的 left 方向的距离 若祖宗都不符合条件，offsetparent 为body\n\n * scrollwidth 元素内容真实的宽度，内容不超出盒子高度时为盒子的 clientwidth\n\n * scrollheight 元素内容真实的高度，内容不超出盒子高度时为盒子的 clientheight\n\nwindow 视图属性\n\n * innerwidth 浏览器窗口可视区宽度（不包括浏览器控制台、菜单栏、工具栏）包含滚动条\n * innerheight 浏览器窗口可视区高度（不包括浏览器控制台、菜单栏、工具栏）包含滚动条\n * outerwidth 浏览器窗口的外部高度 浏览器有非全屏下有边框\n * outerheight 浏览器窗口的外部宽度 浏览器有非全屏下有边框\n\ndocument 文档视图\n\n * document.documentelement.clientwidth 浏览器窗口可视区宽度（不包括浏览器控制台、菜单栏、工具栏、滚动条）\n * document.documentelement.clientheight 浏览器窗口可视区高度（不包括浏览器控制台、菜单栏、工具栏、滚动条）\n * document.documentelement.offsetheight 获取整个文档的高度（包含 body 的 margin）\n * document.body.offsetheight 获取整个文档的高度（不包含 body 的 margin） -document.documentelement.scrolltop 返回文档的滚动 top 方向的距离（当窗口发生滚动时值改变）\n * document.documentelement.scrollleft 返回文档的滚动 left 方向的距离（当窗口发生滚动时值改变）\n\n\n# 谈谈你对 css 盒模型的认识\n\n标准盒子模型，即 box-sizing content-box，浏览器默认模型，我们所写的 width 和 height 并不是最终盒子的宽高，而是 content 的，盒子的宽高由我们的 content+padding+border 来组成的，但是这样在做项目时可能会遇到小问题，假如我想构建一个 100x100 的盒子大小，但是我发现我写的是 width 和 height 是 100，于是我需要加上 padding 及 border，但是加上去之后，盒子也会相应变大，这就造成改动麻烦。\n\n后面 css3 中提供了 ie 盒子模型，能够直接控制盒子的大小。于是项目中大多数用上了 ie 盒子模型，以及我看过 bootstrap 以及 element-ui 源码中大部分也是用的 ie 盒子模型\n\n\n# margin 纵向重叠问题\n\n   <style>\n        p{\n            font-size:16px;\n            line-height:16px;\n            margin-top: 10px;\n            margin-bottom: 15px;\n        }\n    </style>\n</head>\n<body>\n    <p>aaa</p>\n    <p></p>\n    <p></p>\n    <p></p>\n    <p>bbb</p>\n</body>\n\n\naaa 和 bbb 之间的距离？\n\n答案\n * 相邻元素的 margin-top 和 margin-bottom 会发生重叠\n * 空白内容的 p 也会重叠\n * 所以答案为15px\n\n\n# margin 负值问题\n\n * top，left 为负值，元素向上、向左移动\n * right 负值 右侧元素左移，自身不受影响\n * bottom 负值，下方元素上移，自身不受影响\n\n\n# bfc 理解与应用\n\n * 块级格式化上下文\n * 一块独立渲染区域，内部元素的渲染不会影响边界以外的元素。\n * 形成 bfc 的条件？\n\n 1. float 的值不是 none\n\n 2. positon 的值不是 static 或者 relative\n\n 3. display 的值是 inline-block,flex,或者 inline-flex\n\n 4. overflow:hidden\n\n\n# float 布局：实现圣杯和双飞翼布局\n\n> css 布局中圣杯布局与双飞翼布局的实现思路差异在哪里？\n\n\n# 圣杯和双飞翼布局的目的\n\n * 三栏布局，中间一栏最先加载和渲染（内容最重要）\n * 两侧内容固定，中间内容随着宽度自适应\n * 一般用于 pc 网页\n\n\n# 技术总结\n\n * 使用 float 布局\n * 两侧使用 margin 负值，以便和中间内容横向重叠\n * 防止中间内容被两侧覆盖，一个用 padding 一个用 margin\n\n\n# 圣杯布局\n\n特别注意\n\nmin-width 就是页面的最小宽度：要想保证该布局效果正常显示，由于两侧都具有固定的宽度，所以需要给定页面一个最小的宽度，但这并不只是简单的 200+150=350px。回想之前 left 使用了 position: relative，所以就意味着在 center 开始的区域，还存在着一个 left 的宽度。所以页面的最小宽度应该设置为 200+150+200=550px\n\ncss 中，min-width 是用来限制元素的最小宽度，max-width 用来限制元素的最大宽度，也就是说当元素的 width 大于 max-width,或者小于 min-width。就被它们的值所代替，尤其适用于网站的自适应。\n\n理解 css 中 min-width 和 max-width，width 与它们之间的区别联系\n\nsee the pen 圣杯布局 by zhangfanhang (@zhangfanhang) on codepen.\n\n\n# 双飞翼布局\n\n注意\n\n由于双飞翼布局没有用到 position:relative 进行定位，所以最小页面宽度应该为 200+150=350px。但是当页面宽度缩小到 350px 附近时，会挤占中间栏的宽度，使得其内容被右侧栏覆盖，因此在设置最小页面宽度时，应该适当增加一些宽度以供中间栏使用\n\nsee the pen 双飞翼布局 by zhangfanhang (@zhangfanhang) on codepen.\n\n\n# 两者区别\n\n双飞翼布局比圣杯布局多创建了一个 div，但不用相对布局了,终究还是 flex 布局舒服！（flex 实现,代码见 flex 布局）\n\n\n# float 布局：手写 clearfix\n\n.clearfix:after {\n    content: '';\n    display: table;\n    clear: both;\n}\n/* 兼容ie低版本 */\n.clearfix {\n    *zoom: 1;\n}\n\n\n\n# flex 布局\n\n\n# 实现一个三点的色子\n\nsee the pen flex-三点的色子 by zhangfanhang (@zhangfanhang) on codepen.\n\n\n# display:none、visibility:hidden 和 opacity:0 之间的区别？\n\n\n\n扩展：visibility 还有哪些其他的属性值？\n\n\n\n\n# 居中的实现方式\n\n绝对定位+margin auto 垂直居中引发的思考\n\n\n# 水平居中\n\n * inline 元素:text-align:center\n * block 元素：margin: 0 auto（margin:auto）\n * absolute 元素：left:50%+margin-left:-宽度的一半\n * absolute 元素：各个方向为 0，margin:0 auto\n\n\n# 垂直居中\n\n * inline 元素:line-height 的值等于 height 值\n * absolute 元素：top:50%+margin-top:-高度的一半\n * \n\n\n# 垂直水平居中\n\n * absolute 元素：利用 top:50%,left:50%和 margin-top,margin-left (元素尺寸已知可用)\n\n * absolute 元素：利用 top:50%,left:50%和利用 transfrom:translate(-50%,-50%)(元素尺寸不知道也可以用)\n\n * absolute 元素： top,left,bottom,right=0+margin:auto(元素尺寸不知道也可以用)\n\n * flex：align-items:center;justify-content:center;\n\n\n# line-height 如何继承\n\n\n\n * 写具体数值，如 30px，则继承该值（比较好理解），\n * 写比例，如 2/1.5，则继承该比例（比较好理解），\n * 写百分比，如 200%，则继承计算出来的值（考点）\n\nline-height\n\n\n# rem\n\nrem 是一个长度单位，\n\n * px，绝对长度单位，最常用\n * em,相对长度单位，相对于父元素，不常用\n * rem,相对长度单位，相对根元素，常用于响应式布局\n\nhtml {\n    font-size: 100px; // 1rem等于html元素上字体设置的大小\n}\ndiv {\n    font-size: 0.16rem;\n}\n\n\n\n# 用 css 画个三角形\n\n#box {\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-bottom: 100px solid red;\n}\n",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"JS面试题",frontmatter:{title:"JS面试题",date:"2022/05/09 21:08:52",sidebarDepth:2,readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/JS%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"前端面试/JS面试题.md",key:"v-3eb9b545",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/JS%E9%9D%A2%E8%AF%95%E9%A2%98.html",headers:[{level:2,title:"变量类型和计算",slug:"变量类型和计算",normalizedTitle:"变量类型和计算",charIndex:2},{level:3,title:"聊聊 JavaScript 中的数据类型",slug:"聊聊-javascript-中的数据类型",normalizedTitle:"聊聊 javascript 中的数据类型",charIndex:14},{level:3,title:"js 值类型和引用类型的区别",slug:"js-值类型和引用类型的区别",normalizedTitle:"js 值类型和引用类型的区别",charIndex:373},{level:3,title:"typeof 和 instanceof 的区别？",slug:"typeof-和-instanceof-的区别",normalizedTitle:"typeof 和 instanceof 的区别？",charIndex:972},{level:3,title:"变量计算，注意某些类型转换的坑",slug:"变量计算-注意某些类型转换的坑",normalizedTitle:"变量计算，注意某些类型转换的坑",charIndex:1258},{level:3,title:"== 和 === 有什么区别？",slug:"和-有什么区别",normalizedTitle:"== 和 === 有什么区别？",charIndex:1839},{level:2,title:"如何理解 JS 原型（隐式原型和显式原型）和原型链",slug:"如何理解-js-原型-隐式原型和显式原型-和原型链",normalizedTitle:"如何理解 js 原型（隐式原型和显式原型）和原型链",charIndex:2691},{level:2,title:"作用域和闭包",slug:"作用域和闭包",normalizedTitle:"作用域和闭包",charIndex:3142},{level:3,title:"什么是作用域？什么是自由变量？",slug:"什么是作用域-什么是自由变量",normalizedTitle:"什么是作用域？什么是自由变量？",charIndex:3153},{level:3,title:"什么是闭包？闭包会用在哪里？",slug:"什么是闭包-闭包会用在哪里",normalizedTitle:"什么是闭包？闭包会用在哪里？",charIndex:3741},{level:3,title:"this 有几种赋值情况",slug:"this-有几种赋值情况",normalizedTitle:"this 有几种赋值情况",charIndex:5164},{level:3,title:"手写 bind 函数",slug:"手写-bind-函数",normalizedTitle:"手写 bind 函数",charIndex:5340},{level:3,title:"创建 10 个 a,点击弹出序号",slug:"创建-10-个-a-点击弹出序号",normalizedTitle:"创建 10 个 a,点击弹出序号",charIndex:5803},{level:2,title:"异步",slug:"异步",normalizedTitle:"异步",charIndex:4468},{level:3,title:"异步和同步的区别？",slug:"异步和同步的区别",normalizedTitle:"异步和同步的区别？",charIndex:6595},{level:3,title:"手写 promise 加载图片",slug:"手写-promise-加载图片",normalizedTitle:"手写 promise 加载图片",charIndex:6644},{level:3,title:"setTimeout",slug:"settimeout",normalizedTitle:"settimeout",charIndex:4377},{level:3,title:"下面代码的输出结果是（async 函数）？",slug:"下面代码的输出结果是-async-函数",normalizedTitle:"下面代码的输出结果是（async 函数）？",charIndex:8297},{level:2,title:"JS-Web-API-DOM",slug:"js-web-api-dom",normalizedTitle:"js-web-api-dom",charIndex:8657},{level:3,title:"DOM 是那种数据结构？---树",slug:"dom-是那种数据结构-树",normalizedTitle:"dom 是那种数据结构？---树",charIndex:8676},{level:3,title:"DOM 操作常见的 API",slug:"dom-操作常见的-api",normalizedTitle:"dom 操作常见的 api",charIndex:8697},{level:3,title:"property 和 attribute 的区别",slug:"property-和-attribute-的区别",normalizedTitle:"property 和 attribute 的区别",charIndex:8741},{level:3,title:"如何优化 DOM 性能的性能",slug:"如何优化-dom-性能的性能",normalizedTitle:"如何优化 dom 性能的性能",charIndex:8865},{level:2,title:"JS-Web-API-事件",slug:"js-web-api-事件",normalizedTitle:"js-web-api-事件",charIndex:8929},{level:3,title:"编写一个通用的事件监听函数",slug:"编写一个通用的事件监听函数",normalizedTitle:"编写一个通用的事件监听函数",charIndex:8947},{level:3,title:"描述事件冒泡的流程",slug:"描述事件冒泡的流程",normalizedTitle:"描述事件冒泡的流程",charIndex:9954},{level:3,title:"无限下拉的图片列表，如何监听每个图片的点击",slug:"无限下拉的图片列表-如何监听每个图片的点击",normalizedTitle:"无限下拉的图片列表，如何监听每个图片的点击",charIndex:10059},{level:2,title:"ES6",slug:"es6",normalizedTitle:"es6",charIndex:183},{level:3,title:"说说 var、let、const 之间的区别？",slug:"说说-var、let、const-之间的区别",normalizedTitle:"说说 var、let、const 之间的区别？",charIndex:10149},{level:3,title:"箭头函数和普通函数的区别？",slug:"箭头函数和普通函数的区别",normalizedTitle:"箭头函数和普通函数的区别？",charIndex:10542},{level:3,title:"不适用箭头函数的场景?",slug:"不适用箭头函数的场景",normalizedTitle:"不适用箭头函数的场景?",charIndex:12406},{level:2,title:"Map 与 WeakMap 的区别与使用",slug:"map-与-weakmap-的区别与使用",normalizedTitle:"map 与 weakmap 的区别与使用",charIndex:12491},{level:2,title:"输出题&脑瘫题",slug:"输出题-脑瘫题",normalizedTitle:"输出题&amp;脑瘫题",charIndex:null},{level:3,title:"如何让 a==1 && a==2 && a==3 为 true",slug:"如何让-a-1-a-2-a-3-为-true",normalizedTitle:"如何让 a==1 &amp;&amp; a==2 &amp;&amp; a==3 为 true",charIndex:null},{level:3,title:"['1','2','3'].map(parseInt)会输出什么？",slug:"_1-2-3-map-parseint-会输出什么",normalizedTitle:"['1','2','3'].map(parseint)会输出什么？",charIndex:13854},{level:2,title:"JS 原理&机制",slug:"js-原理-机制",normalizedTitle:"js 原理&amp;机制",charIndex:null},{level:3,title:"说一下 js 的垃圾回收机制",slug:"说一下-js-的垃圾回收机制",normalizedTitle:"说一下 js 的垃圾回收机制",charIndex:15699},{level:3,title:"new 的原理？",slug:"new-的原理",normalizedTitle:"new 的原理？",charIndex:16225}],headersStr:"变量类型和计算 聊聊 JavaScript 中的数据类型 js 值类型和引用类型的区别 typeof 和 instanceof 的区别？ 变量计算，注意某些类型转换的坑 == 和 === 有什么区别？ 如何理解 JS 原型（隐式原型和显式原型）和原型链 作用域和闭包 什么是作用域？什么是自由变量？ 什么是闭包？闭包会用在哪里？ this 有几种赋值情况 手写 bind 函数 创建 10 个 a,点击弹出序号 异步 异步和同步的区别？ 手写 promise 加载图片 setTimeout 下面代码的输出结果是（async 函数）？ JS-Web-API-DOM DOM 是那种数据结构？---树 DOM 操作常见的 API property 和 attribute 的区别 如何优化 DOM 性能的性能 JS-Web-API-事件 编写一个通用的事件监听函数 描述事件冒泡的流程 无限下拉的图片列表，如何监听每个图片的点击 ES6 说说 var、let、const 之间的区别？ 箭头函数和普通函数的区别？ 不适用箭头函数的场景? Map 与 WeakMap 的区别与使用 输出题&脑瘫题 如何让 a==1 && a==2 && a==3 为 true ['1','2','3'].map(parseInt)会输出什么？ JS 原理&机制 说一下 js 的垃圾回收机制 new 的原理？",content:"# 变量类型和计算\n\n\n# 聊聊 JavaScript 中的数据类型\n\n参考\n\n【Step-By-Step】一周面试题 && 答案汇总 / 01\n\n【面试说】聊聊 JavaScript 中的数据类型\n\n目前，JS 原始类型有六种，分别为:\n\n * Boolean\n * String\n * Number\n * Undefined\n * Null\n * Symbol(ES6 新增)\n\nES10 新增了一种基本数据类型：BigInt\n\n复杂数据类型只有一种: Object\n\nnull 不是一个对象，尽管 typeof null 输出的是 object，这是一个历史遗留问题，JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，null 表示为全零，所以将它错误的判断为 object\n\n\n# js 值类型和引用类型的区别\n\n参考\n\n【Step-By-Step】一周面试题 && 答案汇总 / 01\n\n内存的分配不同\n\n * 基本数据类型存储在栈中\n * 复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址。\n\n访问机制不同\n\n * 基本数据类型是按值访问\n * 复杂数据类型按引用访问，JS 不允许直接访问保存在堆内存中的对象，在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象的值\n\n复制变量时不同(a=b)\n\n * 基本数据类型：a=b;是将 b 中保存的原始值的副本赋值给新变量 a,a 和 b 完全独立，互不影响\n * 复杂数据类型：a=b;将 b 保存的对象内存的引用地址赋值给了新变量 a;a 和 b 指向了同一个堆内存地址，其中一个值发生了改变，另一个也会改变\n\n比较变量时不同(== , ===)\n\n * 基本数据类型：==比较值是否相等(先进行类型转换再确定操作数是否相等---引自 js 高级程序设计（第四版） P71)，===不仅比较值是否相等，还会比较数据类型是否相同\n\n * 引用数据类型：不管是 == 还是 === ，都是比较内存地址是否相同，即比较是否都指向同一个对象\n\n参数传递的不同(实参/形参)\n\n函数传参都是按值传递(栈中的存储的内容)：基本数据类型，拷贝的是值；复杂数据类型，拷贝的是引用地址\n\n\n# typeof 和 instanceof 的区别？\n\n拓展-参考\n\n手写实现 typeof 和 instanceof，并了解原理\n\ntypeof 对于string,boolean,number,undefined,function,symbol等类型可正确判断\n\n对于null,array,object判断结果均为 object\n\ninstanceof 代码形式为object instanceof constructor（object 是否是 constructor 的实例），该操作符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\n\n\n# 变量计算，注意某些类型转换的坑\n\n 1. 字符串拼接\n\nconst a = 100 + 10\nconst b = 100 + '10' // 只要有一个不是数字，就是字符串拼接\nconst c = true + 10\nconsole.log(a, b, c) // 110 10010 11\n\n\n 2. == 运算符\n\n除了 == null 之外 其它地方一律用===\n\nconst obj = { a: 2 }\nif (obj.b == null) {\n    // 相当于 if(obj.b===null||obj.b===undefined)\n    console.log('b')\n}\n\n\n 3. if 语句和逻辑运算\n\ntruly 变量:!!a===true 的变量\n\nfalsy 变量:!!a===false 的变量\n\n以下是 falsy 变量。除此之外都是 truly 变量\n\n!!0 == false\n!!NaN == false\n!!'' == false\n!!null == false\n!!undefined == false\n!!false == false\n\n\nif 语句:判断该变量是 truly 变量还是 falsy 变量\n\nconst a = 100\nif (a) {\n    // ...\n}\n\n\n逻辑判断:短路计算\n\n\n# == 和 === 有什么区别？\n\n对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换\n\n假如我们需要对比 x 和 y 是否相同，就会进行如下判断流程：\n\n 1. 首先会判断两者类型是否相同。相同的话就是比大小了\n\n 2. 类型不相同的话，那么就会进行类型转换\n\n 3. 会先判断是否在对比 null 和 undefined，是的话就会返回 true\n\n 4. 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number\n\n1 == '1'\n      ↓\n1 ==  1\n\n\n 5. 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断\n\n'1' == true\n        ↓\n'1' ==  1\n        ↓\n 1  ==  1\n\n\n 6. 判断其中一方是否为 object 且另一方为 string、number或者 symbol，是的话就会把 object 转为原始类型再进行判断\n\n'1' == { name: 'yck' }\n        ↓\n'1' == '[object Object]'\n\n\n扩展：[] == ![] 和 {} == !{}\n\n * [] == ![]\n\nECMAScript 中规定，逻辑非 (!) 的优先级高于相等操作符 ( == )\n\n在比较 [] == ![] 的时候，先计算 ![] 得到布尔值 false\n\n所以实际上比较的是 [] == false\n\nNumber([]) == Number(false) // ->  0 == 0  ->  true\n\n\n * {} == !{}\n\n{} == !{}  ->  {} == false  ->  Number({}) == Number(false)  ->  NaN == 0\n\n\n如果有一个操作数是 NaN，相等操作符返回 false\n\n所以 {} == !{} 的结果是 false\n\n\n# 如何理解 JS 原型（隐式原型和显式原型）和原型链\n\n在 JavaScript 中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，这个就是显式原型，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针(proto)，这个指针指向构造函数的 prototype 属性对应的值，这个就是隐式原型__proto__。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。\n\n当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。所以这就是新建的对象为什么能够使用 toString() 等方法的原因。\n\n原型链的终点是 null,因为 Object.prototype.__proto__指向 null\n\n\n# 作用域和闭包\n\n\n# 什么是作用域？什么是自由变量？\n\n参考\n\n函数的作用域是什么？js 的作用域有几种？\n\n全局作用域\n\n声明在任何函数之外的顶层作用域的变量就是全局变量，这样的变量拥有全局作用域\n\n所有未定义直接赋值的变量自动声明为全局作用域=> a=100\n\n所有 window 对象的属性拥有全局作用域\n\n全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。\n\n函数作用域\n\n在函数内部定义的变量(局部变量)，拥有函数作用域\n\n只有函数被调用的时候才会形成函数作用域\n\n内层作用域可以访问外层作用域，反之不行\n\n块级作用域\n\n使用 ES6 中新增的 let 和 const 指令可以声明块级作用域\n\n块作用域内的变量只要出了自己被定义的那个代码块，那么就无法访问了。\n\n在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。\n\n自由变量\n\n一个变量在当前作用域没有定义，但被使用了；向上级作用域，一层一层依次寻找，直至找到为止；如果到全局作用域都没找到，则报错 xx is not defined\n\n作用域链\n\n在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到 window 对象就被终止，这一层层的关系就是作用域链。\n\n\n# 什么是闭包？闭包会用在哪里？\n\n破解前端面试（80% 应聘者不及格系列）：从闭包说起\n\n在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量。而引用了自由变量的函数，就叫闭包\n\n闭包有两个常用的用途：\n\n * 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量，可以使用这种方法来创建私有变量如：\n\nfunction createCache() {\n    const data = {}\n    return {\n        get: function (key) {\n            return data[key]\n        },\n        set: function (key, val) {\n            data[key] = val\n        },\n    }\n}\nconst c = createCache()\nc.set('a', 100)\nconsole.log(c.get('a'))\n\n\n * 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象(每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上)继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收\n\n🌟闭包经典面试题：\n\nfor (var i = 1; i <= 5; i++) {\n    setTimeout(function timer() {\n        console.log(i)\n    }, i * 1000)\n}\n\n\n首先因为 setTimeout 是异步的，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。那如果我们要正确输出 1 ～ 6,该如何处理呢？解决办法有三种：\n\n * 第一种是使用闭包的方式\n\nfor (var i = 1; i <= 5; i++) {\n    ;(function (j) {\n        setTimeout(function timer() {\n            console.log(j)\n        }, j * 1000)\n    })(i)\n}\n\n\n在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的\n\n * 第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。\n\nfor (var i = 1; i <= 5; i++) {\n    setTimeout(\n        function timer(j) {\n            console.log(j)\n        },\n        i * 1000,\n        i\n    )\n}\n\n\n * 第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式\n\nfor (let i = 1; i <= 5; i++) {\n    setTimeout(function timer() {\n        console.log(i)\n    }, i * 1000)\n}\n\n\n\n# this 有几种赋值情况\n\nthis 取什么值函数执行时确认的，不是在函数定义时确认的\n\n * 作为普通函数使用\n\n * call apply bind\n\n * 作为对象方法被调用\n\n\n\n * 在 class 方法中调用\n\n * 箭头函数的this永远取它上层作用域的this\n\n * 原型中的 this\n\n前端面试之彻底搞懂 this 指向\n\n\n# 手写 bind 函数\n\n提示\n\nbind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\n\nbind 的用法\n\nfunction fn1(a, b, c) {\n    console.log('this', this)\n    console.log(a, b, c)\n    return 'this is fn1'\n}\nconst fn2 = fn1.bind({ x: 100 }, 10, 20, 30)\nconst res = fn2()\nconsole.log(res)\n\n\n手写 bind\n\n    Function.prototype.bind1=function(context,...args){\n    const self = this\n    return function (){\n        return self.apply(context,args)\n    }\n\n\n\n# 创建 10 个 a,点击弹出序号\n\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n    </head>\n    <body>\n        <div id=\"root\"></div>\n        <script type=\"text/javascript\">\n            const root = document.getElementById('root')\n            for (let i = 1; i <= 10; i++) {\n                const a = document.createElement('a')\n                a.innerText = i\n                a.style.display = 'block'\n                root.appendChild(a)\n            }\n            root.onclick = function (e) {\n                alert(e.target.innerText)\n            }\n        <\/script>\n    </body>\n</html>\n\n\n\n# 异步\n\n\n# 异步和同步的区别？\n\n基于 JS 是单线程语言，异步不会阻塞代码执行，同步会阻塞代码执行\n\n\n# 手写 promise 加载图片\n\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>promise加载图片</title>\n    </head>\n\n    <body>\n        <div id=\"root\"></div>\n        <script type=\"text/javascript\">\n            const URL = 'https://zfhblog.top/titlelogo.png'\n            const root = document.getElementById('root')\n\n            function loadImg(url) {\n                return new Promise((resolve, reject) => {\n                    const img = document.createElement('img')\n                    // 加载完\n                    img.onload = () => {\n                        resolve(img)\n                    }\n                    // 加载失败\n                    img.onerror = () => {\n                        const err = new Error(`图片加载失败了,图片地址为${url}`)\n                        reject(err)\n                    }\n                    img.src = url\n                })\n            }\n            loadImg(URL)\n                .then(img => {\n                    root.appendChild(img)\n                    console.log('我第二个执行then')\n                })\n                .catch(err => {\n                    console.log(err)\n                })\n            console.log('我第一个执行，同步代码')\n            setTimeout(() => {\n                console.log('我第三个执行setTimeout')\n            }, 0)\n        <\/script>\n    </body>\n</html>\n\n\n\n# setTimeout\n\nconsole.log(1)\nsetTimeout(function () {\n    console.log(2)\n}, 1000)\nconsole.log(3)\nsetTimeout(function () {\n    console.log(4)\n}, 0)\nconsole.log(5)\n\n\n输出结果: 1 , 3 , 5 , 4 , 2\n\n\n# 下面代码的输出结果是（async 函数）？\n\nasync function getData() {\n    return await Promise.resolve('I made it!')\n}\nconst data = getData()\nconsole.log(data)\n\n\n异步函数始终返回一个 promise. await 仍然需要等待 promise 的解决：当我们调用 getData（）并将其赋值给 data，此时 data 为 getData 方法返回的一个挂起的 promise，该 promise 并没有解决。 如果我们想要访问已解决的值 ' I made it！'，可以在 data 上使用 then（）方法：\n\ndata.then(res => console.log(res))\n\n\n\n# JS-Web-API-DOM\n\n\n# DOM 是那种数据结构？---树\n\n\n# DOM 操作常见的 API\n\n * DOM 节点操作\n\n * DOM 结构操作\n\n\n# property 和 attribute 的区别\n\n * property : 修改对象属性，不会体现到 html 结构中\n\n * attribute : 修改 html 属性，会改变 html 结构\n\n两者都有可能引起 DOM 重新渲染\n\n\n# 如何优化 DOM 性能的性能\n\nDOM 查询做缓存\n\n\n\n将频繁操作改为一次性操作(一次性插入多个节点，考虑性能)\n\n\n\n\n# JS-Web-API-事件\n\n\n# 编写一个通用的事件监听函数\n\nElement.matches()\n\n如果元素被指定的选择器字符串选择，Element.matches()方法返回 true; 否则返回 false。\n\n语法：let result = element.matches(selectorString)\n\n * result 的值为 true 或 false.\n * selectorString 是个 css 选择器字符串.\n\nfunction bindEvent(elem, type, selector, fn) {\n    if (fn == null) {\n        fn = selector\n        selector = null\n    }\n    elem.addEventListener(type, event => {\n        const target = event.target\n        if (selector) {\n            // 代理绑定\n            if (target.matches(selector)) {\n                fn.call(target, event)\n            }\n        } else {\n            // 普通绑定\n            fn.call(target, event)\n        }\n    })\n}\n\n// 普通绑定\nconst btn1 = document.getElementById('btn1')\nbindEvent(btn1, 'click', function (event) {\n    // console.log(event.target) // 获取触发的元素\n    event.preventDefault() // 阻止默认行为\n    alert(this.innerHTML)\n})\n\n// 代理绑定\nconst div3 = document.getElementById('div3')\nbindEvent(div3, 'click', 'a', function (event) {\n    event.preventDefault()\n    alert(this.innerHTML)\n})\n\n\n\n# 描述事件冒泡的流程\n\n * 基于 DOM 树形结构\n\n * 事件会顺着触发元素向上冒泡\n\n * 应用场景：代理(利用事件冒泡机制，将后代元素事件代理(事件委托)给祖先元素)=>event.target\n\n\n# 无限下拉的图片列表，如何监听每个图片的点击\n\n * 事件代理\n\n * 用 e.target 获取触发元素\n\n * 用 matches 来判断是否是触发元素\n\n\n# ES6\n\n\n# 说说 var、let、const 之间的区别？\n\n * 变量提升: var 会提升的变量的声明到当前作用域的顶部 let const 不会\n\n * 暂时性死区：在代码块内，使用 let、const 命令声明变量或常量之前，该变量或常量都是不可用的。这在语法上，称为“暂时性死区”\n\n * 块级作用域：var 没有块级作用域，let const 有块级作用域\n\n * 重复声明： var 允许重复声明，let,const 不允许不允许在相同作用域内，重复声明同一个变量。\n\n * 修改声明的变量： var 和 let 可以修改;const 声明一个只读的常量，并且 const 声明时，必须立即初始化\n\n * window 对象的属性和方法:全局作用域中，var声明的变量和通过function声明的函数，会自动变成 window 对象的属性或方法，let、 const 不会。\n\n\n# 箭头函数和普通函数的区别？\n\n不懂的点\n\nyield命令,Generator函数\n\n * 箭头函数没有 prototype (原型)，所以箭头函数本身没有 this\n\n// 箭头函数\nlet a = () => {}\nconsole.log(a.prototype) // undefined\n\n// 普通函数\nfunction a() {}\nconsole.log(a.prototype) // {constructor:f}\n\n\n * 箭头函数不会创建自己的 this\n\n箭头函数没有自己的 this，箭头函数的 this 指向在定义（注意：是定义时，不是调用时）的时候继承自外层第一个普通函数的 this。所以，箭头函数中 this 的指向在它被定义的时候就已经确定了，之后永远不会改变。\n\nlet obj = {\n    a: 10,\n    b: () => {\n        console.log(this.a) // undefined\n        console.log(this) // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}\n    },\n    c: function () {\n        console.log(this.a) // 10\n        console.log(this) // {a: 10, b: ƒ, c: ƒ}\n    },\n}\nobj.b()\nobj.c()\n\n\n * call | apply | bind 无法改变箭头函数中 this 的指向\n\ncall | apply | bind 方法可以用来动态修改函数执行时 this 的指向，但由于箭头函数的 this 定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数 this 的指向。\n\nvar id = 10\nlet fun = () => {\n    console.log(this.id)\n}\nfun() // 10\nfun.call({ id: 20 }) // 10\nfun.apply({ id: 20 }) // 10\nfun.bind({ id: 20 })() // 10\n\n\n * 箭头函数不能作为构造函数使用\n\n我们先了解一下构造函数的 new 都做了些什么？简单来说，分为四步： ① JS 内部首先会先生成一个对象； ② 再把函数中的 this 指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例。但是！！因为箭头函数没有自己的 this，它的 this 其实是继承了外层执行环境中的 this，且 this 指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用 new 调用时会报错！\n\nlet Fun = (name, age) => {\n    this.name = name\n    this.age = age\n}\n// 报错\nlet p = new Fun('dingFY', 24)\n\n\n * 箭头函数不绑定 arguments，取而代之用 rest 参数...代替 arguments 对象，来访问箭头函数的参数列表\n\n箭头函数没有自己的 arguments 对象。在箭头函数中访问 arguments 实际上获得的是外层局部（函数）执行环境中的值。\n\n// 普通函数\nfunction A(a) {\n    console.log(arguments)\n}\nA(1, 2, 3, 4, 5, 8) //  [1, 2, 3, 4, 5, 8, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n\n// 箭头函数\nlet B = b => {\n    console.log(arguments)\n}\nB(2, 92, 32, 32) // Uncaught ReferenceError: arguments is not defined\n\n// rest参数...\nlet C = (...c) => {\n    console.log(c)\n}\nC(3, 82, 32, 11323) // [3, 82, 32, 11323]\n\n\n * 箭头函数不能用作 Generator 函数，不能使用 yield 关键字\n\n\n# 不适用箭头函数的场景?\n\n作为构造函数：因为箭头函数没有 this\n\n需要 this 指向调用对象的时候：如事件处理函数\n\n需要使用 arguments 的时候\n\n\n# Map 与 WeakMap 的区别与使用\n\nWeakMap\n\nWeakSet\n\n1、WeakMap只接受对象作为 key，如果设置其他类型的数据作为 key，会报错。\n\n2、WeakMap 的 key 所引用的对象都是弱引用，只要对象的其他引用被删除，垃圾回收机制就会释放该对象占用的内存，从而避免内存泄漏。\n\n3、由于 WeakMap 的成员随时可能被垃圾回收机制回收，成员的数量不稳定，所以没有 size 属性。\n\n4、没有clear()方法\n\n5、不能遍历\n\n\n# 输出题&脑瘫题\n\n\n# 如何让 a==1 && a==2 && a==3 为 true\n\n参考\n\n「前端面试题」(a ==1 && a== 2 && a==3) 有可能是 true 吗？\n\n涉及考点：隐式类型转换\n\n1.重写默认属性方法\n\nlet a = {\n    i: 1,\n    toString: function () {\n        return this.i++\n    },\n}\nconsole.log(a == 1 && a == 2 && a == 3)\n// valueOf\nlet b = {\n    i: 1,\n    valueOf: function () {\n        return this.i++\n    },\n}\nconsole.log(b == 1 && b == 2 && b == 3)\n// [Symbol.toPrimitive]\nlet c = {\n    i: 1,\n    [Symbol.toPrimitive]: function () {\n        return this.i++\n    },\n}\nconsole.log(c == 1 && c == 2 && c == 3)\n\n\n三个方法的优先级： Symbol.toPrimitive > valueOf > toString\n\n 2. 数据劫持\n\nlet tmp = 1\nObject.defineProperty(window, 'a', {\n    get: function () {\n        return tmp++\n    },\n})\nconsole.log(a === 1 && a === 2 && a === 3)\n\n\n 3. es6 proxy\n\nlet a = new Proxy(\n    {},\n    {\n        tmp: 1,\n        get(target, key) {\n            return () => this.tmp++\n        },\n    }\n)\nconsole.log(a == 1 && a == 2 && a == 3)\n\n\n 4. 重写 Number 对象的 valueOf\n\nNumber.prototype.valueOf = (function () {\n    let i = 1\n    return () => {\n        return i++\n    }\n})()\nlet a = new Number(1)\nconsole.log(a == 1 && a == 2 && a == 3)\n\n\n\n# ['1','2','3'].map(parseInt)会输出什么？\n\n参考\n\n['1','2','3'].map(parseInt) [‘1‘,‘2‘,‘3‘].map(parseInt)结果讲解\n\n答案\n\n[ 1, NaN, NaN ]\n\n 1. map 函数\n\n['1','2','3'].map(parseInt)可以看作：\n\n['1', '2', '3'].map(function (value, index) {\n\treturn parseInt(value, index)\n})\n// 细节\nindex = 0: parsetInt('1', 0) = 1\nindex = 1: parsetInt('2', 1) = NaN\nindex = 2: parsetInt('3', 2) = NaN // 因为 2进制必须是 0，1数字表示\n\n\n将数组的每个元素传递给指定的函数处理，并返回处理后的数组，所以 ['1','2','3'].map(parseInt) 就是将字符串 1，2，3 作为元素；0，1，2 作为下标分别调用 parseInt 函数。即分别求出 parseInt('1',0), parseInt('2',1), parseInt('3',2)的结果。\n\n 2. parseInt 函数（重点）\n\n概念：以第二个参数为基数来解析第一个参数字符串，通常用来做十进制的向上取整（省略小数）如：parseInt(2.7) //结果为 2\n\n特点：接收两个参数 parseInt(string,radix)\n\nstring：字母（大小写均可）、数组、特殊字符（不可放在开头,特殊字符及特殊字符后面的内容不做解析）的任意字符串，如 '2'、'2w'、'2!'\n\nradix：解析字符串的基数，基数规则如下：\n\n1） 区间范围介于 2~36 之间；\n\n2） 当参数为 0，parseInt() 会根据十进制来解析；\n\n3） 如果忽略该参数，默认的基数规则：\n\n * 如果 string 以 \"0x\" 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数；parseInt(\"0xf\") //15\n\n * 如果 string 以 0 开头，其后的字符解析为八进制或十六进制的数字；parseInt(\"08\") //8\n\n * 如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数；parseInt(\"88.99f\") //88\n\n * 只有字符串中的第一个数字会被返回。parseInt(\"10.33\") //返回 10；\n\n * 开头和结尾的空格是允许的。parseInt(\" 69 10 \") //返回 69\n\n * 如果字符串的第一个字符不能被转换为数字，返回 NaN。parseInt(\"f\") //返回 NaN 而 parseInt(\"f\"，16) //返回 15\n\n 3. 再来分析一下结果\n\n['1','2','3'].map(parseInt)即:\n\nparseInt('1',0);radix 为 0，parseInt() 会根据十进制来解析，所以结果为 1；\n\nparseInt('2',1);radix 为 1，超出区间范围，所以结果为 NaN；\n\nparseInt('3',2);radix 为 2，用 2 进制来解析，应以 0 和 1 开头，所以结果为 NaN。\n\n 4. parseInt 方法解析的运算过程\n\nparseInt('101.55',10); //以十进制解析，运算过程：向上取整数(不做四舍五入，省略小数)，结果为 101。\n\nparseInt('101',2); //以二进制解析，运算过程：12 的 2 次方+02 的 1 次方+1*2 的 0 次方=4+0+1=5，结果为 5。\n\nparseInt('101',8); //以八进制解析，运算过程：18 的 2 次方+08 的 1 次方+1*8 的 0 次方=64+0+1=65，结果为 65。\n\nparseInt('101',16); //以十六进制解析，运算过程：116 的 2 次方+016 的 1 次方+1*16 的 0 次方=256+0+1=257，结果为 257。\n\n扩展\n\nmap 和 forEach 数组中 forEach() 和 map() 的区别\n\n\n# JS 原理&机制\n\n\n# 说一下 js 的垃圾回收机制\n\n「硬核 JS」你真的了解垃圾回收机制吗\n\njavaScript 具有自动垃圾收集机制\n\n标记清除,主流的垃圾收集算法，给不使用的值加上标记，然后回收其内存。\n\n引用计数，这种算法是跟踪记录所有值被引用的次数，不在使用这种算法。(存在循环引用的问题)\n\n循环引用\n\nfunction test() {\n    let A = new Object() // 1\n    let B = new Object() // 1\n\n    A.b = B // 2\n    B.a = A // 2\n}\n\n\n如上所示，对象 A 和 B 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 test 执行完成之后，对象 A 和 B 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放\n\n我们再用标记清除的角度看一下，当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一\n\n\n# new 的原理？\n\n * new 的工作流程：\n\n1）在内存中创建一个新对象\n\n2）将新对象与构造函数通过原型链连接起来\n\n3）将构造函数中的this 绑定到新对象上\n\n4）执行构造函数内部的代码\n\n5）如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象\n\n * 手写 new\n\nfunction myNew(Func, ...args) {\n    // 1.创建一个新对象\n    const obj = {}\n    // 2.新对象原型指向构造函数原型对象\n    obj.__proto__ = Func.prototype\n    // 3.将构建函数的this指向新对象\n    let result = Func.apply(obj, args)\n    // 4.根据返回值判断\n    return result instanceof Object ? result : obj\n}\n\nfunction foo(age, name) {\n    this.name = name\n    this.age = age\n}\n\nconst obj = myNew(foo, 14, 'frank')\nconsole.log(obj)\n",normalizedContent:"# 变量类型和计算\n\n\n# 聊聊 javascript 中的数据类型\n\n参考\n\n【step-by-step】一周面试题 && 答案汇总 / 01\n\n【面试说】聊聊 javascript 中的数据类型\n\n目前，js 原始类型有六种，分别为:\n\n * boolean\n * string\n * number\n * undefined\n * null\n * symbol(es6 新增)\n\nes10 新增了一种基本数据类型：bigint\n\n复杂数据类型只有一种: object\n\nnull 不是一个对象，尽管 typeof null 输出的是 object，这是一个历史遗留问题，js 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，null 表示为全零，所以将它错误的判断为 object\n\n\n# js 值类型和引用类型的区别\n\n参考\n\n【step-by-step】一周面试题 && 答案汇总 / 01\n\n内存的分配不同\n\n * 基本数据类型存储在栈中\n * 复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址。\n\n访问机制不同\n\n * 基本数据类型是按值访问\n * 复杂数据类型按引用访问，js 不允许直接访问保存在堆内存中的对象，在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象的值\n\n复制变量时不同(a=b)\n\n * 基本数据类型：a=b;是将 b 中保存的原始值的副本赋值给新变量 a,a 和 b 完全独立，互不影响\n * 复杂数据类型：a=b;将 b 保存的对象内存的引用地址赋值给了新变量 a;a 和 b 指向了同一个堆内存地址，其中一个值发生了改变，另一个也会改变\n\n比较变量时不同(== , ===)\n\n * 基本数据类型：==比较值是否相等(先进行类型转换再确定操作数是否相等---引自 js 高级程序设计（第四版） p71)，===不仅比较值是否相等，还会比较数据类型是否相同\n\n * 引用数据类型：不管是 == 还是 === ，都是比较内存地址是否相同，即比较是否都指向同一个对象\n\n参数传递的不同(实参/形参)\n\n函数传参都是按值传递(栈中的存储的内容)：基本数据类型，拷贝的是值；复杂数据类型，拷贝的是引用地址\n\n\n# typeof 和 instanceof 的区别？\n\n拓展-参考\n\n手写实现 typeof 和 instanceof，并了解原理\n\ntypeof 对于string,boolean,number,undefined,function,symbol等类型可正确判断\n\n对于null,array,object判断结果均为 object\n\ninstanceof 代码形式为object instanceof constructor（object 是否是 constructor 的实例），该操作符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\n\n\n# 变量计算，注意某些类型转换的坑\n\n 1. 字符串拼接\n\nconst a = 100 + 10\nconst b = 100 + '10' // 只要有一个不是数字，就是字符串拼接\nconst c = true + 10\nconsole.log(a, b, c) // 110 10010 11\n\n\n 2. == 运算符\n\n除了 == null 之外 其它地方一律用===\n\nconst obj = { a: 2 }\nif (obj.b == null) {\n    // 相当于 if(obj.b===null||obj.b===undefined)\n    console.log('b')\n}\n\n\n 3. if 语句和逻辑运算\n\ntruly 变量:!!a===true 的变量\n\nfalsy 变量:!!a===false 的变量\n\n以下是 falsy 变量。除此之外都是 truly 变量\n\n!!0 == false\n!!nan == false\n!!'' == false\n!!null == false\n!!undefined == false\n!!false == false\n\n\nif 语句:判断该变量是 truly 变量还是 falsy 变量\n\nconst a = 100\nif (a) {\n    // ...\n}\n\n\n逻辑判断:短路计算\n\n\n# == 和 === 有什么区别？\n\n对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换\n\n假如我们需要对比 x 和 y 是否相同，就会进行如下判断流程：\n\n 1. 首先会判断两者类型是否相同。相同的话就是比大小了\n\n 2. 类型不相同的话，那么就会进行类型转换\n\n 3. 会先判断是否在对比 null 和 undefined，是的话就会返回 true\n\n 4. 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number\n\n1 == '1'\n      ↓\n1 ==  1\n\n\n 5. 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断\n\n'1' == true\n        ↓\n'1' ==  1\n        ↓\n 1  ==  1\n\n\n 6. 判断其中一方是否为 object 且另一方为 string、number或者 symbol，是的话就会把 object 转为原始类型再进行判断\n\n'1' == { name: 'yck' }\n        ↓\n'1' == '[object object]'\n\n\n扩展：[] == ![] 和 {} == !{}\n\n * [] == ![]\n\necmascript 中规定，逻辑非 (!) 的优先级高于相等操作符 ( == )\n\n在比较 [] == ![] 的时候，先计算 ![] 得到布尔值 false\n\n所以实际上比较的是 [] == false\n\nnumber([]) == number(false) // ->  0 == 0  ->  true\n\n\n * {} == !{}\n\n{} == !{}  ->  {} == false  ->  number({}) == number(false)  ->  nan == 0\n\n\n如果有一个操作数是 nan，相等操作符返回 false\n\n所以 {} == !{} 的结果是 false\n\n\n# 如何理解 js 原型（隐式原型和显式原型）和原型链\n\n在 javascript 中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，这个就是显式原型，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针(proto)，这个指针指向构造函数的 prototype 属性对应的值，这个就是隐式原型__proto__。es5 中新增了一个 object.getprototypeof() 方法，可以通过这个方法来获取对象的原型。\n\n当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。所以这就是新建的对象为什么能够使用 tostring() 等方法的原因。\n\n原型链的终点是 null,因为 object.prototype.__proto__指向 null\n\n\n# 作用域和闭包\n\n\n# 什么是作用域？什么是自由变量？\n\n参考\n\n函数的作用域是什么？js 的作用域有几种？\n\n全局作用域\n\n声明在任何函数之外的顶层作用域的变量就是全局变量，这样的变量拥有全局作用域\n\n所有未定义直接赋值的变量自动声明为全局作用域=> a=100\n\n所有 window 对象的属性拥有全局作用域\n\n全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。\n\n函数作用域\n\n在函数内部定义的变量(局部变量)，拥有函数作用域\n\n只有函数被调用的时候才会形成函数作用域\n\n内层作用域可以访问外层作用域，反之不行\n\n块级作用域\n\n使用 es6 中新增的 let 和 const 指令可以声明块级作用域\n\n块作用域内的变量只要出了自己被定义的那个代码块，那么就无法访问了。\n\n在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。\n\n自由变量\n\n一个变量在当前作用域没有定义，但被使用了；向上级作用域，一层一层依次寻找，直至找到为止；如果到全局作用域都没找到，则报错 xx is not defined\n\n作用域链\n\n在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到 window 对象就被终止，这一层层的关系就是作用域链。\n\n\n# 什么是闭包？闭包会用在哪里？\n\n破解前端面试（80% 应聘者不及格系列）：从闭包说起\n\n在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量。而引用了自由变量的函数，就叫闭包\n\n闭包有两个常用的用途：\n\n * 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量，可以使用这种方法来创建私有变量如：\n\nfunction createcache() {\n    const data = {}\n    return {\n        get: function (key) {\n            return data[key]\n        },\n        set: function (key, val) {\n            data[key] = val\n        },\n    }\n}\nconst c = createcache()\nc.set('a', 100)\nconsole.log(c.get('a'))\n\n\n * 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象(每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上)继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收\n\n🌟闭包经典面试题：\n\nfor (var i = 1; i <= 5; i++) {\n    settimeout(function timer() {\n        console.log(i)\n    }, i * 1000)\n}\n\n\n首先因为 settimeout 是异步的，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。那如果我们要正确输出 1 ～ 6,该如何处理呢？解决办法有三种：\n\n * 第一种是使用闭包的方式\n\nfor (var i = 1; i <= 5; i++) {\n    ;(function (j) {\n        settimeout(function timer() {\n            console.log(j)\n        }, j * 1000)\n    })(i)\n}\n\n\n在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的\n\n * 第二种就是使用 settimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。\n\nfor (var i = 1; i <= 5; i++) {\n    settimeout(\n        function timer(j) {\n            console.log(j)\n        },\n        i * 1000,\n        i\n    )\n}\n\n\n * 第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式\n\nfor (let i = 1; i <= 5; i++) {\n    settimeout(function timer() {\n        console.log(i)\n    }, i * 1000)\n}\n\n\n\n# this 有几种赋值情况\n\nthis 取什么值函数执行时确认的，不是在函数定义时确认的\n\n * 作为普通函数使用\n\n * call apply bind\n\n * 作为对象方法被调用\n\n\n\n * 在 class 方法中调用\n\n * 箭头函数的this永远取它上层作用域的this\n\n * 原型中的 this\n\n前端面试之彻底搞懂 this 指向\n\n\n# 手写 bind 函数\n\n提示\n\nbind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\n\nbind 的用法\n\nfunction fn1(a, b, c) {\n    console.log('this', this)\n    console.log(a, b, c)\n    return 'this is fn1'\n}\nconst fn2 = fn1.bind({ x: 100 }, 10, 20, 30)\nconst res = fn2()\nconsole.log(res)\n\n\n手写 bind\n\n    function.prototype.bind1=function(context,...args){\n    const self = this\n    return function (){\n        return self.apply(context,args)\n    }\n\n\n\n# 创建 10 个 a,点击弹出序号\n\n<!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>document</title>\n    </head>\n    <body>\n        <div id=\"root\"></div>\n        <script type=\"text/javascript\">\n            const root = document.getelementbyid('root')\n            for (let i = 1; i <= 10; i++) {\n                const a = document.createelement('a')\n                a.innertext = i\n                a.style.display = 'block'\n                root.appendchild(a)\n            }\n            root.onclick = function (e) {\n                alert(e.target.innertext)\n            }\n        <\/script>\n    </body>\n</html>\n\n\n\n# 异步\n\n\n# 异步和同步的区别？\n\n基于 js 是单线程语言，异步不会阻塞代码执行，同步会阻塞代码执行\n\n\n# 手写 promise 加载图片\n\n<!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>promise加载图片</title>\n    </head>\n\n    <body>\n        <div id=\"root\"></div>\n        <script type=\"text/javascript\">\n            const url = 'https://zfhblog.top/titlelogo.png'\n            const root = document.getelementbyid('root')\n\n            function loadimg(url) {\n                return new promise((resolve, reject) => {\n                    const img = document.createelement('img')\n                    // 加载完\n                    img.onload = () => {\n                        resolve(img)\n                    }\n                    // 加载失败\n                    img.onerror = () => {\n                        const err = new error(`图片加载失败了,图片地址为${url}`)\n                        reject(err)\n                    }\n                    img.src = url\n                })\n            }\n            loadimg(url)\n                .then(img => {\n                    root.appendchild(img)\n                    console.log('我第二个执行then')\n                })\n                .catch(err => {\n                    console.log(err)\n                })\n            console.log('我第一个执行，同步代码')\n            settimeout(() => {\n                console.log('我第三个执行settimeout')\n            }, 0)\n        <\/script>\n    </body>\n</html>\n\n\n\n# settimeout\n\nconsole.log(1)\nsettimeout(function () {\n    console.log(2)\n}, 1000)\nconsole.log(3)\nsettimeout(function () {\n    console.log(4)\n}, 0)\nconsole.log(5)\n\n\n输出结果: 1 , 3 , 5 , 4 , 2\n\n\n# 下面代码的输出结果是（async 函数）？\n\nasync function getdata() {\n    return await promise.resolve('i made it!')\n}\nconst data = getdata()\nconsole.log(data)\n\n\n异步函数始终返回一个 promise. await 仍然需要等待 promise 的解决：当我们调用 getdata（）并将其赋值给 data，此时 data 为 getdata 方法返回的一个挂起的 promise，该 promise 并没有解决。 如果我们想要访问已解决的值 ' i made it！'，可以在 data 上使用 then（）方法：\n\ndata.then(res => console.log(res))\n\n\n\n# js-web-api-dom\n\n\n# dom 是那种数据结构？---树\n\n\n# dom 操作常见的 api\n\n * dom 节点操作\n\n * dom 结构操作\n\n\n# property 和 attribute 的区别\n\n * property : 修改对象属性，不会体现到 html 结构中\n\n * attribute : 修改 html 属性，会改变 html 结构\n\n两者都有可能引起 dom 重新渲染\n\n\n# 如何优化 dom 性能的性能\n\ndom 查询做缓存\n\n\n\n将频繁操作改为一次性操作(一次性插入多个节点，考虑性能)\n\n\n\n\n# js-web-api-事件\n\n\n# 编写一个通用的事件监听函数\n\nelement.matches()\n\n如果元素被指定的选择器字符串选择，element.matches()方法返回 true; 否则返回 false。\n\n语法：let result = element.matches(selectorstring)\n\n * result 的值为 true 或 false.\n * selectorstring 是个 css 选择器字符串.\n\nfunction bindevent(elem, type, selector, fn) {\n    if (fn == null) {\n        fn = selector\n        selector = null\n    }\n    elem.addeventlistener(type, event => {\n        const target = event.target\n        if (selector) {\n            // 代理绑定\n            if (target.matches(selector)) {\n                fn.call(target, event)\n            }\n        } else {\n            // 普通绑定\n            fn.call(target, event)\n        }\n    })\n}\n\n// 普通绑定\nconst btn1 = document.getelementbyid('btn1')\nbindevent(btn1, 'click', function (event) {\n    // console.log(event.target) // 获取触发的元素\n    event.preventdefault() // 阻止默认行为\n    alert(this.innerhtml)\n})\n\n// 代理绑定\nconst div3 = document.getelementbyid('div3')\nbindevent(div3, 'click', 'a', function (event) {\n    event.preventdefault()\n    alert(this.innerhtml)\n})\n\n\n\n# 描述事件冒泡的流程\n\n * 基于 dom 树形结构\n\n * 事件会顺着触发元素向上冒泡\n\n * 应用场景：代理(利用事件冒泡机制，将后代元素事件代理(事件委托)给祖先元素)=>event.target\n\n\n# 无限下拉的图片列表，如何监听每个图片的点击\n\n * 事件代理\n\n * 用 e.target 获取触发元素\n\n * 用 matches 来判断是否是触发元素\n\n\n# es6\n\n\n# 说说 var、let、const 之间的区别？\n\n * 变量提升: var 会提升的变量的声明到当前作用域的顶部 let const 不会\n\n * 暂时性死区：在代码块内，使用 let、const 命令声明变量或常量之前，该变量或常量都是不可用的。这在语法上，称为“暂时性死区”\n\n * 块级作用域：var 没有块级作用域，let const 有块级作用域\n\n * 重复声明： var 允许重复声明，let,const 不允许不允许在相同作用域内，重复声明同一个变量。\n\n * 修改声明的变量： var 和 let 可以修改;const 声明一个只读的常量，并且 const 声明时，必须立即初始化\n\n * window 对象的属性和方法:全局作用域中，var声明的变量和通过function声明的函数，会自动变成 window 对象的属性或方法，let、 const 不会。\n\n\n# 箭头函数和普通函数的区别？\n\n不懂的点\n\nyield命令,generator函数\n\n * 箭头函数没有 prototype (原型)，所以箭头函数本身没有 this\n\n// 箭头函数\nlet a = () => {}\nconsole.log(a.prototype) // undefined\n\n// 普通函数\nfunction a() {}\nconsole.log(a.prototype) // {constructor:f}\n\n\n * 箭头函数不会创建自己的 this\n\n箭头函数没有自己的 this，箭头函数的 this 指向在定义（注意：是定义时，不是调用时）的时候继承自外层第一个普通函数的 this。所以，箭头函数中 this 的指向在它被定义的时候就已经确定了，之后永远不会改变。\n\nlet obj = {\n    a: 10,\n    b: () => {\n        console.log(this.a) // undefined\n        console.log(this) // window {postmessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: window, …}\n    },\n    c: function () {\n        console.log(this.a) // 10\n        console.log(this) // {a: 10, b: ƒ, c: ƒ}\n    },\n}\nobj.b()\nobj.c()\n\n\n * call | apply | bind 无法改变箭头函数中 this 的指向\n\ncall | apply | bind 方法可以用来动态修改函数执行时 this 的指向，但由于箭头函数的 this 定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数 this 的指向。\n\nvar id = 10\nlet fun = () => {\n    console.log(this.id)\n}\nfun() // 10\nfun.call({ id: 20 }) // 10\nfun.apply({ id: 20 }) // 10\nfun.bind({ id: 20 })() // 10\n\n\n * 箭头函数不能作为构造函数使用\n\n我们先了解一下构造函数的 new 都做了些什么？简单来说，分为四步： ① js 内部首先会先生成一个对象； ② 再把函数中的 this 指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例。但是！！因为箭头函数没有自己的 this，它的 this 其实是继承了外层执行环境中的 this，且 this 指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用 new 调用时会报错！\n\nlet fun = (name, age) => {\n    this.name = name\n    this.age = age\n}\n// 报错\nlet p = new fun('dingfy', 24)\n\n\n * 箭头函数不绑定 arguments，取而代之用 rest 参数...代替 arguments 对象，来访问箭头函数的参数列表\n\n箭头函数没有自己的 arguments 对象。在箭头函数中访问 arguments 实际上获得的是外层局部（函数）执行环境中的值。\n\n// 普通函数\nfunction a(a) {\n    console.log(arguments)\n}\na(1, 2, 3, 4, 5, 8) //  [1, 2, 3, 4, 5, 8, callee: ƒ, symbol(symbol.iterator): ƒ]\n\n// 箭头函数\nlet b = b => {\n    console.log(arguments)\n}\nb(2, 92, 32, 32) // uncaught referenceerror: arguments is not defined\n\n// rest参数...\nlet c = (...c) => {\n    console.log(c)\n}\nc(3, 82, 32, 11323) // [3, 82, 32, 11323]\n\n\n * 箭头函数不能用作 generator 函数，不能使用 yield 关键字\n\n\n# 不适用箭头函数的场景?\n\n作为构造函数：因为箭头函数没有 this\n\n需要 this 指向调用对象的时候：如事件处理函数\n\n需要使用 arguments 的时候\n\n\n# map 与 weakmap 的区别与使用\n\nweakmap\n\nweakset\n\n1、weakmap只接受对象作为 key，如果设置其他类型的数据作为 key，会报错。\n\n2、weakmap 的 key 所引用的对象都是弱引用，只要对象的其他引用被删除，垃圾回收机制就会释放该对象占用的内存，从而避免内存泄漏。\n\n3、由于 weakmap 的成员随时可能被垃圾回收机制回收，成员的数量不稳定，所以没有 size 属性。\n\n4、没有clear()方法\n\n5、不能遍历\n\n\n# 输出题&脑瘫题\n\n\n# 如何让 a==1 && a==2 && a==3 为 true\n\n参考\n\n「前端面试题」(a ==1 && a== 2 && a==3) 有可能是 true 吗？\n\n涉及考点：隐式类型转换\n\n1.重写默认属性方法\n\nlet a = {\n    i: 1,\n    tostring: function () {\n        return this.i++\n    },\n}\nconsole.log(a == 1 && a == 2 && a == 3)\n// valueof\nlet b = {\n    i: 1,\n    valueof: function () {\n        return this.i++\n    },\n}\nconsole.log(b == 1 && b == 2 && b == 3)\n// [symbol.toprimitive]\nlet c = {\n    i: 1,\n    [symbol.toprimitive]: function () {\n        return this.i++\n    },\n}\nconsole.log(c == 1 && c == 2 && c == 3)\n\n\n三个方法的优先级： symbol.toprimitive > valueof > tostring\n\n 2. 数据劫持\n\nlet tmp = 1\nobject.defineproperty(window, 'a', {\n    get: function () {\n        return tmp++\n    },\n})\nconsole.log(a === 1 && a === 2 && a === 3)\n\n\n 3. es6 proxy\n\nlet a = new proxy(\n    {},\n    {\n        tmp: 1,\n        get(target, key) {\n            return () => this.tmp++\n        },\n    }\n)\nconsole.log(a == 1 && a == 2 && a == 3)\n\n\n 4. 重写 number 对象的 valueof\n\nnumber.prototype.valueof = (function () {\n    let i = 1\n    return () => {\n        return i++\n    }\n})()\nlet a = new number(1)\nconsole.log(a == 1 && a == 2 && a == 3)\n\n\n\n# ['1','2','3'].map(parseint)会输出什么？\n\n参考\n\n['1','2','3'].map(parseint) [‘1‘,‘2‘,‘3‘].map(parseint)结果讲解\n\n答案\n\n[ 1, nan, nan ]\n\n 1. map 函数\n\n['1','2','3'].map(parseint)可以看作：\n\n['1', '2', '3'].map(function (value, index) {\n\treturn parseint(value, index)\n})\n// 细节\nindex = 0: parsetint('1', 0) = 1\nindex = 1: parsetint('2', 1) = nan\nindex = 2: parsetint('3', 2) = nan // 因为 2进制必须是 0，1数字表示\n\n\n将数组的每个元素传递给指定的函数处理，并返回处理后的数组，所以 ['1','2','3'].map(parseint) 就是将字符串 1，2，3 作为元素；0，1，2 作为下标分别调用 parseint 函数。即分别求出 parseint('1',0), parseint('2',1), parseint('3',2)的结果。\n\n 2. parseint 函数（重点）\n\n概念：以第二个参数为基数来解析第一个参数字符串，通常用来做十进制的向上取整（省略小数）如：parseint(2.7) //结果为 2\n\n特点：接收两个参数 parseint(string,radix)\n\nstring：字母（大小写均可）、数组、特殊字符（不可放在开头,特殊字符及特殊字符后面的内容不做解析）的任意字符串，如 '2'、'2w'、'2!'\n\nradix：解析字符串的基数，基数规则如下：\n\n1） 区间范围介于 2~36 之间；\n\n2） 当参数为 0，parseint() 会根据十进制来解析；\n\n3） 如果忽略该参数，默认的基数规则：\n\n * 如果 string 以 \"0x\" 开头，parseint() 会把 string 的其余部分解析为十六进制的整数；parseint(\"0xf\") //15\n\n * 如果 string 以 0 开头，其后的字符解析为八进制或十六进制的数字；parseint(\"08\") //8\n\n * 如果 string 以 1 ~ 9 的数字开头，parseint() 将把它解析为十进制的整数；parseint(\"88.99f\") //88\n\n * 只有字符串中的第一个数字会被返回。parseint(\"10.33\") //返回 10；\n\n * 开头和结尾的空格是允许的。parseint(\" 69 10 \") //返回 69\n\n * 如果字符串的第一个字符不能被转换为数字，返回 nan。parseint(\"f\") //返回 nan 而 parseint(\"f\"，16) //返回 15\n\n 3. 再来分析一下结果\n\n['1','2','3'].map(parseint)即:\n\nparseint('1',0);radix 为 0，parseint() 会根据十进制来解析，所以结果为 1；\n\nparseint('2',1);radix 为 1，超出区间范围，所以结果为 nan；\n\nparseint('3',2);radix 为 2，用 2 进制来解析，应以 0 和 1 开头，所以结果为 nan。\n\n 4. parseint 方法解析的运算过程\n\nparseint('101.55',10); //以十进制解析，运算过程：向上取整数(不做四舍五入，省略小数)，结果为 101。\n\nparseint('101',2); //以二进制解析，运算过程：12 的 2 次方+02 的 1 次方+1*2 的 0 次方=4+0+1=5，结果为 5。\n\nparseint('101',8); //以八进制解析，运算过程：18 的 2 次方+08 的 1 次方+1*8 的 0 次方=64+0+1=65，结果为 65。\n\nparseint('101',16); //以十六进制解析，运算过程：116 的 2 次方+016 的 1 次方+1*16 的 0 次方=256+0+1=257，结果为 257。\n\n扩展\n\nmap 和 foreach 数组中 foreach() 和 map() 的区别\n\n\n# js 原理&机制\n\n\n# 说一下 js 的垃圾回收机制\n\n「硬核 js」你真的了解垃圾回收机制吗\n\njavascript 具有自动垃圾收集机制\n\n标记清除,主流的垃圾收集算法，给不使用的值加上标记，然后回收其内存。\n\n引用计数，这种算法是跟踪记录所有值被引用的次数，不在使用这种算法。(存在循环引用的问题)\n\n循环引用\n\nfunction test() {\n    let a = new object() // 1\n    let b = new object() // 1\n\n    a.b = b // 2\n    b.a = a // 2\n}\n\n\n如上所示，对象 a 和 b 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 test 执行完成之后，对象 a 和 b 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放\n\n我们再用标记清除的角度看一下，当函数结束后，两个对象都不在作用域中，a 和 b 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一\n\n\n# new 的原理？\n\n * new 的工作流程：\n\n1）在内存中创建一个新对象\n\n2）将新对象与构造函数通过原型链连接起来\n\n3）将构造函数中的this 绑定到新对象上\n\n4）执行构造函数内部的代码\n\n5）如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象\n\n * 手写 new\n\nfunction mynew(func, ...args) {\n    // 1.创建一个新对象\n    const obj = {}\n    // 2.新对象原型指向构造函数原型对象\n    obj.__proto__ = func.prototype\n    // 3.将构建函数的this指向新对象\n    let result = func.apply(obj, args)\n    // 4.根据返回值判断\n    return result instanceof object ? result : obj\n}\n\nfunction foo(age, name) {\n    this.name = name\n    this.age = age\n}\n\nconst obj = mynew(foo, 14, 'frank')\nconsole.log(obj)\n",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"Vue面试题",frontmatter:{title:"Vue面试题",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Vue%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"前端面试/Vue面试题.md",key:"v-469764e9",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Vue%E9%9D%A2%E8%AF%95%E9%A2%98.html",headers:[{level:2,title:"Vue 和 原生 js(jquery) 的区别？",slug:"vue-和-原生-js-jquery-的区别",normalizedTitle:"vue 和 原生 js(jquery) 的区别？",charIndex:21},{level:2,title:"说说 Vue 的优点和缺点(或者项目为什么选择使用 Vue)?",slug:"说说-vue-的优点和缺点-或者项目为什么选择使用-vue",normalizedTitle:"说说 vue 的优点和缺点(或者项目为什么选择使用 vue)?",charIndex:210},{level:2,title:"Vue2 和 Vue3 的响应式区别？",slug:"vue2-和-vue3-的响应式区别",normalizedTitle:"vue2 和 vue3 的响应式区别？",charIndex:552},{level:2,title:"vue-router 有几种路由方式？区别？",slug:"vue-router-有几种路由方式-区别",normalizedTitle:"vue-router 有几种路由方式？区别？",charIndex:1091},{level:2,title:"讲一下 VueX 的工作原理？",slug:"讲一下-vuex-的工作原理",normalizedTitle:"讲一下 vuex 的工作原理？",charIndex:1371},{level:2,title:"Vue 里面 v-if、v-show 的区别",slug:"vue-里面-v-if、v-show-的区别",normalizedTitle:"vue 里面 v-if、v-show 的区别",charIndex:1647},{level:2,title:"computed 和 watch 的区别",slug:"computed-和-watch-的区别",normalizedTitle:"computed 和 watch 的区别",charIndex:1828},{level:2,title:"Vue 组件通讯有哪几种方式",slug:"vue-组件通讯有哪几种方式",normalizedTitle:"vue 组件通讯有哪几种方式",charIndex:2686},{level:2,title:"谈一下对 vuex 的理解",slug:"谈一下对-vuex-的理解",normalizedTitle:"谈一下对 vuex 的理解",charIndex:3033},{level:2,title:"Vuex 中 mapState、mapGetters、mapMutations、mapActions",slug:"vuex-中-mapstate、mapgetters、mapmutations、mapactions",normalizedTitle:"vuex 中 mapstate、mapgetters、mapmutations、mapactions",charIndex:3420},{level:2,title:"Vue.set()和 vm.\\$set()",slug:"vue-set-和-vm-set",normalizedTitle:"vue.set()和 vm.$set()",charIndex:3489},{level:2,title:"\\$nexttick 是怎么可以获取到更新后的 dom 的?",slug:"nexttick-是怎么可以获取到更新后的-dom-的",normalizedTitle:"$nexttick 是怎么可以获取到更新后的 dom 的?",charIndex:3545},{level:2,title:"vue-router 中 push 和 replace 的区别",slug:"vue-router-中-push-和-replace-的区别",normalizedTitle:"vue-router 中 push 和 replace 的区别",charIndex:3746},{level:2,title:"项目中 vue-router 设置的是 history 模式，部署到服务器上要怎么处理",slug:"项目中-vue-router-设置的是-history-模式-部署到服务器上要怎么处理",normalizedTitle:"项目中 vue-router 设置的是 history 模式，部署到服务器上要怎么处理",charIndex:4046},{level:2,title:"mvvm 和 mvc 区别？",slug:"mvvm-和-mvc-区别",normalizedTitle:"mvvm 和 mvc 区别？",charIndex:4189}],headersStr:"Vue 和 原生 js(jquery) 的区别？ 说说 Vue 的优点和缺点(或者项目为什么选择使用 Vue)? Vue2 和 Vue3 的响应式区别？ vue-router 有几种路由方式？区别？ 讲一下 VueX 的工作原理？ Vue 里面 v-if、v-show 的区别 computed 和 watch 的区别 Vue 组件通讯有哪几种方式 谈一下对 vuex 的理解 Vuex 中 mapState、mapGetters、mapMutations、mapActions Vue.set()和 vm.\\$set() \\$nexttick 是怎么可以获取到更新后的 dom 的? vue-router 中 push 和 replace 的区别 项目中 vue-router 设置的是 history 模式，部署到服务器上要怎么处理 mvvm 和 mvc 区别？",content:"最全的 Vue 面试题+详解答案\n\n\n# Vue 和 原生 js(jquery) 的区别？\n\n原生 js、jQuery：jQuery 只是对原生 js 的 API 进行了封装，操作更加方便，但是数据和视图层没有分开，本质上还是要操作 DOM 实现逻辑。\n\nvue：不仅对 js 的 API 实现了封装，还实现了其他功能，使数据和视图层分开，通过数据驱动，操作的是数据，而不是 DOM，能让开发者更加关注到数据上\n\n\n# 说说 Vue 的优点和缺点(或者项目为什么选择使用 Vue)?\n\n优点：\n\n 1. 视图数据分离，声明式编码，让操作者不再直接操作 DOM 对象，有更多的去时间思考业务逻辑\n\n 2. 传统方式编写，依赖关系混乱，代码复用率不高。组件化可以提高代码可阅读性以及代码复用率\n\n 3. 虚拟DOM+优秀的diff算法，尽量复用 DOM 节点\n\n4.渐进式框架，只需一个轻量小巧的核心库，可以引入各式各样的Vue插件进行扩展。\n\n缺点：\n\nVue 是单页面应用对于搜索引擎不友好，影响SEO，比如两个 Vue 页面(路由)它的路径是：index.html#aaa 和 index.html#bbb，但对于搜索引擎来说就是一个页面 index.html,这时搜索引擎就无法收录你的页面\n\n\n# Vue2 和 Vue3 的响应式区别？\n\nVue2:\n\n基于Object.defineProperty，不具备监听数组的能力，需要重新定义数组的原型来达到响应式\n\nObject.defineProperty 无法检测到对象属性的添加和删除\n\n由于 Vue 会在初始化实例时对属性执行getter/setter转化，所有属性必须在 data 对象上存在才能让 Vue 将它转换为响应式\n\n深度监听需要一次性递归，对性能影响比较大\n\nVue3:\n\n基于Proxy和Reflect，可以原生监听数组，可以监听对象属性的添加和删除\n\n提示\n\n * Proxy对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\n\n * Reflect是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers (en-US)的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。 :::\n\n不需要一次性遍历data的属性，可以显著提高性能\n\n因为Proxy是ES6新增的属性，有些浏览器还不支持,只能兼容到IE11\n\n参考\n\n你真的了解 vue2.0 和 vue3.0 响应式原理区别吗？\n\n\n# vue-router 有几种路由方式？区别？\n\nhash：url#后面的东西就是 hash，hash 虽然出现再 URL 中，但不会被包含再 HTTP 中，对后端完全没有影响，因此改变 hash 不会重新加载页面（兼容性好，但不美观）\n\nhistory:利用 HTML5 History 中新增的 pushState()和 replaceState()当调用它们修改浏览器的历史记录栈后，虽然当前 url 改变了，但浏览器不会刷新页面。这就为单页面应用前端路由“更新视图但不重新请求页面”提供了基础，虽然美观，但是刷新会出现 404，需要后端进行配置\n\n\n# 讲一下 VueX 的工作原理？\n\n 1. Vuex 本质是一个对象\n 2. Vuex 对象有两个属性，一个是 install 方法，一个是 Store 这个类\n 3. install 方法的作用是将 store 这个实例挂载到所有的组件上，注意是同一个 store 实例。\n 4. Store 这个类拥有 commit，dispatch 这些方法，Store 类里将传入的 state 包装成 data，作为 new Vue 的参数，从而实现了 state 值的响应式。\n\n参考\n\n手写 Vuex 核心原理，再也不怕面试官问我 Vuex 原理\n\n\n# Vue 里面 v-if、v-show 的区别\n\n * v-if 在编译过程中会被转化成三元表达式,条件不满足时不渲染此节点。\n * v-show 会被编译成指令，条件不满足时控制样式将对应节点隐藏 （display:none）\n\n使用场景\n\nv-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景 v-show 适用于需要非常频繁切换条件的场景\n\n\n# computed 和 watch 的区别\n\n# 计算属性 computed :\n\n 1. 支持缓存，只有依赖数据发生改变，才会重新进行计算\n 2. 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化\n 3. computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值，只在相关响应式依赖发生改变时它们才会重新求值。\n 4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed\n 5. 如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法\n\n# 侦听属性 watch：\n\n 1. 不支持缓存，数据发生改变，会直接触发相应的操作\n 2. watch支持异步\n 3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值\n 4. 当一个属性发生变化时，需要执行对应的操作；一对多\n 5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，\n    1. immediate：组件加载立即触发回调函数执行\n    2. deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep 无法监听到数组的变动(通过数字下标修改数组中元素的值)和对象的新增，参考 vue 如何监测数据的表动,只有以响应式的方式触发才会被监听到\n\n作者：小只前端攻城狮 链接：https://juejin.cn/post/6977363418273562660 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n# Vue 组件通讯有哪几种方式\n\n * props 和 $emit:父组件向子组件传递数据是通过 props 传递的，子组件给父组件传递数据是通过$emit 触发事件来做到的\n\n * $parent,$children 获取当前组件的父组件和当前组件的子组件\n\n * $attrs 和$listeners,适用于爷孙组件通讯，具体用法参考： inheritattrs-attrs-listeners\n\n * 父组件中通过 provide 来提供变量，然后在子组件中通过inject来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用)\n\n * $refs 获取组件实例\n\n * envetBus 任意组件数据传递 这种情况下可以使用全局事件总线的方式\n\n * vueX状态管理\n\n\n# 谈一下对 vuex 的理解\n\nvuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存 （无法持久化、内部核心原理是通过创造一个全局实例 new Vue）\n\n主要包括以下几个模块：\n\n * State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。\n\n * Getter：getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\n * Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。\n\n * Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。\n\n * Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。(命名空间)\n\n\n# Vuex 中 mapState、mapGetters、mapMutations、mapActions\n\n四个 map 方法的使用\n\n\n# Vue.set()和 vm.$set()\n\n可以使原来对象和数组的无法监听变的可监听，使数据正常渲染。\n\n\n# $nexttick 是怎么可以获取到更新后的 dom 的?\n\nvue 是依靠数据驱动视图更新的，该更新的过程是异步的。即：当侦听到你的数据发生变化时， Vue 将开启一个队列(该队列被 Vue 官方称为异步更新队列)。视图需要等队列中所有数据变化完成之后，再统一进行更新。\n\n$nextTick(callback),这里的回调函数( callback)将在数据更新完成，视图更新完毕之后被调用\n\n\n# vue-router 中 push 和 replace 的区别\n\n1.this.$router.push()\n\n描述：跳转到不同的 url，但这个方法会向 history 栈添加一个记录，点击后退会返回到上一个页面。\n\n2.this.$router.replace()\n\n描述：同样是跳转到指定的 url，但是这个方法不会向 history 里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。\n\n3.this.$router.go(n)\n\n相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n 可为正数可为负数。正数返回上一个页面\n\n\n# 项目中 vue-router 设置的是 history 模式，部署到服务器上要怎么处理\n\n我在 koa2 项目中,使用中间件 koa2-connect-history-api-fallback ,它用于处理 vue-router 使用 history 模式返回 404 的问题\n\n\n# mvvm 和 mvc 区别？\n\n几乎所有的 App 都只干这么一件事：将数据展示给用户看，并处理用户对界面的操作。 MVC 的思想：一句话描述就是 Controller 负责将 Model 的数据用 View 显示出来，换句话说就是在 Controller 里面把 Model 的数据赋值给 View。\n\n参考\n\n * MVC 和 MVVM 的区别\n\n * MVC、MVP、MVVM 的区别及联系",normalizedContent:"最全的 vue 面试题+详解答案\n\n\n# vue 和 原生 js(jquery) 的区别？\n\n原生 js、jquery：jquery 只是对原生 js 的 api 进行了封装，操作更加方便，但是数据和视图层没有分开，本质上还是要操作 dom 实现逻辑。\n\nvue：不仅对 js 的 api 实现了封装，还实现了其他功能，使数据和视图层分开，通过数据驱动，操作的是数据，而不是 dom，能让开发者更加关注到数据上\n\n\n# 说说 vue 的优点和缺点(或者项目为什么选择使用 vue)?\n\n优点：\n\n 1. 视图数据分离，声明式编码，让操作者不再直接操作 dom 对象，有更多的去时间思考业务逻辑\n\n 2. 传统方式编写，依赖关系混乱，代码复用率不高。组件化可以提高代码可阅读性以及代码复用率\n\n 3. 虚拟dom+优秀的diff算法，尽量复用 dom 节点\n\n4.渐进式框架，只需一个轻量小巧的核心库，可以引入各式各样的vue插件进行扩展。\n\n缺点：\n\nvue 是单页面应用对于搜索引擎不友好，影响seo，比如两个 vue 页面(路由)它的路径是：index.html#aaa 和 index.html#bbb，但对于搜索引擎来说就是一个页面 index.html,这时搜索引擎就无法收录你的页面\n\n\n# vue2 和 vue3 的响应式区别？\n\nvue2:\n\n基于object.defineproperty，不具备监听数组的能力，需要重新定义数组的原型来达到响应式\n\nobject.defineproperty 无法检测到对象属性的添加和删除\n\n由于 vue 会在初始化实例时对属性执行getter/setter转化，所有属性必须在 data 对象上存在才能让 vue 将它转换为响应式\n\n深度监听需要一次性递归，对性能影响比较大\n\nvue3:\n\n基于proxy和reflect，可以原生监听数组，可以监听对象属性的添加和删除\n\n提示\n\n * proxy对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\n\n * reflect是一个内置的对象，它提供拦截 javascript 操作的方法。这些方法与 proxy handlers (en-us)的方法相同。reflect 不是一个函数对象，因此它是不可构造的。 :::\n\n不需要一次性遍历data的属性，可以显著提高性能\n\n因为proxy是es6新增的属性，有些浏览器还不支持,只能兼容到ie11\n\n参考\n\n你真的了解 vue2.0 和 vue3.0 响应式原理区别吗？\n\n\n# vue-router 有几种路由方式？区别？\n\nhash：url#后面的东西就是 hash，hash 虽然出现再 url 中，但不会被包含再 http 中，对后端完全没有影响，因此改变 hash 不会重新加载页面（兼容性好，但不美观）\n\nhistory:利用 html5 history 中新增的 pushstate()和 replacestate()当调用它们修改浏览器的历史记录栈后，虽然当前 url 改变了，但浏览器不会刷新页面。这就为单页面应用前端路由“更新视图但不重新请求页面”提供了基础，虽然美观，但是刷新会出现 404，需要后端进行配置\n\n\n# 讲一下 vuex 的工作原理？\n\n 1. vuex 本质是一个对象\n 2. vuex 对象有两个属性，一个是 install 方法，一个是 store 这个类\n 3. install 方法的作用是将 store 这个实例挂载到所有的组件上，注意是同一个 store 实例。\n 4. store 这个类拥有 commit，dispatch 这些方法，store 类里将传入的 state 包装成 data，作为 new vue 的参数，从而实现了 state 值的响应式。\n\n参考\n\n手写 vuex 核心原理，再也不怕面试官问我 vuex 原理\n\n\n# vue 里面 v-if、v-show 的区别\n\n * v-if 在编译过程中会被转化成三元表达式,条件不满足时不渲染此节点。\n * v-show 会被编译成指令，条件不满足时控制样式将对应节点隐藏 （display:none）\n\n使用场景\n\nv-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景 v-show 适用于需要非常频繁切换条件的场景\n\n\n# computed 和 watch 的区别\n\n# 计算属性 computed :\n\n 1. 支持缓存，只有依赖数据发生改变，才会重新进行计算\n 2. 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化\n 3. computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值，只在相关响应式依赖发生改变时它们才会重新求值。\n 4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed\n 5. 如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法\n\n# 侦听属性 watch：\n\n 1. 不支持缓存，数据发生改变，会直接触发相应的操作\n 2. watch支持异步\n 3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值\n 4. 当一个属性发生变化时，需要执行对应的操作；一对多\n 5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，\n    1. immediate：组件加载立即触发回调函数执行\n    2. deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep 无法监听到数组的变动(通过数字下标修改数组中元素的值)和对象的新增，参考 vue 如何监测数据的表动,只有以响应式的方式触发才会被监听到\n\n作者：小只前端攻城狮 链接：https://juejin.cn/post/6977363418273562660 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n# vue 组件通讯有哪几种方式\n\n * props 和 $emit:父组件向子组件传递数据是通过 props 传递的，子组件给父组件传递数据是通过$emit 触发事件来做到的\n\n * $parent,$children 获取当前组件的父组件和当前组件的子组件\n\n * $attrs 和$listeners,适用于爷孙组件通讯，具体用法参考： inheritattrs-attrs-listeners\n\n * 父组件中通过 provide 来提供变量，然后在子组件中通过inject来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用)\n\n * $refs 获取组件实例\n\n * envetbus 任意组件数据传递 这种情况下可以使用全局事件总线的方式\n\n * vuex状态管理\n\n\n# 谈一下对 vuex 的理解\n\nvuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存 （无法持久化、内部核心原理是通过创造一个全局实例 new vue）\n\n主要包括以下几个模块：\n\n * state：定义了应用状态的数据结构，可以在这里设置默认的初始状态。\n\n * getter：getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\n * mutation：是唯一更改 store 中状态的方法，且必须是同步函数。\n\n * action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。\n\n * module：允许将单一的 store 拆分为多个 store 且同时保存在单一的状态树中。(命名空间)\n\n\n# vuex 中 mapstate、mapgetters、mapmutations、mapactions\n\n四个 map 方法的使用\n\n\n# vue.set()和 vm.$set()\n\n可以使原来对象和数组的无法监听变的可监听，使数据正常渲染。\n\n\n# $nexttick 是怎么可以获取到更新后的 dom 的?\n\nvue 是依靠数据驱动视图更新的，该更新的过程是异步的。即：当侦听到你的数据发生变化时， vue 将开启一个队列(该队列被 vue 官方称为异步更新队列)。视图需要等队列中所有数据变化完成之后，再统一进行更新。\n\n$nexttick(callback),这里的回调函数( callback)将在数据更新完成，视图更新完毕之后被调用\n\n\n# vue-router 中 push 和 replace 的区别\n\n1.this.$router.push()\n\n描述：跳转到不同的 url，但这个方法会向 history 栈添加一个记录，点击后退会返回到上一个页面。\n\n2.this.$router.replace()\n\n描述：同样是跳转到指定的 url，但是这个方法不会向 history 里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。\n\n3.this.$router.go(n)\n\n相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n 可为正数可为负数。正数返回上一个页面\n\n\n# 项目中 vue-router 设置的是 history 模式，部署到服务器上要怎么处理\n\n我在 koa2 项目中,使用中间件 koa2-connect-history-api-fallback ,它用于处理 vue-router 使用 history 模式返回 404 的问题\n\n\n# mvvm 和 mvc 区别？\n\n几乎所有的 app 都只干这么一件事：将数据展示给用户看，并处理用户对界面的操作。 mvc 的思想：一句话描述就是 controller 负责将 model 的数据用 view 显示出来，换句话说就是在 controller 里面把 model 的数据赋值给 view。\n\n参考\n\n * mvc 和 mvvm 的区别\n\n * mvc、mvp、mvvm 的区别及联系",charsets:{cjk:!0},lastUpdated:"2022年06月11日",lastUpdatedTimestamp:1654956222e3},{title:"手撕代码",frontmatter:{title:"手撕代码",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81.html",relativePath:"前端面试/手撕代码.md",key:"v-69ca47ce",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81.html",headers:[{level:2,title:"手撕 instanceOf",slug:"手撕-instanceof",normalizedTitle:"手撕 instanceof",charIndex:20},{level:2,title:"手撕函数节流",slug:"手撕函数节流",normalizedTitle:"手撕函数节流",charIndex:647},{level:2,title:"手撕函数防抖",slug:"手撕函数防抖",normalizedTitle:"手撕函数防抖",charIndex:1172},{level:2,title:"深拷贝",slug:"深拷贝",normalizedTitle:"深拷贝",charIndex:1798},{level:2,title:"手撕冒泡排序",slug:"手撕冒泡排序",normalizedTitle:"手撕冒泡排序",charIndex:2337},{level:2,title:"手写 new",slug:"手写-new",normalizedTitle:"手写 new",charIndex:2692}],headersStr:"手撕 instanceOf 手撕函数节流 手撕函数防抖 深拷贝 手撕冒泡排序 手写 new",content:"参考\n\nJS 手撕，经典面试题\n\n\n# 手撕 instanceOf\n\nfunction instance_of(L, R) {\n    let prototype = R.prototype\n    while (true) {\n        if (L === null) {\n            return false\n        } else if (prototype === L.__proto__) {\n            return true\n        }\n        L = L.__proto__\n    }\n}\nconsole.log(instance_of([1, 2, 3], Function)) // false\n\n\n借用链表数据结构：\n\nconst instance_of = (A, B) => {\n    let p = A\n    while (p) {\n        if (p.__proto__ === B.prototype) {\n            return true\n        }\n        p = p.__proto__\n    }\n    return false\n}\nconsole.log(instance_of([1, 2, 3], Function)) // false\nconsole.log(instance_of([1, 2, 3], Array)) // true\n\n\n\n# 手撕函数节流\n\n理解： 在函数需要频繁触发时：函数执行一次后，只有大于设定的执行周期后才会执行第二次\n\n适合多次事件按时间做平均分配触发\n\n场景：窗口调整(resize),页面滚动(scroll),DOM 元素的拖拽功能实现(mousemove,drag),抢购疯狂点击(click)\n\n手撕：\n\nfunction throttle(callback, wait) {\n    let timer = null\n    return function (e) {\n        if (timer) {\n            return\n        }\n        timer = setTimeout(() => {\n            callback.call(this, e)\n            timer = null\n        }, wait)\n    }\n}\n\n\n使用：\n\nwindow.addEventListener(\n    'scroll',\n    throttle(function (e) {\n        console.log(this, e)\n    }, 2000)\n)\n\n\n\n# 手撕函数防抖\n\n理解：\n\n在函数需要频繁触发时，在规定时间内，只让最后一次生效，前面的不生效\n\n适合多次事件一次响应\n\n场景：输入框实时搜索联想(change,keyup,keydown)\n\n手撕：\n\nfunction debounce(callback, time) {\n    let timer = null\n    // 闭包\n    return function (e) {\n        if (timer) {\n            clearTimeout(timer)\n        }\n        timer = setTimeout(() => {\n            callback.call(this, e)\n            // 清空定时器\n            timer = null\n        }, time)\n    }\n}\n\n\n使用：\n\n<input type=\"text\" id=\"input\" />\n<script type=\"text/javascript\">\n    const input = document.getElementById('input')\n    input.onkeydown = debounce(function (e) {\n        console.log(e.keyCode)\n    }, 1000)\n<\/script>\n\n\n\n# 深拷贝\n\nJS 深拷贝总结\n\nfunction deepClone(obj = {}) {\n    if (typeof obj !== 'object' || obj == null) {\n        // obj == null 相当于 obj === undefined || obj === null\n        // obj 是 null , 或者不是对象或数组直接返回\n        return obj\n    }\n    // 初始化返回结果\n    let result\n    if (obj instanceof Array) {\n        result = []\n    } else {\n        result = {}\n    }\n    for (let key in obj) {\n        // 保证key不是obj的原型属性\n        if (obj.hasOwnProperty(key)) {\n            // 递归\n            result[key] = deepClone(obj[key])\n        }\n    }\n    return result\n}\n\n\n\n# 手撕冒泡排序\n\n解析\n\n数组-冒泡排序\n\nfunction handleArr(arr) {\n    for (var i = 0; i < arr.length; i++) {\n        for (var j = arr.length - 1; j >= i; j--) {\n            if (arr[j] < arr[j - 1]) {\n                ;[arr[j - 1], arr[j]] = [arr[j], arr[j - 1]]\n            }\n        }\n    }\n    return arr\n}\nconst arr = [1, 3000, -1333, 33]\nconsole.log(handleArr(arr))\n\n\n\n# 手写 new\n\nfunction mynew(Func, ...args) {\n    // 1.创建一个新对象\n    const obj = {}\n    // 2.新对象原型指向构造函数原型对象\n    obj.__proto__ = Func.prototype\n    // 3.将构建函数的this指向新对象\n    let result = Func.apply(obj, args)\n    // 4.根据返回值判断:\n    return result instanceof Object ? result : obj\n}\n",normalizedContent:"参考\n\njs 手撕，经典面试题\n\n\n# 手撕 instanceof\n\nfunction instance_of(l, r) {\n    let prototype = r.prototype\n    while (true) {\n        if (l === null) {\n            return false\n        } else if (prototype === l.__proto__) {\n            return true\n        }\n        l = l.__proto__\n    }\n}\nconsole.log(instance_of([1, 2, 3], function)) // false\n\n\n借用链表数据结构：\n\nconst instance_of = (a, b) => {\n    let p = a\n    while (p) {\n        if (p.__proto__ === b.prototype) {\n            return true\n        }\n        p = p.__proto__\n    }\n    return false\n}\nconsole.log(instance_of([1, 2, 3], function)) // false\nconsole.log(instance_of([1, 2, 3], array)) // true\n\n\n\n# 手撕函数节流\n\n理解： 在函数需要频繁触发时：函数执行一次后，只有大于设定的执行周期后才会执行第二次\n\n适合多次事件按时间做平均分配触发\n\n场景：窗口调整(resize),页面滚动(scroll),dom 元素的拖拽功能实现(mousemove,drag),抢购疯狂点击(click)\n\n手撕：\n\nfunction throttle(callback, wait) {\n    let timer = null\n    return function (e) {\n        if (timer) {\n            return\n        }\n        timer = settimeout(() => {\n            callback.call(this, e)\n            timer = null\n        }, wait)\n    }\n}\n\n\n使用：\n\nwindow.addeventlistener(\n    'scroll',\n    throttle(function (e) {\n        console.log(this, e)\n    }, 2000)\n)\n\n\n\n# 手撕函数防抖\n\n理解：\n\n在函数需要频繁触发时，在规定时间内，只让最后一次生效，前面的不生效\n\n适合多次事件一次响应\n\n场景：输入框实时搜索联想(change,keyup,keydown)\n\n手撕：\n\nfunction debounce(callback, time) {\n    let timer = null\n    // 闭包\n    return function (e) {\n        if (timer) {\n            cleartimeout(timer)\n        }\n        timer = settimeout(() => {\n            callback.call(this, e)\n            // 清空定时器\n            timer = null\n        }, time)\n    }\n}\n\n\n使用：\n\n<input type=\"text\" id=\"input\" />\n<script type=\"text/javascript\">\n    const input = document.getelementbyid('input')\n    input.onkeydown = debounce(function (e) {\n        console.log(e.keycode)\n    }, 1000)\n<\/script>\n\n\n\n# 深拷贝\n\njs 深拷贝总结\n\nfunction deepclone(obj = {}) {\n    if (typeof obj !== 'object' || obj == null) {\n        // obj == null 相当于 obj === undefined || obj === null\n        // obj 是 null , 或者不是对象或数组直接返回\n        return obj\n    }\n    // 初始化返回结果\n    let result\n    if (obj instanceof array) {\n        result = []\n    } else {\n        result = {}\n    }\n    for (let key in obj) {\n        // 保证key不是obj的原型属性\n        if (obj.hasownproperty(key)) {\n            // 递归\n            result[key] = deepclone(obj[key])\n        }\n    }\n    return result\n}\n\n\n\n# 手撕冒泡排序\n\n解析\n\n数组-冒泡排序\n\nfunction handlearr(arr) {\n    for (var i = 0; i < arr.length; i++) {\n        for (var j = arr.length - 1; j >= i; j--) {\n            if (arr[j] < arr[j - 1]) {\n                ;[arr[j - 1], arr[j]] = [arr[j], arr[j - 1]]\n            }\n        }\n    }\n    return arr\n}\nconst arr = [1, 3000, -1333, 33]\nconsole.log(handlearr(arr))\n\n\n\n# 手写 new\n\nfunction mynew(func, ...args) {\n    // 1.创建一个新对象\n    const obj = {}\n    // 2.新对象原型指向构造函数原型对象\n    obj.__proto__ = func.prototype\n    // 3.将构建函数的this指向新对象\n    let result = func.apply(obj, args)\n    // 4.根据返回值判断:\n    return result instanceof object ? result : obj\n}\n",charsets:{cjk:!0},lastUpdated:"2022年04月23日",lastUpdatedTimestamp:1650710412e3},{title:"计网&浏览器面试题",frontmatter:{title:"计网&浏览器面试题",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%BD%91&%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98.html",relativePath:"前端面试/计网&浏览器面试题.md",key:"v-30c5f9aa",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%BD%91&%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9D%A2%E8%AF%95%E9%A2%98.html",headers:[{level:2,title:"说一下 http 和 https 的区别？",slug:"说一下-http-和-https-的区别",normalizedTitle:"说一下 http 和 https 的区别？",charIndex:2},{level:2,title:"tcp 和 udp 的区别？",slug:"tcp-和-udp-的区别",normalizedTitle:"tcp 和 udp 的区别？",charIndex:151},{level:2,title:"如何解决跨域问题?",slug:"如何解决跨域问题",normalizedTitle:"如何解决跨域问题?",charIndex:311},{level:2,title:"手写一个简易的 ajax",slug:"手写一个简易的-ajax",normalizedTitle:"手写一个简易的 ajax",charIndex:353},{level:2,title:"Cookie、LocalStorage、SessionStorage 区别",slug:"cookie、localstorage、sessionstorage-区别",normalizedTitle:"cookie、localstorage、sessionstorage 区别",charIndex:1411},{level:2,title:"从输入 URL 到看到页面发生了什么？",slug:"从输入-url-到看到页面发生了什么",normalizedTitle:"从输入 url 到看到页面发生了什么？",charIndex:2274},{level:2,title:"get 和 post 请求有什么区别?",slug:"get-和-post-请求有什么区别",normalizedTitle:"get 和 post 请求有什么区别?",charIndex:2469}],headersStr:"说一下 http 和 https 的区别？ tcp 和 udp 的区别？ 如何解决跨域问题? 手写一个简易的 ajax Cookie、LocalStorage、SessionStorage 区别 从输入 URL 到看到页面发生了什么？ get 和 post 请求有什么区别?",content:"# 说一下 http 和 https 的区别？\n\nhttps=http+ssl\n\nhttps 有 CA 证书，http 一般没有\n\nhttp 是超文本传输协议，信息是明文传输的。https 则是具有安全性的 SSL 加密传输协议。\n\nhttp 默认 80 端口，https 默认 443 端口\n\n\n# tcp 和 udp 的区别？\n\n 1. 基于连接与无连接；\n 2. 对系统资源的要求（TCP 较多，UDP 少）；\n 3. UDP 程序结构较简单；\n 4. 流模式与数据报模式 ；\n 5. TCP 保证数据正确性，UDP 可能丢包，TCP 保证数据顺序，UDP 不保证。\n\n一文搞懂 TCP 与 UDP 的区别\n\n\n# 如何解决跨域问题?\n\n跨域\n\n同源策略\n\n * JSONP\n * CORS\n\n\n# 手写一个简易的 ajax\n\nconst xhr = new XMLHttpRequest()\nxhr.responseType = 'json'\nxhr.onreadystatechange = function () {\n    if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n            console.log(xhr.response)\n        } else if (xhr.status === 404) {\n            console.log('404 not found')\n        }\n    }\n}\nxhr.open('GET', 'https://www.imooc.com/api/http/search/suggest?words=js', true)\nxhr.send(null)\n// promise版\nfunction ajax(url) {\n    return new Promise(function (resolve, reject) {\n        const xhr = new XMLHttpRequest()\n        xhr.responseType = 'json'\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === 4) {\n                if (xhr.status === 200) {\n                    resolve(xhr.response)\n                } else if (xhr.status === 404) {\n                    reject(new Error('404 not Found'))\n                }\n            }\n        }\n        xhr.open('GET', url, true)\n        xhr.send(null)\n    })\n}\najax('https://www.imooc.com/api/http/search/suggest?words=js').then(res =>\n    console.log(res)\n)\n\n\n\n# Cookie、LocalStorage、SessionStorage 区别\n\n参考\n\n * 浏览器本地存储\n\n * 谨记：Cookie 的作用域不区分协议和端口\n\n * cookie 的 domain 属性\n\n同源：协议相同/域名相同/端口相同\n\n 1. 存储大小\n\ncookie：4k\n\nsessionStorage：5M\n\nlocalStorage：5M\n\n 2. 生命周期\n\ncookie:一般由服务器生成，可以设置失效时间；若没有设置时间，关闭浏览器 cookie 失效，如果设置了时间,过期后失效\n\nsessionStorage：仅在当前浏览器窗口关闭之前有效，关闭页面或者浏览器会被清除\n\nlocalStorage：永久有效，窗口或者浏览器关闭也会一直保存，除非手动永久删除\n\n 3. 作用域\n\ncookie：Cookie 的作用域仅仅由 domain(cookie 的作用域是 domain 本身以及 domain 下的所有子域名。例如设置xxx.com为 domain 的 cookie 时，只有该域名或者其子域名才能获取到这个 cookie)和 path 决定，与协议和端口无关\n\n在访问子路径时，会包含其父路径的 Cookie，而在访问父路径时，不包含子路径的 Cookie\n\nsessionStorage：当前会话窗口\n\nlocalStorage：在所有同源窗口中共享\n\n 4. 通信\n\ncookie：cookie 在浏览器和服务器之间来回传递，如果使用 cookie 保存过多数据会造成性能问题\n\nsessionStorage：仅在客户端（浏览器）中保存，不参与服务器的通信\n\nlocalStorage：仅在客户端（浏览器）中保存，不参与服务器的通信\n\n 5. 应用场景\n\ncookie：判断用户是否登录过网站，以便实现下次自动登录或记住密码；保存事件信息\n\nsessionStorage：敏感账号一次性登录，单页面用的较多\n\nlocalStorage：用于长期登录，适于长期保存在本地的数据\n\n\n# 从输入 URL 到看到页面发生了什么？\n\n * 浏览器地址栏输入 URL 并回车\n * 浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期\n * DNS 解析 URL 对应的 IP\n * 根据 IP 建立 TCP 连接（三次握手）\n * 发送 http 请求\n * 服务器处理请求，浏览器接受 HTTP 响应\n * 浏览器解析并渲染页面\n * 关闭 TCP 连接（四次挥手）\n\n\n# get 和 post 请求有什么区别?\n\nPost 和 Get 是 HTTP 请求的两种方法，其区别如下：\n\n * 应用场景： GET 请求是一个幂等(是指可以使用相同参数重复执行，并能获得相同结果的函数。)的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。\n\n * 是否缓存： 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。\n\n * 发送的报文格式： Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。\n\n * 安全性： Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。\n\n * 请求长度： 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。\n\n * 参数类型： post 的参数传递支持更多的数据类型。",normalizedContent:"# 说一下 http 和 https 的区别？\n\nhttps=http+ssl\n\nhttps 有 ca 证书，http 一般没有\n\nhttp 是超文本传输协议，信息是明文传输的。https 则是具有安全性的 ssl 加密传输协议。\n\nhttp 默认 80 端口，https 默认 443 端口\n\n\n# tcp 和 udp 的区别？\n\n 1. 基于连接与无连接；\n 2. 对系统资源的要求（tcp 较多，udp 少）；\n 3. udp 程序结构较简单；\n 4. 流模式与数据报模式 ；\n 5. tcp 保证数据正确性，udp 可能丢包，tcp 保证数据顺序，udp 不保证。\n\n一文搞懂 tcp 与 udp 的区别\n\n\n# 如何解决跨域问题?\n\n跨域\n\n同源策略\n\n * jsonp\n * cors\n\n\n# 手写一个简易的 ajax\n\nconst xhr = new xmlhttprequest()\nxhr.responsetype = 'json'\nxhr.onreadystatechange = function () {\n    if (xhr.readystate === 4) {\n        if (xhr.status === 200) {\n            console.log(xhr.response)\n        } else if (xhr.status === 404) {\n            console.log('404 not found')\n        }\n    }\n}\nxhr.open('get', 'https://www.imooc.com/api/http/search/suggest?words=js', true)\nxhr.send(null)\n// promise版\nfunction ajax(url) {\n    return new promise(function (resolve, reject) {\n        const xhr = new xmlhttprequest()\n        xhr.responsetype = 'json'\n        xhr.onreadystatechange = function () {\n            if (xhr.readystate === 4) {\n                if (xhr.status === 200) {\n                    resolve(xhr.response)\n                } else if (xhr.status === 404) {\n                    reject(new error('404 not found'))\n                }\n            }\n        }\n        xhr.open('get', url, true)\n        xhr.send(null)\n    })\n}\najax('https://www.imooc.com/api/http/search/suggest?words=js').then(res =>\n    console.log(res)\n)\n\n\n\n# cookie、localstorage、sessionstorage 区别\n\n参考\n\n * 浏览器本地存储\n\n * 谨记：cookie 的作用域不区分协议和端口\n\n * cookie 的 domain 属性\n\n同源：协议相同/域名相同/端口相同\n\n 1. 存储大小\n\ncookie：4k\n\nsessionstorage：5m\n\nlocalstorage：5m\n\n 2. 生命周期\n\ncookie:一般由服务器生成，可以设置失效时间；若没有设置时间，关闭浏览器 cookie 失效，如果设置了时间,过期后失效\n\nsessionstorage：仅在当前浏览器窗口关闭之前有效，关闭页面或者浏览器会被清除\n\nlocalstorage：永久有效，窗口或者浏览器关闭也会一直保存，除非手动永久删除\n\n 3. 作用域\n\ncookie：cookie 的作用域仅仅由 domain(cookie 的作用域是 domain 本身以及 domain 下的所有子域名。例如设置xxx.com为 domain 的 cookie 时，只有该域名或者其子域名才能获取到这个 cookie)和 path 决定，与协议和端口无关\n\n在访问子路径时，会包含其父路径的 cookie，而在访问父路径时，不包含子路径的 cookie\n\nsessionstorage：当前会话窗口\n\nlocalstorage：在所有同源窗口中共享\n\n 4. 通信\n\ncookie：cookie 在浏览器和服务器之间来回传递，如果使用 cookie 保存过多数据会造成性能问题\n\nsessionstorage：仅在客户端（浏览器）中保存，不参与服务器的通信\n\nlocalstorage：仅在客户端（浏览器）中保存，不参与服务器的通信\n\n 5. 应用场景\n\ncookie：判断用户是否登录过网站，以便实现下次自动登录或记住密码；保存事件信息\n\nsessionstorage：敏感账号一次性登录，单页面用的较多\n\nlocalstorage：用于长期登录，适于长期保存在本地的数据\n\n\n# 从输入 url 到看到页面发生了什么？\n\n * 浏览器地址栏输入 url 并回车\n * 浏览器查找当前 url 是否存在缓存，并比较缓存是否过期\n * dns 解析 url 对应的 ip\n * 根据 ip 建立 tcp 连接（三次握手）\n * 发送 http 请求\n * 服务器处理请求，浏览器接受 http 响应\n * 浏览器解析并渲染页面\n * 关闭 tcp 连接（四次挥手）\n\n\n# get 和 post 请求有什么区别?\n\npost 和 get 是 http 请求的两种方法，其区别如下：\n\n * 应用场景： get 请求是一个幂等(是指可以使用相同参数重复执行，并能获得相同结果的函数。)的请求，一般 get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。\n\n * 是否缓存： 因为两者应用场景不同，浏览器一般会对 get 请求缓存，但很少对 post 请求缓存。\n\n * 发送的报文格式： get 请求的报文中实体部分为空，post 请求的报文中实体部分一般为向服务器发送的数据。\n\n * 安全性： get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。\n\n * 请求长度： 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 rfc 规定的。\n\n * 参数类型： post 的参数传递支持更多的数据类型。",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"21.10.12技术面",frontmatter:{title:"21.10.12技术面",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.12%E6%8A%80%E6%9C%AF%E9%9D%A2.html",relativePath:"前端面试/面试复盘/21.10.12技术面.md",key:"v-85f3b0ec",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.12%E6%8A%80%E6%9C%AF%E9%9D%A2.html",headers:[{level:2,title:"vue项目中遇到的最大的问题",slug:"vue项目中遇到的最大的问题",normalizedTitle:"vue项目中遇到的最大的问题",charIndex:2},{level:2,title:"vue-router路由两种工作模式的区别",slug:"vue-router路由两种工作模式的区别",normalizedTitle:"vue-router路由两种工作模式的区别",charIndex:21}],headersStr:"vue项目中遇到的最大的问题 vue-router路由两种工作模式的区别",content:"# vue项目中遇到的最大的问题\n\n\n# vue-router路由两种工作模式的区别",normalizedContent:"# vue项目中遇到的最大的问题\n\n\n# vue-router路由两种工作模式的区别",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"10.20技术面复盘",frontmatter:{title:"10.20技术面复盘",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.20%E6%8A%80%E6%9C%AF%E9%9D%A2%E5%A4%8D%E7%9B%98.html",relativePath:"前端面试/面试复盘/21.10.20技术面复盘.md",key:"v-a312ef94",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.20%E6%8A%80%E6%9C%AF%E9%9D%A2%E5%A4%8D%E7%9B%98.html",headers:[{level:2,title:"get,post的区别？",slug:"get-post的区别",normalizedTitle:"get,post的区别？",charIndex:28},{level:2,title:"v-if,v-show的区别？",slug:"v-if-v-show的区别",normalizedTitle:"v-if,v-show的区别？",charIndex:45},{level:2,title:"用过vue中的哪些指令？",slug:"用过vue中的哪些指令",normalizedTitle:"用过vue中的哪些指令？",charIndex:65},{level:2,title:"vue怎么阻止冒泡？",slug:"vue怎么阻止冒泡",normalizedTitle:"vue怎么阻止冒泡？",charIndex:82},{level:2,title:"跨域,有哪些解决方案？",slug:"跨域-有哪些解决方案",normalizedTitle:"跨域,有哪些解决方案？",charIndex:97},{level:2,title:"常用数组方法",slug:"常用数组方法",normalizedTitle:"常用数组方法",charIndex:113},{level:2,title:"slice改变原数组吗？",slug:"slice改变原数组吗",normalizedTitle:"slice改变原数组吗？",charIndex:124},{level:2,title:"后端返回新闻数据，前端怎么处理？",slug:"后端返回新闻数据-前端怎么处理",normalizedTitle:"后端返回新闻数据，前端怎么处理？",charIndex:141},{level:2,title:"讲一下快速排序？",slug:"讲一下快速排序",normalizedTitle:"讲一下快速排序？",charIndex:172},{level:2,title:"es6新特性",slug:"es6新特性",normalizedTitle:"es6新特性",charIndex:198},{level:2,title:"sort函数原理",slug:"sort函数原理",normalizedTitle:"sort函数原理",charIndex:230},{level:2,title:"vue反向代理怎么配",slug:"vue反向代理怎么配",normalizedTitle:"vue反向代理怎么配",charIndex:243},{level:2,title:"项目中用过哪些生命周期钩子？",slug:"项目中用过哪些生命周期钩子",normalizedTitle:"项目中用过哪些生命周期钩子？",charIndex:258},{level:2,title:"讲一下事件循环",slug:"讲一下事件循环",normalizedTitle:"讲一下事件循环",charIndex:277},{level:2,title:"微信小程序怎么获取用户数据",slug:"微信小程序怎么获取用户数据",normalizedTitle:"微信小程序怎么获取用户数据",charIndex:289}],headersStr:"get,post的区别？ v-if,v-show的区别？ 用过vue中的哪些指令？ vue怎么阻止冒泡？ 跨域,有哪些解决方案？ 常用数组方法 slice改变原数组吗？ 后端返回新闻数据，前端怎么处理？ 讲一下快速排序？ es6新特性 sort函数原理 vue反向代理怎么配 项目中用过哪些生命周期钩子？ 讲一下事件循环 微信小程序怎么获取用户数据",content:"注意\n\n需要加强的部分：数据结构与算法，ES6\n\n\n# get,post的区别？\n\n\n# v-if,v-show的区别？\n\n\n# 用过vue中的哪些指令？\n\n\n# vue怎么阻止冒泡？\n\n\n# 跨域,有哪些解决方案？\n\n\n# 常用数组方法\n\n\n# slice改变原数组吗？\n\n\n# 后端返回新闻数据，前端怎么处理？\n\n自己给自己挖的坑\n\n\n# 讲一下快速排序？\n\n不太会，讲了下冒泡排序\n\n\n# es6新特性\n\n答得不太全，这部分得好好看看阮神的书了\n\n\n# sort函数原理\n\n\n# vue反向代理怎么配\n\n\n# 项目中用过哪些生命周期钩子？\n\n\n# 讲一下事件循环\n\n\n# 微信小程序怎么获取用户数据\n\n又是给自己挖的坑，早知道不说自己用过微信小程序了",normalizedContent:"注意\n\n需要加强的部分：数据结构与算法，es6\n\n\n# get,post的区别？\n\n\n# v-if,v-show的区别？\n\n\n# 用过vue中的哪些指令？\n\n\n# vue怎么阻止冒泡？\n\n\n# 跨域,有哪些解决方案？\n\n\n# 常用数组方法\n\n\n# slice改变原数组吗？\n\n\n# 后端返回新闻数据，前端怎么处理？\n\n自己给自己挖的坑\n\n\n# 讲一下快速排序？\n\n不太会，讲了下冒泡排序\n\n\n# es6新特性\n\n答得不太全，这部分得好好看看阮神的书了\n\n\n# sort函数原理\n\n\n# vue反向代理怎么配\n\n\n# 项目中用过哪些生命周期钩子？\n\n\n# 讲一下事件循环\n\n\n# 微信小程序怎么获取用户数据\n\n又是给自己挖的坑，早知道不说自己用过微信小程序了",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"21.10.21技术面复盘",frontmatter:{title:"21.10.21技术面复盘",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.21%E6%8A%80%E6%9C%AF%E9%9D%A2%E5%A4%8D%E7%9B%98.html",relativePath:"前端面试/面试复盘/21.10.21技术面复盘.md",key:"v-61e67f96",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.10.21%E6%8A%80%E6%9C%AF%E9%9D%A2%E5%A4%8D%E7%9B%98.html",headers:[{level:2,title:"vue生命周期",slug:"vue生命周期",normalizedTitle:"vue生命周期",charIndex:2},{level:2,title:"父子传值怎么传，子串父呢？",slug:"父子传值怎么传-子串父呢",normalizedTitle:"父子传值怎么传，子串父呢？",charIndex:14},{level:2,title:"vue响应式原理",slug:"vue响应式原理",normalizedTitle:"vue响应式原理",charIndex:32},{level:2,title:"forEach和map区别",slug:"foreach和map区别",normalizedTitle:"foreach和map区别",charIndex:45},{level:2,title:"讲一下闭包",slug:"讲一下闭包",normalizedTitle:"讲一下闭包",charIndex:63},{level:2,title:"es6新特性",slug:"es6新特性",normalizedTitle:"es6新特性",charIndex:84}],headersStr:"vue生命周期 父子传值怎么传，子串父呢？ vue响应式原理 forEach和map区别 讲一下闭包 es6新特性",content:"# vue生命周期\n\n\n# 父子传值怎么传，子串父呢？\n\n\n# vue响应式原理\n\n\n# forEach和map区别\n\n\n# 讲一下闭包\n\n这题居然没答好😔\n\n\n# es6新特性\n\n这个基本都会问，好好看看阮神的书吧",normalizedContent:"# vue生命周期\n\n\n# 父子传值怎么传，子串父呢？\n\n\n# vue响应式原理\n\n\n# foreach和map区别\n\n\n# 讲一下闭包\n\n这题居然没答好😔\n\n\n# es6新特性\n\n这个基本都会问，好好看看阮神的书吧",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"21.9.14一面复盘",frontmatter:{title:"21.9.14一面复盘",readingShow:"top"},regularPath:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.9.14%E4%B8%80%E9%9D%A2%E5%A4%8D%E7%9B%98.html",relativePath:"前端面试/面试复盘/21.9.14一面复盘.md",key:"v-3408f9af",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/21.9.14%E4%B8%80%E9%9D%A2%E5%A4%8D%E7%9B%98.html",headers:[{level:2,title:"html",slug:"html",normalizedTitle:"html",charIndex:2},{level:3,title:"html5 新增了那些标签？",slug:"html5-新增了那些标签",normalizedTitle:"html5 新增了那些标签？",charIndex:11},{level:3,title:"html5 提供了两种在客户端存储数据的新方法,说一下它们的区别？",slug:"html5-提供了两种在客户端存储数据的新方法-说一下它们的区别",normalizedTitle:"html5 提供了两种在客户端存储数据的新方法,说一下它们的区别？",charIndex:97},{level:2,title:"css",slug:"css",normalizedTitle:"css",charIndex:230},{level:3,title:"垂直水平居中怎么实现？",slug:"垂直水平居中怎么实现",normalizedTitle:"垂直水平居中怎么实现？",charIndex:238},{level:3,title:"定位有那几种，绝对和相对的区别?",slug:"定位有那几种-绝对和相对的区别",normalizedTitle:"定位有那几种，绝对和相对的区别?",charIndex:525},{level:3,title:"如何清除浮动？",slug:"如何清除浮动",normalizedTitle:"如何清除浮动？",charIndex:566},{level:2,title:"js",slug:"js",normalizedTitle:"js",charIndex:584},{level:3,title:"数组如何转为字符串，字符串转数组呢？",slug:"数组如何转为字符串-字符串转数组呢",normalizedTitle:"数组如何转为字符串，字符串转数组呢？",charIndex:591},{level:3,title:"数组字符串相关方法",slug:"数组字符串相关方法",normalizedTitle:"数组字符串相关方法",charIndex:945},{level:3,title:"const 和 let 的区别？",slug:"const-和-let-的区别",normalizedTitle:"const 和 let 的区别？",charIndex:982},{level:3,title:"数组 es6 新增方法",slug:"数组-es6-新增方法",normalizedTitle:"数组 es6 新增方法",charIndex:1041},{level:2,title:"vue",slug:"vue",normalizedTitle:"vue",charIndex:1070},{level:3,title:"v-if 和 v-show 的区别",slug:"v-if-和-v-show-的区别",normalizedTitle:"v-if 和 v-show 的区别",charIndex:1078},{level:3,title:"说几个生命周期钩子",slug:"说几个生命周期钩子",normalizedTitle:"说几个生命周期钩子",charIndex:1379},{level:3,title:"watch 和 computed 的区别？",slug:"watch-和-computed-的区别",normalizedTitle:"watch 和 computed 的区别？",charIndex:1399},{level:3,title:"说一下 Vue 组件通讯",slug:"说一下-vue-组件通讯",normalizedTitle:"说一下 vue 组件通讯",charIndex:1946}],headersStr:"html html5 新增了那些标签？ html5 提供了两种在客户端存储数据的新方法,说一下它们的区别？ css 垂直水平居中怎么实现？ 定位有那几种，绝对和相对的区别? 如何清除浮动？ js 数组如何转为字符串，字符串转数组呢？ 数组字符串相关方法 const 和 let 的区别？ 数组 es6 新增方法 vue v-if 和 v-show 的区别 说几个生命周期钩子 watch 和 computed 的区别？ 说一下 Vue 组件通讯",content:"# html\n\n\n# html5 新增了那些标签？\n\nheader,nav,footer,aside,article,section,audio,video\n\nhtml5 常见新增标签\n\n\n# html5 提供了两种在客户端存储数据的新方法,说一下它们的区别？\n\n * localStorage 长期存储数据，浏览器关闭后数据不丢失 ,作用域在所有同源窗口中共享\n\n * sessionStorage 的数据在浏览器关闭后自动删除,作用域当前会话窗口\n\n\n# css\n\n\n# 垂直水平居中怎么实现？\n\n * absolute 元素：利用 top:50%,left:50%和 margin-top,margin-left (元素尺寸已知可用)\n * absolute 元素：利用 top:50%,left:50%和利用 transfrom:translate(-50%,-50%)(元素尺寸不知道也可以用)\n * absolute 元素： top,left,bottom,right=0 和 margin:auto(元素尺寸不知道也可以用)\n * flex：align-items:center;justify-content:center;\n\n\n# 定位有那几种，绝对和相对的区别?\n\n相对定位，绝对定位，固定定位\n\n定位\n\n\n# 如何清除浮动？\n\n清除浮动\n\n\n# js\n\n\n# 数组如何转为字符串，字符串转数组呢？\n\n数组的join()方法可以使数组转为字符串；字符串的split()方法可以使字符串转为数组。\n\n * join()的参数表示以什么字符作为连接符，如果留空则默认以逗号分隔，如同调用 tostring()方法\n * split()的参数表示以什么字符拆分字符串，一般不能留空=>(str.split(''))\n\n数组调用 toString() 和String()也可以转为字符串\n\nconst a = [1, 2, 3, 4, 1, 2, 3]\nconst b = a.toString()\nconst c = String(a)\nconsole.log(b) // 1,2,3,4,1,2,3\nconsole.log(c) // 1,2,3,4,1,2,3\n\n\n\n# 数组字符串相关方法\n\n * 字符串常用方法\n\n * 数组常用方法\n\n\n# const 和 let 的区别？\n\nconst 和 let 的最大区别是：const 一旦声明必须立即初始化\n\n\n# 数组 es6 新增方法\n\nES6_数组的新增方法\n\n\n# vue\n\n\n# v-if 和 v-show 的区别\n\n条件渲染\n\n两者都可用来控制 DOM 元素的显示和隐藏，区别在于\n\nv-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件被适当地销毁和重建；v-if 也是惰性的，就是初始条件为假的话什么也不做，直到条件第一次变为真时才开始渲染条件块。相比之下，v-show 就简单得多，无论初始条件是什么都会进行渲染，只是简单地基于 CSS 进行切换，隐藏的话就加入 display:none 的属性值。所以 v-if 具有较高的切换开销，适用于运行时条件很少改变的场景，而 v-show 具有较高的初始化渲染开销，适用于需要频繁切换的场景。\n\n\n# 说几个生命周期钩子\n\n生命周期\n\n\n# watch 和 computed 的区别？\n\nwatch 对比 computed\n\n * computed 1、 computed 是计算属性，也就是依赖某个值或者 props 通过计算得来得数据； 2、 computed 的值是在 getter 执行之后进行缓存的，只有在它依赖的数据发生变化，会重新调用 getter 来计算； 3、 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化；\n\n * watch 1、watch 是监听器，可以监听某一个数据，然后执行相应的操作； 2、不支持缓存，数据变直接会触发相应的操作； 3、监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值； 4、支持异步操作；\n\n什么时候用 computed 什么时候用 watch 比较合适？\n\n当多个属性影响一个属性的时候，建议用 computed，比如：\n\nfullName(){\n return this.firstName + this.secondName\n}\n\n\nfullName 是由 firstName 和 secondName 影响的，这种情况就适合 computed；\n\n当一个值发生变化之后，会引起一系列的操作，这种情况就适合用 watch；\n\n\n# 说一下 Vue 组件通讯\n\n * props 和 $emit:父组件向子组件传递数据是通过 props 传递的，子组件给父组件传递数据是通过$emit 触发事件来做到的\n\n * $parent,$children 获取当前组件的父组件和当前组件的子组件\n\n * $attrs 和$listeners A->B->C (孙传爷)。Vue 2.4 开始提供了$attrs 和$listeners 来解决这个问题\n\n * 父组件中通过 provide 来提供变量，然后在子组件中通过inject来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用)\n\n * $refs 获取组件实例\n\n * envetBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式\n\n * vuex 状态管理",normalizedContent:"# html\n\n\n# html5 新增了那些标签？\n\nheader,nav,footer,aside,article,section,audio,video\n\nhtml5 常见新增标签\n\n\n# html5 提供了两种在客户端存储数据的新方法,说一下它们的区别？\n\n * localstorage 长期存储数据，浏览器关闭后数据不丢失 ,作用域在所有同源窗口中共享\n\n * sessionstorage 的数据在浏览器关闭后自动删除,作用域当前会话窗口\n\n\n# css\n\n\n# 垂直水平居中怎么实现？\n\n * absolute 元素：利用 top:50%,left:50%和 margin-top,margin-left (元素尺寸已知可用)\n * absolute 元素：利用 top:50%,left:50%和利用 transfrom:translate(-50%,-50%)(元素尺寸不知道也可以用)\n * absolute 元素： top,left,bottom,right=0 和 margin:auto(元素尺寸不知道也可以用)\n * flex：align-items:center;justify-content:center;\n\n\n# 定位有那几种，绝对和相对的区别?\n\n相对定位，绝对定位，固定定位\n\n定位\n\n\n# 如何清除浮动？\n\n清除浮动\n\n\n# js\n\n\n# 数组如何转为字符串，字符串转数组呢？\n\n数组的join()方法可以使数组转为字符串；字符串的split()方法可以使字符串转为数组。\n\n * join()的参数表示以什么字符作为连接符，如果留空则默认以逗号分隔，如同调用 tostring()方法\n * split()的参数表示以什么字符拆分字符串，一般不能留空=>(str.split(''))\n\n数组调用 tostring() 和string()也可以转为字符串\n\nconst a = [1, 2, 3, 4, 1, 2, 3]\nconst b = a.tostring()\nconst c = string(a)\nconsole.log(b) // 1,2,3,4,1,2,3\nconsole.log(c) // 1,2,3,4,1,2,3\n\n\n\n# 数组字符串相关方法\n\n * 字符串常用方法\n\n * 数组常用方法\n\n\n# const 和 let 的区别？\n\nconst 和 let 的最大区别是：const 一旦声明必须立即初始化\n\n\n# 数组 es6 新增方法\n\nes6_数组的新增方法\n\n\n# vue\n\n\n# v-if 和 v-show 的区别\n\n条件渲染\n\n两者都可用来控制 dom 元素的显示和隐藏，区别在于\n\nv-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件被适当地销毁和重建；v-if 也是惰性的，就是初始条件为假的话什么也不做，直到条件第一次变为真时才开始渲染条件块。相比之下，v-show 就简单得多，无论初始条件是什么都会进行渲染，只是简单地基于 css 进行切换，隐藏的话就加入 display:none 的属性值。所以 v-if 具有较高的切换开销，适用于运行时条件很少改变的场景，而 v-show 具有较高的初始化渲染开销，适用于需要频繁切换的场景。\n\n\n# 说几个生命周期钩子\n\n生命周期\n\n\n# watch 和 computed 的区别？\n\nwatch 对比 computed\n\n * computed 1、 computed 是计算属性，也就是依赖某个值或者 props 通过计算得来得数据； 2、 computed 的值是在 getter 执行之后进行缓存的，只有在它依赖的数据发生变化，会重新调用 getter 来计算； 3、 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化；\n\n * watch 1、watch 是监听器，可以监听某一个数据，然后执行相应的操作； 2、不支持缓存，数据变直接会触发相应的操作； 3、监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值； 4、支持异步操作；\n\n什么时候用 computed 什么时候用 watch 比较合适？\n\n当多个属性影响一个属性的时候，建议用 computed，比如：\n\nfullname(){\n return this.firstname + this.secondname\n}\n\n\nfullname 是由 firstname 和 secondname 影响的，这种情况就适合 computed；\n\n当一个值发生变化之后，会引起一系列的操作，这种情况就适合用 watch；\n\n\n# 说一下 vue 组件通讯\n\n * props 和 $emit:父组件向子组件传递数据是通过 props 传递的，子组件给父组件传递数据是通过$emit 触发事件来做到的\n\n * $parent,$children 获取当前组件的父组件和当前组件的子组件\n\n * $attrs 和$listeners a->b->c (孙传爷)。vue 2.4 开始提供了$attrs 和$listeners 来解决这个问题\n\n * 父组件中通过 provide 来提供变量，然后在子组件中通过inject来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用)\n\n * $refs 获取组件实例\n\n * envetbus 兄弟组件数据传递 这种情况下可以使用事件总线的方式\n\n * vuex 状态管理",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"Ajax&Fetch与跨域请求",frontmatter:{title:"Ajax&Fetch与跨域请求",readingShow:"top"},regularPath:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Ajax&Fetch%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82.html",relativePath:"基础知识/前端相关/Ajax&Fetch与跨域请求.md",key:"v-8097d612",path:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/Ajax&Fetch%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82.html",headers:[{level:2,title:"ajax",slug:"ajax",normalizedTitle:"ajax",charIndex:2},{level:3,title:"Ajax简介",slug:"ajax简介",normalizedTitle:"ajax简介",charIndex:11},{level:3,title:"Ajax的基本用法",slug:"ajax的基本用法",normalizedTitle:"ajax的基本用法",charIndex:342},{level:3,title:"GET请求",slug:"get请求",normalizedTitle:"get请求",charIndex:1163},{level:3,title:"POST 请求",slug:"post-请求",normalizedTitle:"post 请求",charIndex:1753},{level:2,title:"JSON",slug:"json",normalizedTitle:"json",charIndex:267},{level:3,title:"初识JSON",slug:"初识json",normalizedTitle:"初识json",charIndex:2407},{level:3,title:"JSON的三种形式",slug:"json的三种形式",normalizedTitle:"json的三种形式",charIndex:2533},{level:3,title:"JSON的常用方法",slug:"json的常用方法",normalizedTitle:"json的常用方法",charIndex:2853},{level:2,title:"跨域",slug:"跨域",normalizedTitle:"跨域",charIndex:3605},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:15},{level:3,title:"什么是不同域，什么是同域",slug:"什么是不同域-什么是同域",normalizedTitle:"什么是不同域，什么是同域",charIndex:3667},{level:3,title:"跨域请求为什么会被阻止",slug:"跨域请求为什么会被阻止",normalizedTitle:"跨域请求为什么会被阻止",charIndex:3792},{level:3,title:"跨域解决方案",slug:"跨域解决方案",normalizedTitle:"跨域解决方案",charIndex:3867},{level:3,title:"JSONP",slug:"jsonp",normalizedTitle:"jsonp",charIndex:3893},{level:2,title:"XHR 对象",slug:"xhr-对象",normalizedTitle:"xhr 对象",charIndex:5057},{level:3,title:"XHR 的属性",slug:"xhr-的属性",normalizedTitle:"xhr 的属性",charIndex:5068},{level:3,title:"XHR方法",slug:"xhr方法",normalizedTitle:"xhr方法",charIndex:5526},{level:3,title:"XHR 的事件",slug:"xhr-的事件",normalizedTitle:"xhr 的事件",charIndex:5861},{level:2,title:"FormData",slug:"formdata",normalizedTitle:"formdata",charIndex:7996},{level:2,title:"封装Ajax",slug:"封装ajax",normalizedTitle:"封装ajax",charIndex:9395},{level:2,title:"axios",slug:"axios",normalizedTitle:"axios",charIndex:9593},{level:2,title:"Fetch",slug:"fetch",normalizedTitle:"fetch",charIndex:9656}],headersStr:"ajax Ajax简介 Ajax的基本用法 GET请求 POST 请求 JSON 初识JSON JSON的三种形式 JSON的常用方法 跨域 简介 什么是不同域，什么是同域 跨域请求为什么会被阻止 跨域解决方案 JSONP XHR 对象 XHR 的属性 XHR方法 XHR 的事件 FormData 封装Ajax axios Fetch",content:'# ajax\n\n\n# Ajax简介\n\nAjax即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。\n\nAjax中的异步：可以异步地向服务器发送请求，在等待响应的过程中，不会阻塞当前页面，浏览器可以做自己的事. 直到成功获取响应后，浏览器才开始处理响应数据。\n\nXML 可扩展标记语言，是前后端数据通信时传输数据的一种格式\n\nXML 现在已经不怎么用了，现在比较常用的时JSON\n\nAjax其实就是浏览器与服务器之间的一种 异步通信方式\n\n使用Ajax可以在不重新加载整个页面的情况下， 对页面的某部分进行更新\n\n\n# Ajax的基本用法\n\nAjax想要实现浏览器与服务器之间的异步通信，需要依靠XMLHttpRequest,它是一个构造函数\n\n 1. 创建xhr对象\n\nconst xhr =new XMLHttpRequest()\n\n\n 2. 监听事件,处理响应\n\n当获取到响应后，会触发xhr对象的readystatechange事件，可以在该事件中对响应进行处理\n\nxhr.onreadystatechange = ()=>{\n    if(xhr.readyState !== 4) return;\n    //HTTP CODE\n    //获取响应后，响应的内容会自动填充xhr对象的属性\n    if((xhr.status >= 200 & xhr.status < 300) || xhr.status === 304) {\n        console.log(\'正常使用\')\n        //数据\n        console.log(xhr.responseText);\n        }\n};\n\n\nreadystatechange事件监听readyState这个状态的变化 一共有5个状态\n\n * 0：未初始化，尚未调用open()\n * 1：启动，已经调用open(),但尚未调用send()\n * 2：发送，已经调用send(),当尚未接收到响应\n * 3：接收，已经接收到部分响应数据\n * 4：完成，已经接收到全部响应数据，并且可以在浏览器中使用\n\n 3. 准备发送请求\n    调用open()并不会真正发送请求，而只是做好发送请求前的准备工作\n\nxhr.open(\n//\'http方法\',\n//"地址url",true或false:是否为异步请求，一般肯定true    \n)\n\n\n 4. 发送请求\n\n调用send()正式发送请求\n\nsend()的参数是通过请求体携带的数据\n\nxhr.send(null) //GET请求一般填null，因为GET不能通过请求体携带数据\n\n\neg:使用Ajax来完成前后端通信\n\n        const url = "https://www.imooc.com/api/http/search/suggest?words=js";\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState !== 4) return;\n            if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n        console.log(xhr.responseText);\n            }\n        };\n        xhr.open("get", url);\n        xhr.send(null);\n\n\n\n# GET请求\n\n 1. 携带数据\n    GET请求不能通过请求体携带数据，但可以通过请求头携带， 在url对应的接口下添加名值对\n 2. 数据编码\n    如果携带的数据时非英文字母的话，比如说汉字，就需要编码之后再发送给后端，不然会造成乱码问题\n\n\n# POST 请求\n\n 1. 携带数据\n    POST请求主要通过请求体携带数据，同时也可以通过请求头携带\n\n     const url = "https://www.imooc.com/api/http/search/suggest?words=js";\n      const xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState !== 4) return;\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n          console.log(xhr.responseText);\n          console.log(typeof xhr.responseText);\n        }\n      };\n      xhr.open("POST", url);\n      //如果想发送数据，直接写在 send()的参数位置，一般是字符串\n      // 不能直接传递对象，需要先将对象转换成字符串的形式\n      xhr.send(\'username=alex&age=18\');\n     \n\n\n 2. 数据编码:如果携带的数据时非英文字母的话，比如说汉字，就需要编码之后再发送给后端，不然会造成乱码问题\n\n\n# JSON\n\n\n# 初识JSON\n\n 1. javascript object notation,Ajax发送和接受的一种数据格式\n\n 2. 为什么需要JSON\n\nJSON有3种形式，每种形式的写法都和JS中的数据类型很像，可以很轻松的和JS中的数据类型互相转换\n\n\n# JSON的三种形式\n\n 1. 简单值形式\n\n文件名：xxx.json\nJSON的简单值形式就对应着JS中的基础数据类型,数字，字符串，布尔值，null\n\n 2. 对象形式\n\nJSON的对象形式就对应着JS中的对象\n\n    {\n    "name":"张三",\n    "age":18,\n    "hobby":["足球","乒乓球"]\n    }\n\n\n 3. 数组形式\n\nJSON的数组形式就对应着JS中的数组\n\n注意事项\n\n 1. JSON中没有underfined值\n 2. JSON中的字符串必须使用双引号\n 3. JSON中是不能注释的\n 4. JSON中对象的属性名必须使用双引号，属性值如果是字符串也必须用双引号。\n\n\n# JSON的常用方法\n\n 1. JSON.parse()\n    可以将JSON格式的字符串解析成JS中的对应值\n    一定要是合法的JSON字符串，否则会报错\n 2. JSON.stringify() 可以将JS的基本数据类型，对象或者数组转换成JSON格式的字符串\n\n xhr.open("POST", url, true);\n      xhr.send(\n        JSON.stringify({\n          name: "张三",\n          hobby: ["足球", "乒乓球"],\n        })\n      );\n\n\n 3. 使用JSON.parse()和JSON.stringify()封装localStorage\n\n      const storage = window.localStorage;\n      // 设置\n      const set = (key, value) => {\n        storage.setItem(key, JSON.stringify(value));\n      };\n      // 获取\n      const get = (key) => {\n        return JSON.parse(storage.getItem(key));\n      };\n      // 删除\n      const remove = (key) => {\n        storage.removeItem(key);\n      };\n      // 清空\n      const clear = () => {\n        storage.clear();\n      }; \n\n\n\n# 跨域\n\n\n# 简介\n\n向一个域发送请求，如果要请求的域和当前域是不同域，就叫跨域\n\n不同域之间的请求，就是跨域请求\n\n\n# 什么是不同域，什么是同域\n\nhttps(协议)：// www.imooc.com (域名) ：443 (端口号) /course/list (路径)\n\n * 协议 域名 端口号 任何一个不一样 就是不同域\n * 与路径无关，路径不一样无所谓\n\n\n# 跨域请求为什么会被阻止\n\n * 阻止跨域请求，其实是浏览器本身的一种安全策略---同源策略\n * 其他客户端或者服务器不存在跨域被阻止的问题\n\n\n# 跨域解决方案\n\n * CORS 跨域资源共享\n * JSONP\n * 优先使用CORS ，如果浏览器不支持，使用JSONP\n\n# CORS 跨域资源共享\n\n跨域资源共享 CORS 详解\n\n使用CORS跨域的过程\n\n① 浏览器发送请求\n\n② 后端在响应头中添加 Access-Control-Allow-Origin头信息\n\n③ 浏览器接收到响应\n\n④ 如果是同域下的请求，浏览器不会额外做什么，这次前后端通信就圆满完成了\n\n⑤ 如果是跨域请求，浏览器会从响应头中查找是否允许跨域访问\n\n⑥ 如果允许跨域，通信圆满完成\n\n⑦ 如果没找到或不包含想要跨域的域名，就丢弃响应结果\n\nCORS兼容性：IE10及以上可以正常使用\n\n\n# JSONP\n\n 1. 原理\n    script 标签跨域不会被浏览器阻止\n    JSONP主要就是利用SCRIPT标签，加载跨域文件\n 2. 使用JSONP实现跨域\n    服务器端准备好JSONP接口\n    手动加载JSONP标签或\n\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n\n</head>\n\n<body>\n    <script type=\'text/javascript\'>\n        const handleResponse = data => console.log(data)\n    <\/script>\n    <script src="https://www.imooc.com/api/http/jsonp?callback=handleResponse"><\/script>\n</body>\n\n</html>\n\n\n\n动态加载JSONP接口\n\n// 动态加载JSONP接口\n const script = document.createElement("script");\n      script.src =\n        "https://www.imooc.com/api/http/jsonp?callback=handleResponse";\n      document.body.appendChild(script);\n      const handleResponse = (data) => {\n        console.log(data);\n      };\n\n\n\n# XHR 对象\n\n\n# XHR 的属性\n\n 1. responseType 和response属性\n\n * responseText只能在没有设置responseType或者responseType=\'\'或responseType=\'text\' 的时候才能使用\n * response可以替代responseText，默认返回字符串，可以通过responseType设置返回形式(如果设置为JSON，浏览器默认调用JSON.parse()解析成JS中的对应值，但服务器还是返回的是JSON格式的字符串)\n\nxhr.responseType = "json" \n\n\n 2. timeout属性:设置请求的超时时间（单位：ms）\n\n 3. withCredentitals 属性\n\n * 指定使用Ajax发送请求时是否携带Cookie\n * 使用Ajax发送请求，默认情况下，同域时，会携带Cookie,跨域时，不会\n * 最终是否能成功跨域携带Cookie，还要看服务器同不同意\n\nxhr.withCredentials=true\n\n\n\n# XHR方法\n\n 1. abort():终止当前请求,一般配合abort事件一起使用\n 2. setRequestHeader():可以设置请求头信息\n\nHTTP content-type\n\n//  请求头中的`Content-Type`字段用来告诉服务器，浏览器发送的数据是什么格式的。 \nxhr.setRequestHeader("Content-Type",\'application/x-www-form-urlencoded\') // 对应的数据格式：\'username=ased&password=asd\'\n \nxhr.setRequestHeader("Content-Type",\'application/json\') // JSON格式的数据\n\n\n\n\n# XHR 的事件\n\n 1. load 事件:响应数据可用时触发 推荐使用onload代替onreadystatechange\n\n      const url ="https://www.imooc.com/api/http/search/suggest?words=js";\n      const xhr = new XMLHttpRequest();\n      xhr.addEventListener(\n        "load",\n        () => {\n          if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n            console.log(xhr.response);\n            console.log(typeof xhr.response);\n          }\n        },\n        false\n      );\n      xhr.responseType = "json";\n      xhr.open("GET", url, true);\n      xhr.send();\n\n\n 1. error 事件\n    请求发生错误时触发\n\n      const url = "https://www.imooc1.com/api/http/search/suggest?words=js";\n      const xhr = new XMLHttpRequest();\n      xhr.addEventListener(\n        "load",\n        () => {\n          if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n            console.log(xhr.response);\n            console.log(typeof xhr.response);\n          }\n        },\n        false\n      );\n      xhr.addEventListener("error", () => {\n        console.log("访问出错拉！");\n      });\n      xhr.responseType = "json";\n      xhr.open("GET", url, true);\n      xhr.send();\n\n\n 3. abort 事件\n    调用abort()终止请求时触发\n\n     const url ="https://www.imooc.com/api/http/search/suggest?words=js";\n      const xhr = new XMLHttpRequest();\n      xhr.addEventListener(\n        "abort",\n        () => {\n          console.log("543629463");\n        },\n        false\n      );\n      xhr.addEventListener("error", () => {\n        console.log("访问出错拉！");\n      });\n      xhr.responseType = "json";\n      xhr.open("GET", url, true);\n      xhr.send();\n      xhr.abort();\n\n\n 4. timeout事件\n\n        var xhr = new XMLHttpRequest()\n        xhr.responseType = \'json\'\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState !== 4) return;\n            if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n                console.log(xhr.response );\n            }\n        }\n        xhr.open("GET", "https://www.imooc.com/api/http/search/suggest?words=js")\n        xhr.timeout = 10 \n        xhr.ontimeout = function (e) {\n            console.log("Timeout!!")\n        }\n        xhr.send()\n\n\n\n# FormData\n\n使用Ajax提交表单(避免直接提交表单跳转)\n\nFormData可用于发送表单数据\n\n  <body>\n    <form id="login">\n      <input type="text" name="username" placeholder="用户名" />\n      <input type="password" name="password" placeholder="密码" />\n      <input type="submit" id="submit" value="提交" />\n    </form>\n    <script>\n      const login = document.getElementById("login");\n      const btn = document.getElementById("submit");\n      const url = "https://www.imooc.com/api/http/search/suggest?words=js";\n      btn.addEventListener(\n        "click",\n        (e) => {\n          // 阻止表单跳转\n          e.preventDefault();\n          const xhr = new XMLHttpRequest();\n          xhr.addEventListener(\n            "load",\n            () => {\n              if (\n                (xhr.status >= 200 && xhr.status < 300) ||\n                xhr.status === 304\n              ) {\n                console.log(xhr.response);\n              }\n            },\n            false\n          );\n          xhr.open("POST", url, true);\n          xhr.responseType = "json";\n          const data = new FormData(login);\n          xhr.send(data);\n        },\n        false\n      );\n    <\/script>\n  </body>\n\n\nFormData的基本用法\n\n // 通过 HTML 表单元素创建 FormData 对象\n      const fd = new FormData(表单元素);\n      xhr.send(fd);\n\n      // 通过 自身的append() 方法添加数据\n      const fd = new FormData(表单元素);\n      fd.append(\'age\', 18);\n      fd.append(\'sex\', \'male\');\n      xhr.send(fd);\n\n\n\n# 封装Ajax\n\n1、ajax的原理需要掌握一下。即ajax这门技术是使用XMLHttpRequest这个对象实现的，该对象有一些方法和属性，比如open()、send()、responseType......它们的含义是什么要知道。 2、ajax的具体实现不需要自己手动封装。 3、实际开发中会使用现成的插件，我们只需要按照插件的文档使用即可\n\n源代码：\n\nhand-tear-code\n\n\n# axios\n\n 1. 基于Promise的HTTP库\n\n 2. axios中文官方文档\n\n 3. axios中文说明\n\n\n# Fetch\n\nFetch API 教程\n\n 1. 也是前后端通信的一种方式\n 2. 是Ajax的一种替代方案，它是基于Promise的\n 3. Ajax的兼容性比 Fetch 好\n 4. Fetch没有abort timeout',normalizedContent:'# ajax\n\n\n# ajax简介\n\najax即“asynchronous javascript and xml”（异步 javascript 和 xml），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。\n\najax中的异步：可以异步地向服务器发送请求，在等待响应的过程中，不会阻塞当前页面，浏览器可以做自己的事. 直到成功获取响应后，浏览器才开始处理响应数据。\n\nxml 可扩展标记语言，是前后端数据通信时传输数据的一种格式\n\nxml 现在已经不怎么用了，现在比较常用的时json\n\najax其实就是浏览器与服务器之间的一种 异步通信方式\n\n使用ajax可以在不重新加载整个页面的情况下， 对页面的某部分进行更新\n\n\n# ajax的基本用法\n\najax想要实现浏览器与服务器之间的异步通信，需要依靠xmlhttprequest,它是一个构造函数\n\n 1. 创建xhr对象\n\nconst xhr =new xmlhttprequest()\n\n\n 2. 监听事件,处理响应\n\n当获取到响应后，会触发xhr对象的readystatechange事件，可以在该事件中对响应进行处理\n\nxhr.onreadystatechange = ()=>{\n    if(xhr.readystate !== 4) return;\n    //http code\n    //获取响应后，响应的内容会自动填充xhr对象的属性\n    if((xhr.status >= 200 & xhr.status < 300) || xhr.status === 304) {\n        console.log(\'正常使用\')\n        //数据\n        console.log(xhr.responsetext);\n        }\n};\n\n\nreadystatechange事件监听readystate这个状态的变化 一共有5个状态\n\n * 0：未初始化，尚未调用open()\n * 1：启动，已经调用open(),但尚未调用send()\n * 2：发送，已经调用send(),当尚未接收到响应\n * 3：接收，已经接收到部分响应数据\n * 4：完成，已经接收到全部响应数据，并且可以在浏览器中使用\n\n 3. 准备发送请求\n    调用open()并不会真正发送请求，而只是做好发送请求前的准备工作\n\nxhr.open(\n//\'http方法\',\n//"地址url",true或false:是否为异步请求，一般肯定true    \n)\n\n\n 4. 发送请求\n\n调用send()正式发送请求\n\nsend()的参数是通过请求体携带的数据\n\nxhr.send(null) //get请求一般填null，因为get不能通过请求体携带数据\n\n\neg:使用ajax来完成前后端通信\n\n        const url = "https://www.imooc.com/api/http/search/suggest?words=js";\n        const xhr = new xmlhttprequest();\n        xhr.onreadystatechange = () => {\n            if (xhr.readystate !== 4) return;\n            if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n        console.log(xhr.responsetext);\n            }\n        };\n        xhr.open("get", url);\n        xhr.send(null);\n\n\n\n# get请求\n\n 1. 携带数据\n    get请求不能通过请求体携带数据，但可以通过请求头携带， 在url对应的接口下添加名值对\n 2. 数据编码\n    如果携带的数据时非英文字母的话，比如说汉字，就需要编码之后再发送给后端，不然会造成乱码问题\n\n\n# post 请求\n\n 1. 携带数据\n    post请求主要通过请求体携带数据，同时也可以通过请求头携带\n\n     const url = "https://www.imooc.com/api/http/search/suggest?words=js";\n      const xhr = new xmlhttprequest();\n      xhr.onreadystatechange = () => {\n        if (xhr.readystate !== 4) return;\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n          console.log(xhr.responsetext);\n          console.log(typeof xhr.responsetext);\n        }\n      };\n      xhr.open("post", url);\n      //如果想发送数据，直接写在 send()的参数位置，一般是字符串\n      // 不能直接传递对象，需要先将对象转换成字符串的形式\n      xhr.send(\'username=alex&age=18\');\n     \n\n\n 2. 数据编码:如果携带的数据时非英文字母的话，比如说汉字，就需要编码之后再发送给后端，不然会造成乱码问题\n\n\n# json\n\n\n# 初识json\n\n 1. javascript object notation,ajax发送和接受的一种数据格式\n\n 2. 为什么需要json\n\njson有3种形式，每种形式的写法都和js中的数据类型很像，可以很轻松的和js中的数据类型互相转换\n\n\n# json的三种形式\n\n 1. 简单值形式\n\n文件名：xxx.json\njson的简单值形式就对应着js中的基础数据类型,数字，字符串，布尔值，null\n\n 2. 对象形式\n\njson的对象形式就对应着js中的对象\n\n    {\n    "name":"张三",\n    "age":18,\n    "hobby":["足球","乒乓球"]\n    }\n\n\n 3. 数组形式\n\njson的数组形式就对应着js中的数组\n\n注意事项\n\n 1. json中没有underfined值\n 2. json中的字符串必须使用双引号\n 3. json中是不能注释的\n 4. json中对象的属性名必须使用双引号，属性值如果是字符串也必须用双引号。\n\n\n# json的常用方法\n\n 1. json.parse()\n    可以将json格式的字符串解析成js中的对应值\n    一定要是合法的json字符串，否则会报错\n 2. json.stringify() 可以将js的基本数据类型，对象或者数组转换成json格式的字符串\n\n xhr.open("post", url, true);\n      xhr.send(\n        json.stringify({\n          name: "张三",\n          hobby: ["足球", "乒乓球"],\n        })\n      );\n\n\n 3. 使用json.parse()和json.stringify()封装localstorage\n\n      const storage = window.localstorage;\n      // 设置\n      const set = (key, value) => {\n        storage.setitem(key, json.stringify(value));\n      };\n      // 获取\n      const get = (key) => {\n        return json.parse(storage.getitem(key));\n      };\n      // 删除\n      const remove = (key) => {\n        storage.removeitem(key);\n      };\n      // 清空\n      const clear = () => {\n        storage.clear();\n      }; \n\n\n\n# 跨域\n\n\n# 简介\n\n向一个域发送请求，如果要请求的域和当前域是不同域，就叫跨域\n\n不同域之间的请求，就是跨域请求\n\n\n# 什么是不同域，什么是同域\n\nhttps(协议)：// www.imooc.com (域名) ：443 (端口号) /course/list (路径)\n\n * 协议 域名 端口号 任何一个不一样 就是不同域\n * 与路径无关，路径不一样无所谓\n\n\n# 跨域请求为什么会被阻止\n\n * 阻止跨域请求，其实是浏览器本身的一种安全策略---同源策略\n * 其他客户端或者服务器不存在跨域被阻止的问题\n\n\n# 跨域解决方案\n\n * cors 跨域资源共享\n * jsonp\n * 优先使用cors ，如果浏览器不支持，使用jsonp\n\n# cors 跨域资源共享\n\n跨域资源共享 cors 详解\n\n使用cors跨域的过程\n\n① 浏览器发送请求\n\n② 后端在响应头中添加 access-control-allow-origin头信息\n\n③ 浏览器接收到响应\n\n④ 如果是同域下的请求，浏览器不会额外做什么，这次前后端通信就圆满完成了\n\n⑤ 如果是跨域请求，浏览器会从响应头中查找是否允许跨域访问\n\n⑥ 如果允许跨域，通信圆满完成\n\n⑦ 如果没找到或不包含想要跨域的域名，就丢弃响应结果\n\ncors兼容性：ie10及以上可以正常使用\n\n\n# jsonp\n\n 1. 原理\n    script 标签跨域不会被浏览器阻止\n    jsonp主要就是利用script标签，加载跨域文件\n 2. 使用jsonp实现跨域\n    服务器端准备好jsonp接口\n    手动加载jsonp标签或\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>document</title>\n\n</head>\n\n<body>\n    <script type=\'text/javascript\'>\n        const handleresponse = data => console.log(data)\n    <\/script>\n    <script src="https://www.imooc.com/api/http/jsonp?callback=handleresponse"><\/script>\n</body>\n\n</html>\n\n\n\n动态加载jsonp接口\n\n// 动态加载jsonp接口\n const script = document.createelement("script");\n      script.src =\n        "https://www.imooc.com/api/http/jsonp?callback=handleresponse";\n      document.body.appendchild(script);\n      const handleresponse = (data) => {\n        console.log(data);\n      };\n\n\n\n# xhr 对象\n\n\n# xhr 的属性\n\n 1. responsetype 和response属性\n\n * responsetext只能在没有设置responsetype或者responsetype=\'\'或responsetype=\'text\' 的时候才能使用\n * response可以替代responsetext，默认返回字符串，可以通过responsetype设置返回形式(如果设置为json，浏览器默认调用json.parse()解析成js中的对应值，但服务器还是返回的是json格式的字符串)\n\nxhr.responsetype = "json" \n\n\n 2. timeout属性:设置请求的超时时间（单位：ms）\n\n 3. withcredentitals 属性\n\n * 指定使用ajax发送请求时是否携带cookie\n * 使用ajax发送请求，默认情况下，同域时，会携带cookie,跨域时，不会\n * 最终是否能成功跨域携带cookie，还要看服务器同不同意\n\nxhr.withcredentials=true\n\n\n\n# xhr方法\n\n 1. abort():终止当前请求,一般配合abort事件一起使用\n 2. setrequestheader():可以设置请求头信息\n\nhttp content-type\n\n//  请求头中的`content-type`字段用来告诉服务器，浏览器发送的数据是什么格式的。 \nxhr.setrequestheader("content-type",\'application/x-www-form-urlencoded\') // 对应的数据格式：\'username=ased&password=asd\'\n \nxhr.setrequestheader("content-type",\'application/json\') // json格式的数据\n\n\n\n\n# xhr 的事件\n\n 1. load 事件:响应数据可用时触发 推荐使用onload代替onreadystatechange\n\n      const url ="https://www.imooc.com/api/http/search/suggest?words=js";\n      const xhr = new xmlhttprequest();\n      xhr.addeventlistener(\n        "load",\n        () => {\n          if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n            console.log(xhr.response);\n            console.log(typeof xhr.response);\n          }\n        },\n        false\n      );\n      xhr.responsetype = "json";\n      xhr.open("get", url, true);\n      xhr.send();\n\n\n 1. error 事件\n    请求发生错误时触发\n\n      const url = "https://www.imooc1.com/api/http/search/suggest?words=js";\n      const xhr = new xmlhttprequest();\n      xhr.addeventlistener(\n        "load",\n        () => {\n          if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n            console.log(xhr.response);\n            console.log(typeof xhr.response);\n          }\n        },\n        false\n      );\n      xhr.addeventlistener("error", () => {\n        console.log("访问出错拉！");\n      });\n      xhr.responsetype = "json";\n      xhr.open("get", url, true);\n      xhr.send();\n\n\n 3. abort 事件\n    调用abort()终止请求时触发\n\n     const url ="https://www.imooc.com/api/http/search/suggest?words=js";\n      const xhr = new xmlhttprequest();\n      xhr.addeventlistener(\n        "abort",\n        () => {\n          console.log("543629463");\n        },\n        false\n      );\n      xhr.addeventlistener("error", () => {\n        console.log("访问出错拉！");\n      });\n      xhr.responsetype = "json";\n      xhr.open("get", url, true);\n      xhr.send();\n      xhr.abort();\n\n\n 4. timeout事件\n\n        var xhr = new xmlhttprequest()\n        xhr.responsetype = \'json\'\n        xhr.onreadystatechange = () => {\n            if (xhr.readystate !== 4) return;\n            if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n                console.log(xhr.response );\n            }\n        }\n        xhr.open("get", "https://www.imooc.com/api/http/search/suggest?words=js")\n        xhr.timeout = 10 \n        xhr.ontimeout = function (e) {\n            console.log("timeout!!")\n        }\n        xhr.send()\n\n\n\n# formdata\n\n使用ajax提交表单(避免直接提交表单跳转)\n\nformdata可用于发送表单数据\n\n  <body>\n    <form id="login">\n      <input type="text" name="username" placeholder="用户名" />\n      <input type="password" name="password" placeholder="密码" />\n      <input type="submit" id="submit" value="提交" />\n    </form>\n    <script>\n      const login = document.getelementbyid("login");\n      const btn = document.getelementbyid("submit");\n      const url = "https://www.imooc.com/api/http/search/suggest?words=js";\n      btn.addeventlistener(\n        "click",\n        (e) => {\n          // 阻止表单跳转\n          e.preventdefault();\n          const xhr = new xmlhttprequest();\n          xhr.addeventlistener(\n            "load",\n            () => {\n              if (\n                (xhr.status >= 200 && xhr.status < 300) ||\n                xhr.status === 304\n              ) {\n                console.log(xhr.response);\n              }\n            },\n            false\n          );\n          xhr.open("post", url, true);\n          xhr.responsetype = "json";\n          const data = new formdata(login);\n          xhr.send(data);\n        },\n        false\n      );\n    <\/script>\n  </body>\n\n\nformdata的基本用法\n\n // 通过 html 表单元素创建 formdata 对象\n      const fd = new formdata(表单元素);\n      xhr.send(fd);\n\n      // 通过 自身的append() 方法添加数据\n      const fd = new formdata(表单元素);\n      fd.append(\'age\', 18);\n      fd.append(\'sex\', \'male\');\n      xhr.send(fd);\n\n\n\n# 封装ajax\n\n1、ajax的原理需要掌握一下。即ajax这门技术是使用xmlhttprequest这个对象实现的，该对象有一些方法和属性，比如open()、send()、responsetype......它们的含义是什么要知道。 2、ajax的具体实现不需要自己手动封装。 3、实际开发中会使用现成的插件，我们只需要按照插件的文档使用即可\n\n源代码：\n\nhand-tear-code\n\n\n# axios\n\n 1. 基于promise的http库\n\n 2. axios中文官方文档\n\n 3. axios中文说明\n\n\n# fetch\n\nfetch api 教程\n\n 1. 也是前后端通信的一种方式\n 2. 是ajax的一种替代方案，它是基于promise的\n 3. ajax的兼容性比 fetch 好\n 4. fetch没有abort timeout',charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"前后端数据交互与HTTP协议",frontmatter:{title:"前后端数据交互与HTTP协议",sidebarDepth:2,readingShow:"top"},regularPath:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE.html",relativePath:"基础知识/前端相关/前后端数据交互与HTTP协议.md",key:"v-7863fde9",path:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE.html",headers:[{level:2,title:"前后端数据交互",slug:"前后端数据交互",normalizedTitle:"前后端数据交互",charIndex:2},{level:3,title:"初始前后端通信",slug:"初始前后端通信",normalizedTitle:"初始前后端通信",charIndex:14},{level:3,title:"前后端通信的过程与概念解释",slug:"前后端通信的过程与概念解释",normalizedTitle:"前后端通信的过程与概念解释",charIndex:120},{level:3,title:"前后端的通信方式",slug:"前后端的通信方式",normalizedTitle:"前后端的通信方式",charIndex:228},{level:2,title:"服务端职责",slug:"服务端职责",normalizedTitle:"服务端职责",charIndex:430},{level:2,title:"服务端处理数据:路由",slug:"服务端处理数据-路由",normalizedTitle:"服务端处理数据:路由",charIndex:501},{level:2,title:"HTTP 协议",slug:"http-协议",normalizedTitle:"http 协议",charIndex:735},{level:3,title:"初识 HTTP",slug:"初识-http",normalizedTitle:"初识 http",charIndex:747},{level:3,title:"http 报文",slug:"http-报文",normalizedTitle:"http 报文",charIndex:1469},{level:3,title:"HTTP 方法",slug:"http-方法",normalizedTitle:"http 方法",charIndex:1724},{level:3,title:"GET 和 POST 方法的对比",slug:"get-和-post-方法的对比",normalizedTitle:"get 和 post 方法的对比",charIndex:2343},{level:3,title:"HTTP 状态码",slug:"http-状态码",normalizedTitle:"http 状态码",charIndex:2587}],headersStr:"前后端数据交互 初始前后端通信 前后端通信的过程与概念解释 前后端的通信方式 服务端职责 服务端处理数据:路由 HTTP 协议 初识 HTTP http 报文 HTTP 方法 GET 和 POST 方法的对比 HTTP 状态码",content:"# 前后端数据交互\n\n\n# 初始前后端通信\n\n前后端通信方式什么？\n\n前端和后端数据交互的过程<=>浏览器和服务器交互的过程\n\n前端向后端发送数据：\n\n1.登录功能\n\n2.搜索功能\n\n后端向前端发送数据：\n\n页面上的图、文字等内容\n\n\n# 前后端通信的过程与概念解释\n\n 1. 前后端通信的过程\n    前后端通信是在 请求-响应 中完成的\n\n 2. 概念解释\n\n * 前端：浏览器端\n * 客户端：只要能和通信的就叫客户端\n * 后端：服务器端\n\n\n# 前后端的通信方式\n\n 1. 使用浏览器访问网页\n\n在浏览器地址栏输入网址，按下回车\n\n 2. Html 的标签\n\n浏览器在解析 Html 标签的时候，遇到一些特殊的标签( link img script iframe )，会再次向服务器发送请求\n\n还有一些标签(a,from(表单))，浏览器解析的时候，不会向服务器发送请求，但是用户可以使用他们向服务器发送请求\n\n 3. Ajax Fetch\n\n\n# 服务端职责\n\n * 处理 HTTP 请求(req,res)\n * 定义路由,供前端 Ajax 访问\n * 使用数据库，存储和查询数据\n\n\n# 服务端处理数据:路由\n\n路由和 URL 的关系\n\nGET /api/list 路由 ---\x3e axios.get('api/list?a=1')\n\n路由是规则，url 是具体的形式两者不同\n\n路由是服务端的入口规则，也是与前端的“约定”\n\n路由主要包含：\n\n * 定义 method，如 GET,POST 等\n * 定义 url 规则，如/api/list 和/api/create\n * 定义输入Request body和输出Response body格式\n\n\n# HTTP 协议\n\n\n# 初识 HTTP\n\nhttp协议规定了客户端和服务端如何通讯\n\n * url：后端接口的地址，即前端 Ajax 请求时的地址\n * method：请求方法，如 GET POST PUT DELETE 等\n * 状态码：接口返回的状态，如 200 302 404 500 等\n * Request：请求\n * Request Body：请求时发送给后端的数据\n * Request Content-type：发送数据的格式，如 json\n * Response：响应\n * Response Body：后端返回给前端的数据\n * Response Content-type：返回数据的格式，如 json\n\n 1. HTTP (hypeText Transfer Protocol:超文本传输协议)\n\nHTML:超文本标记语言，超文本：原先一个个单一的文本，通过超链接将其联系起来。由原先的单一的文本变成了可无限伸、扩展的超級文本、立体文本\n\nHTML、JS、CSS、图片、字体、音频、视频等等文件，都是通过HTTP在服务器和浏览器之间传输\n\n每一次前后端通信，前端需要主动向后端发岀请求，后端接收到前端的请求后，可以给出响应\n\nHTTP是一个请求-响应协议\n\n 2. HTTP 请求响应的过程\n\n\n\n * 浏览器地址栏输入 URL 并回车\n * 浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期\n * DNS 解析 URL 对应的 IP\n * 根据 IP 建立 TCP 连接（三次握手）\n * 发送 http 请求\n * 服务器处理请求，浏览器接受 HTTP 响应\n * 浏览器解析并渲染页面\n * 关闭 TCP 连接（四次挥手）\n\n\n# http 报文\n\n 1. HTTP 报文是什么\n\n * 浏览器向服务器发送请求的时候，请求本身就是信息，叫请求报文\n * 服务器向浏览器发送响应时传输的信息，叫响应报文\n\n 2. HTTP 报文格式 // TODO：复查 2022.3.22\n\n * 请求\n\n 1. 请求头：起始行(黄色高亮部分)+首部（剩余部分为首部）\n\n\n\n 2. 请求体\n\nGET 请求没有请求体，数据是通过请求头携带\n\nPOST 请求，有请求体，数据通过请求体携带\n\n * 响应\n\n 1. 响应头：起始行+首部\n 2. 响应体\n\n\n# HTTP 方法\n\n 1. 常用的 HTTP 方法\n\n浏览器发送请求时采用的方法。和响应无关\n\nGET POST PUT DELETE\n\n用来定义对于资源采取什么样的操作的，有各自的语义\n\n 2. HTTP 方法的语义\n\n * GET 获取数据 -POST 创建数据\n * PUT 更新数据(修改个人信息 修改密码) -DELETE 删除数据\n\n这些方法虽然有各自的语义，但是并不是强制性的\n\n3.RESTful 接口设计\n\n一种接口设计风格， 充分利用 HTTP 方法的语义\n\n * 普通方法：\n\n① 通过用户 ID 获取用户个人信息，使用 GET 方法https://www.xxx.com/api/http/getUser?id=1\n\n② 注册新用户，使用 POST 方法https://www.xxx.com/api/http/addUser\n\n③ 修改一个用户，使用 POST 方法https://www.xxx.com/api/http/modifuUser\n\n③ 删除一个用户，使用 POST 方法 https://www.xxx.com/api/http/deleteUser\n\n * RESTful 接口风格\n\n只需要定义一个接口：https://www.xxx.com/api/http/User\n\n分别通过四种语义的方法：GET(获取信息)、POST(注册用户)、PUT(修改信息)、DELETE(删除信息)\n\n\n# GET 和 POST 方法的对比\n\n 1. 语义：GET：获取数据,POST:创建数据\n\n 2. 发送数据\n\nGET 通过地址在请求头中携带数据,能携带的数据和地址的长度有关，一般最多就几 K\n\nPOST 既可以通过地址在请求头中携带数据，也可以通过请求体携带数据,能携带的数据理论上是无限量的\n\n携带少量数据，可以使用 GET 请求。大量的数据可以使用 POST 请求\n\n 3. 缓存：Get 可以被缓存，post 不会被缓存\n\n 4. 安全性：GET 和 POST 都不安全\n\n\n# HTTP 状态码\n\nHTTP 状态码\n\n定义服务器对请求的处理结果，是服务器返回的\n\n100-199=>消息:代表请求已经被接受，需要继续处理\n\n200-299=>成功:200\n\n300-399=>重定向:301永久重定向，除非用户手动清除缓存;302临时重定向,不会缓存;304没有修改,所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。\n\n400-499=>请求错误:404Not Found(没有找到)\n\n500-599=>服务器错误:500服务器内部错误，无法完成请求",normalizedContent:"# 前后端数据交互\n\n\n# 初始前后端通信\n\n前后端通信方式什么？\n\n前端和后端数据交互的过程<=>浏览器和服务器交互的过程\n\n前端向后端发送数据：\n\n1.登录功能\n\n2.搜索功能\n\n后端向前端发送数据：\n\n页面上的图、文字等内容\n\n\n# 前后端通信的过程与概念解释\n\n 1. 前后端通信的过程\n    前后端通信是在 请求-响应 中完成的\n\n 2. 概念解释\n\n * 前端：浏览器端\n * 客户端：只要能和通信的就叫客户端\n * 后端：服务器端\n\n\n# 前后端的通信方式\n\n 1. 使用浏览器访问网页\n\n在浏览器地址栏输入网址，按下回车\n\n 2. html 的标签\n\n浏览器在解析 html 标签的时候，遇到一些特殊的标签( link img script iframe )，会再次向服务器发送请求\n\n还有一些标签(a,from(表单))，浏览器解析的时候，不会向服务器发送请求，但是用户可以使用他们向服务器发送请求\n\n 3. ajax fetch\n\n\n# 服务端职责\n\n * 处理 http 请求(req,res)\n * 定义路由,供前端 ajax 访问\n * 使用数据库，存储和查询数据\n\n\n# 服务端处理数据:路由\n\n路由和 url 的关系\n\nget /api/list 路由 ---\x3e axios.get('api/list?a=1')\n\n路由是规则，url 是具体的形式两者不同\n\n路由是服务端的入口规则，也是与前端的“约定”\n\n路由主要包含：\n\n * 定义 method，如 get,post 等\n * 定义 url 规则，如/api/list 和/api/create\n * 定义输入request body和输出response body格式\n\n\n# http 协议\n\n\n# 初识 http\n\nhttp协议规定了客户端和服务端如何通讯\n\n * url：后端接口的地址，即前端 ajax 请求时的地址\n * method：请求方法，如 get post put delete 等\n * 状态码：接口返回的状态，如 200 302 404 500 等\n * request：请求\n * request body：请求时发送给后端的数据\n * request content-type：发送数据的格式，如 json\n * response：响应\n * response body：后端返回给前端的数据\n * response content-type：返回数据的格式，如 json\n\n 1. http (hypetext transfer protocol:超文本传输协议)\n\nhtml:超文本标记语言，超文本：原先一个个单一的文本，通过超链接将其联系起来。由原先的单一的文本变成了可无限伸、扩展的超級文本、立体文本\n\nhtml、js、css、图片、字体、音频、视频等等文件，都是通过http在服务器和浏览器之间传输\n\n每一次前后端通信，前端需要主动向后端发岀请求，后端接收到前端的请求后，可以给出响应\n\nhttp是一个请求-响应协议\n\n 2. http 请求响应的过程\n\n\n\n * 浏览器地址栏输入 url 并回车\n * 浏览器查找当前 url 是否存在缓存，并比较缓存是否过期\n * dns 解析 url 对应的 ip\n * 根据 ip 建立 tcp 连接（三次握手）\n * 发送 http 请求\n * 服务器处理请求，浏览器接受 http 响应\n * 浏览器解析并渲染页面\n * 关闭 tcp 连接（四次挥手）\n\n\n# http 报文\n\n 1. http 报文是什么\n\n * 浏览器向服务器发送请求的时候，请求本身就是信息，叫请求报文\n * 服务器向浏览器发送响应时传输的信息，叫响应报文\n\n 2. http 报文格式 // todo：复查 2022.3.22\n\n * 请求\n\n 1. 请求头：起始行(黄色高亮部分)+首部（剩余部分为首部）\n\n\n\n 2. 请求体\n\nget 请求没有请求体，数据是通过请求头携带\n\npost 请求，有请求体，数据通过请求体携带\n\n * 响应\n\n 1. 响应头：起始行+首部\n 2. 响应体\n\n\n# http 方法\n\n 1. 常用的 http 方法\n\n浏览器发送请求时采用的方法。和响应无关\n\nget post put delete\n\n用来定义对于资源采取什么样的操作的，有各自的语义\n\n 2. http 方法的语义\n\n * get 获取数据 -post 创建数据\n * put 更新数据(修改个人信息 修改密码) -delete 删除数据\n\n这些方法虽然有各自的语义，但是并不是强制性的\n\n3.restful 接口设计\n\n一种接口设计风格， 充分利用 http 方法的语义\n\n * 普通方法：\n\n① 通过用户 id 获取用户个人信息，使用 get 方法https://www.xxx.com/api/http/getuser?id=1\n\n② 注册新用户，使用 post 方法https://www.xxx.com/api/http/adduser\n\n③ 修改一个用户，使用 post 方法https://www.xxx.com/api/http/modifuuser\n\n③ 删除一个用户，使用 post 方法 https://www.xxx.com/api/http/deleteuser\n\n * restful 接口风格\n\n只需要定义一个接口：https://www.xxx.com/api/http/user\n\n分别通过四种语义的方法：get(获取信息)、post(注册用户)、put(修改信息)、delete(删除信息)\n\n\n# get 和 post 方法的对比\n\n 1. 语义：get：获取数据,post:创建数据\n\n 2. 发送数据\n\nget 通过地址在请求头中携带数据,能携带的数据和地址的长度有关，一般最多就几 k\n\npost 既可以通过地址在请求头中携带数据，也可以通过请求体携带数据,能携带的数据理论上是无限量的\n\n携带少量数据，可以使用 get 请求。大量的数据可以使用 post 请求\n\n 3. 缓存：get 可以被缓存，post 不会被缓存\n\n 4. 安全性：get 和 post 都不安全\n\n\n# http 状态码\n\nhttp 状态码\n\n定义服务器对请求的处理结果，是服务器返回的\n\n100-199=>消息:代表请求已经被接受，需要继续处理\n\n200-299=>成功:200\n\n300-399=>重定向:301永久重定向，除非用户手动清除缓存;302临时重定向,不会缓存;304没有修改,所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。\n\n400-499=>请求错误:404not found(没有找到)\n\n500-599=>服务器错误:500服务器内部错误，无法完成请求",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"本地存储",frontmatter:{title:"本地存储",readingShow:"top"},regularPath:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.html",relativePath:"基础知识/前端相关/本地存储.md",key:"v-6fb355dc",path:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.html",headers:[{level:2,title:"Cookie",slug:"cookie",normalizedTitle:"cookie",charIndex:2},{level:3,title:"初识cookie",slug:"初识cookie",normalizedTitle:"初识cookie",charIndex:13},{level:3,title:"cookie的基本方法",slug:"cookie的基本方法",normalizedTitle:"cookie的基本方法",charIndex:154},{level:3,title:"cookie的属性",slug:"cookie的属性",normalizedTitle:"cookie的属性",charIndex:356},{level:3,title:"Cookie 的封装",slug:"cookie-的封装",normalizedTitle:"cookie 的封装",charIndex:1514},{level:3,title:"cookie的注意事项",slug:"cookie的注意事项",normalizedTitle:"cookie的注意事项",charIndex:2571},{level:2,title:"localStorage",slug:"localstorage",normalizedTitle:"localstorage",charIndex:2707},{level:3,title:"认识 localStorage",slug:"认识-localstorage",normalizedTitle:"认识 localstorage",charIndex:2724},{level:3,title:"localStorage的注意事项",slug:"localstorage的注意事项",normalizedTitle:"localstorage的注意事项",charIndex:3044},{level:2,title:"cookie,localStorage,SessionStorage三者对比",slug:"cookie-localstorage-sessionstorage三者对比",normalizedTitle:"cookie,localstorage,sessionstorage三者对比",charIndex:3334}],headersStr:"Cookie 初识cookie cookie的基本方法 cookie的属性 Cookie 的封装 cookie的注意事项 localStorage 认识 localStorage localStorage的注意事项 cookie,localStorage,SessionStorage三者对比",content:"# Cookie\n\n\n# 初识cookie\n\n * 浏览器存储数据的一种方式\n * 因为存储在用户本地，而不是存储在服务器上，是本地存储\n * 一般会自动随着浏览器每次请求发送到服务器端\n\n作用：利用cookie跟踪统计用户访问该网站的习惯，比如什么时间访问，访问了哪些页面，在每个网页的停留时间等\n\n\n# cookie的基本方法\n\n 1. 写入cookie: 不能一起设置，只能一个一个设置\n\ndocument.cookie='username=zs'\ndocument.cookie='age=18'\n\n\n 2. 读取cookie:读取的是一个由名值对构成的字符串，每个名值对之间由“;\"”（一个分号和一个空格）隔开\n\ndocument.cookie  //username=zs; age=18\n\n\n\n# cookie的属性\n\n 1. cookie的名称Name和值Value\n\n * 最重要的两个属性，创建cookie时必须填写，其他属性可以使用默认值\n * cookie的名称或值如果包含非英文字母，则写入时需要使用 encodeURIComponent()编码，读取时使用decodeURIComponent()解码\n\ndocument.cookie=`${encodeURIComponent('用户名')}=${encodeURIComponent('张三')}`\nconsole.log(decodeURIComponent(document.cookie))\n\n\n * 一般名称名称使用英文，不要用中文，值可以使用中文，但是要编码\n\n 2. 失效（到期）时间\n\n * 对于失效的cookie，会被浏览器清除\n\n * 如果没有设置失效（到期）时间，这样的 Cookie称为会话 Cookie ，它存在内存中，当会话结束，也就是浏览器关闭时， Cookie消失\n\n * 想长时间存在，需要设置expires或 max-age\n\n 1. expires值为Date类型\n 2. max-age值为数字，表示当前时间+多少秒后过期，单位是秒；如果max-age的值为0或负数，则cookie会被删除\n\ndocument.cookie=`username=zs; expires=${new Date('2100-1-01 00:00:00')}`\ndocument.cookie=`username=zs; max-age=${24*3600*30}` // 存活30天\n\n\n * Domain 域\n\nDomain限定了访问cookie的范围（不同域名），使用JS只能读写当前域或父域的cookie，无法读写其他域的 cookie\n\ndocument.cookie='username=alex;domain=www.immoc.com'\n// 当前域： www.immoc.com  www.m.imooc.com\n// 父域： .imooc.com\n\n\n * path 路径\n\npath限定了访问cookie的范围（同一域名），使用JS只能读写当前路径和上級路径的 Cookie，无法读写下级路径的 Cookie\n\n当Name、 Domain、Path这3个字段都相同的时候，才是同一个 cookie\n\n * HttpOnly\n\n设置了 Httponly 属性的Cookie不能通过JS访问\n\n * Secure 安全标志\n\n限定了只有在使用了https而不是http的情况下才可以发送给服务端\n\nDomain、path、 Secure都要满足条件，还不能过期的 Cookie才能随着请求发送到服务器端\n\n\n# Cookie 的封装\n\n`js-cookie`:一个用于处理`cookie`的简单、轻量级`JavaScript API`\n\nJavaScript Cookie官方文档\n\njs-cookie总结，vue构建的项目中使用js-cookie插件\n\n前端鉴权的兄弟们：cookie、session、token、jwt、单点登录\n\n// 写入cookie\nconst set = (name, value, { maxAge, domain, path, secure } = {}) => {\n  let cookieText = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;\n  if (typeof maxAge === \"number\") {\n    cookieText += `; max-age=${maxAge}`;\n  }\n  if (domain) {\n    cookieText += `; domain=${domain}`;\n  }\n  if (path) {\n    cookieText += `; path=${path}`;\n  }\n  if (secure) {\n    cookieText += `; secure`;\n  }\n  document.cookie = cookieText;\n};\n// 通过name获取cookie的值\nconst get = (name) => {\n  name = `${encodeURIComponent(name)}`;\n  const cookies = document.cookie.split(\"; \");\n  for (const item of cookies) {\n    const [cookieName, cookieValue] = item.split(\"=\");\n\n    if (cookieName === name) {\n      return decodeURIComponent(cookieValue);\n    }\n    return undefined;\n  }\n};\nconst remove = (name,{domain,path}) => {\n  set(name, \"\", { domain,path,maxAge: -1 });\n};\nexport { set, get, remove };\n\n\n\n# cookie的注意事项\n\n 1. 前后端都可以创建cookie\n\n 2. cookie有数量限制:当超过单个域名限制之后，在设置cookie,浏览器就会清除以前设置的cookie\n\n3.cookie 有大小限制:每个cookie的存储容量很小，最多只有4kB左右\n\n\n# localStorage\n\n\n# 认识 localStorage\n\n * localStorage也是一种浏览器存储数据的方式（本地存储），它只是存储在本地，不会发送到服务器端\n\n * 单个域名下的localStorage总大小有限制\n\n * 基本用法：\n\nlocalStorage.setItem('username','alex')\nconsole.log(localStorage.length)\nlocalStorage.getItem('username') //获取不存在的返回null\nlocalStorage.removeItem('useraname') //删除不存在的key,不报错\nlocalStorage.clear() // 全部清除\n\n\n\n# localStorage的注意事项\n\n 1. 存储期限\n    持久化的本地存储，除非手动清除，比如通过js删除，或者清除浏览器缓存，否则数据是永远不会过期的。\n\nsessionStorage\n\n当会话结束的时候，sessionStorage的数据会被清空,用法和localStorage一样\n\n 2. localStorage键和值的类型\n\n存储的键和值只能是字符串类型,不是字符串类型，也会先转化为字符串类型再存进去\n\n 3. 不同域名下不能共用localStorage\n\n 4. 兼容性:ie7以下不支持\n\n查看网络技术的浏览器支持\n\nCan I use____?\n\n\n# cookie,localStorage,SessionStorage三者对比\n\n1、cookie会在服务器和浏览器之间传递。localStorage和sessionStorage不会发给服务器，仅在本地保存。\n\n2、cookie存储数据小，不超过4k。localStorage和sessionStorage存储大小也有限制，但是比cookie大，一般在5MB左右。\n\n3、cookie可以通过自带的属性设置有效期；当不设置有效期时，浏览器关闭，cookie就会消失；当设置了有效期后，在有效期内，关闭窗口或者浏览器，它依然存在。到了有效期后，cookie会自动消失。localStorage没有自带的属性设置有限期，关闭窗口或者浏览器后它也是存在的。如果想删除localStorage，则需要手动删除。sessionStorage在关闭窗口或者浏览器时会被删除。\n\n4、cookie和localStorage在同源窗口中是共享的，sessionStorage在不同的窗口中不能共享。",normalizedContent:"# cookie\n\n\n# 初识cookie\n\n * 浏览器存储数据的一种方式\n * 因为存储在用户本地，而不是存储在服务器上，是本地存储\n * 一般会自动随着浏览器每次请求发送到服务器端\n\n作用：利用cookie跟踪统计用户访问该网站的习惯，比如什么时间访问，访问了哪些页面，在每个网页的停留时间等\n\n\n# cookie的基本方法\n\n 1. 写入cookie: 不能一起设置，只能一个一个设置\n\ndocument.cookie='username=zs'\ndocument.cookie='age=18'\n\n\n 2. 读取cookie:读取的是一个由名值对构成的字符串，每个名值对之间由“;\"”（一个分号和一个空格）隔开\n\ndocument.cookie  //username=zs; age=18\n\n\n\n# cookie的属性\n\n 1. cookie的名称name和值value\n\n * 最重要的两个属性，创建cookie时必须填写，其他属性可以使用默认值\n * cookie的名称或值如果包含非英文字母，则写入时需要使用 encodeuricomponent()编码，读取时使用decodeuricomponent()解码\n\ndocument.cookie=`${encodeuricomponent('用户名')}=${encodeuricomponent('张三')}`\nconsole.log(decodeuricomponent(document.cookie))\n\n\n * 一般名称名称使用英文，不要用中文，值可以使用中文，但是要编码\n\n 2. 失效（到期）时间\n\n * 对于失效的cookie，会被浏览器清除\n\n * 如果没有设置失效（到期）时间，这样的 cookie称为会话 cookie ，它存在内存中，当会话结束，也就是浏览器关闭时， cookie消失\n\n * 想长时间存在，需要设置expires或 max-age\n\n 1. expires值为date类型\n 2. max-age值为数字，表示当前时间+多少秒后过期，单位是秒；如果max-age的值为0或负数，则cookie会被删除\n\ndocument.cookie=`username=zs; expires=${new date('2100-1-01 00:00:00')}`\ndocument.cookie=`username=zs; max-age=${24*3600*30}` // 存活30天\n\n\n * domain 域\n\ndomain限定了访问cookie的范围（不同域名），使用js只能读写当前域或父域的cookie，无法读写其他域的 cookie\n\ndocument.cookie='username=alex;domain=www.immoc.com'\n// 当前域： www.immoc.com  www.m.imooc.com\n// 父域： .imooc.com\n\n\n * path 路径\n\npath限定了访问cookie的范围（同一域名），使用js只能读写当前路径和上級路径的 cookie，无法读写下级路径的 cookie\n\n当name、 domain、path这3个字段都相同的时候，才是同一个 cookie\n\n * httponly\n\n设置了 httponly 属性的cookie不能通过js访问\n\n * secure 安全标志\n\n限定了只有在使用了https而不是http的情况下才可以发送给服务端\n\ndomain、path、 secure都要满足条件，还不能过期的 cookie才能随着请求发送到服务器端\n\n\n# cookie 的封装\n\n`js-cookie`:一个用于处理`cookie`的简单、轻量级`javascript api`\n\njavascript cookie官方文档\n\njs-cookie总结，vue构建的项目中使用js-cookie插件\n\n前端鉴权的兄弟们：cookie、session、token、jwt、单点登录\n\n// 写入cookie\nconst set = (name, value, { maxage, domain, path, secure } = {}) => {\n  let cookietext = `${encodeuricomponent(name)}=${encodeuricomponent(value)}`;\n  if (typeof maxage === \"number\") {\n    cookietext += `; max-age=${maxage}`;\n  }\n  if (domain) {\n    cookietext += `; domain=${domain}`;\n  }\n  if (path) {\n    cookietext += `; path=${path}`;\n  }\n  if (secure) {\n    cookietext += `; secure`;\n  }\n  document.cookie = cookietext;\n};\n// 通过name获取cookie的值\nconst get = (name) => {\n  name = `${encodeuricomponent(name)}`;\n  const cookies = document.cookie.split(\"; \");\n  for (const item of cookies) {\n    const [cookiename, cookievalue] = item.split(\"=\");\n\n    if (cookiename === name) {\n      return decodeuricomponent(cookievalue);\n    }\n    return undefined;\n  }\n};\nconst remove = (name,{domain,path}) => {\n  set(name, \"\", { domain,path,maxage: -1 });\n};\nexport { set, get, remove };\n\n\n\n# cookie的注意事项\n\n 1. 前后端都可以创建cookie\n\n 2. cookie有数量限制:当超过单个域名限制之后，在设置cookie,浏览器就会清除以前设置的cookie\n\n3.cookie 有大小限制:每个cookie的存储容量很小，最多只有4kb左右\n\n\n# localstorage\n\n\n# 认识 localstorage\n\n * localstorage也是一种浏览器存储数据的方式（本地存储），它只是存储在本地，不会发送到服务器端\n\n * 单个域名下的localstorage总大小有限制\n\n * 基本用法：\n\nlocalstorage.setitem('username','alex')\nconsole.log(localstorage.length)\nlocalstorage.getitem('username') //获取不存在的返回null\nlocalstorage.removeitem('useraname') //删除不存在的key,不报错\nlocalstorage.clear() // 全部清除\n\n\n\n# localstorage的注意事项\n\n 1. 存储期限\n    持久化的本地存储，除非手动清除，比如通过js删除，或者清除浏览器缓存，否则数据是永远不会过期的。\n\nsessionstorage\n\n当会话结束的时候，sessionstorage的数据会被清空,用法和localstorage一样\n\n 2. localstorage键和值的类型\n\n存储的键和值只能是字符串类型,不是字符串类型，也会先转化为字符串类型再存进去\n\n 3. 不同域名下不能共用localstorage\n\n 4. 兼容性:ie7以下不支持\n\n查看网络技术的浏览器支持\n\ncan i use____?\n\n\n# cookie,localstorage,sessionstorage三者对比\n\n1、cookie会在服务器和浏览器之间传递。localstorage和sessionstorage不会发给服务器，仅在本地保存。\n\n2、cookie存储数据小，不超过4k。localstorage和sessionstorage存储大小也有限制，但是比cookie大，一般在5mb左右。\n\n3、cookie可以通过自带的属性设置有效期；当不设置有效期时，浏览器关闭，cookie就会消失；当设置了有效期后，在有效期内，关闭窗口或者浏览器，它依然存在。到了有效期后，cookie会自动消失。localstorage没有自带的属性设置有限期，关闭窗口或者浏览器后它也是存在的。如果想删除localstorage，则需要手动删除。sessionstorage在关闭窗口或者浏览器时会被删除。\n\n4、cookie和localstorage在同源窗口中是共享的，sessionstorage在不同的窗口中不能共享。",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"01-chrome架构：仅仅打开了一个页面，为什么会有4个进程？",frontmatter:{title:"01-chrome架构：仅仅打开了一个页面，为什么会有4个进程？",readingShow:"top"},regularPath:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/01.html",relativePath:"基础知识/前端相关/浏览器工作原理与实践/01.md",key:"v-185bbf26",path:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/01.html",headers:[{level:2,title:"进程和线程",slug:"进程和线程",normalizedTitle:"进程和线程",charIndex:780},{level:3,title:"什么是并行处理",slug:"什么是并行处理",normalizedTitle:"什么是并行处理",charIndex:867},{level:3,title:"线程 VS 进程",slug:"线程-vs-进程",normalizedTitle:"线程 vs 进程",charIndex:1264},{level:2,title:"单进程浏览器时代",slug:"单进程浏览器时代",normalizedTitle:"单进程浏览器时代",charIndex:2185},{level:3,title:"问题 1:不稳定",slug:"问题-1-不稳定",normalizedTitle:"问题 1:不稳定",charIndex:2415},{level:3,title:"问题 2:不流畅",slug:"问题-2-不流畅",normalizedTitle:"问题 2:不流畅",charIndex:2607},{level:3,title:"问题 3:不安全",slug:"问题-3-不安全",normalizedTitle:"问题 3:不安全",charIndex:3135},{level:2,title:"多进程浏览器时代",slug:"多进程浏览器时代",normalizedTitle:"多进程浏览器时代",charIndex:3514},{level:3,title:"早期多进程架构",slug:"早期多进程架构",normalizedTitle:"早期多进程架构",charIndex:3574},{level:3,title:"目前多进程架构",slug:"目前多进程架构",normalizedTitle:"目前多进程架构",charIndex:4332},{level:3,title:"未来⾯向服务的架构",slug:"未来面向服务的架构",normalizedTitle:"未来⾯向服务的架构",charIndex:5403},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1495}],headersStr:"进程和线程 什么是并行处理 线程 VS 进程 单进程浏览器时代 问题 1:不稳定 问题 2:不流畅 问题 3:不安全 多进程浏览器时代 早期多进程架构 目前多进程架构 未来⾯向服务的架构 总结",content:"# 01-chrome 架构：仅仅打开了一个页面，为什么会有 4 个进程？\n\n无论你是想要设计高性能 Web 应用，还是要优化现有的 Web 应用，你都需要了解浏览器中的网络流程、⻚面渲染过程，JavaScript 执行流程，以及 Web 安全理论，而这些功能是分散在浏览器的各个功能组件中的，比较多、比较散，要怎样学习才能掌握呢?通过浏览器的多进程架构的学习，你就可以把这些分散的知识点串 起来，组成一张网，从而让自己能站在更高的维度去理解 Web 应用。\n\n因此，学习浏览器的多进程架构是很有必要的。需要说明的是，在本专栏中，我所有的分析都是基于 Chrome 浏览器的。那么多浏览器，为什么偏偏选择 Chrome 浏览器呢?因为 Chrome、微软的 Edge 以及国内的大部分主流浏览器，都是基于 Chromium 二次开发而来;而 Chrome 是 Google 的官方发行版，特性和 Chromium 基本一样，只存在一些产品层面差异;再加上 Chrome 是目前世界上使用率最高的浏览器，所以 Chrome 最具代表性\n\n在开始之前，我们一起看下，Chrome 打开一个⻚面需要启动多少进程?你可以点击 Chrome 浏览器右上⻆ 的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开 Chrome 的任务管理器的窗 口，如下图:\n\n\n\n和 Windows 任务管理器一样，Chrome 任务管理器也是用来展示运行中 Chrome 使用的进程信息的。从图中 可以看到，Chrome 启动了 4 个进程，你也许会好奇，只是打开了 1 个⻚面，为什么要启动这么多进程呢?\n\n批注:目前，任务管理器需要通过 窗口选项卡 打开 而且现在不止 4 个进程！原因暂时不详\n\n在解答这个问题之前，我们需要了解一下进程的概念，不过由于好多人容易把进程和线程的概念混淆，从而影响后续其他概念的理解，所以这里我就将这两个概念以及它们之间的关系一并为你讲解下。\n\n\n# 进程和线程\n\n不过，在介绍进程和线程之前，我需要先讲解下什么是并行处理，因为如果你理解了并行处理的概念，那么 再理解进程和线程之间的关系就会变得轻松许多。\n\n\n# 什么是并行处理\n\n计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。\n\nA=1+2\nB=20/5\nC=7*8\n\n\n在编写代码的时候，我们可以把这个过程拆分为四个任务:\n\n * 任务 1 是计算 A=1+2;\n * 任务 2 是计算 B=20/5;\n * 任务 3 是计算 C=7*8;\n * 任务 4 是显示最后计算的结果\n\n正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。\n\n如果采用多线程，会怎么样呢?我们只需分“两步走”:第一步，使用三个线程同时执行前三个任务;第二步，再执行第四个显示任务。\n\n通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能。\n\n\n# 线程 VS 进程\n\n多线程可以并行处理任务，但是**线程是不能单独存在的，它是由进程来启动和管理的。**那什么又是进程呢?\n\n**一个进程就是一个程序的运行实例。**详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。\n\n为了让你更好地理解上述计算过程，我画了下面这张对比图:\n\n\n\n从图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。\n\n总结来说，进程和线程之间的关系有以下 4 个特点:\n\n1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃\n\n我们可以模拟以下场景:\n\nA=1+2\nB=20/0\nC=7*8\n\n\n我把上述三个表达式稍作修改，在计算 B 的值的时候，我把表达式的分母改成 0，当线程执行到 B = 20/0 时， 由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了。\n\n2. 线程之间共享进程中的数据\n\n如下图所示，线程之间可以对进程的公共数据进行读写操作。\n\n\n\n从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。\n\n3. 当一个进程关闭之后，操作系统会回收进程所占用的内存\n\n当一个进程退出时，操作系统会回收该进程所申请的所有资源;即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。\n\n比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉。\n\n4. 进程之间的内容相互隔离\n\n进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进 程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信 (IPC)的机制了。\n\n\n# 单进程浏览器时代\n\n在了解了进程和线程之后，我们再来一起看下单进程浏览器的架构。顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和⻚面等。其实早在 2007 年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示:\n\n\n\n如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。下面 我就来一一分析下出现这些问题的原因。\n\n\n# 问题 1:不稳定\n\n早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。\n\n除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。\n\n\n# 问题 2:不流畅\n\n从上面的“单进程浏览器架构示意图”可以看出，所有⻚面的渲染模块、JavaScript 执行环境以及插件都是 运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。\n\n比如，下面这个无限循环的脚本：\n\nfunction freeze() {\n    while (1) {\n        console.log('freeze')\n    }\n}\nfreeze()\n\n\n如果让这个脚本运行在一个单进程浏览器的⻚面里，你感觉会发生什么?\n\n因为这个脚本是无限循环的，所以当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就 没有机会被执行。因为浏览器中所有的⻚面都运行在该线程中，所以这些⻚面都没有机会去执行任务，这样 就会导致整个浏览器失去响应，变卡顿。这块内容要继续往深的地方讲就到⻚面的事件循环系统了，具体相关内容我会在后面的模块中为你深入讲解。\n\n除了上述脚本或者插件会让单进程浏览器变卡顿外，⻚面的内存泄漏也是单进程变慢的一个重要原因。通常 浏览器的内核都是非常复杂的，运行一个复杂点的⻚面再关闭⻚面，会存在内存不能完全回收的情况，这样 导致的问题是使用时间越⻓，内存占用越高，浏览器会变得越慢。\n\n\n# 问题 3:不安全\n\n这里依然可以从插件和⻚面脚本两个方面来解释该原因。\n\n插件可以使用 C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在⻚面运行一个插件时也 就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码， 引发安全性问题。\n\n至于⻚面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做 一些恶意的事情，同样也会引发安全问题\n\n以上这些就是当时浏览器的特点，不稳定，不流畅，而且不安全。这是一段不堪回首的过去，也许你没有经 历过，不过你可以想象一下这样的场景:当你正在用浏览器打开多个⻚面时，突然某个⻚面崩溃了或者失去 响应，随之而来的是整个浏览器的崩溃或者无响应，然后你发现你给老板写的邮件⻚面也随之消失了，这时 你的心情会不会和⻚面一样崩溃呢?\n\n\n# 多进程浏览器时代\n\n好在现代浏览器已经解决了这些问题，是如何解决的呢?这就得聊聊我们这个“多进程浏览器时代”了\n\n\n# 早期多进程架构\n\n你可以先看看下面这张图，这是 2008 年 Chrome 发布时的进程架构。\n\n\n\n从图中可以看出，Chrome 的⻚面是运行在单独的渲染进程中的，同时⻚面里的插件也是运行在单独的插件 进程之中，而进程之间是通过 IPC 机制进行通信(如图中虚线部分)\n\n我们先看看如何解决不稳定的问题。由于进程是相互隔离的，所以当一个⻚面或者插件崩溃时，影响到的仅 仅是当前的⻚面进程或者插件进程，并不会影响到浏览器和其他⻚面，这就完美地解决了⻚面或者插件的崩 溃会导致整个浏览器崩溃，也就是不稳定的问题。\n\n接下来再来看看不流畅的问题是如何解决的。同样，JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染⻚面，而并不会影响浏览器和其他⻚面，因为其他 ⻚面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时， 没有响应的仅仅是当前的⻚面。\n\n对于内存泄漏的解决方法那就更简单了，因为当关闭一个⻚面时，整个渲染进程也会被关闭，之后该进程所 占用的内存都会被系统回收，这样就轻松解决了浏览器⻚面的内存泄漏问题。\n\n最后我们再来看看上面的两个安全问题是怎么解决的。采用多进程架构的额外好处是可以使用安全沙箱，你 可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何 数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里 面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。\n\n好了，分析完早期的 Chrome 浏览器后，相信你已经了解了浏览器采用多进程架构的必要性\n\n\n# 目前多进程架构\n\n不过 Chrome 的发展是滚滚向前的，相较之前，目前的架构又有了很多新的变化。我们先看看最新的 Chrome 进程架构，你可以参考下图:\n\n\n\n从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个⽹络\n\n（NetWork）进程、多个渲染进程和多个插件进程。\n\n下⾯我们来逐个分析下这⼏个进程的功能。\n\n * 浏器器进程。主要负责界⾯显⽰、⽤⼾交互、⼦进程管理，同时提供存储等功能。\n\n * 渲染进程。核⼼任务是将 HTML、CSS 和 JavaScript 转换为⽤⼾可以与之交互的⽹⻚，排版引擎 Blink 和\n\nJavaScript 引擎 V8 都是运⾏在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建⼀个渲染进程。出\n\n于安全考虑，渲染进程都是运⾏在沙箱模式下。\n\n * GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。⽽ GPU 的使⽤初衷是为了实现 3D CSS 的\n\n效果，只是随后⽹⻚、Chrome 的 UI 界⾯都选择采⽤ GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最\n\n后，Chrome 在其多进程架构上也引⼊了 GPU 进程。\n\n * ⽹络进程。主要负责⻚⾯的⽹络资源加载，之前是作为⼀个模块运⾏在浏览器进程⾥⾯的，直⾄最近才独\n\n⽴出来，成为⼀个单独的进程。\n\n * 插件进程。主要是负责插件的运⾏，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃\n\n不会对浏览器和⻚⾯造成影响。\n\n讲到这⾥，现在你应该就可以回答⽂章开头提到的问题了：仅仅打开了 1 个⻚⾯，为什么有 4 个进程？因为打\n\n开 1 个⻚⾯⾄少需要 1 个⽹络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的⻚\n\n⾯有运⾏插件的话，还需要再加上 1 个插件进程。\n\n不过凡事都有两⾯性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了\n\n⼀些问题：\n\n更⾼的的资源占⽤。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运⾏环境），这就意味着浏\n\n览器会消耗更多的内存资源。\n\n更复杂的体系架构。浏览器各模块之间耦合性⾼、扩展性差等问题，会导致现在的架构已经很难适应新的\n\n需求了。\n\n对于上⾯这两个问题，Chrome 团队⼀直在寻求⼀种弹性⽅案，既可以解决资源占⽤⾼的问题，也可以解决\n\n复杂的体系架构的问题。\n\n\n# 未来⾯向服务的架构\n\n为了解决这些问题，在 2016 年，Chrome 官⽅团队使⽤“未来⾯向服务的架构 ”（Services Oriented\n\nArchitecture，简称 SSOOAA）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系\n\n统所采⽤的“⾯向服务的架构” ⽅向发展，原来的各种模块会被重构成独⽴的服务（Service），每个服务\n\n（Service）都可以在独⽴的进程中运⾏，访问服务（Service）必须使⽤定义好的接⼝，通过 IPC 来通信，\n\n从⽽构建⼀个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、⾼速、安全的⽬\n\n标。如果你对⾯向服务的架构感兴趣，你可以去⽹上搜索下资料，这⾥就不过多介绍了。\n\nChrome 最终要把 UI、数据库、⽂件、设备、⽹络等模块重构为基础服务，类似操作系统底层服务，下⾯是\n\nChrome“⾯向服务的架构”的进程模型图：\n\n\n\n⽬前 Chrome 正处在⽼的架构向服务化架构过渡阶段，这将是⼀个漫⻓的迭代过程。\n\nChrome 正在逐步构建 Chrome 基础服务（Chrome Foundation Service），如果你认为 Chrome 是“便携式\n\n操作系统”，那么 Chrome 基础服务便可以被视为该操作系统的“基础”系统服务层。\n\n同时 Chrome 还提供灵活的弹性架构，在强⼤性能设备上会以多进程的⽅式运⾏基础服务，但是如果在资源\n\n受限的设备上（如下图），Chrome 会将很多服务整合到⼀个进程中，从⽽节省内存占⽤。\n\n\n\n\n# 总结\n\n好了，今天就到这⾥，下⾯我来简要梳理并总结今天的内容。本⽂我主要是从 Chrome 进程架构的视⻆，分析了浏览器的进化史。\n\n最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 Chrome，创造性地引⼊了多进程\n\n架构，并解决了这些遗留问题。随后 Chrome 试图应⽤到更多业务场景，如移动设备、VR、视频等，为了⽀\n\n持这些场景，Chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 Chrome 开发团队必须进⾏架构\n\n的重构，最终 Chrome 团队选择了⾯向服务架构（SOA）形式，这也是 Chrome 团队现阶段的⼀个主要任\n\n务。\n\n鉴于⽬前架构的复杂性，要完整过渡到⾯向服务架构，估计还需要好⼏年时间才能完成。不过 Chrome 开发\n\n是⼀个渐进的过程，新的特性会⼀点点加⼊进来，这也意味着我们随时能看到 Chrome 新的变化。\n\n总体说来，Chrome 是以一个非常快速的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发，身 为开发人员，我们不能坐视不管，而应该紧跟其步伐，收获这波技术红利。",normalizedContent:"# 01-chrome 架构：仅仅打开了一个页面，为什么会有 4 个进程？\n\n无论你是想要设计高性能 web 应用，还是要优化现有的 web 应用，你都需要了解浏览器中的网络流程、⻚面渲染过程，javascript 执行流程，以及 web 安全理论，而这些功能是分散在浏览器的各个功能组件中的，比较多、比较散，要怎样学习才能掌握呢?通过浏览器的多进程架构的学习，你就可以把这些分散的知识点串 起来，组成一张网，从而让自己能站在更高的维度去理解 web 应用。\n\n因此，学习浏览器的多进程架构是很有必要的。需要说明的是，在本专栏中，我所有的分析都是基于 chrome 浏览器的。那么多浏览器，为什么偏偏选择 chrome 浏览器呢?因为 chrome、微软的 edge 以及国内的大部分主流浏览器，都是基于 chromium 二次开发而来;而 chrome 是 google 的官方发行版，特性和 chromium 基本一样，只存在一些产品层面差异;再加上 chrome 是目前世界上使用率最高的浏览器，所以 chrome 最具代表性\n\n在开始之前，我们一起看下，chrome 打开一个⻚面需要启动多少进程?你可以点击 chrome 浏览器右上⻆ 的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开 chrome 的任务管理器的窗 口，如下图:\n\n\n\n和 windows 任务管理器一样，chrome 任务管理器也是用来展示运行中 chrome 使用的进程信息的。从图中 可以看到，chrome 启动了 4 个进程，你也许会好奇，只是打开了 1 个⻚面，为什么要启动这么多进程呢?\n\n批注:目前，任务管理器需要通过 窗口选项卡 打开 而且现在不止 4 个进程！原因暂时不详\n\n在解答这个问题之前，我们需要了解一下进程的概念，不过由于好多人容易把进程和线程的概念混淆，从而影响后续其他概念的理解，所以这里我就将这两个概念以及它们之间的关系一并为你讲解下。\n\n\n# 进程和线程\n\n不过，在介绍进程和线程之前，我需要先讲解下什么是并行处理，因为如果你理解了并行处理的概念，那么 再理解进程和线程之间的关系就会变得轻松许多。\n\n\n# 什么是并行处理\n\n计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。\n\na=1+2\nb=20/5\nc=7*8\n\n\n在编写代码的时候，我们可以把这个过程拆分为四个任务:\n\n * 任务 1 是计算 a=1+2;\n * 任务 2 是计算 b=20/5;\n * 任务 3 是计算 c=7*8;\n * 任务 4 是显示最后计算的结果\n\n正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。\n\n如果采用多线程，会怎么样呢?我们只需分“两步走”:第一步，使用三个线程同时执行前三个任务;第二步，再执行第四个显示任务。\n\n通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能。\n\n\n# 线程 vs 进程\n\n多线程可以并行处理任务，但是**线程是不能单独存在的，它是由进程来启动和管理的。**那什么又是进程呢?\n\n**一个进程就是一个程序的运行实例。**详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。\n\n为了让你更好地理解上述计算过程，我画了下面这张对比图:\n\n\n\n从图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。\n\n总结来说，进程和线程之间的关系有以下 4 个特点:\n\n1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃\n\n我们可以模拟以下场景:\n\na=1+2\nb=20/0\nc=7*8\n\n\n我把上述三个表达式稍作修改，在计算 b 的值的时候，我把表达式的分母改成 0，当线程执行到 b = 20/0 时， 由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了。\n\n2. 线程之间共享进程中的数据\n\n如下图所示，线程之间可以对进程的公共数据进行读写操作。\n\n\n\n从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 a、b、c 中，然后线程 2 继续从 a、b、c 中读取数据，用来显示执行结果。\n\n3. 当一个进程关闭之后，操作系统会回收进程所占用的内存\n\n当一个进程退出时，操作系统会回收该进程所申请的所有资源;即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。\n\n比如之前的 ie 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉。\n\n4. 进程之间的内容相互隔离\n\n进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进 程 a 写入数据到进程 b 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信 (ipc)的机制了。\n\n\n# 单进程浏览器时代\n\n在了解了进程和线程之后，我们再来一起看下单进程浏览器的架构。顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、javascript 运行环境、渲染引擎和⻚面等。其实早在 2007 年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示:\n\n\n\n如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。下面 我就来一一分析下出现这些问题的原因。\n\n\n# 问题 1:不稳定\n\n早期浏览器需要借助于插件来实现诸如 web 视频、web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。\n\n除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 javascript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃。\n\n\n# 问题 2:不流畅\n\n从上面的“单进程浏览器架构示意图”可以看出，所有⻚面的渲染模块、javascript 执行环境以及插件都是 运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。\n\n比如，下面这个无限循环的脚本：\n\nfunction freeze() {\n    while (1) {\n        console.log('freeze')\n    }\n}\nfreeze()\n\n\n如果让这个脚本运行在一个单进程浏览器的⻚面里，你感觉会发生什么?\n\n因为这个脚本是无限循环的，所以当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就 没有机会被执行。因为浏览器中所有的⻚面都运行在该线程中，所以这些⻚面都没有机会去执行任务，这样 就会导致整个浏览器失去响应，变卡顿。这块内容要继续往深的地方讲就到⻚面的事件循环系统了，具体相关内容我会在后面的模块中为你深入讲解。\n\n除了上述脚本或者插件会让单进程浏览器变卡顿外，⻚面的内存泄漏也是单进程变慢的一个重要原因。通常 浏览器的内核都是非常复杂的，运行一个复杂点的⻚面再关闭⻚面，会存在内存不能完全回收的情况，这样 导致的问题是使用时间越⻓，内存占用越高，浏览器会变得越慢。\n\n\n# 问题 3:不安全\n\n这里依然可以从插件和⻚面脚本两个方面来解释该原因。\n\n插件可以使用 c/c++等代码编写，通过插件可以获取到操作系统的任意资源，当你在⻚面运行一个插件时也 就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码， 引发安全性问题。\n\n至于⻚面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做 一些恶意的事情，同样也会引发安全问题\n\n以上这些就是当时浏览器的特点，不稳定，不流畅，而且不安全。这是一段不堪回首的过去，也许你没有经 历过，不过你可以想象一下这样的场景:当你正在用浏览器打开多个⻚面时，突然某个⻚面崩溃了或者失去 响应，随之而来的是整个浏览器的崩溃或者无响应，然后你发现你给老板写的邮件⻚面也随之消失了，这时 你的心情会不会和⻚面一样崩溃呢?\n\n\n# 多进程浏览器时代\n\n好在现代浏览器已经解决了这些问题，是如何解决的呢?这就得聊聊我们这个“多进程浏览器时代”了\n\n\n# 早期多进程架构\n\n你可以先看看下面这张图，这是 2008 年 chrome 发布时的进程架构。\n\n\n\n从图中可以看出，chrome 的⻚面是运行在单独的渲染进程中的，同时⻚面里的插件也是运行在单独的插件 进程之中，而进程之间是通过 ipc 机制进行通信(如图中虚线部分)\n\n我们先看看如何解决不稳定的问题。由于进程是相互隔离的，所以当一个⻚面或者插件崩溃时，影响到的仅 仅是当前的⻚面进程或者插件进程，并不会影响到浏览器和其他⻚面，这就完美地解决了⻚面或者插件的崩 溃会导致整个浏览器崩溃，也就是不稳定的问题。\n\n接下来再来看看不流畅的问题是如何解决的。同样，javascript 也是运行在渲染进程中的，所以即使 javascript 阻塞了渲染进程，影响到的也只是当前的渲染⻚面，而并不会影响浏览器和其他⻚面，因为其他 ⻚面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 chrome 中运行上面那个死循环的脚本时， 没有响应的仅仅是当前的⻚面。\n\n对于内存泄漏的解决方法那就更简单了，因为当关闭一个⻚面时，整个渲染进程也会被关闭，之后该进程所 占用的内存都会被系统回收，这样就轻松解决了浏览器⻚面的内存泄漏问题。\n\n最后我们再来看看上面的两个安全问题是怎么解决的。采用多进程架构的额外好处是可以使用安全沙箱，你 可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何 数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。chrome 把插件进程和渲染进程锁在沙箱里 面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。\n\n好了，分析完早期的 chrome 浏览器后，相信你已经了解了浏览器采用多进程架构的必要性\n\n\n# 目前多进程架构\n\n不过 chrome 的发展是滚滚向前的，相较之前，目前的架构又有了很多新的变化。我们先看看最新的 chrome 进程架构，你可以参考下图:\n\n\n\n从图中可以看出，最新的 chrome 浏览器包括：1 个浏览器（browser）主进程、1 个 gpu 进程、1 个⽹络\n\n（network）进程、多个渲染进程和多个插件进程。\n\n下⾯我们来逐个分析下这⼏个进程的功能。\n\n * 浏器器进程。主要负责界⾯显⽰、⽤⼾交互、⼦进程管理，同时提供存储等功能。\n\n * 渲染进程。核⼼任务是将 html、css 和 javascript 转换为⽤⼾可以与之交互的⽹⻚，排版引擎 blink 和\n\njavascript 引擎 v8 都是运⾏在该进程中，默认情况下，chrome 会为每个 tab 标签创建⼀个渲染进程。出\n\n于安全考虑，渲染进程都是运⾏在沙箱模式下。\n\n * gpu 进程。其实，chrome 刚开始发布的时候是没有 gpu 进程的。⽽ gpu 的使⽤初衷是为了实现 3d css 的\n\n效果，只是随后⽹⻚、chrome 的 ui 界⾯都选择采⽤ gpu 来绘制，这使得 gpu 成为浏览器普遍的需求。最\n\n后，chrome 在其多进程架构上也引⼊了 gpu 进程。\n\n * ⽹络进程。主要负责⻚⾯的⽹络资源加载，之前是作为⼀个模块运⾏在浏览器进程⾥⾯的，直⾄最近才独\n\n⽴出来，成为⼀个单独的进程。\n\n * 插件进程。主要是负责插件的运⾏，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃\n\n不会对浏览器和⻚⾯造成影响。\n\n讲到这⾥，现在你应该就可以回答⽂章开头提到的问题了：仅仅打开了 1 个⻚⾯，为什么有 4 个进程？因为打\n\n开 1 个⻚⾯⾄少需要 1 个⽹络进程、1 个浏览器进程、1 个 gpu 进程以及 1 个渲染进程，共 4 个；如果打开的⻚\n\n⾯有运⾏插件的话，还需要再加上 1 个插件进程。\n\n不过凡事都有两⾯性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了\n\n⼀些问题：\n\n更⾼的的资源占⽤。因为每个进程都会包含公共基础结构的副本（如 javascript 运⾏环境），这就意味着浏\n\n览器会消耗更多的内存资源。\n\n更复杂的体系架构。浏览器各模块之间耦合性⾼、扩展性差等问题，会导致现在的架构已经很难适应新的\n\n需求了。\n\n对于上⾯这两个问题，chrome 团队⼀直在寻求⼀种弹性⽅案，既可以解决资源占⽤⾼的问题，也可以解决\n\n复杂的体系架构的问题。\n\n\n# 未来⾯向服务的架构\n\n为了解决这些问题，在 2016 年，chrome 官⽅团队使⽤“未来⾯向服务的架构 ”（services oriented\n\narchitecture，简称 ssooaa）的思想设计了新的 chrome 架构。也就是说 chrome 整体架构会朝向现代操作系\n\n统所采⽤的“⾯向服务的架构” ⽅向发展，原来的各种模块会被重构成独⽴的服务（service），每个服务\n\n（service）都可以在独⽴的进程中运⾏，访问服务（service）必须使⽤定义好的接⼝，通过 ipc 来通信，\n\n从⽽构建⼀个更内聚、松耦合、易于维护和扩展的系统，更好实现 chrome 简单、稳定、⾼速、安全的⽬\n\n标。如果你对⾯向服务的架构感兴趣，你可以去⽹上搜索下资料，这⾥就不过多介绍了。\n\nchrome 最终要把 ui、数据库、⽂件、设备、⽹络等模块重构为基础服务，类似操作系统底层服务，下⾯是\n\nchrome“⾯向服务的架构”的进程模型图：\n\n\n\n⽬前 chrome 正处在⽼的架构向服务化架构过渡阶段，这将是⼀个漫⻓的迭代过程。\n\nchrome 正在逐步构建 chrome 基础服务（chrome foundation service），如果你认为 chrome 是“便携式\n\n操作系统”，那么 chrome 基础服务便可以被视为该操作系统的“基础”系统服务层。\n\n同时 chrome 还提供灵活的弹性架构，在强⼤性能设备上会以多进程的⽅式运⾏基础服务，但是如果在资源\n\n受限的设备上（如下图），chrome 会将很多服务整合到⼀个进程中，从⽽节省内存占⽤。\n\n\n\n\n# 总结\n\n好了，今天就到这⾥，下⾯我来简要梳理并总结今天的内容。本⽂我主要是从 chrome 进程架构的视⻆，分析了浏览器的进化史。\n\n最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 chrome，创造性地引⼊了多进程\n\n架构，并解决了这些遗留问题。随后 chrome 试图应⽤到更多业务场景，如移动设备、vr、视频等，为了⽀\n\n持这些场景，chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 chrome 开发团队必须进⾏架构\n\n的重构，最终 chrome 团队选择了⾯向服务架构（soa）形式，这也是 chrome 团队现阶段的⼀个主要任\n\n务。\n\n鉴于⽬前架构的复杂性，要完整过渡到⾯向服务架构，估计还需要好⼏年时间才能完成。不过 chrome 开发\n\n是⼀个渐进的过程，新的特性会⼀点点加⼊进来，这也意味着我们随时能看到 chrome 新的变化。\n\n总体说来，chrome 是以一个非常快速的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发，身 为开发人员，我们不能坐视不管，而应该紧跟其步伐，收获这波技术红利。",charsets:{cjk:!0},lastUpdated:"2022年06月03日",lastUpdatedTimestamp:1654269825e3},{title:"思维导图",frontmatter:{title:"思维导图",readingShow:"top"},regularPath:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",relativePath:"基础知识/前端相关/浏览器工作原理与实践/思维导图.md",key:"v-3cae5cfe",path:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",headersStr:null,content:"# 思维导图\n\n放大 🔍 页面查看\n\n",normalizedContent:"# 思维导图\n\n放大 🔍 页面查看\n\n",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"概述篇",frontmatter:{title:"概述篇",sidebarDepth:2,readingShow:"top"},regularPath:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%A6%82%E8%BF%B0%E7%AF%87.html",relativePath:"基础知识/计算机通识/计算机网络/概述篇.md",key:"v-83959742",path:"/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%A6%82%E8%BF%B0%E7%AF%87.html",headers:[{level:2,title:"什么是计算机网络？",slug:"什么是计算机网络",normalizedTitle:"什么是计算机网络？",charIndex:2},{level:2,title:"计算机网络分类",slug:"计算机网络分类",normalizedTitle:"计算机网络分类",charIndex:132},{level:2,title:"计算机网络发展历史",slug:"计算机网络发展历史",normalizedTitle:"计算机网络发展历史",charIndex:150},{level:3,title:"互联网的发展历史",slug:"互联网的发展历史",normalizedTitle:"互联网的发展历史",charIndex:164},{level:3,title:"中国互联网发展历史",slug:"中国互联网发展历史",normalizedTitle:"中国互联网发展历史",charIndex:208},{level:2,title:"计算机网络的层次结构",slug:"计算机网络的层次结构",normalizedTitle:"计算机网络的层次结构",charIndex:226},{level:3,title:"层次结构设计的基本原则",slug:"层次结构设计的基本原则",normalizedTitle:"层次结构设计的基本原则",charIndex:565},{level:3,title:"OSI 七层模型",slug:"osi-七层模型",normalizedTitle:"osi 七层模型",charIndex:730},{level:3,title:"TCP/IP 模型",slug:"tcp-ip-模型",normalizedTitle:"tcp/ip 模型",charIndex:804},{level:2,title:"现代互联网的网络拓扑",slug:"现代互联网的网络拓扑",normalizedTitle:"现代互联网的网络拓扑",charIndex:824},{level:2,title:"计算机网络的性能指标",slug:"计算机网络的性能指标",normalizedTitle:"计算机网络的性能指标",charIndex:1224},{level:3,title:"时延",slug:"时延",normalizedTitle:"时延",charIndex:1295},{level:3,title:"往返时间 RTT",slug:"往返时间-rtt",normalizedTitle:"往返时间 rtt",charIndex:1435},{level:2,title:"物理层概述",slug:"物理层概述",normalizedTitle:"物理层概述",charIndex:1534},{level:3,title:"物理层作用",slug:"物理层作用",normalizedTitle:"物理层作用",charIndex:1544},{level:3,title:"传输介质",slug:"传输介质",normalizedTitle:"传输介质",charIndex:1594},{level:3,title:"信道",slug:"信道",normalizedTitle:"信道",charIndex:1652},{level:2,title:"分用-复用技术",slug:"分用-复用技术",normalizedTitle:"分用-复用技术",charIndex:1815},{level:2,title:"数据链路层概述",slug:"数据链路层概述",normalizedTitle:"数据链路层概述",charIndex:1850},{level:3,title:"封装成帧",slug:"封装成帧",normalizedTitle:"封装成帧",charIndex:1862},{level:3,title:"透明传输",slug:"透明传输",normalizedTitle:"透明传输",charIndex:1867},{level:3,title:"差错检测",slug:"差错检测",normalizedTitle:"差错检测",charIndex:1872},{level:3,title:"最大传输单元 MTU",slug:"最大传输单元-mtu",normalizedTitle:"最大传输单元 mtu",charIndex:2860},{level:3,title:"以太网协议详解",slug:"以太网协议详解",normalizedTitle:"以太网协议详解",charIndex:2946},{level:2,title:"计算机网络概述篇-面试常考题",slug:"计算机网络概述篇-面试常考题",normalizedTitle:"计算机网络概述篇-面试常考题",charIndex:3160},{level:2,title:"重要概念",slug:"重要概念",normalizedTitle:"重要概念",charIndex:5166}],headersStr:"什么是计算机网络？ 计算机网络分类 计算机网络发展历史 互联网的发展历史 中国互联网发展历史 计算机网络的层次结构 层次结构设计的基本原则 OSI 七层模型 TCP/IP 模型 现代互联网的网络拓扑 计算机网络的性能指标 时延 往返时间 RTT 物理层概述 物理层作用 传输介质 信道 分用-复用技术 数据链路层概述 封装成帧 透明传输 差错检测 最大传输单元 MTU 以太网协议详解 计算机网络概述篇-面试常考题 重要概念",content:'# 什么是计算机网络？\n\n计算机网络主要由一些通用的、可编程的硬件互连而成，通过这些硬件，可以传送不同类型的数据，并且可以支持广泛和日益增长的应用。\n\n * 计算机网络的不是软件概念，还包含硬件设备\n * 计算机网络不仅仅是信息通信，还可以支持广泛的应用\n\n\n# 计算机网络分类\n\n\n\n\n\n\n\n\n# 计算机网络发展历史\n\n\n# 互联网的发展历史\n\n\n\n\n\n\n\n\n\n> isp:网络服务提供商 中国移动...\n\n\n# 中国互联网发展历史\n\n\n\n\n\n\n# 计算机网络的层次结构\n\n⭐ 计算机网络为什么要使用层次结构的设计？\n\n 1. 各层之间相互独立：高层是不需要知道底层的功能是采取硬件技术来实现的，它只需要知道通过与底层的接口就可以获得所需要的服务；\n\n 2. 灵活性好：各层都可以采用最适当的技术来实现，例如某一层的实现技术发生了变化，用硬件代替了软件，只要这一层的功能与接口保持不变，实现技术的变化都并不会对其他各层以及整个系统的工作产生影响；\n\n 3. 易于实现和标准化：由于采取了规范的层次结构去组织网络功能与协议，因此可以将计算机网络复杂的通信过程，划分为有序的连续动作与有序的交互过程，有利于将网络复杂的通信工作过程化解为一系列可以控制和实现的功能模块，使得复杂的计算机网络系统变得易于设计，实现和标准化\n\n\n\n\n# 层次结构设计的基本原则\n\n * 各层之间是相互独立的\n * 每一层有足够的灵活性\n * 各层之间完全解耦\n\n> 相互独立意思可以理解为各自是独立，强调的自成一体，有自己的独立的体系，或者功能，是一个整体。而相互解耦指的则是相互之间减少依赖，强调的是依赖关系，依赖程度越少，就是常说的耦合程度越低。\n\n> 什么是耦合、解耦\n\n\n# OSI 七层模型\n\n\n\n * OSI 欲成为全球计算机都遵循的标准\n * OSI 在市场化过程中困难重重，TCP/IP 在全球范围成功运行\n\n\n# TCP/IP 模型\n\n\n\n\n\n\n\n\n# 现代互联网的网络拓扑\n\nTIP\n\n路由器一般是工作在一个网络内部，负责的是同一个网段之间的路由。而网关则不一样，网关是一个网络非常重要的设备，一般作为网络的统一出口或入口使用的。意味着，一个网络和另外一个网络连接，从虚拟互联网络来看，就是两个网关的连接。\n\n * 边缘部分：由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享\n\n\n\n\n\n * 核心部分：由大量的网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的\n\n\n\n把边缘部分和核心部分连接起来会形成现代互联网的树状结构\n\n\n\n从用户角度出发，去看计算机网络，更多看到是各种模式：\n\n1、客户-服务器方式（C/S 方式）：即 Client/Server 方式，简称为 C/S 方式。\n\n2、对等方式（P2P 方式）：即 Peer-to-Peer 方式 ，简称为 P2P 方式。\n\n\n# 计算机网络的性能指标\n\n * 速率\n\n\n\nbps=bit/s\n\neg:为什么电信拉的 100m,测试峰值速度只有 12M 每秒？\n\n\n\n\n# 时延\n\n * 发送时延\n\n本机进行网络发送的时候，在本机所停留的时间\n\n\n\n * 传播时延\n\n\n\n * 排队时延\n\n数据包在网络设备中等待被处理的时间\n\n * 处理时延\n\n数据包到达设备或者目的机器被处理所需要的时间\n\n> 总时延=发送时延+传播时延+排队时延+处理时延\n\n\n# 往返时间 RTT\n\nRTT(Route-Trip Time) 是评估网络质量的一项重要指标\n\nRTT 表示的是数据报文在端到端通信中的来回一次的时间\n\n通常使用 ping 命令查看 RTT\n\n\n# 物理层概述\n\n\n# 物理层作用\n\n * 连接不同的物理设备\n\n * 传输比特流(01010101011...)\n\n\n# 传输介质\n\n * 双绞线\n\n\n\n * 同轴电缆\n\n\n\n * 光纤\n\n\n\n * 无线介质：红外线，无线，激光\n\n\n# 信道\n\n信道是往一个方向传送信息的媒体\n\n一条通信电路包含一个接收信道和一个发送信道\n\n单工通信信道：只能一个方向通信，没有反方向反馈的信道，（有线电视、无线电收音机）\n\n半双工通信信道：双方都可以发送和接收信息，不能双方同时发送，也不能同时接收，（非常落后）\n\n全双工通信信道：双方都可以同时发送和接收信息（网线）\n\n\n# 分用-复用技术\n\n解决信道利用率低的问题\n\n无需关注细节\n\n\n\n\n# 数据链路层概述\n\n解决：封装成帧，透明传输，差错检测\n\n\n# 封装成帧\n\n“帧”是数据链路层数据的基本单位\n\n发送端在网络层的一段数据前后添加特定标记形成“帧”\n\n接收端根据前后特定标记识别出“帧”\n\n提示\n\n物理层不会管你’帧‘不’帧‘，只管比特流的传输。层与层之间相互独立，解耦。\n\n封装成帧的过程：\n\n\n\n帧首部SOH:00000001 和尾部EOT:00000100是特定的控制字符（特定比特流）\n\n\n# 透明传输\n\nTIP\n\n透明：一种实际存在的事物却又看起来不存在一样\n\n即使控制字符在帧数据中，但是要当做不存在的去处理\n\n数据里面恰好有这些特定比特流怎么办？对数据中的控制字符进行特殊处理，在它的前面加一个转义字符\n\n数据中也出现转义字符咋办？转义字符前再加一个转义字符\n\n这种处理类似于编程语言中的转义字符\n\n\n\n注：ESC转义字符\n\n\n# 差错检测\n\n物理层只管传输比特流，无法控制是否出错\n\n# 奇偶校验码\n\n\n\n局限性\n\n\n\n# 循环冗余校验码-CRC\n\n一种根据传输或保存的数据而产生固定位数校验码的方法\n\n检测数据传输或者保存后可能出现的错误\n\n生成的数字计算出来并且附加到数据后面\n\n# 模 2 除法\n\n模 2 除法它既不向上位借位，也不比较除数和被除数的相同位数值的大小，只要以相同位数进行相除即可。\n\n原则：\n\n1、被除数的首位为 1，商为 1\n\n2、被除数的首位为 0，商为 0\n\n3、模 2 除法等同于按位异或，要保证每次除完首位都为 0，才能进行右移\n\n异或运算：\n\n\n\n4、计算时每次右移一位，当被除数的位数小于除数，其为余数\n\n\n\n# 过程\n\n 1. 选定一个用于校验的多项式G(x)，并在数据尾部添加r 个 0(多项式 G(x)最高阶个 0)\n\n> G(x)是协议规定的,不同的协议使用不同的 G(x)\n\n 2. 将添加 r 个 0 后的数据，使用模"2″除法除以多项式的位串\n\n 3. 得到的余数填充在原数据 r 个 0 的位置得到可校验的位串\n\n接收端接收的数据除以 G(x)的位串，根据余数判断出错(余数为 0 就没有出错)\n\nCRC 的错误检测能力与位串的阶数 r 有关\n\n数据链路层只进行数据的检测，不进行纠正，直接把错误的数据丢掉。\n\neg:使用 CRC 计算 101001 的可校验位串\n\n 1. 第一步\n\n\n\n 2. 第二步\n\n\n\n 3. 第三步\n\n\n\n\n# 最大传输单元 MTU\n\n数据链路层的数据帧也不是无限大的,长度不能超过 MTU\n\n数据帧过大或过小都会影响传输的效率\n\n以太网 MTU 一般为 1500 字节\n\n\n\n\n# 以太网协议详解\n\nMAC 地址（物理地址、硬件地址）\n\n每一个设备都拥有唯一的 MAC 地址\n\nMAC 地址共 48（12*4）位，使用十六进制表示\n\n以太网（ Ethernet）是一种使用广泛的局域网技术\n\n以太网是一种应用于数据链路层的协议\n\n使用以太网可以完成相邻设备的数据帧传输\n\n以太网数据格式\n\n\n\nMAC 地址表\n\n映射关系\n\n\n\n发送数据帧\n\n\n\n如果无法获取目的 mac 地址对应的硬件接口信息，\n\n\n\n\n# 计算机网络概述篇-面试常考题\n\n * 计算机网络的七层模型从顶往下分别是什么？请按顺序列举出来。\n\n> 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。\n\n * 现在开发者更喜欢使用 TCP/IP 四层模型来划分计算机网络，为什么 TCP/IP 四层模型会取代 OSI 七层模型被广泛使用？\n\n> ①OSI 的专家缺乏实际经验、他们基于理论来设计的 ②OSI 标准置顶周期过长，按 OSI 标准生产的设备无法及时进入市场 ③OSI 模型设计得并不合理，一些功能在多层中重复出现\n\n * ARP 协议、RARP 协议属于计算机网络的哪一个层次？\n\n> 数据链路层（这主要是一个归类的问题，这两个协议准确来说是工作在数据链路层和网络层之间，一般是把他归为数据链路层的协议）\n\n * IP 协议、ICMP 协议属于计算机网络的哪一个层次？\n\n> 网络层\n\n * 传输层最重要的两个协议是什么？\n\n> TCP 协议、UDP 协议\n\n * 常见的应用层协议有 HTTP 协议、FTP 协议等，你还能列举一些常见的应用层协议吗？\n\n> HTTP、FTP、SMTP、DNS、POP3、Telnet、TFTP、DHCP 等\n\n * 路由器工作在计算机网络的哪几个层次？\n\n> 物理层、数据链路层、网络层\n\n * 现代网络设备互联的两种模式分别是什么？他们有什么特点？\n\n> 客户 - 服务端模式、对等连接模式。客户 - 服务端模式由服务端提供网络服务，客户端使用服务，常常表现为一个服务端，多个客户端的连接模式。对等连接模式不分客户端和服务端，只要两个主机都运行了对等连接软件（P2P 软件），它们就可以进行平等的、对等连接通信\n\n * 时延是判断计算机网络质量的重要标准，网络时延由哪几个部分组成？\n\n> 网络时延可以划分成发送时延、传播时延、排队时延、处理时延几个部分\n\n * 物理层主要的作用是什么？\n\n> 物理层主要的作用是连接不同的网络设备并在网络设备之间传输比特流\n\n * 请列举物理层常见的传输介质。\n\n> 有线传输（铜线、光纤），无线传输\n\n * 什么是信道，什么是单工信道、半双工信道、全双工信道？\n\n> 信道是往一个方向传送信息的媒体，单工信道指的是只能发送或者接收的信道，半双工信道指的是双方都能发送和接收信息但是不能同时发送或同时接收的信道，全双工信道指的是双方可以自由发送和接收信息的信道\n\n * 数据链路层的三个重要功能分别是什么？\n\n> 封装成帧、透明传输、差错检测\n\n * 物理层只负责比特流的传输，这些数据在数据链路层称为什么？\n\n> 数据帧\n\n * 为了界定区分一个单独的数据帧，数据链路层通常会做什么操作？\n\n> 在数据的头部和尾部加入特殊比特位\n\n * 假设有数据 00100101 需要传输，目标机器接收到的数据为 10100100，请问使用奇偶校验码是否可以检测出错误？\n\n> 不能，因为奇偶校验位只能检测单个比特位出现的错误\n\n * 假设有数据 1101011011 需要传输，采用 CRC 的生成多项式为 P (X)=X^4+X+1，请计算添加了 CRC 校验码之后的数据。\n\n> 多项式位串为：10011，模二除法得到余数 1110，所以得到结果 11010110111110\n\n * 什么是 MAC 地址？如何查看本机的 MAC 地址？MAC 地址有什么作用？\n\n> MAC 地址也称为物理地址、硬件地址，通过在 windows 系统下输入命令 ipconfig 可以查看网络设备的 MAC 地址，MAC 地址使用 48 个比特位标记一个物理设备\n\n * 请简述以太网的工作过程。MAC 地址在其中起到了什么作用？\n\n> 以太网（Ethernet）是一种是使用广泛的局域网技术、以太网是一种应用于数据链路层的协议、使用以太网可以完成相邻设备的数据帧传输。\n\n> 在一个以太网里边，现在有 3 台计算机 A、B、C。都连接了路由器 D，如果 A 想发送信息给 B，就必须通过路由器才知道这个信息是发送给谁的，路由器怎么就知道发送给谁呢？因为路由器里边有个叫 MAC 地址表的东西，它保存了连接它自身的计算机的 MAC 地址和映射的硬件接口，通过 MAC 地址，就可以找到对应要发送的端口，就好比键值对。\n\n> 以太网发送的数据由 5 部分组成：目的地址、源地址、类型、帧数据、CRC\n\n> 目的地址（6 个字节，即 MAC 地址）、源地址（6 个字节），类型（2 个字节，0800 为 IP 数据报，0806 为 ARP 请求/响应，8035 为 RARP 请求/答应）、帧数据（46~1500 字节），CRC（4 字节，循环冗余校验码）。\n\n> MAC 地址作用:以太网协议通过 MAC 地址和硬件接口的映射关系了解到通过具体哪个接口把数据发送给下一跳。\n\n\n# 重要概念\n\n * 计算机网络\n * ISP\n * OSI 七层模型\n * TCP/IP 四层模型\n * C/S 模式\n * P2P 模式\n * RTT\n * 信道\n * 奇偶校验码\n * CRC 循环冗余校验码\n * MTU\n * 路径 MTU\n * 以太网',normalizedContent:'# 什么是计算机网络？\n\n计算机网络主要由一些通用的、可编程的硬件互连而成，通过这些硬件，可以传送不同类型的数据，并且可以支持广泛和日益增长的应用。\n\n * 计算机网络的不是软件概念，还包含硬件设备\n * 计算机网络不仅仅是信息通信，还可以支持广泛的应用\n\n\n# 计算机网络分类\n\n\n\n\n\n\n\n\n# 计算机网络发展历史\n\n\n# 互联网的发展历史\n\n\n\n\n\n\n\n\n\n> isp:网络服务提供商 中国移动...\n\n\n# 中国互联网发展历史\n\n\n\n\n\n\n# 计算机网络的层次结构\n\n⭐ 计算机网络为什么要使用层次结构的设计？\n\n 1. 各层之间相互独立：高层是不需要知道底层的功能是采取硬件技术来实现的，它只需要知道通过与底层的接口就可以获得所需要的服务；\n\n 2. 灵活性好：各层都可以采用最适当的技术来实现，例如某一层的实现技术发生了变化，用硬件代替了软件，只要这一层的功能与接口保持不变，实现技术的变化都并不会对其他各层以及整个系统的工作产生影响；\n\n 3. 易于实现和标准化：由于采取了规范的层次结构去组织网络功能与协议，因此可以将计算机网络复杂的通信过程，划分为有序的连续动作与有序的交互过程，有利于将网络复杂的通信工作过程化解为一系列可以控制和实现的功能模块，使得复杂的计算机网络系统变得易于设计，实现和标准化\n\n\n\n\n# 层次结构设计的基本原则\n\n * 各层之间是相互独立的\n * 每一层有足够的灵活性\n * 各层之间完全解耦\n\n> 相互独立意思可以理解为各自是独立，强调的自成一体，有自己的独立的体系，或者功能，是一个整体。而相互解耦指的则是相互之间减少依赖，强调的是依赖关系，依赖程度越少，就是常说的耦合程度越低。\n\n> 什么是耦合、解耦\n\n\n# osi 七层模型\n\n\n\n * osi 欲成为全球计算机都遵循的标准\n * osi 在市场化过程中困难重重，tcp/ip 在全球范围成功运行\n\n\n# tcp/ip 模型\n\n\n\n\n\n\n\n\n# 现代互联网的网络拓扑\n\ntip\n\n路由器一般是工作在一个网络内部，负责的是同一个网段之间的路由。而网关则不一样，网关是一个网络非常重要的设备，一般作为网络的统一出口或入口使用的。意味着，一个网络和另外一个网络连接，从虚拟互联网络来看，就是两个网关的连接。\n\n * 边缘部分：由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享\n\n\n\n\n\n * 核心部分：由大量的网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的\n\n\n\n把边缘部分和核心部分连接起来会形成现代互联网的树状结构\n\n\n\n从用户角度出发，去看计算机网络，更多看到是各种模式：\n\n1、客户-服务器方式（c/s 方式）：即 client/server 方式，简称为 c/s 方式。\n\n2、对等方式（p2p 方式）：即 peer-to-peer 方式 ，简称为 p2p 方式。\n\n\n# 计算机网络的性能指标\n\n * 速率\n\n\n\nbps=bit/s\n\neg:为什么电信拉的 100m,测试峰值速度只有 12m 每秒？\n\n\n\n\n# 时延\n\n * 发送时延\n\n本机进行网络发送的时候，在本机所停留的时间\n\n\n\n * 传播时延\n\n\n\n * 排队时延\n\n数据包在网络设备中等待被处理的时间\n\n * 处理时延\n\n数据包到达设备或者目的机器被处理所需要的时间\n\n> 总时延=发送时延+传播时延+排队时延+处理时延\n\n\n# 往返时间 rtt\n\nrtt(route-trip time) 是评估网络质量的一项重要指标\n\nrtt 表示的是数据报文在端到端通信中的来回一次的时间\n\n通常使用 ping 命令查看 rtt\n\n\n# 物理层概述\n\n\n# 物理层作用\n\n * 连接不同的物理设备\n\n * 传输比特流(01010101011...)\n\n\n# 传输介质\n\n * 双绞线\n\n\n\n * 同轴电缆\n\n\n\n * 光纤\n\n\n\n * 无线介质：红外线，无线，激光\n\n\n# 信道\n\n信道是往一个方向传送信息的媒体\n\n一条通信电路包含一个接收信道和一个发送信道\n\n单工通信信道：只能一个方向通信，没有反方向反馈的信道，（有线电视、无线电收音机）\n\n半双工通信信道：双方都可以发送和接收信息，不能双方同时发送，也不能同时接收，（非常落后）\n\n全双工通信信道：双方都可以同时发送和接收信息（网线）\n\n\n# 分用-复用技术\n\n解决信道利用率低的问题\n\n无需关注细节\n\n\n\n\n# 数据链路层概述\n\n解决：封装成帧，透明传输，差错检测\n\n\n# 封装成帧\n\n“帧”是数据链路层数据的基本单位\n\n发送端在网络层的一段数据前后添加特定标记形成“帧”\n\n接收端根据前后特定标记识别出“帧”\n\n提示\n\n物理层不会管你’帧‘不’帧‘，只管比特流的传输。层与层之间相互独立，解耦。\n\n封装成帧的过程：\n\n\n\n帧首部soh:00000001 和尾部eot:00000100是特定的控制字符（特定比特流）\n\n\n# 透明传输\n\ntip\n\n透明：一种实际存在的事物却又看起来不存在一样\n\n即使控制字符在帧数据中，但是要当做不存在的去处理\n\n数据里面恰好有这些特定比特流怎么办？对数据中的控制字符进行特殊处理，在它的前面加一个转义字符\n\n数据中也出现转义字符咋办？转义字符前再加一个转义字符\n\n这种处理类似于编程语言中的转义字符\n\n\n\n注：esc转义字符\n\n\n# 差错检测\n\n物理层只管传输比特流，无法控制是否出错\n\n# 奇偶校验码\n\n\n\n局限性\n\n\n\n# 循环冗余校验码-crc\n\n一种根据传输或保存的数据而产生固定位数校验码的方法\n\n检测数据传输或者保存后可能出现的错误\n\n生成的数字计算出来并且附加到数据后面\n\n# 模 2 除法\n\n模 2 除法它既不向上位借位，也不比较除数和被除数的相同位数值的大小，只要以相同位数进行相除即可。\n\n原则：\n\n1、被除数的首位为 1，商为 1\n\n2、被除数的首位为 0，商为 0\n\n3、模 2 除法等同于按位异或，要保证每次除完首位都为 0，才能进行右移\n\n异或运算：\n\n\n\n4、计算时每次右移一位，当被除数的位数小于除数，其为余数\n\n\n\n# 过程\n\n 1. 选定一个用于校验的多项式g(x)，并在数据尾部添加r 个 0(多项式 g(x)最高阶个 0)\n\n> g(x)是协议规定的,不同的协议使用不同的 g(x)\n\n 2. 将添加 r 个 0 后的数据，使用模"2″除法除以多项式的位串\n\n 3. 得到的余数填充在原数据 r 个 0 的位置得到可校验的位串\n\n接收端接收的数据除以 g(x)的位串，根据余数判断出错(余数为 0 就没有出错)\n\ncrc 的错误检测能力与位串的阶数 r 有关\n\n数据链路层只进行数据的检测，不进行纠正，直接把错误的数据丢掉。\n\neg:使用 crc 计算 101001 的可校验位串\n\n 1. 第一步\n\n\n\n 2. 第二步\n\n\n\n 3. 第三步\n\n\n\n\n# 最大传输单元 mtu\n\n数据链路层的数据帧也不是无限大的,长度不能超过 mtu\n\n数据帧过大或过小都会影响传输的效率\n\n以太网 mtu 一般为 1500 字节\n\n\n\n\n# 以太网协议详解\n\nmac 地址（物理地址、硬件地址）\n\n每一个设备都拥有唯一的 mac 地址\n\nmac 地址共 48（12*4）位，使用十六进制表示\n\n以太网（ ethernet）是一种使用广泛的局域网技术\n\n以太网是一种应用于数据链路层的协议\n\n使用以太网可以完成相邻设备的数据帧传输\n\n以太网数据格式\n\n\n\nmac 地址表\n\n映射关系\n\n\n\n发送数据帧\n\n\n\n如果无法获取目的 mac 地址对应的硬件接口信息，\n\n\n\n\n# 计算机网络概述篇-面试常考题\n\n * 计算机网络的七层模型从顶往下分别是什么？请按顺序列举出来。\n\n> 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。\n\n * 现在开发者更喜欢使用 tcp/ip 四层模型来划分计算机网络，为什么 tcp/ip 四层模型会取代 osi 七层模型被广泛使用？\n\n> ①osi 的专家缺乏实际经验、他们基于理论来设计的 ②osi 标准置顶周期过长，按 osi 标准生产的设备无法及时进入市场 ③osi 模型设计得并不合理，一些功能在多层中重复出现\n\n * arp 协议、rarp 协议属于计算机网络的哪一个层次？\n\n> 数据链路层（这主要是一个归类的问题，这两个协议准确来说是工作在数据链路层和网络层之间，一般是把他归为数据链路层的协议）\n\n * ip 协议、icmp 协议属于计算机网络的哪一个层次？\n\n> 网络层\n\n * 传输层最重要的两个协议是什么？\n\n> tcp 协议、udp 协议\n\n * 常见的应用层协议有 http 协议、ftp 协议等，你还能列举一些常见的应用层协议吗？\n\n> http、ftp、smtp、dns、pop3、telnet、tftp、dhcp 等\n\n * 路由器工作在计算机网络的哪几个层次？\n\n> 物理层、数据链路层、网络层\n\n * 现代网络设备互联的两种模式分别是什么？他们有什么特点？\n\n> 客户 - 服务端模式、对等连接模式。客户 - 服务端模式由服务端提供网络服务，客户端使用服务，常常表现为一个服务端，多个客户端的连接模式。对等连接模式不分客户端和服务端，只要两个主机都运行了对等连接软件（p2p 软件），它们就可以进行平等的、对等连接通信\n\n * 时延是判断计算机网络质量的重要标准，网络时延由哪几个部分组成？\n\n> 网络时延可以划分成发送时延、传播时延、排队时延、处理时延几个部分\n\n * 物理层主要的作用是什么？\n\n> 物理层主要的作用是连接不同的网络设备并在网络设备之间传输比特流\n\n * 请列举物理层常见的传输介质。\n\n> 有线传输（铜线、光纤），无线传输\n\n * 什么是信道，什么是单工信道、半双工信道、全双工信道？\n\n> 信道是往一个方向传送信息的媒体，单工信道指的是只能发送或者接收的信道，半双工信道指的是双方都能发送和接收信息但是不能同时发送或同时接收的信道，全双工信道指的是双方可以自由发送和接收信息的信道\n\n * 数据链路层的三个重要功能分别是什么？\n\n> 封装成帧、透明传输、差错检测\n\n * 物理层只负责比特流的传输，这些数据在数据链路层称为什么？\n\n> 数据帧\n\n * 为了界定区分一个单独的数据帧，数据链路层通常会做什么操作？\n\n> 在数据的头部和尾部加入特殊比特位\n\n * 假设有数据 00100101 需要传输，目标机器接收到的数据为 10100100，请问使用奇偶校验码是否可以检测出错误？\n\n> 不能，因为奇偶校验位只能检测单个比特位出现的错误\n\n * 假设有数据 1101011011 需要传输，采用 crc 的生成多项式为 p (x)=x^4+x+1，请计算添加了 crc 校验码之后的数据。\n\n> 多项式位串为：10011，模二除法得到余数 1110，所以得到结果 11010110111110\n\n * 什么是 mac 地址？如何查看本机的 mac 地址？mac 地址有什么作用？\n\n> mac 地址也称为物理地址、硬件地址，通过在 windows 系统下输入命令 ipconfig 可以查看网络设备的 mac 地址，mac 地址使用 48 个比特位标记一个物理设备\n\n * 请简述以太网的工作过程。mac 地址在其中起到了什么作用？\n\n> 以太网（ethernet）是一种是使用广泛的局域网技术、以太网是一种应用于数据链路层的协议、使用以太网可以完成相邻设备的数据帧传输。\n\n> 在一个以太网里边，现在有 3 台计算机 a、b、c。都连接了路由器 d，如果 a 想发送信息给 b，就必须通过路由器才知道这个信息是发送给谁的，路由器怎么就知道发送给谁呢？因为路由器里边有个叫 mac 地址表的东西，它保存了连接它自身的计算机的 mac 地址和映射的硬件接口，通过 mac 地址，就可以找到对应要发送的端口，就好比键值对。\n\n> 以太网发送的数据由 5 部分组成：目的地址、源地址、类型、帧数据、crc\n\n> 目的地址（6 个字节，即 mac 地址）、源地址（6 个字节），类型（2 个字节，0800 为 ip 数据报，0806 为 arp 请求/响应，8035 为 rarp 请求/答应）、帧数据（46~1500 字节），crc（4 字节，循环冗余校验码）。\n\n> mac 地址作用:以太网协议通过 mac 地址和硬件接口的映射关系了解到通过具体哪个接口把数据发送给下一跳。\n\n\n# 重要概念\n\n * 计算机网络\n * isp\n * osi 七层模型\n * tcp/ip 四层模型\n * c/s 模式\n * p2p 模式\n * rtt\n * 信道\n * 奇偶校验码\n * crc 循环冗余校验码\n * mtu\n * 路径 mtu\n * 以太网',charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"Docker",frontmatter:{title:"Docker",date:"2022/06/04 22:45:19",sidebar:"auto",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker.html",relativePath:"开发工具/Docker.md",key:"v-66d6172e",path:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker.html",headers:[{level:2,title:"容器和 Docker",slug:"容器和-docker",normalizedTitle:"容器和 docker",charIndex:2},{level:3,title:"什么是容器化？",slug:"什么是容器化",normalizedTitle:"什么是容器化？",charIndex:17}],headersStr:"容器和 Docker 什么是容器化？",content:"# 容器和 Docker\n\n\n# 什么是容器化？\n\n容器化是将应用程序或服务、其依赖项及其配置（抽象化为部署清单文件）一起打包为容器映像的一种软件开发方法",normalizedContent:"# 容器和 docker\n\n\n# 什么是容器化？\n\n容器化是将应用程序或服务、其依赖项及其配置（抽象化为部署清单文件）一起打包为容器映像的一种软件开发方法",charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"git",frontmatter:{title:"git",sidebar:"auto",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git.html",relativePath:"开发工具/git.md",key:"v-5cace148",path:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git.html",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:2},{level:3,title:"mac",slug:"mac",normalizedTitle:"mac",charIndex:9},{level:2,title:"配置账户",slug:"配置账户",normalizedTitle:"配置账户",charIndex:48},{level:2,title:"配置 SSH 密钥",slug:"配置-ssh-密钥",normalizedTitle:"配置 ssh 密钥",charIndex:163},{level:2,title:"墙内自救指南",slug:"墙内自救指南",normalizedTitle:"墙内自救指南",charIndex:602},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:1288},{level:3,title:"生成版本",slug:"生成版本",normalizedTitle:"生成版本",charIndex:1295},{level:3,title:"重置版本",slug:"重置版本",normalizedTitle:"重置版本",charIndex:1741},{level:3,title:"git忽略文件---.gitignore",slug:"git忽略文件-gitignore",normalizedTitle:"git忽略文件---.gitignore",charIndex:1953},{level:2,title:"git分支",slug:"git分支",normalizedTitle:"git分支",charIndex:2144},{level:3,title:"创建和切换分支",slug:"创建和切换分支",normalizedTitle:"创建和切换分支",charIndex:2154},{level:3,title:"合并和删除分支",slug:"合并和删除分支",normalizedTitle:"合并和删除分支",charIndex:2354}],headersStr:"安装 mac 配置账户 配置 SSH 密钥 墙内自救指南 使用 生成版本 重置版本 git忽略文件---.gitignore git分支 创建和切换分支 合并和删除分支",content:"# 安装\n\n\n# mac\n\n通过homebrew安装:brew install git\n\n\n# 配置账户\n\n1、设置用户名：git config --global user.name '你git平台上的用户名';\n\n2、设置用户邮箱：git config --global user.email '注册时候的邮箱';\n\n\n# 配置 SSH 密钥\n\n * 生成/添加 SSH 公钥\n * Git 配置多个 SSH-Key\n\n以下命令 win 在 git bash 下执行\n\nssh-keygen -t rsa -C 'gitee' -f ~/.ssh/gitee_id_rsa\n\nssh-keygen -t rsa -C 'github' -f ~/.ssh/github_id_rsa\n\n# 生成完去gitee，github设置添加公钥 pub文件\n# mac 操作 win忽略\nssh-add ~/.ssh/github_id_rsa\nssh-add ~/.ssh/gitee_id_rsa\n# 终端连接\nssh -T git@gitee.com\nssh -T git@github.com\n\n\nmac 下每次开机后需要执行:\n\nssh-add ~/.ssh/gitee_id_rsa\nssh-add ~/.ssh/github_id_rsa\n\n\n可以自动添加，在每次开机后自动运行：具体步骤\n\n\n# 墙内自救指南\n\ngit push,git clone加速github\n\n.gitconfig 配置文件写入：\n\n[http \"https://github.com\"]\n\tproxy = socks5://127.0.0.1:7890\n[https \"https://github.com\"]\n\tproxy = socks5://127.0.0.1:7890\n\n\n或者终端执行：\n\ngit config --global http.https://github.com.proxy socks5://127.0.0.1:7890\ngit config --global https.https://github.com.proxy socks5://127.0.0.1:7890\n\n\n~/.ssh/config（config 前面没有点） 配置文件写入：\n\n# gitee\nHost gitee.com\nHostName gitee.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/gitee_id_rsa\n# github\nHost github.com\nHostName github.com\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/github_id_rsa\nProxyCommand nc -v -x 127.0.0.1:7890 %h %p\n\n\nmacOS 给 Git(Github) 设置代理（HTTP/SSH）\n\n\n# 使用\n\n\n# 生成版本\n\n * git init:在项目中初始化 Git，让 Git 管理当前项目\n * git status:检查当前文件状态，需要经常使用 -git add <file1> <file2> ...:将工作区的指定内容添加到暂存区\n * git add . :将工作区的内容一起添加到暂存区\n\ngit add\n\n使用 git add 后，工作区和暂存区的内容是一致的\n\n工作区和暂存区内容不一致的时候，需要通过 git add，让它们内容一致\n\n只要工作区的文件有变动，就需要将工作区的变动添加到暂存区\n\n * git commit -m '描述消息'：将暂存区的内容提交到本地仓库，生成版本\n\ngit commit\n\ngit commit 后，暂存区和本地版本库的内容是一致的\n\n暂存区和本地版本库内容不一致的时候，需要通过 git commit ，让它们内容一致\n\n * git log ：查看提交内容\n * git log --oneline：以一行的方式查看提交记录\n\n\n\n\n# 重置版本\n\n * git reset --soft 版本号：仅重置本地仓库\n\n * git reset --mixed 版本号：重置本地仓库和暂存区，默认行为\n\n * git reset --hard 版本号：重置本地仓库、暂存区和工作目录 --hard 危险，会覆盖正在开发的代码\n\n * git reflog:可以查看所有记录，包括被\"丢弃\"的版本\n\n * git log:查看提交记录，不包括被\"丢弃\"的版本\n\n\n# git忽略文件---.gitignore\n\n * #：注释\n * test.html:忽略指定文件，不让Git管理\n * test.*：忽略所有文件名是test的文件，不管后缀是什么\n * *.tmp：忽略所有后缀是.tmp的文件，不管文件名是什么\n * node_modules/:忽略node_modules目录下的所有文件\n * git管理的是文件，空目录会自动忽略\n\n\n# git分支\n\n\n# 创建和切换分支\n\ncheckout\n\ncheckout=>签出操作(webstrom)\n\n * git branch:查看分支\n * git branch-v:查看分支（展示的信息多一些）\n * git branch 分支名：在当前分支的节点上创建新的分支\n * git checkout 分支名：切换分支，兼容性好\n * git switch 分支名：切换分支，v2.23.0版及以后可用\n\n\n# 合并和删除分支",normalizedContent:"# 安装\n\n\n# mac\n\n通过homebrew安装:brew install git\n\n\n# 配置账户\n\n1、设置用户名：git config --global user.name '你git平台上的用户名';\n\n2、设置用户邮箱：git config --global user.email '注册时候的邮箱';\n\n\n# 配置 ssh 密钥\n\n * 生成/添加 ssh 公钥\n * git 配置多个 ssh-key\n\n以下命令 win 在 git bash 下执行\n\nssh-keygen -t rsa -c 'gitee' -f ~/.ssh/gitee_id_rsa\n\nssh-keygen -t rsa -c 'github' -f ~/.ssh/github_id_rsa\n\n# 生成完去gitee，github设置添加公钥 pub文件\n# mac 操作 win忽略\nssh-add ~/.ssh/github_id_rsa\nssh-add ~/.ssh/gitee_id_rsa\n# 终端连接\nssh -t git@gitee.com\nssh -t git@github.com\n\n\nmac 下每次开机后需要执行:\n\nssh-add ~/.ssh/gitee_id_rsa\nssh-add ~/.ssh/github_id_rsa\n\n\n可以自动添加，在每次开机后自动运行：具体步骤\n\n\n# 墙内自救指南\n\ngit push,git clone加速github\n\n.gitconfig 配置文件写入：\n\n[http \"https://github.com\"]\n\tproxy = socks5://127.0.0.1:7890\n[https \"https://github.com\"]\n\tproxy = socks5://127.0.0.1:7890\n\n\n或者终端执行：\n\ngit config --global http.https://github.com.proxy socks5://127.0.0.1:7890\ngit config --global https.https://github.com.proxy socks5://127.0.0.1:7890\n\n\n~/.ssh/config（config 前面没有点） 配置文件写入：\n\n# gitee\nhost gitee.com\nhostname gitee.com\npreferredauthentications publickey\nidentityfile ~/.ssh/gitee_id_rsa\n# github\nhost github.com\nhostname github.com\npreferredauthentications publickey\nidentityfile ~/.ssh/github_id_rsa\nproxycommand nc -v -x 127.0.0.1:7890 %h %p\n\n\nmacos 给 git(github) 设置代理（http/ssh）\n\n\n# 使用\n\n\n# 生成版本\n\n * git init:在项目中初始化 git，让 git 管理当前项目\n * git status:检查当前文件状态，需要经常使用 -git add <file1> <file2> ...:将工作区的指定内容添加到暂存区\n * git add . :将工作区的内容一起添加到暂存区\n\ngit add\n\n使用 git add 后，工作区和暂存区的内容是一致的\n\n工作区和暂存区内容不一致的时候，需要通过 git add，让它们内容一致\n\n只要工作区的文件有变动，就需要将工作区的变动添加到暂存区\n\n * git commit -m '描述消息'：将暂存区的内容提交到本地仓库，生成版本\n\ngit commit\n\ngit commit 后，暂存区和本地版本库的内容是一致的\n\n暂存区和本地版本库内容不一致的时候，需要通过 git commit ，让它们内容一致\n\n * git log ：查看提交内容\n * git log --oneline：以一行的方式查看提交记录\n\n\n\n\n# 重置版本\n\n * git reset --soft 版本号：仅重置本地仓库\n\n * git reset --mixed 版本号：重置本地仓库和暂存区，默认行为\n\n * git reset --hard 版本号：重置本地仓库、暂存区和工作目录 --hard 危险，会覆盖正在开发的代码\n\n * git reflog:可以查看所有记录，包括被\"丢弃\"的版本\n\n * git log:查看提交记录，不包括被\"丢弃\"的版本\n\n\n# git忽略文件---.gitignore\n\n * #：注释\n * test.html:忽略指定文件，不让git管理\n * test.*：忽略所有文件名是test的文件，不管后缀是什么\n * *.tmp：忽略所有后缀是.tmp的文件，不管文件名是什么\n * node_modules/:忽略node_modules目录下的所有文件\n * git管理的是文件，空目录会自动忽略\n\n\n# git分支\n\n\n# 创建和切换分支\n\ncheckout\n\ncheckout=>签出操作(webstrom)\n\n * git branch:查看分支\n * git branch-v:查看分支（展示的信息多一些）\n * git branch 分支名：在当前分支的节点上创建新的分支\n * git checkout 分支名：切换分支，兼容性好\n * git switch 分支名：切换分支，v2.23.0版及以后可用\n\n\n# 合并和删除分支",charsets:{cjk:!0},lastUpdated:"2022年07月31日",lastUpdatedTimestamp:1659277691e3},{title:"homebrew",frontmatter:{title:"homebrew",sidebar:"auto",date:"2022/06/03 00:16:41",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/homebrew.html",relativePath:"开发工具/homebrew.md",key:"v-82023764",path:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/homebrew.html",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:34},{level:2,title:"报错",slug:"报错",normalizedTitle:"报错",charIndex:522},{level:2,title:"注意",slug:"注意",normalizedTitle:"注意",charIndex:813}],headersStr:"安装 报错 注意",content:'Homebrew 是一款 Mac OS 平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。例如 homebrew 可以快速安装 git,nvm,mysql,mongodb 等开发工具\n\n\n# 安装\n\nhomebrew使用脚本安装:\n\n 1. 国内脚本：🈶️莫名其妙的BUG\n\n/bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)"\n\n\n 2. 科学环境推荐官方脚本：\n\n/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"\n\n\n 3. mac，homebrew卸载脚本：\n\n/bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)"\n\n\n\n# 报错\n\nfatal: not in a git directory Error: Command failed with exit 128: git\n\n解决办法：执行 brew -v 命令看看是不是有两个提示，你的 homebrew-core 和 homebrew-cask 目录被 git 认为不是一个安全的目录，需要手动添加 git config --global --add safe.directory 你的 homebrew-core 路径 git config --global --add safe.directory 你的 homebrew-cask 路径\n\n\n# 注意\n\n提示\n\n使用 brew uninstall git 卸载软件只会卸载软件本身而不会同时卸载其依赖包，使用以下命令可完全卸载，并且不会影响到其他软件。需要挂梯子！\n\nbrew tap beeftornado/rmtree\n\n结束后执行如下命令即可完全卸载软件。\n\nbrew rmtree git\n\n * mysql:安装教程\n * git:brew install git\n * nvm: ( node 版本管理工具)brew install nvm,配置见 node 入门->node 基础,如何安装低版本 node\n * mongoDB:安装教程',normalizedContent:'homebrew 是一款 mac os 平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。例如 homebrew 可以快速安装 git,nvm,mysql,mongodb 等开发工具\n\n\n# 安装\n\nhomebrew使用脚本安装:\n\n 1. 国内脚本：🈶️莫名其妙的bug\n\n/bin/zsh -c "$(curl -fssl https://gitee.com/cunkai/homebrewcn/raw/master/homebrew.sh)"\n\n\n 2. 科学环境推荐官方脚本：\n\n/bin/bash -c "$(curl -fssl https://raw.githubusercontent.com/homebrew/install/head/install.sh)"\n\n\n 3. mac，homebrew卸载脚本：\n\n/bin/zsh -c "$(curl -fssl https://gitee.com/cunkai/homebrewcn/raw/master/homebrewuninstall.sh)"\n\n\n\n# 报错\n\nfatal: not in a git directory error: command failed with exit 128: git\n\n解决办法：执行 brew -v 命令看看是不是有两个提示，你的 homebrew-core 和 homebrew-cask 目录被 git 认为不是一个安全的目录，需要手动添加 git config --global --add safe.directory 你的 homebrew-core 路径 git config --global --add safe.directory 你的 homebrew-cask 路径\n\n\n# 注意\n\n提示\n\n使用 brew uninstall git 卸载软件只会卸载软件本身而不会同时卸载其依赖包，使用以下命令可完全卸载，并且不会影响到其他软件。需要挂梯子！\n\nbrew tap beeftornado/rmtree\n\n结束后执行如下命令即可完全卸载软件。\n\nbrew rmtree git\n\n * mysql:安装教程\n * git:brew install git\n * nvm: ( node 版本管理工具)brew install nvm,配置见 node 入门->node 基础,如何安装低版本 node\n * mongodb:安装教程',charsets:{cjk:!0},lastUpdated:"2022年06月05日",lastUpdatedTimestamp:1654439564e3},{title:"Babel",frontmatter:{title:"Babel",sidebarDepth:2,readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Babel.html",relativePath:"开发工具/前端工具/Babel.md",key:"v-40014b6e",path:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Babel.html",headers:[{level:2,title:"Babel 简介",slug:"babel-简介",normalizedTitle:"babel 简介",charIndex:48},{level:2,title:"使用 Babel 前的准备工作",slug:"使用-babel-前的准备工作",normalizedTitle:"使用 babel 前的准备工作",charIndex:292},{level:2,title:"插件 plugins",slug:"插件-plugins",normalizedTitle:"插件 plugins",charIndex:654},{level:2,title:"Presets",slug:"presets",normalizedTitle:"presets",charIndex:986},{level:2,title:"babel.config.js 配置文件",slug:"babel-config-js-配置文件",normalizedTitle:"babel.config.js 配置文件",charIndex:1556},{level:2,title:"Polyfill",slug:"polyfill",normalizedTitle:"polyfill",charIndex:1926}],headersStr:"Babel 简介 使用 Babel 前的准备工作 插件 plugins Presets babel.config.js 配置文件 Polyfill",content:"参考\n\n【建议改成】读完这篇你还不懂 Babel 我给你寄口罩\n\nBabel 中文文档\n\n\n# Babel 简介\n\nBabel 是 JavaScript 的编译器，用来将 ES6 的代码，转换成 ES6 之前的代码\n\nBabel 本身可以编译 ES6 的大部分语法，比如 let、const、箭头函数、类\n\n但是对于 ES6 新增的 API，比如 Set、Map、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign/Array.from）都不能直接编译，需要借助其它的模块\n\nBabel 一般需要配合 webpack 来编译模块语法\n\n\n# 使用 Babel 前的准备工作\n\n 1. 安装 Node.js 和 npm\n\n 2. 初始化项目：npm init\n\n 3. 安装 Babel\n\nnpm install --save-dev @babel/core @babel/cli\n\n提示\n\n@babel/core 是 Babel 的核心模块.\n\n@babel/cli, 它是一个终端运行工具, 内置的插件,运行你从终端使用 babel 的工具.\n\n 4. 在 package.json 文件中添加执行 babel 的命令\n\n \"scripts\": {\n    \"build\":\"babel src -d dist\"\n  }\n\n\n这段语句的意思是: 它使用我们设置的解析方式来解析src目录下的所有 JS 文件, 并将转换后的每个文件都输出到dist目录下.\n\n\n# 插件 plugins\n\n插件plugins, 它的本质就是一个 JS 程序, 指示着 Babel 如何对代码进行转换.\n\n如果你是要将 ES6+转成 ES5, 可以依赖官方插件, 例如:\n\n@babel/plugin-transform-arrow-functions:npm i --save-dev @babel/plugin-transform-arrow-functions\n\n这个插件的作用是将箭头函数转换为 ES5 兼容的函数\n\n虽然我们已经实现了箭头函数转换的功能, 但是 ES6+其它的语法却并不能转换, 这是因为我们只使用了@babel/plugin-transform-arrow-functions这个功能插件, 没有使用其它的了.\n\n\n# Presets\n\n如果想要转换 ES6+的其它代码为 ES5, 我们可以使用\"preset\"来代替预先设定的一组插件, 而不是逐一添加我们想要的所有插件.\n\n这里可以理解为一个 preset 就是一组插件的集合.\n\n@babel/preset-env\n\n例如, 我们使用env preset，env preset这个 preset 包括支持现代 JavaScript(ES6+)的所有插件.\n\n安装： npm i --save-dev @babel/preset-env\n\n所以也就是说你安装使用了env preset之后, 就可以看到其它 ES6+语法的转换了.\n\n现在让我们来用用 ES7 中的求幂运算符和函数参数支持尾部逗号这两个功能吧:\n\nconst fn = () => 1 // ES6箭头函数, 返回值为1\nlet num = 3 ** 2 // ES7求幂运算符\nlet foo = function (a, b, c) {\n    // ES7参数支持尾部逗号\n    console.log('a:', a)\n    console.log('b:', b)\n    console.log('c:', c)\n}\nfoo(1, 3, 4)\nconsole.log(fn())\nconsole.log(num)\n\n\n\n# babel.config.js 配置文件\n\n配置\n\nconst presets = [\n    [\n        '@babel/env',\n        {\n            targets: {\n                edge: '17',\n                chrome: '64',\n                firefox: '60',\n                safari: '11.1',\n            },\n        },\n    ],\n]\n\nmodule.exports = { presets }\n\n\n加上这个配置的作用是:\n\n * 使用了env preset这个 preset\n * env preset只会为目标浏览器中没有的功能加载转换插件\n\n\n# Polyfill\n\nPlugins 是提供的插件, 例如箭头函数转普通函数@babel/plugin-transform-arrow-functions\n\nPresets 是一组 Plugins 的集合.\n\n而 Polyfill 是对执行环境或者其它功能的一个补充.\n\n就像现在你想在 edge10 浏览器中使用 ES7 中的方法includes(), 但是我们知道这个版本的浏览器环境是不支持你使用这个方法的, 所以如果你强行使用并不能达到预期的效果.\n\n而 polyfill 的作用正是如此, 知道你的环境不允许, 那就帮你引用一个这个环境, 也就是说此时编译后的代码就会变成这样:\n\n// 原来的代码\nvar hasTwo = [1, 2, 3].includes(2)\n\n// 加了polyfill之后的代码\nrequire('core-js/modules/es7.array.includes')\nrequire('core-js/modules/es6.string.includes')\nvar hasTwo = [1, 2, 3].includes(2)\n\n\n@babel/polyfill用来模拟完成 ES6+环境:\n\n * 可以使用像 Promise 或者 WeakMap 这样的新内置函数\n\n * 可以使用像 Array.from 或者 Object.assign 这样的静态方法\n\n * 可以使用像 Array.prototype.includes 这样的实例方法\n\n * 还有 generator 函数\n\n安装： npm i --save @babel/polyfill (注意 --save 选项而不是 --save-dev，因为这是一个需要在源代码之前运行的 polyfill。)\n\n由于我们使用的是 envpreset, 这里个配置中有一个叫做 \"useBuiltIns\"的选项\n\n如果将这个选择设置为\"usage\", 就只包括你需要的 polyfill\n\n安装配置了@babel/polyfill, Babel 将检查你的所有代码, 然后查找目标环境中缺少的功能, 并引入仅包含所需的 polyfill\n\n使用 Edge17 中没有的 Promise.prototype.finally:\n\nconst presets = [\n    [\n        '@babel/env',\n        {\n            targets: {\n                edge: '17',\n                chrome: '64',\n                firefox: '67',\n                safari: '11.1',\n            },\n            useBuiltIns: 'usage',\n        },\n    ],\n]\n\nmodule.exports = { presets }\n\n\n@babel/polyfill 的 polypill, 其实它在 Babel7.4.0 以上已经不被推荐使用了.\n\n而是推荐使用core-js@3+@babel/preset-env然后设置@babel/preset-env的corejs选项为3.\n\n安装：npm i --save core-js@3\n\n添加corejs选项:\n\nconst presets = [\n    [\n        '@babel/env',\n        {\n            targets: {\n                edge: '17',\n                chrome: '64',\n                firefox: '67',\n                safari: '11.1',\n            },\n            useBuiltIns: 'usage',\n            corejs: 3,\n        },\n    ],\n]\n\nmodule.exports = { presets }\n",normalizedContent:"参考\n\n【建议改成】读完这篇你还不懂 babel 我给你寄口罩\n\nbabel 中文文档\n\n\n# babel 简介\n\nbabel 是 javascript 的编译器，用来将 es6 的代码，转换成 es6 之前的代码\n\nbabel 本身可以编译 es6 的大部分语法，比如 let、const、箭头函数、类\n\n但是对于 es6 新增的 api，比如 set、map、promise 等全局对象，以及一些定义在全局对象上的方法（比如 object.assign/array.from）都不能直接编译，需要借助其它的模块\n\nbabel 一般需要配合 webpack 来编译模块语法\n\n\n# 使用 babel 前的准备工作\n\n 1. 安装 node.js 和 npm\n\n 2. 初始化项目：npm init\n\n 3. 安装 babel\n\nnpm install --save-dev @babel/core @babel/cli\n\n提示\n\n@babel/core 是 babel 的核心模块.\n\n@babel/cli, 它是一个终端运行工具, 内置的插件,运行你从终端使用 babel 的工具.\n\n 4. 在 package.json 文件中添加执行 babel 的命令\n\n \"scripts\": {\n    \"build\":\"babel src -d dist\"\n  }\n\n\n这段语句的意思是: 它使用我们设置的解析方式来解析src目录下的所有 js 文件, 并将转换后的每个文件都输出到dist目录下.\n\n\n# 插件 plugins\n\n插件plugins, 它的本质就是一个 js 程序, 指示着 babel 如何对代码进行转换.\n\n如果你是要将 es6+转成 es5, 可以依赖官方插件, 例如:\n\n@babel/plugin-transform-arrow-functions:npm i --save-dev @babel/plugin-transform-arrow-functions\n\n这个插件的作用是将箭头函数转换为 es5 兼容的函数\n\n虽然我们已经实现了箭头函数转换的功能, 但是 es6+其它的语法却并不能转换, 这是因为我们只使用了@babel/plugin-transform-arrow-functions这个功能插件, 没有使用其它的了.\n\n\n# presets\n\n如果想要转换 es6+的其它代码为 es5, 我们可以使用\"preset\"来代替预先设定的一组插件, 而不是逐一添加我们想要的所有插件.\n\n这里可以理解为一个 preset 就是一组插件的集合.\n\n@babel/preset-env\n\n例如, 我们使用env preset，env preset这个 preset 包括支持现代 javascript(es6+)的所有插件.\n\n安装： npm i --save-dev @babel/preset-env\n\n所以也就是说你安装使用了env preset之后, 就可以看到其它 es6+语法的转换了.\n\n现在让我们来用用 es7 中的求幂运算符和函数参数支持尾部逗号这两个功能吧:\n\nconst fn = () => 1 // es6箭头函数, 返回值为1\nlet num = 3 ** 2 // es7求幂运算符\nlet foo = function (a, b, c) {\n    // es7参数支持尾部逗号\n    console.log('a:', a)\n    console.log('b:', b)\n    console.log('c:', c)\n}\nfoo(1, 3, 4)\nconsole.log(fn())\nconsole.log(num)\n\n\n\n# babel.config.js 配置文件\n\n配置\n\nconst presets = [\n    [\n        '@babel/env',\n        {\n            targets: {\n                edge: '17',\n                chrome: '64',\n                firefox: '60',\n                safari: '11.1',\n            },\n        },\n    ],\n]\n\nmodule.exports = { presets }\n\n\n加上这个配置的作用是:\n\n * 使用了env preset这个 preset\n * env preset只会为目标浏览器中没有的功能加载转换插件\n\n\n# polyfill\n\nplugins 是提供的插件, 例如箭头函数转普通函数@babel/plugin-transform-arrow-functions\n\npresets 是一组 plugins 的集合.\n\n而 polyfill 是对执行环境或者其它功能的一个补充.\n\n就像现在你想在 edge10 浏览器中使用 es7 中的方法includes(), 但是我们知道这个版本的浏览器环境是不支持你使用这个方法的, 所以如果你强行使用并不能达到预期的效果.\n\n而 polyfill 的作用正是如此, 知道你的环境不允许, 那就帮你引用一个这个环境, 也就是说此时编译后的代码就会变成这样:\n\n// 原来的代码\nvar hastwo = [1, 2, 3].includes(2)\n\n// 加了polyfill之后的代码\nrequire('core-js/modules/es7.array.includes')\nrequire('core-js/modules/es6.string.includes')\nvar hastwo = [1, 2, 3].includes(2)\n\n\n@babel/polyfill用来模拟完成 es6+环境:\n\n * 可以使用像 promise 或者 weakmap 这样的新内置函数\n\n * 可以使用像 array.from 或者 object.assign 这样的静态方法\n\n * 可以使用像 array.prototype.includes 这样的实例方法\n\n * 还有 generator 函数\n\n安装： npm i --save @babel/polyfill (注意 --save 选项而不是 --save-dev，因为这是一个需要在源代码之前运行的 polyfill。)\n\n由于我们使用的是 envpreset, 这里个配置中有一个叫做 \"usebuiltins\"的选项\n\n如果将这个选择设置为\"usage\", 就只包括你需要的 polyfill\n\n安装配置了@babel/polyfill, babel 将检查你的所有代码, 然后查找目标环境中缺少的功能, 并引入仅包含所需的 polyfill\n\n使用 edge17 中没有的 promise.prototype.finally:\n\nconst presets = [\n    [\n        '@babel/env',\n        {\n            targets: {\n                edge: '17',\n                chrome: '64',\n                firefox: '67',\n                safari: '11.1',\n            },\n            usebuiltins: 'usage',\n        },\n    ],\n]\n\nmodule.exports = { presets }\n\n\n@babel/polyfill 的 polypill, 其实它在 babel7.4.0 以上已经不被推荐使用了.\n\n而是推荐使用core-js@3+@babel/preset-env然后设置@babel/preset-env的corejs选项为3.\n\n安装：npm i --save core-js@3\n\n添加corejs选项:\n\nconst presets = [\n    [\n        '@babel/env',\n        {\n            targets: {\n                edge: '17',\n                chrome: '64',\n                firefox: '67',\n                safari: '11.1',\n            },\n            usebuiltins: 'usage',\n            corejs: 3,\n        },\n    ],\n]\n\nmodule.exports = { presets }\n",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"Mock.js",frontmatter:{title:"Mock.js",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Mock.js.html",relativePath:"开发工具/前端工具/Mock.js.md",key:"v-d895e9e4",path:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Mock.js.html",headersStr:null,content:"写在前面\n\nMock.js is a simulation data generator to help the front-end to develop and prototype separate from the back-end progress and reduce some monotony particularly while writing automated tests.\n\n本文档是本人在学习使用过程中的笔记记录，如有问题，欢迎批评指正\n\n官方网站",normalizedContent:"写在前面\n\nmock.js is a simulation data generator to help the front-end to develop and prototype separate from the back-end progress and reduce some monotony particularly while writing automated tests.\n\n本文档是本人在学习使用过程中的笔记记录，如有问题，欢迎批评指正\n\n官方网站",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"webpack",frontmatter:{title:"webpack",sidebarDepth:2,readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Webpack.html",relativePath:"开发工具/前端工具/Webpack.md",key:"v-7201f9e4",path:"/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/Webpack.html",headersStr:null,content:"待整理学习....",normalizedContent:"待整理学习....",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"CSS关于deep的用法",frontmatter:{title:"CSS关于deep的用法",date:"2022/07/21 13:14:12",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/CSS%E5%85%B3%E4%BA%8Edeep%E7%9A%84%E7%94%A8%E6%B3%95.html",relativePath:"开发记录/CSS/CSS关于deep的用法.md",key:"v-5c684536",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/CSS%E5%85%B3%E4%BA%8Edeep%E7%9A%84%E7%94%A8%E6%B3%95.html",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022年07月31日",lastUpdatedTimestamp:1659277691e3},{title:"CSS文本溢出处理方式",frontmatter:{title:"CSS文本溢出处理方式",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/CSS%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F.html",relativePath:"开发记录/CSS/CSS文本溢出处理方式.md",key:"v-cfd1bbbe",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/CSS%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F.html",headers:[{level:2,title:"单行文本溢出省略号效果",slug:"单行文本溢出省略号效果",normalizedTitle:"单行文本溢出省略号效果",charIndex:2},{level:2,title:"指定 N 行文字溢出省略号效果（以 4 行为例）",slug:"指定-n-行文字溢出省略号效果-以-4-行为例",normalizedTitle:"指定 n 行文字溢出省略号效果（以 4 行为例）",charIndex:116}],headersStr:"单行文本溢出省略号效果 指定 N 行文字溢出省略号效果（以 4 行为例）",content:"# 单行文本溢出省略号效果\n\n.ellipsis {\n    　　overflow: hidden;\n    　　white-space: nowrap;\n    　　text-overflow: ellipsis;\n}\n\n\n\n# 指定 N 行文字溢出省略号效果（以 4 行为例）\n\n因使用了 WebKit 的 CSS 扩展属性，适用于 WebKit 浏览器及移动端\n\nellipsis_four {\n    　　display: -webkit-box;\n    　　-webkit-line-clamp: 4;\n    　　-webkit-box-orient: vertical;\n    　　overflow: hidden;\n}\n\n\n提示\n\n-webkit-line-clamp 用来限制在一个块元素显示的文本的行数。为了实现该效果，它需要组合其他的 WebKit 属性。\n\n常见结合属性：\n\ndisplay: -webkit-box 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示\n\n-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式",normalizedContent:"# 单行文本溢出省略号效果\n\n.ellipsis {\n    　　overflow: hidden;\n    　　white-space: nowrap;\n    　　text-overflow: ellipsis;\n}\n\n\n\n# 指定 n 行文字溢出省略号效果（以 4 行为例）\n\n因使用了 webkit 的 css 扩展属性，适用于 webkit 浏览器及移动端\n\nellipsis_four {\n    　　display: -webkit-box;\n    　　-webkit-line-clamp: 4;\n    　　-webkit-box-orient: vertical;\n    　　overflow: hidden;\n}\n\n\n提示\n\n-webkit-line-clamp 用来限制在一个块元素显示的文本的行数。为了实现该效果，它需要组合其他的 webkit 属性。\n\n常见结合属性：\n\ndisplay: -webkit-box 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示\n\n-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"calc函数",frontmatter:{title:"calc函数",date:"2022/07/21 13:13:52",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/calc%E5%87%BD%E6%95%B0.html",relativePath:"开发记录/CSS/calc函数.md",key:"v-1d9f91d2",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/CSS/calc%E5%87%BD%E6%95%B0.html",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022年07月31日",lastUpdatedTimestamp:1659277691e3},{title:"Array.prototype.slice.call()&Array.from()的应用和理解",frontmatter:{title:"Array.prototype.slice.call()&Array.from()的应用和理解",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/Array.prototype.slice.call()&Array.from()%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3.html",relativePath:"开发记录/JS/Array.prototype.slice.call()&Array.from()的应用和理解.md",key:"v-03875860",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/Array.prototype.slice.call()&Array.from()%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E7%90%86%E8%A7%A3.html",headers:[{level:2,title:"Array.prototype.slice.call() 的常用示例",slug:"array-prototype-slice-call-的常用示例",normalizedTitle:"array.prototype.slice.call() 的常用示例",charIndex:150},{level:2,title:"Array.from() 的常用示例",slug:"array-from-的常用示例",normalizedTitle:"array.from() 的常用示例",charIndex:836},{level:3,title:"示例 1——将类数组转化为数组",slug:"示例-1-将类数组转化为数组",normalizedTitle:"示例 1——将类数组转化为数组",charIndex:957},{level:3,title:"示例 2——将 Set 集合转化为数组",slug:"示例-2-将-set-集合转化为数组",normalizedTitle:"示例 2——将 set 集合转化为数组",charIndex:1198},{level:3,title:"示例 3——将 map 集合转化为数组",slug:"示例-3-将-map-集合转化为数组",normalizedTitle:"示例 3——将 map 集合转化为数组",charIndex:1328}],headersStr:"Array.prototype.slice.call() 的常用示例 Array.from() 的常用示例 示例 1——将类数组转化为数组 示例 2——将 Set 集合转化为数组 示例 3——将 map 集合转化为数组",content:"Array.prototype.slice.call() 可将类数组(arguments,NodeList)，字符串(String)转换成数组。\n\nArray.from() 可将类数组(arguments,NodeList)，可迭代对象(Set,Map)，字符串(String)转换成数组。\n\n\n# Array.prototype.slice.call() 的常用示例\n\nArray.prototype.slice.call(arrayLike, start, end) 将类数组 arrayLike 转换为数组，并且从下标 start 开始到下标为 end 截取数组。\n\nfunction makeArray (arrayLike) {\n    return Array.prototype.slice.call(arrayLike);\n}\nfunction doSomething() {\n    var args = makeArray(arguments);\n    // 使用args\n    ...\n}\n\n\n上述示例中，将 slice()方法执行时的 this 值设置为类数组对象(arguments)，而 slice()对象只需是数值型索引和 length 属性就能够正常运行，即任何类数组对象(arguments)都能被转换为数组, 例如下面对象就可转换为数组：\n\nvar obj = { 0: 'hello', 1: 'world', length: 2 }\nconsole.log(Array.prototype.slice.call(obj)) // [\"hello\", \"world\"]\n\n\n而没有 length 属性的对象则不能\n\nvar obj = { 0: 'hello', 1: 'world' } // 没有length属性\nconsole.log(Array.prototype.slice.call(obj)) // []\n\n\n\n# Array.from() 的常用示例\n\nArray.from()\n\nArray.from(arrayLike, mapFn, thisArg) --\x3e Array.from(arrayLike).map(fn(), thisArg)\n\n\n# 示例 1——将类数组转化为数组\n\nfunction doSomething () {\n    var args = Array.from(arguments);\n    // 使用args\n    ...\n}\n\n\n此方法为 ECMAScript6 新方法，更简洁清晰的将类数组对象转化为数组。\n\nArray.from()方法调用会基于 arguments 对象中的元素创建一个新的数组，args 是 Array 的一个实例，包含 arguments 对象中同位置的相同值。\n\n\n# 示例 2——将 Set 集合转化为数组\n\nlet arr = [1,2,3,4,5,6,7,8,9]\nlet set = new Set(arr)\nconsole.log(Array.from(set) // [1,2,3,4,5,6,7,8,9]\n\n\n\n# 示例 3——将 map 集合转化为数组\n\nconst myMap = new Map().set(true, 7)\nconsole.log(myMap) // Map(1) {true => 7}\nconsole.log(Array.from(myMap)) // [[true,7]]\n// 如需变为一维数组可\nconsole.log(Array.from(myMap).flat()) // [true ,7]\n\n\n版权声明\n\n作者：黑桃 z18889 链接：https://juejin.cn/post/6844904106159505421 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",normalizedContent:"array.prototype.slice.call() 可将类数组(arguments,nodelist)，字符串(string)转换成数组。\n\narray.from() 可将类数组(arguments,nodelist)，可迭代对象(set,map)，字符串(string)转换成数组。\n\n\n# array.prototype.slice.call() 的常用示例\n\narray.prototype.slice.call(arraylike, start, end) 将类数组 arraylike 转换为数组，并且从下标 start 开始到下标为 end 截取数组。\n\nfunction makearray (arraylike) {\n    return array.prototype.slice.call(arraylike);\n}\nfunction dosomething() {\n    var args = makearray(arguments);\n    // 使用args\n    ...\n}\n\n\n上述示例中，将 slice()方法执行时的 this 值设置为类数组对象(arguments)，而 slice()对象只需是数值型索引和 length 属性就能够正常运行，即任何类数组对象(arguments)都能被转换为数组, 例如下面对象就可转换为数组：\n\nvar obj = { 0: 'hello', 1: 'world', length: 2 }\nconsole.log(array.prototype.slice.call(obj)) // [\"hello\", \"world\"]\n\n\n而没有 length 属性的对象则不能\n\nvar obj = { 0: 'hello', 1: 'world' } // 没有length属性\nconsole.log(array.prototype.slice.call(obj)) // []\n\n\n\n# array.from() 的常用示例\n\narray.from()\n\narray.from(arraylike, mapfn, thisarg) --\x3e array.from(arraylike).map(fn(), thisarg)\n\n\n# 示例 1——将类数组转化为数组\n\nfunction dosomething () {\n    var args = array.from(arguments);\n    // 使用args\n    ...\n}\n\n\n此方法为 ecmascript6 新方法，更简洁清晰的将类数组对象转化为数组。\n\narray.from()方法调用会基于 arguments 对象中的元素创建一个新的数组，args 是 array 的一个实例，包含 arguments 对象中同位置的相同值。\n\n\n# 示例 2——将 set 集合转化为数组\n\nlet arr = [1,2,3,4,5,6,7,8,9]\nlet set = new set(arr)\nconsole.log(array.from(set) // [1,2,3,4,5,6,7,8,9]\n\n\n\n# 示例 3——将 map 集合转化为数组\n\nconst mymap = new map().set(true, 7)\nconsole.log(mymap) // map(1) {true => 7}\nconsole.log(array.from(mymap)) // [[true,7]]\n// 如需变为一维数组可\nconsole.log(array.from(mymap).flat()) // [true ,7]\n\n\n版权声明\n\n作者：黑桃 z18889 链接：https://juejin.cn/post/6844904106159505421 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"关于async和await",frontmatter:{title:"关于async和await",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E5%85%B3%E4%BA%8Easync%E5%92%8Cawait.html",relativePath:"开发记录/JS/关于async和await.md",key:"v-43456df0",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E5%85%B3%E4%BA%8Easync%E5%92%8Cawait.html",headers:[{level:2,title:"发现问题",slug:"发现问题",normalizedTitle:"发现问题",charIndex:2},{level:2,title:"问题分析",slug:"问题分析",normalizedTitle:"问题分析",charIndex:249},{level:2,title:"备注",slug:"备注",normalizedTitle:"备注",charIndex:1253},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:1951}],headersStr:"发现问题 问题分析 备注 参考文章",content:"# 发现问题\n\n某天吃饭，刷到这样一道题\n\nasync function getData() {\n    return await Promise.resolve('I made it!')\n}\nconst data = getData()\nconsole.log(data)\n\n\n问输出结果是什么？我想这也太简单了，肯定是返回一个成功状态的 Promise 啊，一看答案我傻了，居然是一个未解决的 Promise.\n\n最后我好好想了想，之前的理解一直是错的。看了几篇大牛的文章，我学废了\n\n\n# 问题分析\n\n看回上面那段代码，async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。 当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。但是最重要的一点是异步函数 async 始终返回一个 promise。其实这段代码这样写可能更好理解：\n\nasync function getData() {\n    const res = await Promise.resolve('I made it!')\n    return res\n}\nconst data = getData()\nconsole.log(data)\n\n\n当调用getData()的时候，遇到了await那么就会暂停在这一行，等待后面的Promise返回结果，getData()会先返回，此时返回的肯定是一个Promise，而且是等待状态的。接着执行调用getData()之后（async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个Promise 对象中异步执行）的代码，那么这行代码console.log(data)便会紧跟着执行,此时打印的结果肯定是一个处于等待状态的Promise。\n\ndata.then(res => console.log(res)) // I made it!\n\n\n这段代码可能也会让人困惑：\n\nasync function getData() {\n    console.log('async执行开始')\n    return await Promise.resolve('123')\n}\nconst data = getData()\nconsole.log(data)\nconst c = data.then(res => {\n    console.log(res)\n})\nconsole.log(c) // 这里也打印的是一个等待状态的Promise\n\n\n其实是一样的，分析以下这段代码的执行顺序：调用 getData(),打印async执行开始,遇到 await，先返回。打印 data,一个等待状态的 Promise，先执行同步代码，打印 c,结果一样。返回去执行异步任务，先清掉所有微任务，async 返回了成功状态的 Promise 且参数为123,接着执行 then 里面的代码，打印出123\n\n\n# 备注\n\nasync 函数和普通 函数没有什么不同，他只是表示这个函数里有异步操作的方法，并返回一个Promise 对象 翻译过来其实就是：\n\n// async/await 写法\nasync function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\n// Promise 写法\nasync function async1() {\n    console.log('async1 start')\n    // 如果传入的参数是Promise对象，则参数的结果决定了Promise.resolve()的结果\n    Promise.resolve(async2()).then(() => console.log('async1 end'))\n}\n\nasync function async2() {\n    console.log('async2')\n}\n\n\n显然，await后面的代码，实际上相当于Promise中then里面的代码\n\nawait 会暂停代码在该行上，直到 promise 完成，然后返回结果值。在暂停的同时，其他正在等待执行的代码就有机会执行了。\n\n如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。\n\n还有一点就是如果 async 函数没有返回值，又该如何？很容易想到，它会返回 Promise.resolve(undefined)\n\n\n# 参考文章\n\n * await MDN 文档\n\n * async 和 await:让异步编程更简单\n\n * 理解 JavaScript 的 async/await\n\n * 每日一题（五）async\n\n * async 函数的含义和用法(阮一峰)\n\n * 一次搞懂- JS 事件循环之宏任务和微任务",normalizedContent:"# 发现问题\n\n某天吃饭，刷到这样一道题\n\nasync function getdata() {\n    return await promise.resolve('i made it!')\n}\nconst data = getdata()\nconsole.log(data)\n\n\n问输出结果是什么？我想这也太简单了，肯定是返回一个成功状态的 promise 啊，一看答案我傻了，居然是一个未解决的 promise.\n\n最后我好好想了想，之前的理解一直是错的。看了几篇大牛的文章，我学废了\n\n\n# 问题分析\n\n看回上面那段代码，async 函数返回一个 promise 对象，可以使用 then 方法添加回调函数。 当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。但是最重要的一点是异步函数 async 始终返回一个 promise。其实这段代码这样写可能更好理解：\n\nasync function getdata() {\n    const res = await promise.resolve('i made it!')\n    return res\n}\nconst data = getdata()\nconsole.log(data)\n\n\n当调用getdata()的时候，遇到了await那么就会暂停在这一行，等待后面的promise返回结果，getdata()会先返回，此时返回的肯定是一个promise，而且是等待状态的。接着执行调用getdata()之后（async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个promise 对象中异步执行）的代码，那么这行代码console.log(data)便会紧跟着执行,此时打印的结果肯定是一个处于等待状态的promise。\n\ndata.then(res => console.log(res)) // i made it!\n\n\n这段代码可能也会让人困惑：\n\nasync function getdata() {\n    console.log('async执行开始')\n    return await promise.resolve('123')\n}\nconst data = getdata()\nconsole.log(data)\nconst c = data.then(res => {\n    console.log(res)\n})\nconsole.log(c) // 这里也打印的是一个等待状态的promise\n\n\n其实是一样的，分析以下这段代码的执行顺序：调用 getdata(),打印async执行开始,遇到 await，先返回。打印 data,一个等待状态的 promise，先执行同步代码，打印 c,结果一样。返回去执行异步任务，先清掉所有微任务，async 返回了成功状态的 promise 且参数为123,接着执行 then 里面的代码，打印出123\n\n\n# 备注\n\nasync 函数和普通 函数没有什么不同，他只是表示这个函数里有异步操作的方法，并返回一个promise 对象 翻译过来其实就是：\n\n// async/await 写法\nasync function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\n// promise 写法\nasync function async1() {\n    console.log('async1 start')\n    // 如果传入的参数是promise对象，则参数的结果决定了promise.resolve()的结果\n    promise.resolve(async2()).then(() => console.log('async1 end'))\n}\n\nasync function async2() {\n    console.log('async2')\n}\n\n\n显然，await后面的代码，实际上相当于promise中then里面的代码\n\nawait 会暂停代码在该行上，直到 promise 完成，然后返回结果值。在暂停的同时，其他正在等待执行的代码就有机会执行了。\n\n如果在函数中 return 一个直接量，async 会把这个直接量通过 promise.resolve() 封装成 promise 对象。\n\n还有一点就是如果 async 函数没有返回值，又该如何？很容易想到，它会返回 promise.resolve(undefined)\n\n\n# 参考文章\n\n * await mdn 文档\n\n * async 和 await:让异步编程更简单\n\n * 理解 javascript 的 async/await\n\n * 每日一题（五）async\n\n * async 函数的含义和用法(阮一峰)\n\n * 一次搞懂- js 事件循环之宏任务和微任务",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"js的严格模式",frontmatter:{title:"js的严格模式",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/js%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html",relativePath:"开发记录/JS/js的严格模式.md",key:"v-27816f24",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/js%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html",headersStr:null,content:"JavaScript 中除了正常运行模式（非严格模式），还有一种严格模式（strict mode），顾名思义，这种模式使得 JavaScript 在更严格的模式下运行\n\n严格模式消除了 JavaScript 语法的一些不合理、不严谨之处，减少一些怪异行为。 消除代码运行一些不安全之处，保证代码运行的安全。 提高代码编译效率，增加运行速度。 为未来新版本的 JavaScript 做好铺垫。\n\n开启严格模式：\n\n1、为整个脚本开启严格模式，需要在所有语句之前放一个特定语句\"use strict\"\n\n2、为函数开启严格模式，把\"use strict\"声明放在函数体的所有语句之前\n\n严格模式与非严格模式（正常运行模式）的常见区别:\n\n(1) 在非严格模式中，如果一个变量没有声明就赋值，默认是全局变量，不会出现报错。严格模式禁止这种用法，添加\"use strict\"开启严格模式后，会出现报错\n\n'use strict'\nnum = 1 //Uncaught ReferenceError: num is not defined\n\n\n(2) 在非严格模式中，全局作用域中的函数内部 this 默认指向 window,在严格模式中，全局作用域中的函数内部 this 默认指向 undefined\n\nfunction fn() {\n    console.log(this) // window\n}\nfn()\n\n\nfunction fn() {\n    'use strict'\n    console.log(this) // undefined\n}\nfn()\n\n\n(3) 非严格模式下，允许重复变量命名;在严格模式下，不允许重复变量命名\n\nfunction sum(a, a, c) {\n    return a + a + c\n}\n\n\n'use strict'\nfunction sum(a, a, c) {\n    // !!! 语法错误\n    return a + a + c // 代码运行到这里会出错\n}\n",normalizedContent:"javascript 中除了正常运行模式（非严格模式），还有一种严格模式（strict mode），顾名思义，这种模式使得 javascript 在更严格的模式下运行\n\n严格模式消除了 javascript 语法的一些不合理、不严谨之处，减少一些怪异行为。 消除代码运行一些不安全之处，保证代码运行的安全。 提高代码编译效率，增加运行速度。 为未来新版本的 javascript 做好铺垫。\n\n开启严格模式：\n\n1、为整个脚本开启严格模式，需要在所有语句之前放一个特定语句\"use strict\"\n\n2、为函数开启严格模式，把\"use strict\"声明放在函数体的所有语句之前\n\n严格模式与非严格模式（正常运行模式）的常见区别:\n\n(1) 在非严格模式中，如果一个变量没有声明就赋值，默认是全局变量，不会出现报错。严格模式禁止这种用法，添加\"use strict\"开启严格模式后，会出现报错\n\n'use strict'\nnum = 1 //uncaught referenceerror: num is not defined\n\n\n(2) 在非严格模式中，全局作用域中的函数内部 this 默认指向 window,在严格模式中，全局作用域中的函数内部 this 默认指向 undefined\n\nfunction fn() {\n    console.log(this) // window\n}\nfn()\n\n\nfunction fn() {\n    'use strict'\n    console.log(this) // undefined\n}\nfn()\n\n\n(3) 非严格模式下，允许重复变量命名;在严格模式下，不允许重复变量命名\n\nfunction sum(a, a, c) {\n    return a + a + c\n}\n\n\n'use strict'\nfunction sum(a, a, c) {\n    // !!! 语法错误\n    return a + a + c // 代码运行到这里会出错\n}\n",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"数组delete元素",frontmatter:{title:"数组delete元素",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84delete%E5%85%83%E7%B4%A0.html",relativePath:"开发记录/JS/数组delete元素.md",key:"v-e25d7d4c",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84delete%E5%85%83%E7%B4%A0.html",headersStr:null,content:"let arr = ['I', 'go', 'home']\n\ndelete arr[1] // remove \"go\"\n\nalert(arr[1]) // undefined\n\n// now arr = [\"I\",  , \"home\"];\nalert(arr.length) // 3\n\n\n使用 delete 删除指定索引号的数组元素后会发生什么？\n\n * 数组元素值消失\n * 通过索引号访问，得到 undefined\n * 数组长度不变",normalizedContent:"let arr = ['i', 'go', 'home']\n\ndelete arr[1] // remove \"go\"\n\nalert(arr[1]) // undefined\n\n// now arr = [\"i\",  , \"home\"];\nalert(arr.length) // 3\n\n\n使用 delete 删除指定索引号的数组元素后会发生什么？\n\n * 数组元素值消失\n * 通过索引号访问，得到 undefined\n * 数组长度不变",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"数组对象根据对象中指定的属性去重",frontmatter:{title:"数组对象根据对象中指定的属性去重",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%A0%B9%E6%8D%AE%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8E%BB%E9%87%8D.html",relativePath:"开发记录/JS/数组对象根据对象中指定的属性去重.md",key:"v-d81aa7ca",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%A0%B9%E6%8D%AE%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8E%BB%E9%87%8D.html",headersStr:null,content:"只有对象重复排重比较符合实际业务，毕竟后端的数据都是数组对象，业务很可能会出现根据 ID 来排重\n\nconst obj = [\n    {\n        name: 'frank',\n        age: 123,\n    },\n    {\n        name: 'chang',\n        age: 124,\n    },\n    {\n        name: 'chang',\n        age: 123,\n    },\n]\n// 使用filter和Map\nfunction uniqueFunc(arr, uniId) {\n    const res = new Map()\n    return arr.filter(item => !res.has(item[uniId]) && res.set(item[uniId], 1))\n}\n// 使用reduce\nfunction uniqueFunc2(arr, uniId) {\n    let hash = {}\n    return arr.reduce((accum, item) => {\n        if (!hash[item[uniId]]) {\n            hash[item[uniId]] = true\n            accum.push(item)\n        }\n        return accum\n    }, [])\n}\n// 使用for循环\nfunction uniqueFunc3(arr, uniId) {\n    let obj = {}\n    let tempArr = []\n    for (var i = 0; i < arr.length; i++) {\n        if (!obj[arr[i][uniId]]) {\n            tempArr.push(arr[i])\n            obj[arr[i][uniId]] = true\n        }\n    }\n    return tempArr\n}\n\nconst arr2 = uniqueFunc2(obj, 'age')\nconsole.log(arr2)\n\n\n纯数组:数组去重 12 种方案（经典面试必问）",normalizedContent:"只有对象重复排重比较符合实际业务，毕竟后端的数据都是数组对象，业务很可能会出现根据 id 来排重\n\nconst obj = [\n    {\n        name: 'frank',\n        age: 123,\n    },\n    {\n        name: 'chang',\n        age: 124,\n    },\n    {\n        name: 'chang',\n        age: 123,\n    },\n]\n// 使用filter和map\nfunction uniquefunc(arr, uniid) {\n    const res = new map()\n    return arr.filter(item => !res.has(item[uniid]) && res.set(item[uniid], 1))\n}\n// 使用reduce\nfunction uniquefunc2(arr, uniid) {\n    let hash = {}\n    return arr.reduce((accum, item) => {\n        if (!hash[item[uniid]]) {\n            hash[item[uniid]] = true\n            accum.push(item)\n        }\n        return accum\n    }, [])\n}\n// 使用for循环\nfunction uniquefunc3(arr, uniid) {\n    let obj = {}\n    let temparr = []\n    for (var i = 0; i < arr.length; i++) {\n        if (!obj[arr[i][uniid]]) {\n            temparr.push(arr[i])\n            obj[arr[i][uniid]] = true\n        }\n    }\n    return temparr\n}\n\nconst arr2 = uniquefunc2(obj, 'age')\nconsole.log(arr2)\n\n\n纯数组:数组去重 12 种方案（经典面试必问）",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"数组对象根据数据项状态属性如何筛选数据",frontmatter:{title:"数组对象根据数据项状态属性如何筛选数据",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%8A%B6%E6%80%81%E5%B1%9E%E6%80%A7%E5%A6%82%E4%BD%95%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE.html",relativePath:"开发记录/JS/数组对象根据数据项状态属性如何筛选数据.md",key:"v-3fe0e2ee",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%8A%B6%E6%80%81%E5%B1%9E%E6%80%A7%E5%A6%82%E4%BD%95%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE.html",headersStr:null,content:"比如一个小功能:需要计算当前已完成的项的数量？ 这时我们就需要数组中每一项的某个状态属性值去筛选\n\n在 vue 中往往使用计算属性去完成，这里使用数组三种不同的方法完成：\n\n// 统计当前已完成的数据项\n    doneSum() {\n      // ``````reduce`````\n      return this.todos.reduce((acc, cur) => {\n        return acc + (cur.done ? 1 : 0);\n      }, 0);\n      // ``````filter`````\n      const done  = this.todos.filter((todo)=>{\n        return todo.done==true\n      })\n      return done.length\n      // ````forEach`````\n        let i =0\n        this.todos.forEach(element => {\n            if(element.done==true){\n              i++\n            }\n        })\n        return i\n    },\n",normalizedContent:"比如一个小功能:需要计算当前已完成的项的数量？ 这时我们就需要数组中每一项的某个状态属性值去筛选\n\n在 vue 中往往使用计算属性去完成，这里使用数组三种不同的方法完成：\n\n// 统计当前已完成的数据项\n    donesum() {\n      // ``````reduce`````\n      return this.todos.reduce((acc, cur) => {\n        return acc + (cur.done ? 1 : 0);\n      }, 0);\n      // ``````filter`````\n      const done  = this.todos.filter((todo)=>{\n        return todo.done==true\n      })\n      return done.length\n      // ````foreach`````\n        let i =0\n        this.todos.foreach(element => {\n            if(element.done==true){\n              i++\n            }\n        })\n        return i\n    },\n",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"理解js事件循环",frontmatter:{title:"理解js事件循环",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E7%90%86%E8%A7%A3js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html",relativePath:"开发记录/JS/理解js事件循环.md",key:"v-29760d32",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E7%90%86%E8%A7%A3js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html",headersStr:null,content:" * 这一次，彻底弄懂 JavaScript 执行机制\n\n * 一次搞懂- JS 事件循环之宏任务和微任务\n\n * 10 分钟理解 JS 引擎的执行机制\n\n----------------------------------------\n\n\n\n任务队列的执行过程是：先执行一个宏任务，执行过程中如果产出新的宏/微任务，就将他们推入相应的任务队列，之后在执行一队微任务，之后再执行宏任务，如此循环。以上不断重复的过程就叫做 Event Loop(事件循环)。\n\n那些是宏任务？那些是微任务？\n\n * 宏任务主要包括：包括整体代码 script、setTimeout、setInterval...\n * 微任务主要包括：Promise.then...\n\n",normalizedContent:" * 这一次，彻底弄懂 javascript 执行机制\n\n * 一次搞懂- js 事件循环之宏任务和微任务\n\n * 10 分钟理解 js 引擎的执行机制\n\n----------------------------------------\n\n\n\n任务队列的执行过程是：先执行一个宏任务，执行过程中如果产出新的宏/微任务，就将他们推入相应的任务队列，之后在执行一队微任务，之后再执行宏任务，如此循环。以上不断重复的过程就叫做 event loop(事件循环)。\n\n那些是宏任务？那些是微任务？\n\n * 宏任务主要包括：包括整体代码 script、settimeout、setinterval...\n * 微任务主要包括：promise.then...\n\n",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"重新理解闭包",frontmatter:{title:"重新理解闭包",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85.html",relativePath:"开发记录/JS/重新理解闭包.md",key:"v-4a906e56",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/JS/%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85.html",headersStr:null,content:"闭包确实很难理解，之前我是这样理解的：\n\n闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。\n\n再后来看到这样一段话：\n\n在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量。而引用了自由变量的函数，就叫闭包。\n\n比如说：\n\nfunction fun() {\n    let a = 123\n    return function () {\n        console.log(a)\n    }\n}\nvar fuN = fun()\nfuN()\n\n\n没错，这样就形成了一个闭包。a 既不是函数的参数，也不是函数的局部变量，对于该函数来说 a 就是一个自由变量，这个函数就是闭包\n\n闭包使已经运行结束的函数上下文中的变量对象(每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上)继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n\n所以我们在调用完fun()函数之后，调用fuN()，依然可以打印出 a 的值",normalizedContent:"闭包确实很难理解，之前我是这样理解的：\n\n闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。\n\n再后来看到这样一段话：\n\n在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量。而引用了自由变量的函数，就叫闭包。\n\n比如说：\n\nfunction fun() {\n    let a = 123\n    return function () {\n        console.log(a)\n    }\n}\nvar fun = fun()\nfun()\n\n\n没错，这样就形成了一个闭包。a 既不是函数的参数，也不是函数的局部变量，对于该函数来说 a 就是一个自由变量，这个函数就是闭包\n\n闭包使已经运行结束的函数上下文中的变量对象(每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上)继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n\n所以我们在调用完fun()函数之后，调用fun()，依然可以打印出 a 的值",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"在Vue+koa项目中如何解决跨域和cookie问题",frontmatter:{title:"在Vue+koa项目中如何解决跨域和cookie问题",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Node/%E5%9C%A8Vuekoa%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E5%92%8Ccookie%E9%97%AE%E9%A2%98.html",relativePath:"开发记录/Node/在Vuekoa项目中如何解决跨域和cookie问题.md",key:"v-2eca1248",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Node/%E5%9C%A8Vuekoa%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E5%92%8Ccookie%E9%97%AE%E9%A2%98.html",headersStr:null,content:"Vue 中，要设置withCredentials请求中才能携带 cookie\n\nimport axios from 'axios'\nconst instance = axios.create({\n    baseURL: 'http://localhost:3000',\n    // 当前请求为跨域类型时,在请求中协带cookie\n    // 在做登录认证的时候，会出现请求未登录的情况，\n    // 查看请求头的时候发现并没有把登录时的cookie设置到第二次的请求头里面。\n    // 查看资料才知道跨域请求要想带上cookie，必须要在ajax请求里加上\n    withCredentials: true,\n})\nexport const get = (url, params = {}) => {\n    return new Promise((resolve, reject) => {\n        instance.get(url, { params }).then(\n            res => {\n                resolve(res.data)\n            },\n            err => {\n                reject(err)\n            }\n        )\n    })\n}\nexport const post = (url, data = {}) => {\n    return new Promise((resolve, reject) => {\n        instance\n            .post(url, data, {\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n            })\n            .then(\n                res => {\n                    resolve(res.data)\n                },\n                err => {\n                    reject(err)\n                }\n            )\n    })\n}\n\n\nkoa 中，安装koa2-cors中间件，\n\n// app.js\napp.use(\n    cors({\n        // origin: 'http://localhost:8081', // 支持前端哪个域，可以跨域\n        credentials: true, // 允许跨域的时候带着 cookie\n    })\n)\n\n\nsession 配置(安装koa-generic-session中间件)：\n\n// app.js\n// session\napp.keys = ['Frank@#%koa2%$test'] // 秘钥\napp.use(\n    session({\n        // 配置 cookie\n        cookie: {\n            path: '/', // cookie 在根目录下有效\n            httpOnly: true, // cookie 只允许服务端来操作\n            maxAge: 24 * 60 * 60 * 1000, // cookie 的过期时间\n        },\n    })\n)\n",normalizedContent:"vue 中，要设置withcredentials请求中才能携带 cookie\n\nimport axios from 'axios'\nconst instance = axios.create({\n    baseurl: 'http://localhost:3000',\n    // 当前请求为跨域类型时,在请求中协带cookie\n    // 在做登录认证的时候，会出现请求未登录的情况，\n    // 查看请求头的时候发现并没有把登录时的cookie设置到第二次的请求头里面。\n    // 查看资料才知道跨域请求要想带上cookie，必须要在ajax请求里加上\n    withcredentials: true,\n})\nexport const get = (url, params = {}) => {\n    return new promise((resolve, reject) => {\n        instance.get(url, { params }).then(\n            res => {\n                resolve(res.data)\n            },\n            err => {\n                reject(err)\n            }\n        )\n    })\n}\nexport const post = (url, data = {}) => {\n    return new promise((resolve, reject) => {\n        instance\n            .post(url, data, {\n                headers: {\n                    'content-type': 'application/json',\n                },\n            })\n            .then(\n                res => {\n                    resolve(res.data)\n                },\n                err => {\n                    reject(err)\n                }\n            )\n    })\n}\n\n\nkoa 中，安装koa2-cors中间件，\n\n// app.js\napp.use(\n    cors({\n        // origin: 'http://localhost:8081', // 支持前端哪个域，可以跨域\n        credentials: true, // 允许跨域的时候带着 cookie\n    })\n)\n\n\nsession 配置(安装koa-generic-session中间件)：\n\n// app.js\n// session\napp.keys = ['frank@#%koa2%$test'] // 秘钥\napp.use(\n    session({\n        // 配置 cookie\n        cookie: {\n            path: '/', // cookie 在根目录下有效\n            httponly: true, // cookie 只允许服务端来操作\n            maxage: 24 * 60 * 60 * 1000, // cookie 的过期时间\n        },\n    })\n)\n",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"记一次koa2项目部署过程",frontmatter:{title:"记一次koa2项目部署过程",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Node/%E8%AE%B0%E4%B8%80%E6%AC%A1koa2%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B.html",relativePath:"开发记录/Node/记一次koa2项目部署过程.md",key:"v-820a830c",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Node/%E8%AE%B0%E4%B8%80%E6%AC%A1koa2%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B.html",headers:[{level:2,title:"准备",slug:"准备",normalizedTitle:"准备",charIndex:2},{level:2,title:"安装软件",slug:"安装软件",normalizedTitle:"安装软件",charIndex:39},{level:2,title:"前端配置",slug:"前端配置",normalizedTitle:"前端配置",charIndex:85},{level:2,title:"后端配置",slug:"后端配置",normalizedTitle:"后端配置",charIndex:458}],headersStr:"准备 安装软件 前端配置 后端配置",content:"# 准备\n\n一台安装宝塔面板的centOS服务器,我的版本是 7.9\n\n\n# 安装软件\n\n之后在宝塔面板的软件商店：安装mongodb,nginx,pm2管理器\n\n\n# 前端配置\n\n在服务器/www/wwwroot目录下放入前端打包后代码\n\n\n\n然后配置nginx，随便在那个文件夹(我是在/www/wwwroot/nginx下)，新建一个.conf配置文件，如下进行配置，我已经配置好了域名\n\n一定要在nginx主配置文件中加上：include /www/nginx/*.conf;\n\n\n\nserver {\n        listen 80;\n        server_name message.zfhblog.top;\n\n        location / {\n                root /www/wwwroot/message;\n                index index.html;\n        }\n}\n\n\n现在前端页面已经可以访问了，我们对后端服务进行配置\n\n\n# 后端配置\n\n接着把后端代码，不要node_modules,传到服务器，在终端输入npm i,在这之前尽量更换淘宝源\n\n在软件商店打开 PM2,如图进行添加项目，看下有没有出现停止重启，说明基本成功了，再看下有没有报错\n\n\n\n我遇到了一个比较奇葩的报错，说找不到某个具体的模块，怀疑是相对路径的问题，于是我把相对路径，全部换成了服务器的文件绝对路径，最后可以了\n\n成功后,接下来,配置跨域 Nginx代理,还是来到 Nginx 的配置修改:\n\nserver {\n        listen 80;\n        server_name message.zfhblog.top;\n\n        location / {\n                root /www/wwwroot/message;\n                index index.html;\n        }\n        location /api/ {\n            proxy_pass http://localhost:3000/;\n        }\n}\n\n\n修改后重启Nginx,最后一步还需要在前端项目中修改的baseURL,然后重新打包上传\n\nconst instance = axios.create({\n    baseURL: 'http://message.zfhblog.top/api/',\n    withCredentials: true,\n})\n\n\n至此完成项目部署,上线成功",normalizedContent:"# 准备\n\n一台安装宝塔面板的centos服务器,我的版本是 7.9\n\n\n# 安装软件\n\n之后在宝塔面板的软件商店：安装mongodb,nginx,pm2管理器\n\n\n# 前端配置\n\n在服务器/www/wwwroot目录下放入前端打包后代码\n\n\n\n然后配置nginx，随便在那个文件夹(我是在/www/wwwroot/nginx下)，新建一个.conf配置文件，如下进行配置，我已经配置好了域名\n\n一定要在nginx主配置文件中加上：include /www/nginx/*.conf;\n\n\n\nserver {\n        listen 80;\n        server_name message.zfhblog.top;\n\n        location / {\n                root /www/wwwroot/message;\n                index index.html;\n        }\n}\n\n\n现在前端页面已经可以访问了，我们对后端服务进行配置\n\n\n# 后端配置\n\n接着把后端代码，不要node_modules,传到服务器，在终端输入npm i,在这之前尽量更换淘宝源\n\n在软件商店打开 pm2,如图进行添加项目，看下有没有出现停止重启，说明基本成功了，再看下有没有报错\n\n\n\n我遇到了一个比较奇葩的报错，说找不到某个具体的模块，怀疑是相对路径的问题，于是我把相对路径，全部换成了服务器的文件绝对路径，最后可以了\n\n成功后,接下来,配置跨域 nginx代理,还是来到 nginx 的配置修改:\n\nserver {\n        listen 80;\n        server_name message.zfhblog.top;\n\n        location / {\n                root /www/wwwroot/message;\n                index index.html;\n        }\n        location /api/ {\n            proxy_pass http://localhost:3000/;\n        }\n}\n\n\n修改后重启nginx,最后一步还需要在前端项目中修改的baseurl,然后重新打包上传\n\nconst instance = axios.create({\n    baseurl: 'http://message.zfhblog.top/api/',\n    withcredentials: true,\n})\n\n\n至此完成项目部署,上线成功",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"开发流程管理平台学习心得",frontmatter:{title:"开发流程管理平台学习心得",date:"2022/05/21 20:47:36",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/React/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97.html",relativePath:"开发记录/React/开发流程管理平台学习心得.md",key:"v-7933b2a2",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/React/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97.html",headers:[{level:2,title:"项目初始化配置",slug:"项目初始化配置",normalizedTitle:"项目初始化配置",charIndex:14}],headersStr:"项目初始化配置",content:"TIP\n\n在线体验\n\n\n# 项目初始化配置",normalizedContent:"tip\n\n在线体验\n\n\n# 项目初始化配置",charsets:{cjk:!0},lastUpdated:"2022年05月21日",lastUpdatedTimestamp:1653144975e3},{title:"Vue3+ElementPlus+Koa2全栈开发后台系统学习记录",frontmatter:{title:"Vue3+ElementPlus+Koa2全栈开发后台系统学习记录",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/Vue3ElementPlusKoa2%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html",relativePath:"开发记录/Vue/Vue3ElementPlusKoa2全栈开发后台系统学习记录.md",key:"v-8bf3fad8",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/Vue3ElementPlusKoa2%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html",headers:[{level:2,title:"前端部分",slug:"前端部分",normalizedTitle:"前端部分",charIndex:2},{level:2,title:"vite 环境变量",slug:"vite-环境变量",normalizedTitle:"vite 环境变量",charIndex:11},{level:2,title:"axios的使用",slug:"axios的使用",normalizedTitle:"axios的使用",charIndex:34},{level:3,title:"二次封装",slug:"二次封装",normalizedTitle:"二次封装",charIndex:47},{level:3,title:"全局挂载",slug:"全局挂载",normalizedTitle:"全局挂载",charIndex:1976},{level:3,title:"组件中使用",slug:"组件中使用",normalizedTitle:"组件中使用",charIndex:2121},{level:2,title:"storage二次封装",slug:"storage二次封装",normalizedTitle:"storage二次封装",charIndex:2486},{level:2,title:"vite 项目index.html中使用变量",slug:"vite-项目index-html中使用变量",normalizedTitle:"vite 项目index.html中使用变量",charIndex:3288}],headersStr:"前端部分 vite 环境变量 axios的使用 二次封装 全局挂载 组件中使用 storage二次封装 vite 项目index.html中使用变量",content:"# 前端部分\n\n\n# vite 环境变量\n\n环境变量和模式\n\n\n# axios的使用\n\n\n# 二次封装\n\n/**\n * axios 二次封装\n */\nimport axios from 'axios'\nimport {ElMessage} from \"element-plus\"\n// 引入路由实例\nimport router from \"../router\"\n// import {useRouter} from 'vue-router'\n// const router=useRouter()\nimport config from './../config'\n\n// 错误消息\nconst TOKEN_INVALID=\"Token认证失败，请重新登陆\"\nconst NETWORK_ERROR=\"网络请求异常，请稍后重试\"\n// 创建axios对象\nconst service = axios.create({\n    baseURL:config.baseApi,\n    timeout:10000,\n})\n\n// 请求拦截\nservice.interceptors.request.use(req=>{\n    // TODO: 待完善\n    // JWT\n    const headers=req.headers\n    if(!headers.Authorization) headers.Authorization='frank zhang'\n    return req\n})\n\n// 响应拦截\nservice.interceptors.response.use(res=>{\n    const {code,data,msg}=res.data\n    // 状态码判断\n    if(code===200){\n        // 请求成功\n        ElMessage.success('请求成功')\n        console.log(res.data)\n        return data\n    }else if(code === 40001){\n        // token认证失败\n        ElMessage.error(TOKEN_INVALID)\n        // 路由跳转到登陆页面\n        setTimeout(()=>{\n            router.push('/login')\n        },15000)\n        return Promise.reject(TOKEN_INVALID)\n    }else{\n        // 网络异常(其他情况）\n        ElMessage.error(msg||NETWORK_ERROR)\n        return Promise.reject(msg||NETWORK_ERROR)\n    }\n})\n\n/**\n * 请求核心函数\n * @param options 请求配置\n */\nfunction request(options){\n    options.method=options.method || 'get'\n    if(options.method.toLowerCase()==='get') {\n        // 无论是get还是post 数据字段均为data\n        options.params=options.data\n    }\n    // 确保生产环境调取线上地址\n    if(config.env==='prod'){\n        service.defaults.baseURL=config.baseApi\n    }else{\n        // mock 开关 控制 开发测试环境api地址切换\n        service.defaults.baseURL=config.mock?config.mockApi:config.baseApi\n    }\n    return service(options)\n}\n// 支持request.get()调用\n['get','push'].forEach(item=>{\n    request[item]=(url,data,options)=>{\n        return request({\n            url,\n            data,\n            method:item,\n            ...options\n        })\n    }\n})\n\nexport default request\n\n\n\n# 全局挂载\n\n在vue3的setup中使用getCurrentInstanceAPI获取全局对象,通过getCurrentInstance方法获取上下文，这里的proxy就相当于this。\n\napp.config.globalProperties.$request=request\n\n\n\n# 组件中使用\n\n将获取request的逻辑进行封装，方便复用：\n\n/**\n * 获取request请求实例\n */\nimport {getCurrentInstance} from 'vue'\nfunction useRequest(){\n    const {proxy }=getCurrentInstance()\n\nreturn proxy.$request\n}\nexport default useRequest\n\n\n在组件中进行使用：\n\nimport useRequest from \"../hooks/useRequest.js\"\nconst request=useRequest()\n// ......\n  request({\n    method:'get',\n    url:'/login'\n  })\n\n\n\n# storage二次封装\n\ncookie，localStorage，sessionStorage的区别？\n\n/**\n * storage类封装\n */\nimport config from \"../config/index.js\";\n\nexport default {\n    // 获取storage下项目命名空间的值\n    getStorage() {\n        return JSON.parse(localStorage.getItem(config.namespace) || \"{}\")\n    },\n    // 设置数据\n    setItem(key, value) {\n        // TODO this指向问题\n        const storage = this.getStorage()\n        storage[key] = value\n        localStorage.setItem(config.namespace, JSON.stringify(storage))\n    },\n    // 获取数据\n    getItem(key) {\n        return this.getStorage()[key]\n    },\n    // 删除数据\n    clearItem(key) {\n        let storage = this.getStorage()\n        delete storage[key]\n        localStorage.setItem(config.namespace, JSON.stringify(storage))\n    },\n    // 清空所有数据\n    clearAll() {\n        localStorage.clear()\n    }\n}\n\n\n\n# vite 项目index.html中使用变量\n\nvite-plugin-html 插件",normalizedContent:"# 前端部分\n\n\n# vite 环境变量\n\n环境变量和模式\n\n\n# axios的使用\n\n\n# 二次封装\n\n/**\n * axios 二次封装\n */\nimport axios from 'axios'\nimport {elmessage} from \"element-plus\"\n// 引入路由实例\nimport router from \"../router\"\n// import {userouter} from 'vue-router'\n// const router=userouter()\nimport config from './../config'\n\n// 错误消息\nconst token_invalid=\"token认证失败，请重新登陆\"\nconst network_error=\"网络请求异常，请稍后重试\"\n// 创建axios对象\nconst service = axios.create({\n    baseurl:config.baseapi,\n    timeout:10000,\n})\n\n// 请求拦截\nservice.interceptors.request.use(req=>{\n    // todo: 待完善\n    // jwt\n    const headers=req.headers\n    if(!headers.authorization) headers.authorization='frank zhang'\n    return req\n})\n\n// 响应拦截\nservice.interceptors.response.use(res=>{\n    const {code,data,msg}=res.data\n    // 状态码判断\n    if(code===200){\n        // 请求成功\n        elmessage.success('请求成功')\n        console.log(res.data)\n        return data\n    }else if(code === 40001){\n        // token认证失败\n        elmessage.error(token_invalid)\n        // 路由跳转到登陆页面\n        settimeout(()=>{\n            router.push('/login')\n        },15000)\n        return promise.reject(token_invalid)\n    }else{\n        // 网络异常(其他情况）\n        elmessage.error(msg||network_error)\n        return promise.reject(msg||network_error)\n    }\n})\n\n/**\n * 请求核心函数\n * @param options 请求配置\n */\nfunction request(options){\n    options.method=options.method || 'get'\n    if(options.method.tolowercase()==='get') {\n        // 无论是get还是post 数据字段均为data\n        options.params=options.data\n    }\n    // 确保生产环境调取线上地址\n    if(config.env==='prod'){\n        service.defaults.baseurl=config.baseapi\n    }else{\n        // mock 开关 控制 开发测试环境api地址切换\n        service.defaults.baseurl=config.mock?config.mockapi:config.baseapi\n    }\n    return service(options)\n}\n// 支持request.get()调用\n['get','push'].foreach(item=>{\n    request[item]=(url,data,options)=>{\n        return request({\n            url,\n            data,\n            method:item,\n            ...options\n        })\n    }\n})\n\nexport default request\n\n\n\n# 全局挂载\n\n在vue3的setup中使用getcurrentinstanceapi获取全局对象,通过getcurrentinstance方法获取上下文，这里的proxy就相当于this。\n\napp.config.globalproperties.$request=request\n\n\n\n# 组件中使用\n\n将获取request的逻辑进行封装，方便复用：\n\n/**\n * 获取request请求实例\n */\nimport {getcurrentinstance} from 'vue'\nfunction userequest(){\n    const {proxy }=getcurrentinstance()\n\nreturn proxy.$request\n}\nexport default userequest\n\n\n在组件中进行使用：\n\nimport userequest from \"../hooks/userequest.js\"\nconst request=userequest()\n// ......\n  request({\n    method:'get',\n    url:'/login'\n  })\n\n\n\n# storage二次封装\n\ncookie，localstorage，sessionstorage的区别？\n\n/**\n * storage类封装\n */\nimport config from \"../config/index.js\";\n\nexport default {\n    // 获取storage下项目命名空间的值\n    getstorage() {\n        return json.parse(localstorage.getitem(config.namespace) || \"{}\")\n    },\n    // 设置数据\n    setitem(key, value) {\n        // todo this指向问题\n        const storage = this.getstorage()\n        storage[key] = value\n        localstorage.setitem(config.namespace, json.stringify(storage))\n    },\n    // 获取数据\n    getitem(key) {\n        return this.getstorage()[key]\n    },\n    // 删除数据\n    clearitem(key) {\n        let storage = this.getstorage()\n        delete storage[key]\n        localstorage.setitem(config.namespace, json.stringify(storage))\n    },\n    // 清空所有数据\n    clearall() {\n        localstorage.clear()\n    }\n}\n\n\n\n# vite 项目index.html中使用变量\n\nvite-plugin-html 插件",charsets:{cjk:!0},lastUpdated:"2022年07月31日",lastUpdatedTimestamp:1659277691e3},{title:"vue+echarts数据报表项目学习心得",frontmatter:{title:"vue+echarts数据报表项目学习心得",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/vueecharts%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A1%A8%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97.html",relativePath:"开发记录/Vue/vueecharts数据报表项目学习心得.md",key:"v-4ce5dc34",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/vueecharts%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A1%A8%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97.html",headers:[{level:2,title:"echarts 在 vue 的使用",slug:"echarts-在-vue-的使用",normalizedTitle:"echarts 在 vue 的使用",charIndex:17},{level:2,title:"使用 vue-echarts 简化配置",slug:"使用-vue-echarts-简化配置",normalizedTitle:"使用 vue-echarts 简化配置",charIndex:274},{level:2,title:"几种常见图表的配置",slug:"几种常见图表的配置",normalizedTitle:"几种常见图表的配置",charIndex:641},{level:3,title:"折线图",slug:"折线图",normalizedTitle:"折线图",charIndex:655},{level:3,title:"柱状图",slug:"柱状图",normalizedTitle:"柱状图",charIndex:840},{level:3,title:"饼状图",slug:"饼状图",normalizedTitle:"饼状图",charIndex:920},{level:2,title:"v-charts",slug:"v-charts",normalizedTitle:"v-charts",charIndex:937},{level:2,title:"element-UI 相关问题",slug:"element-ui-相关问题",normalizedTitle:"element-ui 相关问题",charIndex:1192},{level:3,title:"使用 element-ui 的 row 和 col 组件完成布局",slug:"使用-element-ui-的-row-和-col-组件完成布局",normalizedTitle:"使用 element-ui 的 row 和 col 组件完成布局",charIndex:1212},{level:3,title:"表格数据分页功能",slug:"表格数据分页功能",normalizedTitle:"表格数据分页功能",charIndex:1278}],headersStr:"echarts 在 vue 的使用 使用 vue-echarts 简化配置 几种常见图表的配置 折线图 柱状图 饼状图 v-charts element-UI 相关问题 使用 element-ui 的 row 和 col 组件完成布局 表格数据分页功能",content:"项目演示地址\n\n演示地址\n\n\n# echarts 在 vue 的使用\n\necharts 4.x 文档\n\n * 定义\n\nimport ECharts from 'echarts'\n\nVue.prototype.$echarts = ECharts\n\n\n * 消费\n\nconst chartDom = document.getElementById('today-users-chart')\nconst chart = this.$echarts.init(chartDom)\nchart.setOption({\n    // ...\n})\n\n\n\n# 使用 vue-echarts 简化配置\n\n官方文档 vue2.x,echarts4\n\n * 默认尺寸为 600px×400px，如果想让图表响应尺寸变化，可以像下面这样\n * 把尺寸设为百分比值（同时请记得为容器设置尺寸）。\n\n.echarts {\n    width: 100%;\n    height: 100%;\n}\n\n\n在模板中使用：\n\n<v-chart :options=\"chartOption\" ::autoresize=\"true\"></v-chart>\n\n\n * options：ECharts 实例的数据。修改这个 prop 会触发 ECharts 实例的 setOption 方法。\n * autoresize:这个 prop 用来指定 ECharts 实例在组件根元素尺寸变化时是否需要自动进行重绘。\n\n\n# 几种常见图表的配置\n\n\n# 折线图\n\n提示\n\n在没有使用任何模块系统的情况下，组件将通过 window.VueECharts 变量暴露接口：\n\n// 注册组件后即可使用\nVue.component('v-chart', VueECharts)\n\n\nSee the Pen vue-echarts折线图 by zhangfanhang (@zhangfanhang) on CodePen.\n\n\n# 柱状图\n\nSee the Pen vue-echarts柱状图 by zhangfanhang (@zhangfanhang) on CodePen.\n\n\n# 饼状图\n\nSee the Pen v-charts饼状图 by zhangfanhang (@zhangfanhang) on CodePen.\n\n\n# v-charts\n\n在使用 echarts 生成图表时，经常需要做繁琐的数据类型转化、修改复杂的配置项，v-charts 的出现正是为了解决这个痛点。基于 Vue2.0 和 echarts 封装的 v-charts 图表组件，只需要统一提供一种对前后端都友好的数据格式设置简单的配置项，便可轻松生成常见的图表。\n\n文档\n\n本示例中的词云图，水球图，地图使用 v-charts 开发\n\n\n# element-UI 相关问题\n\n\n# 使用 element-ui 的 row 和 col 组件完成布局\n\n通过基础的 24 分栏，迅速简便地创建布局\n\nmore\n\n\n# 表格数据分页功能\n\nSee the Pen element-ui表格分页 by zhangfanhang (@zhangfanhang) on CodePen.",normalizedContent:"项目演示地址\n\n演示地址\n\n\n# echarts 在 vue 的使用\n\necharts 4.x 文档\n\n * 定义\n\nimport echarts from 'echarts'\n\nvue.prototype.$echarts = echarts\n\n\n * 消费\n\nconst chartdom = document.getelementbyid('today-users-chart')\nconst chart = this.$echarts.init(chartdom)\nchart.setoption({\n    // ...\n})\n\n\n\n# 使用 vue-echarts 简化配置\n\n官方文档 vue2.x,echarts4\n\n * 默认尺寸为 600px×400px，如果想让图表响应尺寸变化，可以像下面这样\n * 把尺寸设为百分比值（同时请记得为容器设置尺寸）。\n\n.echarts {\n    width: 100%;\n    height: 100%;\n}\n\n\n在模板中使用：\n\n<v-chart :options=\"chartoption\" ::autoresize=\"true\"></v-chart>\n\n\n * options：echarts 实例的数据。修改这个 prop 会触发 echarts 实例的 setoption 方法。\n * autoresize:这个 prop 用来指定 echarts 实例在组件根元素尺寸变化时是否需要自动进行重绘。\n\n\n# 几种常见图表的配置\n\n\n# 折线图\n\n提示\n\n在没有使用任何模块系统的情况下，组件将通过 window.vueecharts 变量暴露接口：\n\n// 注册组件后即可使用\nvue.component('v-chart', vueecharts)\n\n\nsee the pen vue-echarts折线图 by zhangfanhang (@zhangfanhang) on codepen.\n\n\n# 柱状图\n\nsee the pen vue-echarts柱状图 by zhangfanhang (@zhangfanhang) on codepen.\n\n\n# 饼状图\n\nsee the pen v-charts饼状图 by zhangfanhang (@zhangfanhang) on codepen.\n\n\n# v-charts\n\n在使用 echarts 生成图表时，经常需要做繁琐的数据类型转化、修改复杂的配置项，v-charts 的出现正是为了解决这个痛点。基于 vue2.0 和 echarts 封装的 v-charts 图表组件，只需要统一提供一种对前后端都友好的数据格式设置简单的配置项，便可轻松生成常见的图表。\n\n文档\n\n本示例中的词云图，水球图，地图使用 v-charts 开发\n\n\n# element-ui 相关问题\n\n\n# 使用 element-ui 的 row 和 col 组件完成布局\n\n通过基础的 24 分栏，迅速简便地创建布局\n\nmore\n\n\n# 表格数据分页功能\n\nsee the pen element-ui表格分页 by zhangfanhang (@zhangfanhang) on codepen.",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"vue如何实现界面刷新",frontmatter:{title:"vue如何实现界面刷新",readingShow:"top"},regularPath:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/vue%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%95%8C%E9%9D%A2%E5%88%B7%E6%96%B0.html",relativePath:"开发记录/Vue/vue如何实现界面刷新.md",key:"v-1c966386",path:"/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/Vue/vue%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%95%8C%E9%9D%A2%E5%88%B7%E6%96%B0.html",headersStr:null,content:" 1. 原始方法： location.reload();\n 2. vue 自带的路由跳转: this.$router.go(0);\n\n前两者都是强制刷新页面，会出现短暂的闪烁，用户体验效果不好。所以，我们选择第三种方式\n\n首先在 App 里面写下如下代码：\n\n<template>\n    <div id=\"app\">\n    \t<router-view v-if=\"isRouterAlive\"></router-view>\n\t</div>\n</template>\n<script>\n    export default {\n        name: 'App',\n         //父组件中通过provide来提供变量，在子组件中通过inject来注入变量。\n        provide () {\n            return {\n                reload: this.reload\n            }\n        },\n        data() {\n            return{\n                isRouterAlive: true  //控制视图是否显示的变量\n            }\n        },\n        methods: {\n            reload () {\n                this.isRouterAlive = false;   //先关闭，\n                this.$nextTick(function () {\n                    this.isRouterAlive = true; //再打开\n                })\n            }\n        }，\n    }\n<\/script>\n\n\n接下来，我们就可以在需要刷新页面的组件里这样写：\n\nexport default {\n    inject: ['reload'], //注入App里的reload方法\n    data() {\n        return {}\n    },\n}\n\n\n在需要刷新页面的代码块中使用：\n\nthis.reload()\n",normalizedContent:" 1. 原始方法： location.reload();\n 2. vue 自带的路由跳转: this.$router.go(0);\n\n前两者都是强制刷新页面，会出现短暂的闪烁，用户体验效果不好。所以，我们选择第三种方式\n\n首先在 app 里面写下如下代码：\n\n<template>\n    <div id=\"app\">\n    \t<router-view v-if=\"isrouteralive\"></router-view>\n\t</div>\n</template>\n<script>\n    export default {\n        name: 'app',\n         //父组件中通过provide来提供变量，在子组件中通过inject来注入变量。\n        provide () {\n            return {\n                reload: this.reload\n            }\n        },\n        data() {\n            return{\n                isrouteralive: true  //控制视图是否显示的变量\n            }\n        },\n        methods: {\n            reload () {\n                this.isrouteralive = false;   //先关闭，\n                this.$nexttick(function () {\n                    this.isrouteralive = true; //再打开\n                })\n            }\n        }，\n    }\n<\/script>\n\n\n接下来，我们就可以在需要刷新页面的组件里这样写：\n\nexport default {\n    inject: ['reload'], //注入app里的reload方法\n    data() {\n        return {}\n    },\n}\n\n\n在需要刷新页面的代码块中使用：\n\nthis.reload()\n",charsets:{cjk:!0},lastUpdated:"2022年05月18日",lastUpdatedTimestamp:1652886614e3},{title:"MySQL",frontmatter:{title:"MySQL",date:"2022/04/15 14:02:17",sidebar:"auto",readingShow:"top"},regularPath:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html",relativePath:"数据库/MySQL.md",key:"v-379c6be0",path:"/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:2},{level:3,title:"MacOS",slug:"macos",normalizedTitle:"macos",charIndex:9}],headersStr:"安装 MacOS",content:"# 安装\n\n\n# MacOS\n\n通过 homebrew 安装：\n\nbrew install mysql\n\n\n启动 mysql 服务：\n\nmysql.server start\n\n\n设置 mysql:\n\nmysql_secure_installation\n\n\n,出现以下提示:\n\nSecuring the MySQL server deployment.\n\nConnecting to MySQL using a blank password.\n//验证密码插件可以用来测试密码和提高安全性。它检查密码的强度，并允许用户只设置那些足够安全的密码。你愿意安装验证密码插件吗?\nVALIDATE PASSWORD PLUGIN can be used to test passwords\nand improve security. It checks the strength of password\nand allows the users to set only those passwords which are\nsecure enough. Would you like to setup VALIDATE PASSWORD plugin?\n//在下边的问题中输入y或者Y,输入其他的都表示为否\nPress y|Y for Yes, any other key for No:y\n\n// 密码验证策略有三个级别:\n// 低长度> = 8\n// 中长度>= 8，数字，混合情况，和特殊字符。\n// 强长度>= 8，数字，混合情况，特殊字符和字典文件。\n\nThere are three levels of password validation policy:\n\nLOW    Length >= 8\nMEDIUM Length >= 8, numeric, mixed case, and special characters\nSTRONG Length >= 8, numeric, mixed case, special characters and dictionary file\n\n// 0,1,2分别代表3个不同的级别,看自己的生产环境需要的密码需求\n\nPlease enter 0 = LOW, 1 = MEDIUM and 2 = STRONG:0\n\n// 请在这里设置root的密码。\n// 新密码:\n// 重新输入新密码:\n// 估计密码强度:50。\n\n// 您希望继续提供密码吗?(请按y| y为Yes，任何其他关键字):\n\n\nPlease set the password for root here.\n\nNew password:\n\nRe-enter new password:\n\nEstimated strength of the password: 50\nDo you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) :y\n\n// 默认情况下，MySQL安装有匿名用户，\n// 允许任何人在不需要的情况下登录MySQL。\n// 为它们创建的用户帐户。这仅仅是为了。\n// 测试，并使安装更加顺利。\n// 在开始生产之前，你应该把它们去掉。\n// 环境。\n// 删除匿名用户?(请按y| y为Yes，任何其他关键字):\n\nBy default, a MySQL installation has an anonymous user,\nallowing anyone to log into MySQL without having to have\na user account created for them. This is intended only for\ntesting, and to make the installation go a bit smoother.\nYou should remove them before moving into a production\nenvironment.\n\nRemove anonymous users? (Press y|Y for Yes, any other key for No) :y\n\n// 成功。\n// 通常，根应该只允许连接。\n// “localhost”。这确保了某人无法猜测。\n// 来自网络的根密码。\n// 不允许远程root登录吗?(请按y| y为Yes，任何其他关键字):\n// 这里表示是否允许远程登录root用户,我这里是测试环境,选择键入Y\n\nSuccess.\n\nNormally, root should only be allowed to connect from\n'localhost'. This ensures that someone cannot guess at\nthe root password from the network.\n\nDisallow root login remotely? (Press y|Y for Yes, any other key for No) :y\n\n成功。\n\n// 默认情况下，MySQL附带一个名为“test”的数据库。\n// 任何人都可以访问。这也只用于测试，\n// 在开始生产之前应该将其移除。\n// 环境。\n// 这里提示是否删除mysql的test数据库\n\n\n删除测试数据库并访问它?(请按y| y为Yes，任何其他关键字):\n\nSuccess.\n\nBy default, MySQL comes with a database named 'test' that\nanyone can access. This is also intended only for testing,\nand should be removed before moving into a production\nenvironment.\n\n\nRemove test database and access to it? (Press y|Y for Yes, any other key for No) :y\n\n\n// ——删除测试数据库……\n// 成功。\n// -删除测试数据库上的特权…\n// 成功。\n// 重新加载特权表将确保所有更改。\n// 到目前为止，将立即生效。\n// 现在重新加载权限表吗?(请按y| y为Yes，任何其他关键字):\n- Dropping test database...\nSuccess.\n\n - Removing privileges on test database...\nSuccess.\n\nReloading the privilege tables will ensure that all changes\nmade so far will take effect immediately.\n\nReload privilege tables now? (Press y|Y for Yes, any other key for No) :y\n\n\nSuccess.\n//出现此消息,说明mysql设置成功,请牢记输入的mysql密码\nAll done!\n",normalizedContent:"# 安装\n\n\n# macos\n\n通过 homebrew 安装：\n\nbrew install mysql\n\n\n启动 mysql 服务：\n\nmysql.server start\n\n\n设置 mysql:\n\nmysql_secure_installation\n\n\n,出现以下提示:\n\nsecuring the mysql server deployment.\n\nconnecting to mysql using a blank password.\n//验证密码插件可以用来测试密码和提高安全性。它检查密码的强度，并允许用户只设置那些足够安全的密码。你愿意安装验证密码插件吗?\nvalidate password plugin can be used to test passwords\nand improve security. it checks the strength of password\nand allows the users to set only those passwords which are\nsecure enough. would you like to setup validate password plugin?\n//在下边的问题中输入y或者y,输入其他的都表示为否\npress y|y for yes, any other key for no:y\n\n// 密码验证策略有三个级别:\n// 低长度> = 8\n// 中长度>= 8，数字，混合情况，和特殊字符。\n// 强长度>= 8，数字，混合情况，特殊字符和字典文件。\n\nthere are three levels of password validation policy:\n\nlow    length >= 8\nmedium length >= 8, numeric, mixed case, and special characters\nstrong length >= 8, numeric, mixed case, special characters and dictionary file\n\n// 0,1,2分别代表3个不同的级别,看自己的生产环境需要的密码需求\n\nplease enter 0 = low, 1 = medium and 2 = strong:0\n\n// 请在这里设置root的密码。\n// 新密码:\n// 重新输入新密码:\n// 估计密码强度:50。\n\n// 您希望继续提供密码吗?(请按y| y为yes，任何其他关键字):\n\n\nplease set the password for root here.\n\nnew password:\n\nre-enter new password:\n\nestimated strength of the password: 50\ndo you wish to continue with the password provided?(press y|y for yes, any other key for no) :y\n\n// 默认情况下，mysql安装有匿名用户，\n// 允许任何人在不需要的情况下登录mysql。\n// 为它们创建的用户帐户。这仅仅是为了。\n// 测试，并使安装更加顺利。\n// 在开始生产之前，你应该把它们去掉。\n// 环境。\n// 删除匿名用户?(请按y| y为yes，任何其他关键字):\n\nby default, a mysql installation has an anonymous user,\nallowing anyone to log into mysql without having to have\na user account created for them. this is intended only for\ntesting, and to make the installation go a bit smoother.\nyou should remove them before moving into a production\nenvironment.\n\nremove anonymous users? (press y|y for yes, any other key for no) :y\n\n// 成功。\n// 通常，根应该只允许连接。\n// “localhost”。这确保了某人无法猜测。\n// 来自网络的根密码。\n// 不允许远程root登录吗?(请按y| y为yes，任何其他关键字):\n// 这里表示是否允许远程登录root用户,我这里是测试环境,选择键入y\n\nsuccess.\n\nnormally, root should only be allowed to connect from\n'localhost'. this ensures that someone cannot guess at\nthe root password from the network.\n\ndisallow root login remotely? (press y|y for yes, any other key for no) :y\n\n成功。\n\n// 默认情况下，mysql附带一个名为“test”的数据库。\n// 任何人都可以访问。这也只用于测试，\n// 在开始生产之前应该将其移除。\n// 环境。\n// 这里提示是否删除mysql的test数据库\n\n\n删除测试数据库并访问它?(请按y| y为yes，任何其他关键字):\n\nsuccess.\n\nby default, mysql comes with a database named 'test' that\nanyone can access. this is also intended only for testing,\nand should be removed before moving into a production\nenvironment.\n\n\nremove test database and access to it? (press y|y for yes, any other key for no) :y\n\n\n// ——删除测试数据库……\n// 成功。\n// -删除测试数据库上的特权…\n// 成功。\n// 重新加载特权表将确保所有更改。\n// 到目前为止，将立即生效。\n// 现在重新加载权限表吗?(请按y| y为yes，任何其他关键字):\n- dropping test database...\nsuccess.\n\n - removing privileges on test database...\nsuccess.\n\nreloading the privilege tables will ensure that all changes\nmade so far will take effect immediately.\n\nreload privilege tables now? (press y|y for yes, any other key for no) :y\n\n\nsuccess.\n//出现此消息,说明mysql设置成功,请牢记输入的mysql密码\nall done!\n",charsets:{cjk:!0},lastUpdated:"2022年04月15日",lastUpdatedTimestamp:1650012895e3},{title:"mongoDB",frontmatter:{title:"mongoDB",sidebar:"auto",readingShow:"top"},regularPath:"/%E6%95%B0%E6%8D%AE%E5%BA%93/mongoDB.html",relativePath:"数据库/mongoDB.md",key:"v-92a93060",path:"/%E6%95%B0%E6%8D%AE%E5%BA%93/mongoDB.html",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:25},{level:3,title:"windows",slug:"windows",normalizedTitle:"windows",charIndex:32},{level:3,title:"macOS",slug:"macos",normalizedTitle:"macos",charIndex:65},{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:228},{level:3,title:"NoSQL",slug:"nosql",normalizedTitle:"nosql",charIndex:281},{level:2,title:"node.js 连接 mongodb",slug:"node-js-连接-mongodb",normalizedTitle:"node.js 连接 mongodb",charIndex:332},{level:3,title:"查询",slug:"查询",normalizedTitle:"查询",charIndex:325},{level:3,title:"查询条件",slug:"查询条件",normalizedTitle:"查询条件",charIndex:972},{level:3,title:"排序",slug:"排序",normalizedTitle:"排序",charIndex:1031},{level:3,title:"新增",slug:"新增",normalizedTitle:"新增",charIndex:1099},{level:3,title:"修改",slug:"修改",normalizedTitle:"修改",charIndex:2096},{level:3,title:"删除",slug:"删除",normalizedTitle:"删除",charIndex:2773},{level:2,title:"mongoose",slug:"mongoose",normalizedTitle:"mongoose",charIndex:3746},{level:3,title:"为什么要用 mongoose?",slug:"为什么要用-mongoose",normalizedTitle:"为什么要用 mongoose?",charIndex:3759},{level:3,title:"安装 mongoose",slug:"安装-mongoose",normalizedTitle:"安装 mongoose",charIndex:3918},{level:3,title:"连接数据库",slug:"连接数据库",normalizedTitle:"连接数据库",charIndex:4008},{level:3,title:"定义 Schema",slug:"定义-schema",normalizedTitle:"定义 schema",charIndex:4559},{level:3,title:"新增",slug:"新增-2",normalizedTitle:"新增",charIndex:1099},{level:3,title:"查询",slug:"查询-2",normalizedTitle:"查询",charIndex:325},{level:3,title:"查询条件",slug:"查询条件-2",normalizedTitle:"查询条件",charIndex:972},{level:3,title:"排序",slug:"排序-2",normalizedTitle:"排序",charIndex:1031},{level:3,title:"更新",slug:"更新",normalizedTitle:"更新",charIndex:5066},{level:3,title:"删除",slug:"删除-2",normalizedTitle:"删除",charIndex:2773},{level:3,title:"对接 nodejs 路由",slug:"对接-nodejs-路由",normalizedTitle:"对接 nodejs 路由",charIndex:7303},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"安装 windows macOS 概念 NoSQL node.js 连接 mongodb 查询 查询条件 排序 新增 修改 删除 mongoose 为什么要用 mongoose? 安装 mongoose 连接数据库 定义 Schema 新增 查询 查询条件 排序 更新 删除 对接 nodejs 路由 ",content:"// TODO: 2022-5-25 查\n\n\n# 安装\n\n\n# windows\n\nwindows下的安装比较简单，不赘述\n\n\n# macOS\n\n建议使用homebrew进行安装\n\n第一步：brew tap mongodb/brew\n\n第二步：brew install mongodb-community\n\n接着启动 mongodb 服务：brew services start mongodb-community\n\n在终端下输入mongo进行测试\n\n\n# 概念\n\n数据库 database---\x3e集合 collection---\x3e文档 document\n\n\n# NoSQL\n\n关系型数据库需要学习 SQL 语言\n\nNoSQL 数据库无需用 SQL语句查询\n\n\n# node.js 连接 mongodb\n\n安装 mongodb 插件,当前版本@4.0.2,具体用法参考：mongodb-npm\n\nnpm i mongodb --save\n\n\n\n# 查询\n\nconst { MongoClient } = require('mongodb')\n\nconst url = 'mongodb://localhost:27017'\nconst client = new MongoClient(url)\n// 数据库名称\nconst dbName = 'comments'\n\nasync function main() {\n    await client.connect()\n    console.log('数据库连接成功!')\n    // 切换数据库\n    const db = client.db(dbName)\n    // 切换到指定的集合\n    const collection = db.collection('message')\n    // 返回查询结果\n    return await collection.find({}).toArray()\n}\n\nmain()\n    .then(res => console.log('查询结果：', res))\n    .catch(err => console.error('出错：', err))\n    .finally(() => client.close())\n\n\n\n# 查询条件\n\ncollection.find({ city: 'shanghai' }).toArray()\n\n\n\n# 排序\n\n// -1逆序  1顺序\ncollection.find().sort({ _id: -1 }).toArray()\n\n\n\n# 新增\n\ninsertMany同时新增多条文档，需要传入一个数组对象\n\nconst { MongoClient } = require('mongodb')\n\nconst url = 'mongodb://localhost:27017'\nconst client = new MongoClient(url)\n// 数据库名称\nconst dbName = 'comments'\n\nasync function main() {\n    await client.connect()\n    console.log('数据库连接成功!')\n    // 切换数据库\n    const db = client.db(dbName)\n    // 切换到指定的集合\n    const collection = db.collection('message')\n    //  插入一条文档\n    return await collection.insertOne({\n        name: 'zhangfanhang',\n        message: 'this is a message!',\n    })\n    // return await collection.insertMany([\n    //     {\n    //         name: 'frank',\n    //         message: '这是第1个message',\n    //     },\n    //     {\n    //         name: 'frank',\n    //         message: '这是第2个message',\n    //     },\n    //     {\n    //         name: 'frank',\n    //         message: '这是第2个message',\n    //     },\n    // ])\n}\n\nmain()\n    .then(res => console.log('插入成功！', res))\n    .catch(err => console.error('插入出错！', err))\n    .finally(() => client.close())\n\n\n\n# 修改\n\nconst { MongoClient } = require('mongodb')\n\nconst url = 'mongodb://localhost:27017'\nconst client = new MongoClient(url)\n// 数据库名称\nconst dbName = 'comments'\n\nasync function main() {\n    await client.connect()\n    console.log('数据库连接成功!')\n    // 切换数据库\n    const db = client.db(dbName)\n    // 切换到指定的集合\n    const collection = db.collection('message')\n    // 返回查询结果\n    return await collection.updateOne(\n        // 修改的条件\n        { name: 'fuvke' },\n        // 要修改的属性和属性值,或者要新增的属性和属性值\n        { $set: { message: 'change', age: 12 } }\n    )\n}\n\nmain()\n    .then(res => console.log('修改成功！', res))\n    .catch(err => console.error('修改出错！', err))\n    .finally(() => client.close())\n\n\n\n# 删除\n\ndeleteMany 删除所有符合条件的文档，deleteOne 删除一条最先添加到集合中的文档\n\nconst { MongoClient } = require('mongodb')\n\nconst url = 'mongodb://localhost:27017'\nconst client = new MongoClient(url)\n// 数据库名称\nconst dbName = 'comments'\n\nasync function main() {\n    await client.connect()\n    console.log('数据库连接成功!')\n    // 切换数据库\n    const db = client.db(dbName)\n    // 切换到指定的集合\n    const collection = db.collection('message')\n    // 返回结果\n    return await collection.deleteMany({ name: 'frank' })\n    // return await collection.insertMany([\n    //     {\n    //         name: 'frank',\n    //         message: '这是第1个frank message',\n    //     },\n    //     {\n    //         name: 'frank',\n    //         message: '这是第2个frank message',\n    //     },\n    //     {\n    //         name: 'frank',\n    //         message: '这是第2个frank message',\n    //     },\n    // ])\n}\n\nmain()\n    .then(res => console.log('删除成功！', res))\n    .catch(err => console.error('删除出错！', err))\n    .finally(() => client.close())\n\n\n\n# mongoose\n\n\n# 为什么要用 mongoose?\n\nmongodb 的数据格式过于灵活，可以插入任何数据，不受限制。实际开发中，要有数据格式的规范(重要)。\n\nmongoose 可以提供规范，\n\n * Schema 可以定义数据格式的规范\n * 以 Model 规范 Collection（集合）\n * 规范数据操作的 API\n\n\n# 安装 mongoose\n\n> 以下代码测试环境为 mongose@5.9.9 node.js v12.16.1\n\nnpm i mongoose@5.9.9 --save\n\n\n\n# 连接数据库\n\ndb/db.js\n\n// 连接数据库（mongodb的服务端）\n\nconst mongoose = require('mongoose')\n\nconst url = 'mongodb://localhost:27017'\nconst dbName = 'commentDB'\n\n// 将 mongoose 发送到 MongoDB 的操作打印到控制台\nmongoose.set('debug', true)\n// 写上就完了\nmongoose.set('useCreateIndex', true)\nmongoose.set('useFindAndModify', true)\n\n// 开始连接\nmongoose.connect(`${url}/${dbName}`, {\n    useNewUrlParser: true,\n    useUnifiedTopology: true,\n})\n\nconst conn = mongoose.connection\n\nconn.on('error', err => {\n    console.error('mongoose 连接出错', err)\n})\n\nmodule.exports = mongoose // commonjs\n\n\n\n# 定义 Schema\n\ndb/model.js\n\n// 数据模型（规范数据格式）\n\nconst mongoose = require('./db')\n\n// 定义 User Schema （数据规范）\nconst UserSchema = mongoose.Schema(\n    {\n        username: {\n            type: String,\n            required: true, // 必需\n            unique: true, // 唯一，不重复\n        },\n        password: String,\n        age: Number,\n        city: String,\n        // 性别\n        gender: {\n            type: Number,\n            default: 0, // 0 - 保密，1 男，2 女\n        },\n    },\n    {\n        timestamps: true, // 时间戳，自动添加文档的创建时间、更新时间\n    }\n)\n\n// 定义 User Model\nconst User = mongoose.model('user', UserSchema)\n\n// 定义 Comment Schema\nconst CommentSchema = mongoose.Schema(\n    {\n        content: {\n            type: String,\n            required: true, // 必需\n        },\n        username: String, // 用户名\n    },\n    { timestamps: true }\n)\n\n// 定义 Comment Model\nconst Comment = mongoose.model('comment', CommentSchema)\n\nmodule.exports = {\n    User,\n    Comment,\n}\n\n\n\n# 新增\n\nconst { User } = require('./model')\n!(async () => {\n    const zhangsan = new User({\n        username: '李四2',\n        password: 'bbbb',\n        age: 18,\n        city: '上海',\n        gender: 2,\n    })\n    zhangsan.save()\n})()\n\n\ncreate()方法返回的是 promise 对象，里面包含返回值，使用 await 可以直接拿到值，输出比较方便，所以这里添加了 await 。具体情况具体分析，如果不输出也不一定要加 await 。\n\nconst { User } = require('./model')\n!(async () => {\n    const wangwu = await User.create({\n        username: '王五',\n        password: '123456',\n        age: 21,\n        city: '南京',\n    })\n    console.log('王五创建完成', wangwu)\n})()\n\n\n\n# 查询\n\ndb/test.js\n\n查询列表数据，返回的是数组\n\nconst { User } = require('./model')\n!(async () => {\n    const useList = await User.find()\n    console.log('查询结果', useList)\n})()\n\n\n查询单条数据，返回的是对象\n\nconst { User } = require('./model')\n!(async () => {\n    const user = await User.findOne({ username: '王五' })\n    console.log('查询结果', user)\n})()\n\n\n\n# 查询条件\n\ndb/test.js 查询列表数据，返回的是数组\n\nconst { User } = require('./model')\n!(async () => {\n    const useList = await User.find({ age: '21' })\n    console.log('查询结果', useList)\n})()\n\n\n\n# 排序\n\n查询列表数据，返回的是数组\n\nconst { User } = require('./model')\n!(async () => {\n    const useList = await User.find().sort({ _id: -1 })\n    console.log('查询结果', useList)\n})()\n\n\n\n# 更新\n\nconst { User } = require('./model')\n// 定义一个 async 的匿名函数，并执行。为了里面能用 await\n!(async () => {\n    // 更新\n    const updateResult = await User.findOneAndUpdate(\n        { username: 'zhangsan' }, // 条件\n        { age: 30 }, // 更新的内容\n        {\n            new: true, // 返回更新后的数据,不写返回的是更新前的数据\n        }\n    )\n    console.log('更新的返回结果', updateResult)\n})()\n\n\n\n# 删除\n\nconst { User } = require('./model')\n// 定义一个 async 的匿名函数，并执行。为了里面能用 await\n!(async () => {\n    // 删除\n    const removeResult = await User.remove({ username: 'lisi' })\n    console.log('删除的返回结果', removeResult)\n})()\n\n\n\n# 对接 nodejs 路由\n\n以获取留言列表，创建留言为例 routes/comments.js\n\nconst router = require('koa-router')()\nconst { Comment } = require('../db/model')\n\nrouter.prefix('/api')\n\n// 定义路由：模拟获取留言板列表\nrouter.get('/list', async (ctx, next) => {\n    const query = ctx.query // req 功能\n    console.log('query', query)\n    // ctx.body = 'api list' // res 功能\n\n    // 获取数据库的列表\n    const commentList = await Comment.find().sort({ _id: -1 })\n\n    ctx.body = {\n        errno: 0,\n        data: commentList,\n    }\n})\n\n// 定义路由：模拟创建留言\nrouter.post('/create', async ctx => {\n    const body = ctx.request.body // request body\n    console.log('body', body)\n\n    // 获取数据\n    const { content, username } = body\n    // 插入到数据库\n    const newComment = await Comment.create({\n        content,\n        username,\n    })\n\n    ctx.body = {\n        errno: 0,\n        message: '成功',\n        data: newComment,\n    }\n})\n\nmodule.exports = router // 输出\n\n\n\n#\n\n【",normalizedContent:"// todo: 2022-5-25 查\n\n\n# 安装\n\n\n# windows\n\nwindows下的安装比较简单，不赘述\n\n\n# macos\n\n建议使用homebrew进行安装\n\n第一步：brew tap mongodb/brew\n\n第二步：brew install mongodb-community\n\n接着启动 mongodb 服务：brew services start mongodb-community\n\n在终端下输入mongo进行测试\n\n\n# 概念\n\n数据库 database---\x3e集合 collection---\x3e文档 document\n\n\n# nosql\n\n关系型数据库需要学习 sql 语言\n\nnosql 数据库无需用 sql语句查询\n\n\n# node.js 连接 mongodb\n\n安装 mongodb 插件,当前版本@4.0.2,具体用法参考：mongodb-npm\n\nnpm i mongodb --save\n\n\n\n# 查询\n\nconst { mongoclient } = require('mongodb')\n\nconst url = 'mongodb://localhost:27017'\nconst client = new mongoclient(url)\n// 数据库名称\nconst dbname = 'comments'\n\nasync function main() {\n    await client.connect()\n    console.log('数据库连接成功!')\n    // 切换数据库\n    const db = client.db(dbname)\n    // 切换到指定的集合\n    const collection = db.collection('message')\n    // 返回查询结果\n    return await collection.find({}).toarray()\n}\n\nmain()\n    .then(res => console.log('查询结果：', res))\n    .catch(err => console.error('出错：', err))\n    .finally(() => client.close())\n\n\n\n# 查询条件\n\ncollection.find({ city: 'shanghai' }).toarray()\n\n\n\n# 排序\n\n// -1逆序  1顺序\ncollection.find().sort({ _id: -1 }).toarray()\n\n\n\n# 新增\n\ninsertmany同时新增多条文档，需要传入一个数组对象\n\nconst { mongoclient } = require('mongodb')\n\nconst url = 'mongodb://localhost:27017'\nconst client = new mongoclient(url)\n// 数据库名称\nconst dbname = 'comments'\n\nasync function main() {\n    await client.connect()\n    console.log('数据库连接成功!')\n    // 切换数据库\n    const db = client.db(dbname)\n    // 切换到指定的集合\n    const collection = db.collection('message')\n    //  插入一条文档\n    return await collection.insertone({\n        name: 'zhangfanhang',\n        message: 'this is a message!',\n    })\n    // return await collection.insertmany([\n    //     {\n    //         name: 'frank',\n    //         message: '这是第1个message',\n    //     },\n    //     {\n    //         name: 'frank',\n    //         message: '这是第2个message',\n    //     },\n    //     {\n    //         name: 'frank',\n    //         message: '这是第2个message',\n    //     },\n    // ])\n}\n\nmain()\n    .then(res => console.log('插入成功！', res))\n    .catch(err => console.error('插入出错！', err))\n    .finally(() => client.close())\n\n\n\n# 修改\n\nconst { mongoclient } = require('mongodb')\n\nconst url = 'mongodb://localhost:27017'\nconst client = new mongoclient(url)\n// 数据库名称\nconst dbname = 'comments'\n\nasync function main() {\n    await client.connect()\n    console.log('数据库连接成功!')\n    // 切换数据库\n    const db = client.db(dbname)\n    // 切换到指定的集合\n    const collection = db.collection('message')\n    // 返回查询结果\n    return await collection.updateone(\n        // 修改的条件\n        { name: 'fuvke' },\n        // 要修改的属性和属性值,或者要新增的属性和属性值\n        { $set: { message: 'change', age: 12 } }\n    )\n}\n\nmain()\n    .then(res => console.log('修改成功！', res))\n    .catch(err => console.error('修改出错！', err))\n    .finally(() => client.close())\n\n\n\n# 删除\n\ndeletemany 删除所有符合条件的文档，deleteone 删除一条最先添加到集合中的文档\n\nconst { mongoclient } = require('mongodb')\n\nconst url = 'mongodb://localhost:27017'\nconst client = new mongoclient(url)\n// 数据库名称\nconst dbname = 'comments'\n\nasync function main() {\n    await client.connect()\n    console.log('数据库连接成功!')\n    // 切换数据库\n    const db = client.db(dbname)\n    // 切换到指定的集合\n    const collection = db.collection('message')\n    // 返回结果\n    return await collection.deletemany({ name: 'frank' })\n    // return await collection.insertmany([\n    //     {\n    //         name: 'frank',\n    //         message: '这是第1个frank message',\n    //     },\n    //     {\n    //         name: 'frank',\n    //         message: '这是第2个frank message',\n    //     },\n    //     {\n    //         name: 'frank',\n    //         message: '这是第2个frank message',\n    //     },\n    // ])\n}\n\nmain()\n    .then(res => console.log('删除成功！', res))\n    .catch(err => console.error('删除出错！', err))\n    .finally(() => client.close())\n\n\n\n# mongoose\n\n\n# 为什么要用 mongoose?\n\nmongodb 的数据格式过于灵活，可以插入任何数据，不受限制。实际开发中，要有数据格式的规范(重要)。\n\nmongoose 可以提供规范，\n\n * schema 可以定义数据格式的规范\n * 以 model 规范 collection（集合）\n * 规范数据操作的 api\n\n\n# 安装 mongoose\n\n> 以下代码测试环境为 mongose@5.9.9 node.js v12.16.1\n\nnpm i mongoose@5.9.9 --save\n\n\n\n# 连接数据库\n\ndb/db.js\n\n// 连接数据库（mongodb的服务端）\n\nconst mongoose = require('mongoose')\n\nconst url = 'mongodb://localhost:27017'\nconst dbname = 'commentdb'\n\n// 将 mongoose 发送到 mongodb 的操作打印到控制台\nmongoose.set('debug', true)\n// 写上就完了\nmongoose.set('usecreateindex', true)\nmongoose.set('usefindandmodify', true)\n\n// 开始连接\nmongoose.connect(`${url}/${dbname}`, {\n    usenewurlparser: true,\n    useunifiedtopology: true,\n})\n\nconst conn = mongoose.connection\n\nconn.on('error', err => {\n    console.error('mongoose 连接出错', err)\n})\n\nmodule.exports = mongoose // commonjs\n\n\n\n# 定义 schema\n\ndb/model.js\n\n// 数据模型（规范数据格式）\n\nconst mongoose = require('./db')\n\n// 定义 user schema （数据规范）\nconst userschema = mongoose.schema(\n    {\n        username: {\n            type: string,\n            required: true, // 必需\n            unique: true, // 唯一，不重复\n        },\n        password: string,\n        age: number,\n        city: string,\n        // 性别\n        gender: {\n            type: number,\n            default: 0, // 0 - 保密，1 男，2 女\n        },\n    },\n    {\n        timestamps: true, // 时间戳，自动添加文档的创建时间、更新时间\n    }\n)\n\n// 定义 user model\nconst user = mongoose.model('user', userschema)\n\n// 定义 comment schema\nconst commentschema = mongoose.schema(\n    {\n        content: {\n            type: string,\n            required: true, // 必需\n        },\n        username: string, // 用户名\n    },\n    { timestamps: true }\n)\n\n// 定义 comment model\nconst comment = mongoose.model('comment', commentschema)\n\nmodule.exports = {\n    user,\n    comment,\n}\n\n\n\n# 新增\n\nconst { user } = require('./model')\n!(async () => {\n    const zhangsan = new user({\n        username: '李四2',\n        password: 'bbbb',\n        age: 18,\n        city: '上海',\n        gender: 2,\n    })\n    zhangsan.save()\n})()\n\n\ncreate()方法返回的是 promise 对象，里面包含返回值，使用 await 可以直接拿到值，输出比较方便，所以这里添加了 await 。具体情况具体分析，如果不输出也不一定要加 await 。\n\nconst { user } = require('./model')\n!(async () => {\n    const wangwu = await user.create({\n        username: '王五',\n        password: '123456',\n        age: 21,\n        city: '南京',\n    })\n    console.log('王五创建完成', wangwu)\n})()\n\n\n\n# 查询\n\ndb/test.js\n\n查询列表数据，返回的是数组\n\nconst { user } = require('./model')\n!(async () => {\n    const uselist = await user.find()\n    console.log('查询结果', uselist)\n})()\n\n\n查询单条数据，返回的是对象\n\nconst { user } = require('./model')\n!(async () => {\n    const user = await user.findone({ username: '王五' })\n    console.log('查询结果', user)\n})()\n\n\n\n# 查询条件\n\ndb/test.js 查询列表数据，返回的是数组\n\nconst { user } = require('./model')\n!(async () => {\n    const uselist = await user.find({ age: '21' })\n    console.log('查询结果', uselist)\n})()\n\n\n\n# 排序\n\n查询列表数据，返回的是数组\n\nconst { user } = require('./model')\n!(async () => {\n    const uselist = await user.find().sort({ _id: -1 })\n    console.log('查询结果', uselist)\n})()\n\n\n\n# 更新\n\nconst { user } = require('./model')\n// 定义一个 async 的匿名函数，并执行。为了里面能用 await\n!(async () => {\n    // 更新\n    const updateresult = await user.findoneandupdate(\n        { username: 'zhangsan' }, // 条件\n        { age: 30 }, // 更新的内容\n        {\n            new: true, // 返回更新后的数据,不写返回的是更新前的数据\n        }\n    )\n    console.log('更新的返回结果', updateresult)\n})()\n\n\n\n# 删除\n\nconst { user } = require('./model')\n// 定义一个 async 的匿名函数，并执行。为了里面能用 await\n!(async () => {\n    // 删除\n    const removeresult = await user.remove({ username: 'lisi' })\n    console.log('删除的返回结果', removeresult)\n})()\n\n\n\n# 对接 nodejs 路由\n\n以获取留言列表，创建留言为例 routes/comments.js\n\nconst router = require('koa-router')()\nconst { comment } = require('../db/model')\n\nrouter.prefix('/api')\n\n// 定义路由：模拟获取留言板列表\nrouter.get('/list', async (ctx, next) => {\n    const query = ctx.query // req 功能\n    console.log('query', query)\n    // ctx.body = 'api list' // res 功能\n\n    // 获取数据库的列表\n    const commentlist = await comment.find().sort({ _id: -1 })\n\n    ctx.body = {\n        errno: 0,\n        data: commentlist,\n    }\n})\n\n// 定义路由：模拟创建留言\nrouter.post('/create', async ctx => {\n    const body = ctx.request.body // request body\n    console.log('body', body)\n\n    // 获取数据\n    const { content, username } = body\n    // 插入到数据库\n    const newcomment = await comment.create({\n        content,\n        username,\n    })\n\n    ctx.body = {\n        errno: 0,\n        message: '成功',\n        data: newcomment,\n    }\n})\n\nmodule.exports = router // 输出\n\n\n\n#\n\n【",charsets:{cjk:!0},lastUpdated:"2022年05月29日",lastUpdatedTimestamp:1653837709e3},{title:"图",frontmatter:{title:"图",readingShow:"top"},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%9B%BE.html",relativePath:"数据结构算法/图.md",key:"v-ef44e3ec",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%9B%BE.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"图的深度广度优先遍历",slug:"图的深度广度优先遍历",normalizedTitle:"图的深度广度优先遍历",charIndex:140}],headersStr:"简介 图的深度广度优先遍历",content:"# 简介\n\n图是网络结构的抽象模型，是一组由边连接的节点\n\n图可以表示任何二元关系,比如道路航班......\n\nJS 中没有图，但是可以用 Object和 Array 构建图\n\n图的表示法：邻接矩阵、邻接表、关联矩阵......\n\n * 邻接矩阵\n\n\n\n * 邻接表\n\n\n\n\n# 图的深度广度优先遍历",normalizedContent:"# 简介\n\n图是网络结构的抽象模型，是一组由边连接的节点\n\n图可以表示任何二元关系,比如道路航班......\n\njs 中没有图，但是可以用 object和 array 构建图\n\n图的表示法：邻接矩阵、邻接表、关联矩阵......\n\n * 邻接矩阵\n\n\n\n * 邻接表\n\n\n\n\n# 图的深度广度优先遍历",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"序言",frontmatter:{title:"序言",date:"2022/05/11 14:21:16",readingShow:"top"},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/",relativePath:"数据结构算法/README.md",key:"v-efde0330",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/",headersStr:null,content:"在前端工程师中，常常有一种声音：“我为什么要学习数据结构与算法？没有数据结构与 算法，我一样很好地完成了工作？”\n\n实际上，算法是一个十分宽泛的概念，我们写的任何程序都可称为算法，甚至往冰箱里面 放一头大象，也要经过开门、放入、关门这样的规划，这也可以视为一种简单的算法。可 以说，简单的算法是人类的本能。而算法知识的学习则是吸取前人的经验，对复杂的问题 进行归类、抽象，帮助我们脱离刀耕火种时代，系统掌握算法的一个过程。 随着自身成长和职业发展，不论是做前端、服务端还是客户端，任何一个程序员都会开始 面对更加复杂的问题，算法和数据结构知识就变得不可或缺了。\n\n我一直认为前端工程师则是最需要重视算法和数据结构基础的人。因为历史原因，不少前 端工程师是从视觉设计、网站编辑转过来的，在学校没有学过相应的基础课程，而数据结 构与算法的经典名著大部分又没照顾到入门的需要，所以前端工程师如果自身不重视算法 和数据结构这样的基础知识，很可能陷入数年从事单一重复劳动毫无成长这样的职业发展 困境。在移动浪潮到来之后，用户体验要求越来越高，对前端提出了更高的要求，前端这 个职能，必须提高自身才能继续发展，未来的网页 UI，绝对不是靠几个选择器操作加超链接就能应付的。越来越复杂的产品和基础库，需要坚实的数据结构与算法基础才能驾驭。\n\n《数据结构与算法 JavaScript 描述》 推荐序 **程劭非** **阿里无线事业部高级技术专家** 2014 年 7 月",normalizedContent:"在前端工程师中，常常有一种声音：“我为什么要学习数据结构与算法？没有数据结构与 算法，我一样很好地完成了工作？”\n\n实际上，算法是一个十分宽泛的概念，我们写的任何程序都可称为算法，甚至往冰箱里面 放一头大象，也要经过开门、放入、关门这样的规划，这也可以视为一种简单的算法。可 以说，简单的算法是人类的本能。而算法知识的学习则是吸取前人的经验，对复杂的问题 进行归类、抽象，帮助我们脱离刀耕火种时代，系统掌握算法的一个过程。 随着自身成长和职业发展，不论是做前端、服务端还是客户端，任何一个程序员都会开始 面对更加复杂的问题，算法和数据结构知识就变得不可或缺了。\n\n我一直认为前端工程师则是最需要重视算法和数据结构基础的人。因为历史原因，不少前 端工程师是从视觉设计、网站编辑转过来的，在学校没有学过相应的基础课程，而数据结 构与算法的经典名著大部分又没照顾到入门的需要，所以前端工程师如果自身不重视算法 和数据结构这样的基础知识，很可能陷入数年从事单一重复劳动毫无成长这样的职业发展 困境。在移动浪潮到来之后，用户体验要求越来越高，对前端提出了更高的要求，前端这 个职能，必须提高自身才能继续发展，未来的网页 ui，绝对不是靠几个选择器操作加超链接就能应付的。越来越复杂的产品和基础库，需要坚实的数据结构与算法基础才能驾驭。\n\n《数据结构与算法 javascript 描述》 推荐序 **程劭非** **阿里无线事业部高级技术专家** 2014 年 7 月",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652251017e3},{title:"字典",frontmatter:{title:"字典",readingShow:"top"},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8.html",relativePath:"数据结构算法/字典.md",key:"v-180fb8c6",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"LeetCode：349. 两个数组的交集",slug:"leetcode-349-两个数组的交集",normalizedTitle:"leetcode：349. 两个数组的交集",charIndex:81},{level:2,title:"LeetCode：20.有效的括号",slug:"leetcode-20-有效的括号",normalizedTitle:"leetcode：20.有效的括号",charIndex:864},{level:2,title:"LeetCode：1. 两数之和",slug:"leetcode-1-两数之和",normalizedTitle:"leetcode：1. 两数之和",charIndex:1569},{level:2,title:"LeetCode：3. 无重复字符的最长子串",slug:"leetcode-3-无重复字符的最长子串",normalizedTitle:"leetcode：3. 无重复字符的最长子串",charIndex:2158},{level:2,title:"LeetCode：76. 最小覆盖子串",slug:"leetcode-76-最小覆盖子串",normalizedTitle:"leetcode：76. 最小覆盖子串",charIndex:3002}],headersStr:"简介 LeetCode：349. 两个数组的交集 LeetCode：20.有效的括号 LeetCode：1. 两数之和 LeetCode：3. 无重复字符的最长子串 LeetCode：76. 最小覆盖子串",content:"# 简介\n\n与集合类似，字典也是一种存储唯一值的数据结构，但它是以键值对的形式来存储。\n\nES6中有字典，名为Map\n\n字典的常用操作：键值对的增删改查\n\n\n# LeetCode：349. 两个数组的交集\n\nLeetCode：349. 两个数组的交集\n\n * 解题思路\n\n求nums1 和 nums2 都有的值\n\n用字典建立一个映射关系，记录nums1里都有的值\n\n遍历 nums2 找出nums1里也有的值\n\n * 解题步骤\n\n新建一个字典，遍历nums1,填充字典\n\n遍历nums2 遇到字典里的值就选出，并从字典中删除\n\n/*\n * @lc app=leetcode.cn id=349 lang=javascript\n *\n * [349] 两个数组的交集\n */\n\n// @lc code=start\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersection = function (nums1, nums2) {\n    // 集合\n    // return [...new Set(nums1)].filter((item) => {\n    //     return nums2.includes(item)\n    // })\n    // 字典\n    let m = new Map()\n    nums1.forEach(item=>{\n        m.set(item,true)\n    })\n    let res=[]\n    nums2.forEach(item=>{\n        if(m.get(item)){\n            res.push(item)\n            m.delete(item)\n        }\n    })\n    return res\n};\n// @lc code=end\n\n\n\n\n# LeetCode：20.有效的括号\n\nLeetCode：20.有效的括号 使用字典建立左右括号映射关系\n\n/*\n * @lc app=leetcode.cn id=20 lang=javascript\n *\n * [20] 有效的括号\n */\n\n// @lc code=start\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function (s) {\n    // 有手就行\n    const stack = []\n    const map= new Map()\n    map.set('{','}')\n    map.set('(',')')\n    map.set('[',']')\n    for (let i = 0; i < s.length; i++) {\n        if (map.has(s[i])) {\n            stack.push(s[i])\n        } else {\n            const top = stack[stack.length - 1]\n            if (map.get(top)===s[i]) {\n                stack.pop()\n            } else {\n                return false\n            }\n        }\n    }\n    return stack.length === 0\n}\n// @lc code=end\n\n\n\n# LeetCode：1. 两数之和\n\nLeetCode：1. 两数之和\n\n * 解题思路\n\n把nums想象成相亲者\n\n把target想象成匹配条件\n\n用字典建立一个婚姻介绍所，存储相亲者的数字和下标\n\n * 解题步骤\n\n新建一个字典作为婚姻介绍所。\n\nnums里的值，逐个来介绍所找对象，没有合适的就先登记着，有合适的就牵手成功。\n\n/*\n * @lc app=leetcode.cn id=1 lang=javascript\n *\n * [1] 两数之和\n */\n\n// @lc code=start\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function (nums, target) {\n  let map = new Map()\n  for ([index, val] of nums.entries()) {\n    let n = target - val\n    if (map.has(n)) {\n      return [ map.get(n),index]\n    } else {\n      map.set(val, index)\n    } \n  }\n};\n// @lc code=end\n\n\n\n# LeetCode：3. 无重复字符的最长子串\n\nLeetCode：3. 无重复字符的最长子串\n\n * 解题思路\n\n先找出所有的不包含重复字符的子串\n\n找出长度最大那个子串，返回其长度即可。\n\n * 解题步骤\n\n用双指针维护一个滑动窗口(slice)，用来剪切子串。\n\n不断移动右指针，遇到重复字符，就把左指针移动到重复字符的下一位。\n\n过程中，记录所有窗口的长度，并返回最大值。\n\n有个坑\n\n如果输入的为“abbcdea”,无重复字符的最长子串的长度应该为5(\"bcdea\")，此时左指针在索引为2的那一项，当右指针要马上指向最后一个a时，发现map中已经有一个a了，所以会移动左指针到索引为1的位置，这就导致输出结果为6了\n\n解决方法：移动左指针时，必须确保重复字符的索引必须大于左指针的索引\n\n/*\n * @lc app=leetcode.cn id=3 lang=javascript\n *\n * [3] 无重复字符的最长子串\n */\n\n// @lc code=start\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function (s) {\n    let l = 0\n    let r = 0\n    let res = 0\n    let map = new Map()\n    for (r = 0; r < s.length; r++) {\n        if (map.has(s[r]) && map.get(s[r]) >= l) {\n            l = map.get(s[r]) + 1\n        }\n        res = Math.max(res, r - l + 1)\n        map.set(s[r], r)\n    }\n    return res\n};\n// @lc code=end\n\n\n\n# LeetCode：76. 最小覆盖子串\n\nLeetCode：76. 最小覆盖子串\n\n * 解题思路\n\n先找出所有的包含T的子串。\n\n找出长度最小那个子串，返回即可。\n\n * 解题步骤\n\n用双指针维护一个滑动窗口。\n\n移动右指针，找到包含T的子串，移动左指针，尽量减少包含T的子串的长度。\n\n循环上述过程，找出包含T的最小子串\n\n提示\n\nsubstring参数为左闭右开区间，substring(a,b)可以得到从a开始到b结束（不包括b处）的子串\n\n/*\n * @lc app=leetcode.cn id=76 lang=javascript\n *\n * [76] 最小覆盖子串\n */\n\n// @lc code=start\n/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function (s, t) {\n    let l = 0\n    let r = 0\n    let res = ''\n    // 需要\n    const need = new Map()\n    for (let c of t) {\n        need.set(c, need.has(c) ? need.get(c) + 1 : 1)\n    }\n    let needType = need.size\n    while (r < s.length) {\n        const c = s[r]\n        if (need.has(c)) {\n            need.set(c, need.get(c) - 1)\n            if (need.get(c) === 0) needType--\n        }\n        while (needType === 0) {\n            let newRes = s.substring(l, r + 1)\n            if (!res || newRes.length < res.length) res = newRes\n            const c2 = s[l]\n            if (need.has(c2)) {\n                need.set(c2, need.get(c2) + 1)\n                if (need.get(c2) === 1) needType++\n            }\n            l++\n        }\n        r++\n    }\n    return res\n};\n// @lc code=end\n",normalizedContent:"# 简介\n\n与集合类似，字典也是一种存储唯一值的数据结构，但它是以键值对的形式来存储。\n\nes6中有字典，名为map\n\n字典的常用操作：键值对的增删改查\n\n\n# leetcode：349. 两个数组的交集\n\nleetcode：349. 两个数组的交集\n\n * 解题思路\n\n求nums1 和 nums2 都有的值\n\n用字典建立一个映射关系，记录nums1里都有的值\n\n遍历 nums2 找出nums1里也有的值\n\n * 解题步骤\n\n新建一个字典，遍历nums1,填充字典\n\n遍历nums2 遇到字典里的值就选出，并从字典中删除\n\n/*\n * @lc app=leetcode.cn id=349 lang=javascript\n *\n * [349] 两个数组的交集\n */\n\n// @lc code=start\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersection = function (nums1, nums2) {\n    // 集合\n    // return [...new set(nums1)].filter((item) => {\n    //     return nums2.includes(item)\n    // })\n    // 字典\n    let m = new map()\n    nums1.foreach(item=>{\n        m.set(item,true)\n    })\n    let res=[]\n    nums2.foreach(item=>{\n        if(m.get(item)){\n            res.push(item)\n            m.delete(item)\n        }\n    })\n    return res\n};\n// @lc code=end\n\n\n\n\n# leetcode：20.有效的括号\n\nleetcode：20.有效的括号 使用字典建立左右括号映射关系\n\n/*\n * @lc app=leetcode.cn id=20 lang=javascript\n *\n * [20] 有效的括号\n */\n\n// @lc code=start\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isvalid = function (s) {\n    // 有手就行\n    const stack = []\n    const map= new map()\n    map.set('{','}')\n    map.set('(',')')\n    map.set('[',']')\n    for (let i = 0; i < s.length; i++) {\n        if (map.has(s[i])) {\n            stack.push(s[i])\n        } else {\n            const top = stack[stack.length - 1]\n            if (map.get(top)===s[i]) {\n                stack.pop()\n            } else {\n                return false\n            }\n        }\n    }\n    return stack.length === 0\n}\n// @lc code=end\n\n\n\n# leetcode：1. 两数之和\n\nleetcode：1. 两数之和\n\n * 解题思路\n\n把nums想象成相亲者\n\n把target想象成匹配条件\n\n用字典建立一个婚姻介绍所，存储相亲者的数字和下标\n\n * 解题步骤\n\n新建一个字典作为婚姻介绍所。\n\nnums里的值，逐个来介绍所找对象，没有合适的就先登记着，有合适的就牵手成功。\n\n/*\n * @lc app=leetcode.cn id=1 lang=javascript\n *\n * [1] 两数之和\n */\n\n// @lc code=start\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twosum = function (nums, target) {\n  let map = new map()\n  for ([index, val] of nums.entries()) {\n    let n = target - val\n    if (map.has(n)) {\n      return [ map.get(n),index]\n    } else {\n      map.set(val, index)\n    } \n  }\n};\n// @lc code=end\n\n\n\n# leetcode：3. 无重复字符的最长子串\n\nleetcode：3. 无重复字符的最长子串\n\n * 解题思路\n\n先找出所有的不包含重复字符的子串\n\n找出长度最大那个子串，返回其长度即可。\n\n * 解题步骤\n\n用双指针维护一个滑动窗口(slice)，用来剪切子串。\n\n不断移动右指针，遇到重复字符，就把左指针移动到重复字符的下一位。\n\n过程中，记录所有窗口的长度，并返回最大值。\n\n有个坑\n\n如果输入的为“abbcdea”,无重复字符的最长子串的长度应该为5(\"bcdea\")，此时左指针在索引为2的那一项，当右指针要马上指向最后一个a时，发现map中已经有一个a了，所以会移动左指针到索引为1的位置，这就导致输出结果为6了\n\n解决方法：移动左指针时，必须确保重复字符的索引必须大于左指针的索引\n\n/*\n * @lc app=leetcode.cn id=3 lang=javascript\n *\n * [3] 无重复字符的最长子串\n */\n\n// @lc code=start\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthoflongestsubstring = function (s) {\n    let l = 0\n    let r = 0\n    let res = 0\n    let map = new map()\n    for (r = 0; r < s.length; r++) {\n        if (map.has(s[r]) && map.get(s[r]) >= l) {\n            l = map.get(s[r]) + 1\n        }\n        res = math.max(res, r - l + 1)\n        map.set(s[r], r)\n    }\n    return res\n};\n// @lc code=end\n\n\n\n# leetcode：76. 最小覆盖子串\n\nleetcode：76. 最小覆盖子串\n\n * 解题思路\n\n先找出所有的包含t的子串。\n\n找出长度最小那个子串，返回即可。\n\n * 解题步骤\n\n用双指针维护一个滑动窗口。\n\n移动右指针，找到包含t的子串，移动左指针，尽量减少包含t的子串的长度。\n\n循环上述过程，找出包含t的最小子串\n\n提示\n\nsubstring参数为左闭右开区间，substring(a,b)可以得到从a开始到b结束（不包括b处）的子串\n\n/*\n * @lc app=leetcode.cn id=76 lang=javascript\n *\n * [76] 最小覆盖子串\n */\n\n// @lc code=start\n/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minwindow = function (s, t) {\n    let l = 0\n    let r = 0\n    let res = ''\n    // 需要\n    const need = new map()\n    for (let c of t) {\n        need.set(c, need.has(c) ? need.get(c) + 1 : 1)\n    }\n    let needtype = need.size\n    while (r < s.length) {\n        const c = s[r]\n        if (need.has(c)) {\n            need.set(c, need.get(c) - 1)\n            if (need.get(c) === 0) needtype--\n        }\n        while (needtype === 0) {\n            let newres = s.substring(l, r + 1)\n            if (!res || newres.length < res.length) res = newres\n            const c2 = s[l]\n            if (need.has(c2)) {\n                need.set(c2, need.get(c2) + 1)\n                if (need.get(c2) === 1) needtype++\n            }\n            l++\n        }\n        r++\n    }\n    return res\n};\n// @lc code=end\n",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"栈",frontmatter:{title:"栈",sidebarDepth:2,readingShow:"top"},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%A0%88.html",relativePath:"数据结构算法/栈.md",key:"v-275267e8",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%A0%88.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:155},{level:3,title:"十进制转二级制",slug:"十进制转二级制",normalizedTitle:"十进制转二级制",charIndex:175},{level:3,title:"判断字符串的括号是否有效",slug:"判断字符串的括号是否有效",normalizedTitle:"判断字符串的括号是否有效",charIndex:787},{level:3,title:"前端与栈：函数调用堆栈",slug:"前端与栈-函数调用堆栈",normalizedTitle:"前端与栈：函数调用堆栈",charIndex:1654}],headersStr:"简介 应用场景 十进制转二级制 判断字符串的括号是否有效 前端与栈：函数调用堆栈",content:"# 简介\n\n * 一个后进先出的数据结构\n * js 中没有栈，但可以用 Array 实现栈的所有功能\n\nconst stack = []\nstack.push(1)\nstack.push(2)\nconst item1 = stack.pop()\nconst item2 = stack.pop()\n\n\n\n# 应用场景\n\n需要后进先出的场景\n\n\n# 十进制转二级制\n\n\n\n后出来的余数反而要排到前面\n把余数依次入栈，然后再出栈，就可以实现余数倒序输出\n\nconst tenToTwo = num => {\n    const stack = []\n    let remainNum\n    while (num >= 1) {\n        remainNum = num % 2\n        // 向下取整\n        num = Math.floor(num / 2)\n        stack.push(remainNum)\n    }\n    let str = ``\n    while (stack.length > 0) {\n        str += stack.pop()\n    }\n    return str\n}\n\n\n个人思路：不用栈，直接把字符串反转\n\nconst tenToTwo = num => {\n    const arr = []\n    let remainNum\n    while (num >= 1) {\n        remainNum = num % 2\n        // 向下取整\n        num = Math.floor(num / 2)\n        arr.push(remainNum)\n    }\n    return arr.reverse().join('')\n}\n\n\n\n# 判断字符串的括号是否有效\n\n20.有效的括号\n\n * 解题思路 对于没有闭合的左括号而言，越靠后的左括号，对应的右括号越靠前;满足后进先出，考虑用栈。\n\n * 解题步骤\n\n 1. 新建一个栈\n 2. 遍历字符串，遇左括号入栈，遇到和栈顶括号类型匹配的右括号就出栈，类型不匹配直接判定为不合法。\n 3. 最后栈空了就合法，否则不合法\n\n注意\n\n可以使用字典 Map 优化算法\n\n/*\n * @lc app=leetcode.cn id=20 lang=javascript\n *\n * [20] 有效的括号\n */\n\n// @lc code=start\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function (s) {\n    if (s.length < 2) return false\n    const stack = []\n    const map = new Map()\n    map.set('{', '}')\n    map.set('(', ')')\n    map.set('[', ']')\n    for (let i = 0; i < s.length; i++) {\n        if (map.has(s[i])) {\n            stack.push(s[i])\n        } else {\n            let top = stack[stack.length - 1]\n            if (s[i] === map.get(top)) {\n                stack.pop()\n            } else {\n                return false\n            }\n        }\n    }\n    return stack.length === 0\n}\n// @lc code=end\n\n\n\n# 前端与栈：函数调用堆栈\n\n * js 解释器使用栈来控制函数的调用顺序\n\n * 最后调用的函数反而最先执行完\n\nconst fun1 = () => {\n    fun2()\n}\nconst fun2 = () => {\n    fun3()\n}\nconst fun3 = () => {}\nfun1()\n\n\n函数执行顺序fun3() -> fun2() -> fun1()",normalizedContent:"# 简介\n\n * 一个后进先出的数据结构\n * js 中没有栈，但可以用 array 实现栈的所有功能\n\nconst stack = []\nstack.push(1)\nstack.push(2)\nconst item1 = stack.pop()\nconst item2 = stack.pop()\n\n\n\n# 应用场景\n\n需要后进先出的场景\n\n\n# 十进制转二级制\n\n\n\n后出来的余数反而要排到前面\n把余数依次入栈，然后再出栈，就可以实现余数倒序输出\n\nconst tentotwo = num => {\n    const stack = []\n    let remainnum\n    while (num >= 1) {\n        remainnum = num % 2\n        // 向下取整\n        num = math.floor(num / 2)\n        stack.push(remainnum)\n    }\n    let str = ``\n    while (stack.length > 0) {\n        str += stack.pop()\n    }\n    return str\n}\n\n\n个人思路：不用栈，直接把字符串反转\n\nconst tentotwo = num => {\n    const arr = []\n    let remainnum\n    while (num >= 1) {\n        remainnum = num % 2\n        // 向下取整\n        num = math.floor(num / 2)\n        arr.push(remainnum)\n    }\n    return arr.reverse().join('')\n}\n\n\n\n# 判断字符串的括号是否有效\n\n20.有效的括号\n\n * 解题思路 对于没有闭合的左括号而言，越靠后的左括号，对应的右括号越靠前;满足后进先出，考虑用栈。\n\n * 解题步骤\n\n 1. 新建一个栈\n 2. 遍历字符串，遇左括号入栈，遇到和栈顶括号类型匹配的右括号就出栈，类型不匹配直接判定为不合法。\n 3. 最后栈空了就合法，否则不合法\n\n注意\n\n可以使用字典 map 优化算法\n\n/*\n * @lc app=leetcode.cn id=20 lang=javascript\n *\n * [20] 有效的括号\n */\n\n// @lc code=start\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isvalid = function (s) {\n    if (s.length < 2) return false\n    const stack = []\n    const map = new map()\n    map.set('{', '}')\n    map.set('(', ')')\n    map.set('[', ']')\n    for (let i = 0; i < s.length; i++) {\n        if (map.has(s[i])) {\n            stack.push(s[i])\n        } else {\n            let top = stack[stack.length - 1]\n            if (s[i] === map.get(top)) {\n                stack.pop()\n            } else {\n                return false\n            }\n        }\n    }\n    return stack.length === 0\n}\n// @lc code=end\n\n\n\n# 前端与栈：函数调用堆栈\n\n * js 解释器使用栈来控制函数的调用顺序\n\n * 最后调用的函数反而最先执行完\n\nconst fun1 = () => {\n    fun2()\n}\nconst fun2 = () => {\n    fun3()\n}\nconst fun3 = () => {}\nfun1()\n\n\n函数执行顺序fun3() -> fun2() -> fun1()",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652251017e3},{title:"链表",frontmatter:{title:"链表",sidebarDepth:2,readingShow:"top"},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8.html",relativePath:"数据结构算法/链表.md",key:"v-7230c420",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"LeetCode：237.删除链表中的节点",slug:"leetcode-237-删除链表中的节点",normalizedTitle:"leetcode：237.删除链表中的节点",charIndex:469},{level:2,title:"LeetCode：206.反转链表",slug:"leetcode-206-反转链表",normalizedTitle:"leetcode：206.反转链表",charIndex:1108},{level:2,title:"LeetCode：2. 两数相加",slug:"leetcode-2-两数相加",normalizedTitle:"leetcode：2. 两数相加",charIndex:2282},{level:2,title:"LeetCode：83. 删除排序链表中的重复元素",slug:"leetcode-83-删除排序链表中的重复元素",normalizedTitle:"leetcode：83. 删除排序链表中的重复元素",charIndex:3244},{level:2,title:"LeetCode：141. 环形链表",slug:"leetcode-141-环形链表",normalizedTitle:"leetcode：141. 环形链表",charIndex:4028},{level:2,title:"LeetCode： 234. 回文链表",slug:"leetcode-234-回文链表",normalizedTitle:"leetcode： 234. 回文链表",charIndex:4735},{level:2,title:"前端与链表：JS 中的原型链",slug:"前端与链表-js-中的原型链",normalizedTitle:"前端与链表：js 中的原型链",charIndex:6130},{level:3,title:"面试题：instanceof 的原理，并用代码实现。",slug:"面试题-instanceof-的原理-并用代码实现。",normalizedTitle:"面试题：instanceof 的原理，并用代码实现。",charIndex:6247},{level:3,title:"面试题：看输出",slug:"面试题-看输出",normalizedTitle:"面试题：看输出",charIndex:6381},{level:2,title:"前端与链表：使用链表指针获取 JSON 的节点值",slug:"前端与链表-使用链表指针获取-json-的节点值",normalizedTitle:"前端与链表：使用链表指针获取 json 的节点值",charIndex:6648}],headersStr:"简介 LeetCode：237.删除链表中的节点 LeetCode：206.反转链表 LeetCode：2. 两数相加 LeetCode：83. 删除排序链表中的重复元素 LeetCode：141. 环形链表 LeetCode： 234. 回文链表 前端与链表：JS 中的原型链 面试题：instanceof 的原理，并用代码实现。 面试题：看输出 前端与链表：使用链表指针获取 JSON 的节点值",content:"# 简介\n\n注意\n\n链表头就是一个链表，因为链表是一个串，你拿起来头，自然拿起来一串\n\n多个元素组成的列表。\n\n元素存储不连续，用 next 指针连在一起。\n\n\n\n在数组中增删非首尾元素时往往需要移动元素，链表在增删非首尾元素，不需要移动元素，只需要更改 next 的指向即可。\n\njs 中没有链表，需要用 Object 模拟:\n\nconst a = { val: 'a' }\nconst b = { val: 'b' }\nconst c = { val: 'c' }\nconst d = { val: 'd' }\n\n// 创建\na.next = b\nb.next = c\nc.next = d\n\n// 遍历\nlet p = a //声明一个指针指向a\nwhile (p) {\n    console.log(p.val)\n    p = p.next\n}\n// 插入e\nconst e = { val: 'e' }\nc.next = e\ne.next = d\nconsole.log(a)\n// 删除e\nc.next = d\n\n\n\n# LeetCode：237.删除链表中的节点\n\nLeetCode：237.删除链表中的节点\n\n * 解题思路\n\n无法直接获取被删除节点的上个节点\n\n把要删除的下个结点的值赋给被删除节点，然后将被删除节点的下一节点删除\n\n比如 1-2-3-4 要删除 3，先 1-2-4-4 然后删除最后一个 4，最后变成 1-2-4\n\n * 解题步骤\n\n将被删节点的值改为下个节点的值。\n\n删除下个节点。\n\n/*\n * @lc app=leetcode.cn id=237 lang=javascript\n *\n * [237] 删除链表中的节点\n */\n\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} node\n * @return {void} Do not return anything, modify node in-place instead.\n */\nvar deleteNode = function (node) {\n    node.val = node.next.val\n    node.next = node.next.next\n}\n// @lc code=end\n\n\n\n# LeetCode：206.反转链表\n\nLeetCode：206.反转链表\n\n * 解题思路\n\n反转两个节点：将 n+1 的 next 指向 n\n\n反转多个节点：双指针遍历链表，重复上述操作。\n\n * 解题步骤\n\n双指针一前一后遍历链表。\n\n反转双指针。\n\n解法一\n\n/*\n * @lc app=leetcode.cn id=206 lang=javascript\n *\n * [206] 反转链表\n */\n\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n    let [p1, p2] = [head, null]\n    while (p1) {\n        let tmp = p1.next\n        p1.next = p2\n        p2 = p1\n        p1 = tmp\n    }\n    return p2\n}\n// @lc code=end\n\n\n解法二\n\n/*\n * @lc app=leetcode.cn id=206 lang=javascript\n *\n * [206] 反转链表\n */\n\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function (head) {\n    let [p1, p2] = [head, null]\n    while (p1) {\n        ;[p1.next, p2, p1] = [p2, p1, p1.next]\n    }\n    return p2\n}\n// @lc code=end\n\n\n\n# LeetCode：2. 两数相加\n\nLeetCode：2. 两数相加\n\n * 解题思路\n\n小学数学题，模拟相加操作\n\n需要遍历链表\n\n * 解题步骤\n\n新建一个空链表\n\n遍历被相加的两个链表，模拟相加操作，将个位数追加到新链表上，将十位数留到下一位去相加\n\n/*\n * @lc app=leetcode.cn id=2 lang=javascript\n *\n * [2] 两数相加\n */\n\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n    let l3 = new ListNode()\n    let [p1, p2, p3, carry] = [l1, l2, l3, 0]\n    while (p1 || p2) {\n        let v1 = p1 ? p1.val : 0\n        let v2 = p2 ? p2.val : 0\n        let val = v1 + v2 + carry\n        carry = Math.floor(val / 10)\n        p3.next = new ListNode(val % 10)\n        if (p1) p1 = p1.next\n        if (p2) p2 = p2.next\n        p3 = p3.next\n    }\n    if (carry) p3.next = new ListNode(carry)\n    return l3.next\n}\n// @lc code=end\n\n\n\n# LeetCode：83. 删除排序链表中的重复元素\n\nLeetCode：83. 删除排序链表中的重复元素\n\n * 解题思路\n   \n   因为链表是有序的，所以重复元素一定相邻\n   \n   遍历链表，如果发现当前元素和下个元素值相同，就删除下个元素值\n\n * 解题步骤\n\n遍历链表，如果发现当前元素和下个元素值相同，就删除下个元素值\n\n遍历结束后，直接返回原链表的头部(head)\n\n/*\n * @lc app=leetcode.cn id=83 lang=javascript\n *\n * [83] 删除排序链表中的重复元素\n */\n\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteDuplicates = function (head) {\n    let p1 = head\n    while (p1 && p1.next) {\n        if (p1.val === p1.next.val) {\n            p1.next = p1.next.next\n        } else {\n            p1 = p1.next\n        }\n    }\n    return head\n}\n// @lc code=end\n\n\n\n# LeetCode：141. 环形链表\n\nLeetCode：141. 环形链表\n\n * 解题思路\n\n两个人在圆形操场上的起点同时起跑，速度快的人一定会超过速度慢的人一圈\n\n用一快一慢两个指针遍历链表，如果指针能够相逢，那么链表就有圈。\n\n\n\n * 解题步骤\n\n用一快一慢两个指针遍历链表，如果指针能够相逢，就返回 true。\n\n遍历结束后，还没有相逢就返回 false。\n\n/*\n * @lc app=leetcode.cn id=141 lang=javascript\n *\n * [141] 环形链表\n */\n\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar hasCycle = function (head) {\n    let [slow, fast] = [head, head]\n    while (slow && fast && fast.next) {\n        slow = slow.next\n        fast = fast.next.next\n        if (slow === fast) return true\n    }\n    return false\n}\n// @lc code=end\n\n\n\n# LeetCode： 234. 回文链表\n\nLeetCode： 234. 回文链表\n\n * 解题思路\n\n回文就是反转以后和以前一样的就是回文结构，例如 1->2->3->2->1，我们将它反转之后还是与原链表一样，我们就称这种链表结构为回文结构\n\n * 解题步骤\n\n快慢指针，起初都指向表头，快指针一次走两步，慢指针一次走一步，遍历结束时：\n\n要么，slow 正好指向中间两个结点的后一个。\n\n要么，slow 正好指向中间结点。\n\n用 prev 保存 slow 的前一个结点，通过prev.next = null断成两个链表。\n\n将后半段链表翻转(参考 leetcode.206)，和前半段从头比对。\n\n\n\n/*\n * @lc app=leetcode.cn id=234 lang=javascript\n *\n * [234] 回文链表\n */\n\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar isPalindrome = function (head) {\n    // 链表只有一个节点的情况\n    if (head.next == null) {\n        return true\n    }\n    let [fast, slow, prev] = [head, head, null]\n    while (fast && fast.next) {\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n    }\n    // 断成两个链表\n    prev.next = null\n    // 翻转后半段\n    let head2 = null\n    while (slow) {\n        // 解构赋值，不用使用临时变量\n        // ;[slow.next, head2, slow] = [head2, slow, slow.next]\n        let temp = slow.next\n        slow.next = head2\n        head2 = slow\n        slow = temp\n    }\n    // 前后两段进行比较\n    while (head && head2) {\n        if (head.val !== head2.val) {\n            return false\n        }\n        head = head.next\n        head2 = head2.next\n    }\n    return true\n}\n// @lc code=end\n\n\n\n# 前端与链表：JS 中的原型链\n\n原型链的本质是链表。\n\n原型链上的节点是各种原型对象， 比如 Function.prototype、 Object.prototype……\n\n原型链通过__proto__属性连接各种原型对象。\n\n\n# 面试题：instanceof 的原理，并用代码实现。\n\n知识点：如果 A 沿着原型链能找到B.prototype，那么A instanceof B为 true。\n\n解法：遍历 A 的原型链，如果找到B.prototype，返回 true，否则返回 false\n\n\n# 面试题：看输出\n\nconst foo = {}\nF = function () {}\nObject.prototype.a = 'value a'\nFunction.prototype.b = 'value b'\nconsole.log(foo.a)\nconsole.log(foo.b)\nconsole.log(F.b)\nconsole.log(F.b)\n\n\n知识点：如果在 A 对象上没有找到 ⅹ 属性，那么会沿着原型链找 ⅹ 属性。\n\n解法：明确 foo 和 F 变量的原型链，沿着原型链找 a 属性和 b 属性。\n\n\n\n\n# 前端与链表：使用链表指针获取 JSON 的节点值\n\nconst json = {\n    a: { b: { c: 1 } },\n    d: { e: 2 },\n}\nconst path = ['d', 'e']\n\nlet p = json\n\npath.forEach(k => {\n    p = p[k]\n})\n",normalizedContent:"# 简介\n\n注意\n\n链表头就是一个链表，因为链表是一个串，你拿起来头，自然拿起来一串\n\n多个元素组成的列表。\n\n元素存储不连续，用 next 指针连在一起。\n\n\n\n在数组中增删非首尾元素时往往需要移动元素，链表在增删非首尾元素，不需要移动元素，只需要更改 next 的指向即可。\n\njs 中没有链表，需要用 object 模拟:\n\nconst a = { val: 'a' }\nconst b = { val: 'b' }\nconst c = { val: 'c' }\nconst d = { val: 'd' }\n\n// 创建\na.next = b\nb.next = c\nc.next = d\n\n// 遍历\nlet p = a //声明一个指针指向a\nwhile (p) {\n    console.log(p.val)\n    p = p.next\n}\n// 插入e\nconst e = { val: 'e' }\nc.next = e\ne.next = d\nconsole.log(a)\n// 删除e\nc.next = d\n\n\n\n# leetcode：237.删除链表中的节点\n\nleetcode：237.删除链表中的节点\n\n * 解题思路\n\n无法直接获取被删除节点的上个节点\n\n把要删除的下个结点的值赋给被删除节点，然后将被删除节点的下一节点删除\n\n比如 1-2-3-4 要删除 3，先 1-2-4-4 然后删除最后一个 4，最后变成 1-2-4\n\n * 解题步骤\n\n将被删节点的值改为下个节点的值。\n\n删除下个节点。\n\n/*\n * @lc app=leetcode.cn id=237 lang=javascript\n *\n * [237] 删除链表中的节点\n */\n\n// @lc code=start\n/**\n * definition for singly-linked list.\n * function listnode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {listnode} node\n * @return {void} do not return anything, modify node in-place instead.\n */\nvar deletenode = function (node) {\n    node.val = node.next.val\n    node.next = node.next.next\n}\n// @lc code=end\n\n\n\n# leetcode：206.反转链表\n\nleetcode：206.反转链表\n\n * 解题思路\n\n反转两个节点：将 n+1 的 next 指向 n\n\n反转多个节点：双指针遍历链表，重复上述操作。\n\n * 解题步骤\n\n双指针一前一后遍历链表。\n\n反转双指针。\n\n解法一\n\n/*\n * @lc app=leetcode.cn id=206 lang=javascript\n *\n * [206] 反转链表\n */\n\n// @lc code=start\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} head\n * @return {listnode}\n */\nvar reverselist = function (head) {\n    let [p1, p2] = [head, null]\n    while (p1) {\n        let tmp = p1.next\n        p1.next = p2\n        p2 = p1\n        p1 = tmp\n    }\n    return p2\n}\n// @lc code=end\n\n\n解法二\n\n/*\n * @lc app=leetcode.cn id=206 lang=javascript\n *\n * [206] 反转链表\n */\n\n// @lc code=start\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} head\n * @return {listnode}\n */\nvar reverselist = function (head) {\n    let [p1, p2] = [head, null]\n    while (p1) {\n        ;[p1.next, p2, p1] = [p2, p1, p1.next]\n    }\n    return p2\n}\n// @lc code=end\n\n\n\n# leetcode：2. 两数相加\n\nleetcode：2. 两数相加\n\n * 解题思路\n\n小学数学题，模拟相加操作\n\n需要遍历链表\n\n * 解题步骤\n\n新建一个空链表\n\n遍历被相加的两个链表，模拟相加操作，将个位数追加到新链表上，将十位数留到下一位去相加\n\n/*\n * @lc app=leetcode.cn id=2 lang=javascript\n *\n * [2] 两数相加\n */\n\n// @lc code=start\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} l1\n * @param {listnode} l2\n * @return {listnode}\n */\nvar addtwonumbers = function (l1, l2) {\n    let l3 = new listnode()\n    let [p1, p2, p3, carry] = [l1, l2, l3, 0]\n    while (p1 || p2) {\n        let v1 = p1 ? p1.val : 0\n        let v2 = p2 ? p2.val : 0\n        let val = v1 + v2 + carry\n        carry = math.floor(val / 10)\n        p3.next = new listnode(val % 10)\n        if (p1) p1 = p1.next\n        if (p2) p2 = p2.next\n        p3 = p3.next\n    }\n    if (carry) p3.next = new listnode(carry)\n    return l3.next\n}\n// @lc code=end\n\n\n\n# leetcode：83. 删除排序链表中的重复元素\n\nleetcode：83. 删除排序链表中的重复元素\n\n * 解题思路\n   \n   因为链表是有序的，所以重复元素一定相邻\n   \n   遍历链表，如果发现当前元素和下个元素值相同，就删除下个元素值\n\n * 解题步骤\n\n遍历链表，如果发现当前元素和下个元素值相同，就删除下个元素值\n\n遍历结束后，直接返回原链表的头部(head)\n\n/*\n * @lc app=leetcode.cn id=83 lang=javascript\n *\n * [83] 删除排序链表中的重复元素\n */\n\n// @lc code=start\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} head\n * @return {listnode}\n */\nvar deleteduplicates = function (head) {\n    let p1 = head\n    while (p1 && p1.next) {\n        if (p1.val === p1.next.val) {\n            p1.next = p1.next.next\n        } else {\n            p1 = p1.next\n        }\n    }\n    return head\n}\n// @lc code=end\n\n\n\n# leetcode：141. 环形链表\n\nleetcode：141. 环形链表\n\n * 解题思路\n\n两个人在圆形操场上的起点同时起跑，速度快的人一定会超过速度慢的人一圈\n\n用一快一慢两个指针遍历链表，如果指针能够相逢，那么链表就有圈。\n\n\n\n * 解题步骤\n\n用一快一慢两个指针遍历链表，如果指针能够相逢，就返回 true。\n\n遍历结束后，还没有相逢就返回 false。\n\n/*\n * @lc app=leetcode.cn id=141 lang=javascript\n *\n * [141] 环形链表\n */\n\n// @lc code=start\n/**\n * definition for singly-linked list.\n * function listnode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {listnode} head\n * @return {boolean}\n */\nvar hascycle = function (head) {\n    let [slow, fast] = [head, head]\n    while (slow && fast && fast.next) {\n        slow = slow.next\n        fast = fast.next.next\n        if (slow === fast) return true\n    }\n    return false\n}\n// @lc code=end\n\n\n\n# leetcode： 234. 回文链表\n\nleetcode： 234. 回文链表\n\n * 解题思路\n\n回文就是反转以后和以前一样的就是回文结构，例如 1->2->3->2->1，我们将它反转之后还是与原链表一样，我们就称这种链表结构为回文结构\n\n * 解题步骤\n\n快慢指针，起初都指向表头，快指针一次走两步，慢指针一次走一步，遍历结束时：\n\n要么，slow 正好指向中间两个结点的后一个。\n\n要么，slow 正好指向中间结点。\n\n用 prev 保存 slow 的前一个结点，通过prev.next = null断成两个链表。\n\n将后半段链表翻转(参考 leetcode.206)，和前半段从头比对。\n\n\n\n/*\n * @lc app=leetcode.cn id=234 lang=javascript\n *\n * [234] 回文链表\n */\n\n// @lc code=start\n/**\n * definition for singly-linked list.\n * function listnode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {listnode} head\n * @return {boolean}\n */\nvar ispalindrome = function (head) {\n    // 链表只有一个节点的情况\n    if (head.next == null) {\n        return true\n    }\n    let [fast, slow, prev] = [head, head, null]\n    while (fast && fast.next) {\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n    }\n    // 断成两个链表\n    prev.next = null\n    // 翻转后半段\n    let head2 = null\n    while (slow) {\n        // 解构赋值，不用使用临时变量\n        // ;[slow.next, head2, slow] = [head2, slow, slow.next]\n        let temp = slow.next\n        slow.next = head2\n        head2 = slow\n        slow = temp\n    }\n    // 前后两段进行比较\n    while (head && head2) {\n        if (head.val !== head2.val) {\n            return false\n        }\n        head = head.next\n        head2 = head2.next\n    }\n    return true\n}\n// @lc code=end\n\n\n\n# 前端与链表：js 中的原型链\n\n原型链的本质是链表。\n\n原型链上的节点是各种原型对象， 比如 function.prototype、 object.prototype……\n\n原型链通过__proto__属性连接各种原型对象。\n\n\n# 面试题：instanceof 的原理，并用代码实现。\n\n知识点：如果 a 沿着原型链能找到b.prototype，那么a instanceof b为 true。\n\n解法：遍历 a 的原型链，如果找到b.prototype，返回 true，否则返回 false\n\n\n# 面试题：看输出\n\nconst foo = {}\nf = function () {}\nobject.prototype.a = 'value a'\nfunction.prototype.b = 'value b'\nconsole.log(foo.a)\nconsole.log(foo.b)\nconsole.log(f.b)\nconsole.log(f.b)\n\n\n知识点：如果在 a 对象上没有找到 ⅹ 属性，那么会沿着原型链找 ⅹ 属性。\n\n解法：明确 foo 和 f 变量的原型链，沿着原型链找 a 属性和 b 属性。\n\n\n\n\n# 前端与链表：使用链表指针获取 json 的节点值\n\nconst json = {\n    a: { b: { c: 1 } },\n    d: { e: 2 },\n}\nconst path = ['d', 'e']\n\nlet p = json\n\npath.foreach(k => {\n    p = p[k]\n})\n",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"树",frontmatter:{title:"树",readingShow:"top"},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%A0%91.html",relativePath:"数据结构算法/树.md",key:"v-3e3f78e7",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E6%A0%91.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"深度与广度优先遍历",slug:"深度与广度优先遍历",normalizedTitle:"深度与广度优先遍历",charIndex:77},{level:3,title:"深度优先遍历",slug:"深度优先遍历",normalizedTitle:"深度优先遍历",charIndex:91},{level:3,title:"广度优先遍历",slug:"广度优先遍历",normalizedTitle:"广度优先遍历",charIndex:59},{level:2,title:"二叉树的先中后序遍历",slug:"二叉树的先中后序遍历",normalizedTitle:"二叉树的先中后序遍历",charIndex:1995},{level:3,title:"一个普普通通的二叉树",slug:"一个普普通通的二叉树",normalizedTitle:"一个普普通通的二叉树",charIndex:2034},{level:3,title:"先序遍历算法口诀",slug:"先序遍历算法口诀",normalizedTitle:"先序遍历算法口诀",charIndex:2539},{level:3,title:"中序遍历算法口诀",slug:"中序遍历算法口诀",normalizedTitle:"中序遍历算法口诀",charIndex:2842},{level:3,title:"后序遍历算法口诀",slug:"后序遍历算法口诀",normalizedTitle:"后序遍历算法口诀",charIndex:3128},{level:3,title:"先中后序遍历非递归版",slug:"先中后序遍历非递归版",normalizedTitle:"先中后序遍历非递归版",charIndex:3425},{level:2,title:"LeetCode：144. 二叉树的前序遍历",slug:"leetcode-144-二叉树的前序遍历",normalizedTitle:"leetcode：144. 二叉树的前序遍历",charIndex:4499},{level:2,title:"LeetCode：145. 二叉树的后序遍历",slug:"leetcode-145-二叉树的后序遍历",normalizedTitle:"leetcode：145. 二叉树的后序遍历",charIndex:5259},{level:2,title:"LeetCode：104. 二叉树的最大深度",slug:"leetcode-104-二叉树的最大深度",normalizedTitle:"leetcode：104. 二叉树的最大深度",charIndex:6148},{level:2,title:"LeetCode：111. 二叉树的最小深度",slug:"leetcode-111-二叉树的最小深度",normalizedTitle:"leetcode：111. 二叉树的最小深度",charIndex:7085},{level:2,title:"LeetCode：102. 二叉树的层序遍历",slug:"leetcode-102-二叉树的层序遍历",normalizedTitle:"leetcode：102. 二叉树的层序遍历",charIndex:7945},{level:2,title:"LeetCode：94. 二叉树的中序遍历",slug:"leetcode-94-二叉树的中序遍历",normalizedTitle:"leetcode：94. 二叉树的中序遍历",charIndex:9715},{level:2,title:"LeetCode：112. 路径总和",slug:"leetcode-112-路径总和",normalizedTitle:"leetcode：112. 路径总和",charIndex:11152},{level:2,title:"前端与树：遍历 JSON 的所有节点值",slug:"前端与树-遍历-json-的所有节点值",normalizedTitle:"前端与树：遍历 json 的所有节点值",charIndex:12183}],headersStr:"简介 深度与广度优先遍历 深度优先遍历 广度优先遍历 二叉树的先中后序遍历 一个普普通通的二叉树 先序遍历算法口诀 中序遍历算法口诀 后序遍历算法口诀 先中后序遍历非递归版 LeetCode：144. 二叉树的前序遍历 LeetCode：145. 二叉树的后序遍历 LeetCode：104. 二叉树的最大深度 LeetCode：111. 二叉树的最小深度 LeetCode：102. 二叉树的层序遍历 LeetCode：94. 二叉树的中序遍历 LeetCode：112. 路径总和 前端与树：遍历 JSON 的所有节点值",content:"# 简介\n\n一种分层数据的抽象模型\n\njs 中没有树，但是可以用Object和Array构建树\n\n树的常用操作：深度/广度优先遍历,先中后序遍历\n\n\n# 深度与广度优先遍历\n\n\n# 深度优先遍历\n\n尽可能深的搜索树的分支\n\n\n\n深度优先遍历算法口诀：\n\n访问根节点\n\n对根节点的children挨个进行深度优先遍历。\n\n深度优先遍历 dfs\n\n/**\n * 深度优先遍历 dfs\n */\nconst tree = {\n    val: 'a',\n    children: [\n        {\n            val: 'b',\n            children: [\n                {\n                    val: 'd',\n                    children: [],\n                },\n                {\n                    val: 'e',\n                    children: [],\n                },\n            ],\n        },\n        {\n            val: 'c',\n            children: [\n                {\n                    val: 'f',\n                    children: [],\n                },\n                {\n                    val: 'g',\n                    children: [],\n                },\n            ],\n        },\n    ],\n}\n\nconst dfs = root => {\n    if (!root) return\n    console.log(root.val)\n    root.children.forEach(dfs)\n}\ndfs(tree)\n// a\n// b\n// d\n// e\n// c\n// f\n// g\n\n\n\n# 广度优先遍历\n\n先访问离根节点最近的节点\n\n\n\n广度优先遍历算法口诀：\n\n 1. 新建一个队列，把根节点入队。\n 2. 把队头出队并访问。\n 3. 把队头的children挨个入队。\n 4. 重复第二、三步，直到队列为空。\n\n广度优先遍历 bfs\n\n/**\n * 广度优先遍历 bfs\n */\nconst tree = {\n    val: 'a',\n    children: [\n        {\n            val: 'b',\n            children: [\n                {\n                    val: 'd',\n                    children: [],\n                },\n                {\n                    val: 'e',\n                    children: [],\n                },\n            ],\n        },\n        {\n            val: 'c',\n            children: [\n                {\n                    val: 'f',\n                    children: [],\n                },\n                {\n                    val: 'g',\n                    children: [],\n                },\n            ],\n        },\n    ],\n}\nconst bfs = root => {\n    if (!root) return\n    const q = [root]\n    while (q.length > 0) {\n        const n = q.shift()\n        console.log(n.val)\n        n.children.forEach(child => q.push(child))\n    }\n}\nbfs(tree)\n// a\n// b\n// c\n// d\n// e\n// f\n// g\n\n\n\n# 二叉树的先中后序遍历\n\n二叉树:树中每个节点最多只能有两个子节点\n\n\n\n\n# 一个普普通通的二叉树\n\nconst bt = {\n    val: 1,\n    left: {\n        val: 2,\n        left: {\n            val: 3,\n            left: null,\n            right: null,\n        },\n        right: {\n            val: 4,\n            left: {\n                val: 5,\n                left: 5,\n            },\n            right: null,\n        },\n    },\n    right: {\n        val: 6,\n        left: null,\n        right: {\n            val: 7,\n            left: null,\n            right: null,\n        },\n    },\n}\nmodule.exports = bt\n\n\n\n# 先序遍历算法口诀\n\n 1. 访问根节点\n 2. 对根节点的左子树进行先序遍历\n 3. 对根节点的右子树进行先序遍历\n\npreorder\n\n/**\n * preorder 先序遍历\n */\nconst bt = require('./bt')\n\nconst preorder = root => {\n    if (!root) return\n    console.log(root.val)\n    preorder(root.left)\n    preorder(root.right)\n}\n\npreorder(bt)\n\n// 1\n// 2\n// 3\n// 4\n// 5\n// 6\n// 7\n\n\n\n# 中序遍历算法口诀\n\n对根节点的左子树进行中序遍历\n\n访问根节点\n\n对根节点的右子树进行中序遍历\n\ninorder\n\n/**\n * inorder 中序遍历\n */\n\nconst bt = require('./bt')\n\nconst inorder = root => {\n    if (!root) return\n    inorder(root.left)\n    console.log(root.val)\n    inorder(root.right)\n}\ninorder(bt)\n// 3\n// 2\n// 5\n// 4\n// 1\n// 6\n// 7\n\n\n\n# 后序遍历算法口诀\n\n对根节点的左子树进行后序遍历\n\n对根节点的右子树进行后序遍历\n\n访问根节点\n\npostorder\n\n/**\n * postorder 后序遍历\n */\nconst bt = require('./bt')\n\nconst postorder = root => {\n    if (!root) return\n    postorder(root.left)\n    postorder(root.right)\n    console.log(root.val)\n}\npostorder(bt)\n// 3\n// 5\n// 4\n// 2\n// 7\n// 6\n// 1\n\n\n\n# 先中后序遍历非递归版\n\n提示\n\n画个栈理解\n\n先序遍历\n\nconst preorder = root => {\n    const stack = [root]\n    while (stack.length) {\n        const n = stack.pop()\n        console.log(n.val)\n        // 栈：先进后出,所以应该先把右子树入栈。\n        if (n.right) stack.push(n.right)\n        if (n.left) stack.push(n.left)\n    }\n}\npreorder(bt)\n\n\n中序遍历\n\nconst inorder = root => {\n    if (!root) return\n    const stack = []\n    let p = root\n    while (stack.length || p) {\n        while (p) {\n            stack.push(p)\n            p = p.left\n        }\n        const n = stack.pop()\n        console.log(n.val)\n        p = n.right\n    }\n}\ninorder(bt)\n\n\n提示\n\n先序遍历：根—>左—>右,后序倒过来：左—>右—>根\n\n先先序遍历，然后利用另外一个栈，倒序输出\n\n后序遍历\n\nconst postorder = root => {\n    if (!root) return\n    const outputStack = []\n    const stack = [root]\n    while (stack.length) {\n        const n = stack.pop()\n        // 压入输出栈\n        outputStack.push(n)\n        if (n.left) stack.push(n.left)\n        if (n.right) stack.push(n.right)\n    }\n    while (outputStack.length) {\n        const n = outputStack.pop()\n        console.log(n.val)\n    }\n}\npostorder(bt)\n\n\n\n# LeetCode：144. 二叉树的前序遍历\n\nLeetCode：144. 二叉树的前序遍历\n\ncode\n\n/*\n * @lc app=leetcode.cn id=144 lang=javascript\n *\n * [144] 二叉树的前序遍历\n */\n\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function (root) {\n    if (!root) return []\n    let stack = [root]\n    let res = []\n    while (stack.length) {\n        const n = stack.pop()\n        res.push(n.val)\n        if (n.right) stack.push(n.right)\n        if (n.left) stack.push(n.left)\n    }\n    return res\n}\n// @lc code=end\n\n\n\n# LeetCode：145. 二叉树的后序遍历\n\nLeetCode：145. 二叉树的后序遍历\n\ncode\n\n/*\n * @lc app=leetcode.cn id=145 lang=javascript\n *\n * [145] 二叉树的后序遍历\n */\n\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar postorderTraversal = function (root) {\n    if (!root) return []\n    let stack = [root]\n    let outputStack = []\n    while (stack.length) {\n        const n = stack.pop()\n        outputStack.push(n.val)\n        if (n.left) stack.push(n.left)\n        if (n.right) stack.push(n.right)\n    }\n    let res = []\n    while (outputStack.length) {\n        const n = outputStack.pop()\n        res.push(n)\n    }\n    return res\n}\n// @lc code=end\n\n\n\n# LeetCode：104. 二叉树的最大深度\n\nLeetCode：104. 二叉树的最大深度\n\n * 解题思路\n\n求最大深度，考虑使用深度优先遍历。\n\n在深度优先遍历过程中，记录每个节点所在的层级，找出最大的层级即可。\n\n * 解题步骤\n\n新建一个变量，记录最大深度。\n\n深度优先遍历整棵树，并记录每个节点的层级，同时不断刷新最大深度这个变量。\n\n遍历结束返回最大深度这个变量\n\ncode\n\n/*\n * @lc app=leetcode.cn id=104 lang=javascript\n *\n * [104] 二叉树的最大深度\n */\n\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n    if (!root) return 0\n    let dep = 0\n    const dfs = (n, d) => {\n        if (!n) return\n        // 只有节点是叶子节点才会刷新dep\n        if (!n.left || !n.right) dep = Math.max(dep, d)\n        if (n.left) dfs(n.left, d + 1)\n        if (n.right) dfs(n.right, d + 1)\n    }\n    dfs(root, 1)\n    return dep\n}\n// @lc code=end\n\n\n\n# LeetCode：111. 二叉树的最小深度\n\nLeetCode：111. 二叉树的最小深度\n\n * 解题思路\n\n求最小深度，考虑使用广度优先遍历。\n\n在广度优先遍历过程中，遇到叶子节点，停止遍历，返回节点层级。\n\n * 解题步骤\n\n广度优先遍历整棵树，并记录每个节点的层级\n\n遇到叶子节点，返回节点层级，停止遍历\n\ncode\n\n/*\n * @lc app=leetcode.cn id=111 lang=javascript\n *\n * [111] 二叉树的最小深度\n */\n\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar minDepth = function (root) {\n    if (!root) return 0\n    const q = [[root, 1]]\n    while (q.length) {\n        const [n, d] = q.shift()\n        if (!n.left && !n.right) return d //\n        if (n.left) q.push([n.left, d + 1])\n        if (n.right) q.push([n.right, d + 1])\n    }\n}\n// @lc code=end\n\n\n\n# LeetCode：102. 二叉树的层序遍历\n\nLeetCode：102. 二叉树的层序遍历\n\n * 解题思路\n\n层序遍历顺序就是广度优先遍历。\n\n不过在遍历时候需要记录当前节点所处的层级，方便将其添加到不同的数组中\n\n * 解题步骤\n\n广度优先遍历二叉树。\n\n遍历过程中，记录每个节点的层级，并将其添加到不同的数组中。\n\n解法 1\n\n/*\n * @lc app=leetcode.cn id=102 lang=javascript\n *\n * [102] 二叉树的层序遍历\n */\n\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function (root) {\n    if (!root) return []\n    const q = [[root, 0]]\n    let res = []\n    while (q.length) {\n        const [n, d] = q.shift()\n        if (!res[d]) {\n            res.push([n.val])\n        } else {\n            res[d].push(n.val)\n        }\n        if (n.left) q.push([n.left, d + 1])\n        if (n.right) q.push([n.right, d + 1])\n    }\n    return res\n}\n// @lc code=end\n\n\n解法 2\n\n/*\n * @lc app=leetcode.cn id=102 lang=javascript\n *\n * [102] 二叉树的层序遍历\n */\n\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function (root) {\n    if (!root) return []\n    const q = [root]\n    let res = []\n    while (q.length) {\n        let len = q.length\n        res.push([])\n        while (len--) {\n            const n = q.shift()\n            res[res.length - 1].push(n.val)\n            if (n.left) q.push(n.left)\n            if (n.right) q.push(n.right)\n        }\n    }\n    return res\n}\n// @lc code=end\n\n\n\n# LeetCode：94. 二叉树的中序遍历\n\nLeetCode：94. 二叉树的中序遍历\n\n递归\n\n/*\n * @lc app=leetcode.cn id=94 lang=javascript\n *\n * [94] 二叉树的中序遍历\n */\n\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function (root) {\n    if (!root) return []\n    const res = []\n    const rec = n => {\n        if (!n) return\n        rec(n.left)\n        res.push(n.val)\n        rec(n.right)\n    }\n    rec(root)\n    return res\n}\n// @lc code=end\n\n\n迭代\n\n/*\n * @lc app=leetcode.cn id=94 lang=javascript\n *\n * [94] 二叉树的中序遍历\n */\n\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function (root) {\n    if (!root) return []\n    let stack = []\n    let res = []\n    let p = root\n    while (stack.length || p) {\n        while (p) {\n            stack.push(p)\n            p = p.left\n        }\n        const n = stack.pop()\n        res.push(n.val)\n        p = n.right\n    }\n    return res\n}\n// @lc code=end\n\n\n\n# LeetCode：112. 路径总和\n\nLeetCode：112. 路径总和\n\n * 解题思路\n   \n   在深度优先遍历的过程中，记录当前路径的节点值的和。\n   \n   在叶子节点处，判断当前路径的节点值的和是否等于目标值。\n\n * 解题步骤\n   \n   深度优先遍历二叉树，在叶子节点处，判断当前路径的节点值的和是否等于目标值是就返回 true\n   \n   遍历结束，如果没有匹配，就返回 false\n\ncode\n\n/*\n * @lc app=leetcode.cn id=112 lang=javascript\n *\n * [112] 路径总和\n */\n\n// @lc code=start\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {boolean}\n */\nvar hasPathSum = function (root, targetSum) {\n    if (!root) return false\n    let res = false\n    const dfs = (n, s) => {\n        if (!n) return\n        if (!n.left && !n.right && targetSum === s) {\n            res = true\n        }\n        if (n.left) dfs(n.left, s + n.left.val)\n        if (n.right) dfs(n.right, s + n.right.val)\n    }\n    dfs(root, root.val)\n    return res\n}\n// @lc code=end\n\n\n\n# 前端与树：遍历 JSON 的所有节点值\n\nconst json = {\n    a: { b: { c: 1 } },\n    d: [1, 2],\n}\nconst dfs = (n, path) => {\n    console.log(n, path)\n    Object.keys(n).forEach(k => {\n        dfs(n[k], path.concat(k))\n    })\n}\ndfs(json, [])\n// { a: { b: { c: 1 } }, d: [ 1, 2 ] } []\n// { b: { c: 1 } } [ 'a' ]\n// { c: 1 } [ 'a', 'b' ]\n// 1 [ 'a', 'b', 'c' ]\n// [ 1, 2 ] [ 'd' ]\n// 1 [ 'd', '0' ]\n// 2 [ 'd', '1' ]\n",normalizedContent:"# 简介\n\n一种分层数据的抽象模型\n\njs 中没有树，但是可以用object和array构建树\n\n树的常用操作：深度/广度优先遍历,先中后序遍历\n\n\n# 深度与广度优先遍历\n\n\n# 深度优先遍历\n\n尽可能深的搜索树的分支\n\n\n\n深度优先遍历算法口诀：\n\n访问根节点\n\n对根节点的children挨个进行深度优先遍历。\n\n深度优先遍历 dfs\n\n/**\n * 深度优先遍历 dfs\n */\nconst tree = {\n    val: 'a',\n    children: [\n        {\n            val: 'b',\n            children: [\n                {\n                    val: 'd',\n                    children: [],\n                },\n                {\n                    val: 'e',\n                    children: [],\n                },\n            ],\n        },\n        {\n            val: 'c',\n            children: [\n                {\n                    val: 'f',\n                    children: [],\n                },\n                {\n                    val: 'g',\n                    children: [],\n                },\n            ],\n        },\n    ],\n}\n\nconst dfs = root => {\n    if (!root) return\n    console.log(root.val)\n    root.children.foreach(dfs)\n}\ndfs(tree)\n// a\n// b\n// d\n// e\n// c\n// f\n// g\n\n\n\n# 广度优先遍历\n\n先访问离根节点最近的节点\n\n\n\n广度优先遍历算法口诀：\n\n 1. 新建一个队列，把根节点入队。\n 2. 把队头出队并访问。\n 3. 把队头的children挨个入队。\n 4. 重复第二、三步，直到队列为空。\n\n广度优先遍历 bfs\n\n/**\n * 广度优先遍历 bfs\n */\nconst tree = {\n    val: 'a',\n    children: [\n        {\n            val: 'b',\n            children: [\n                {\n                    val: 'd',\n                    children: [],\n                },\n                {\n                    val: 'e',\n                    children: [],\n                },\n            ],\n        },\n        {\n            val: 'c',\n            children: [\n                {\n                    val: 'f',\n                    children: [],\n                },\n                {\n                    val: 'g',\n                    children: [],\n                },\n            ],\n        },\n    ],\n}\nconst bfs = root => {\n    if (!root) return\n    const q = [root]\n    while (q.length > 0) {\n        const n = q.shift()\n        console.log(n.val)\n        n.children.foreach(child => q.push(child))\n    }\n}\nbfs(tree)\n// a\n// b\n// c\n// d\n// e\n// f\n// g\n\n\n\n# 二叉树的先中后序遍历\n\n二叉树:树中每个节点最多只能有两个子节点\n\n\n\n\n# 一个普普通通的二叉树\n\nconst bt = {\n    val: 1,\n    left: {\n        val: 2,\n        left: {\n            val: 3,\n            left: null,\n            right: null,\n        },\n        right: {\n            val: 4,\n            left: {\n                val: 5,\n                left: 5,\n            },\n            right: null,\n        },\n    },\n    right: {\n        val: 6,\n        left: null,\n        right: {\n            val: 7,\n            left: null,\n            right: null,\n        },\n    },\n}\nmodule.exports = bt\n\n\n\n# 先序遍历算法口诀\n\n 1. 访问根节点\n 2. 对根节点的左子树进行先序遍历\n 3. 对根节点的右子树进行先序遍历\n\npreorder\n\n/**\n * preorder 先序遍历\n */\nconst bt = require('./bt')\n\nconst preorder = root => {\n    if (!root) return\n    console.log(root.val)\n    preorder(root.left)\n    preorder(root.right)\n}\n\npreorder(bt)\n\n// 1\n// 2\n// 3\n// 4\n// 5\n// 6\n// 7\n\n\n\n# 中序遍历算法口诀\n\n对根节点的左子树进行中序遍历\n\n访问根节点\n\n对根节点的右子树进行中序遍历\n\ninorder\n\n/**\n * inorder 中序遍历\n */\n\nconst bt = require('./bt')\n\nconst inorder = root => {\n    if (!root) return\n    inorder(root.left)\n    console.log(root.val)\n    inorder(root.right)\n}\ninorder(bt)\n// 3\n// 2\n// 5\n// 4\n// 1\n// 6\n// 7\n\n\n\n# 后序遍历算法口诀\n\n对根节点的左子树进行后序遍历\n\n对根节点的右子树进行后序遍历\n\n访问根节点\n\npostorder\n\n/**\n * postorder 后序遍历\n */\nconst bt = require('./bt')\n\nconst postorder = root => {\n    if (!root) return\n    postorder(root.left)\n    postorder(root.right)\n    console.log(root.val)\n}\npostorder(bt)\n// 3\n// 5\n// 4\n// 2\n// 7\n// 6\n// 1\n\n\n\n# 先中后序遍历非递归版\n\n提示\n\n画个栈理解\n\n先序遍历\n\nconst preorder = root => {\n    const stack = [root]\n    while (stack.length) {\n        const n = stack.pop()\n        console.log(n.val)\n        // 栈：先进后出,所以应该先把右子树入栈。\n        if (n.right) stack.push(n.right)\n        if (n.left) stack.push(n.left)\n    }\n}\npreorder(bt)\n\n\n中序遍历\n\nconst inorder = root => {\n    if (!root) return\n    const stack = []\n    let p = root\n    while (stack.length || p) {\n        while (p) {\n            stack.push(p)\n            p = p.left\n        }\n        const n = stack.pop()\n        console.log(n.val)\n        p = n.right\n    }\n}\ninorder(bt)\n\n\n提示\n\n先序遍历：根—>左—>右,后序倒过来：左—>右—>根\n\n先先序遍历，然后利用另外一个栈，倒序输出\n\n后序遍历\n\nconst postorder = root => {\n    if (!root) return\n    const outputstack = []\n    const stack = [root]\n    while (stack.length) {\n        const n = stack.pop()\n        // 压入输出栈\n        outputstack.push(n)\n        if (n.left) stack.push(n.left)\n        if (n.right) stack.push(n.right)\n    }\n    while (outputstack.length) {\n        const n = outputstack.pop()\n        console.log(n.val)\n    }\n}\npostorder(bt)\n\n\n\n# leetcode：144. 二叉树的前序遍历\n\nleetcode：144. 二叉树的前序遍历\n\ncode\n\n/*\n * @lc app=leetcode.cn id=144 lang=javascript\n *\n * [144] 二叉树的前序遍历\n */\n\n// @lc code=start\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @return {number[]}\n */\nvar preordertraversal = function (root) {\n    if (!root) return []\n    let stack = [root]\n    let res = []\n    while (stack.length) {\n        const n = stack.pop()\n        res.push(n.val)\n        if (n.right) stack.push(n.right)\n        if (n.left) stack.push(n.left)\n    }\n    return res\n}\n// @lc code=end\n\n\n\n# leetcode：145. 二叉树的后序遍历\n\nleetcode：145. 二叉树的后序遍历\n\ncode\n\n/*\n * @lc app=leetcode.cn id=145 lang=javascript\n *\n * [145] 二叉树的后序遍历\n */\n\n// @lc code=start\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @return {number[]}\n */\nvar postordertraversal = function (root) {\n    if (!root) return []\n    let stack = [root]\n    let outputstack = []\n    while (stack.length) {\n        const n = stack.pop()\n        outputstack.push(n.val)\n        if (n.left) stack.push(n.left)\n        if (n.right) stack.push(n.right)\n    }\n    let res = []\n    while (outputstack.length) {\n        const n = outputstack.pop()\n        res.push(n)\n    }\n    return res\n}\n// @lc code=end\n\n\n\n# leetcode：104. 二叉树的最大深度\n\nleetcode：104. 二叉树的最大深度\n\n * 解题思路\n\n求最大深度，考虑使用深度优先遍历。\n\n在深度优先遍历过程中，记录每个节点所在的层级，找出最大的层级即可。\n\n * 解题步骤\n\n新建一个变量，记录最大深度。\n\n深度优先遍历整棵树，并记录每个节点的层级，同时不断刷新最大深度这个变量。\n\n遍历结束返回最大深度这个变量\n\ncode\n\n/*\n * @lc app=leetcode.cn id=104 lang=javascript\n *\n * [104] 二叉树的最大深度\n */\n\n// @lc code=start\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @return {number}\n */\nvar maxdepth = function (root) {\n    if (!root) return 0\n    let dep = 0\n    const dfs = (n, d) => {\n        if (!n) return\n        // 只有节点是叶子节点才会刷新dep\n        if (!n.left || !n.right) dep = math.max(dep, d)\n        if (n.left) dfs(n.left, d + 1)\n        if (n.right) dfs(n.right, d + 1)\n    }\n    dfs(root, 1)\n    return dep\n}\n// @lc code=end\n\n\n\n# leetcode：111. 二叉树的最小深度\n\nleetcode：111. 二叉树的最小深度\n\n * 解题思路\n\n求最小深度，考虑使用广度优先遍历。\n\n在广度优先遍历过程中，遇到叶子节点，停止遍历，返回节点层级。\n\n * 解题步骤\n\n广度优先遍历整棵树，并记录每个节点的层级\n\n遇到叶子节点，返回节点层级，停止遍历\n\ncode\n\n/*\n * @lc app=leetcode.cn id=111 lang=javascript\n *\n * [111] 二叉树的最小深度\n */\n\n// @lc code=start\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @return {number}\n */\nvar mindepth = function (root) {\n    if (!root) return 0\n    const q = [[root, 1]]\n    while (q.length) {\n        const [n, d] = q.shift()\n        if (!n.left && !n.right) return d //\n        if (n.left) q.push([n.left, d + 1])\n        if (n.right) q.push([n.right, d + 1])\n    }\n}\n// @lc code=end\n\n\n\n# leetcode：102. 二叉树的层序遍历\n\nleetcode：102. 二叉树的层序遍历\n\n * 解题思路\n\n层序遍历顺序就是广度优先遍历。\n\n不过在遍历时候需要记录当前节点所处的层级，方便将其添加到不同的数组中\n\n * 解题步骤\n\n广度优先遍历二叉树。\n\n遍历过程中，记录每个节点的层级，并将其添加到不同的数组中。\n\n解法 1\n\n/*\n * @lc app=leetcode.cn id=102 lang=javascript\n *\n * [102] 二叉树的层序遍历\n */\n\n// @lc code=start\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @return {number[][]}\n */\nvar levelorder = function (root) {\n    if (!root) return []\n    const q = [[root, 0]]\n    let res = []\n    while (q.length) {\n        const [n, d] = q.shift()\n        if (!res[d]) {\n            res.push([n.val])\n        } else {\n            res[d].push(n.val)\n        }\n        if (n.left) q.push([n.left, d + 1])\n        if (n.right) q.push([n.right, d + 1])\n    }\n    return res\n}\n// @lc code=end\n\n\n解法 2\n\n/*\n * @lc app=leetcode.cn id=102 lang=javascript\n *\n * [102] 二叉树的层序遍历\n */\n\n// @lc code=start\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @return {number[][]}\n */\nvar levelorder = function (root) {\n    if (!root) return []\n    const q = [root]\n    let res = []\n    while (q.length) {\n        let len = q.length\n        res.push([])\n        while (len--) {\n            const n = q.shift()\n            res[res.length - 1].push(n.val)\n            if (n.left) q.push(n.left)\n            if (n.right) q.push(n.right)\n        }\n    }\n    return res\n}\n// @lc code=end\n\n\n\n# leetcode：94. 二叉树的中序遍历\n\nleetcode：94. 二叉树的中序遍历\n\n递归\n\n/*\n * @lc app=leetcode.cn id=94 lang=javascript\n *\n * [94] 二叉树的中序遍历\n */\n\n// @lc code=start\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @return {number[]}\n */\nvar inordertraversal = function (root) {\n    if (!root) return []\n    const res = []\n    const rec = n => {\n        if (!n) return\n        rec(n.left)\n        res.push(n.val)\n        rec(n.right)\n    }\n    rec(root)\n    return res\n}\n// @lc code=end\n\n\n迭代\n\n/*\n * @lc app=leetcode.cn id=94 lang=javascript\n *\n * [94] 二叉树的中序遍历\n */\n\n// @lc code=start\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @return {number[]}\n */\nvar inordertraversal = function (root) {\n    if (!root) return []\n    let stack = []\n    let res = []\n    let p = root\n    while (stack.length || p) {\n        while (p) {\n            stack.push(p)\n            p = p.left\n        }\n        const n = stack.pop()\n        res.push(n.val)\n        p = n.right\n    }\n    return res\n}\n// @lc code=end\n\n\n\n# leetcode：112. 路径总和\n\nleetcode：112. 路径总和\n\n * 解题思路\n   \n   在深度优先遍历的过程中，记录当前路径的节点值的和。\n   \n   在叶子节点处，判断当前路径的节点值的和是否等于目标值。\n\n * 解题步骤\n   \n   深度优先遍历二叉树，在叶子节点处，判断当前路径的节点值的和是否等于目标值是就返回 true\n   \n   遍历结束，如果没有匹配，就返回 false\n\ncode\n\n/*\n * @lc app=leetcode.cn id=112 lang=javascript\n *\n * [112] 路径总和\n */\n\n// @lc code=start\n/**\n * definition for a binary tree node.\n * function treenode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {treenode} root\n * @param {number} targetsum\n * @return {boolean}\n */\nvar haspathsum = function (root, targetsum) {\n    if (!root) return false\n    let res = false\n    const dfs = (n, s) => {\n        if (!n) return\n        if (!n.left && !n.right && targetsum === s) {\n            res = true\n        }\n        if (n.left) dfs(n.left, s + n.left.val)\n        if (n.right) dfs(n.right, s + n.right.val)\n    }\n    dfs(root, root.val)\n    return res\n}\n// @lc code=end\n\n\n\n# 前端与树：遍历 json 的所有节点值\n\nconst json = {\n    a: { b: { c: 1 } },\n    d: [1, 2],\n}\nconst dfs = (n, path) => {\n    console.log(n, path)\n    object.keys(n).foreach(k => {\n        dfs(n[k], path.concat(k))\n    })\n}\ndfs(json, [])\n// { a: { b: { c: 1 } }, d: [ 1, 2 ] } []\n// { b: { c: 1 } } [ 'a' ]\n// { c: 1 } [ 'a', 'b' ]\n// 1 [ 'a', 'b', 'c' ]\n// [ 1, 2 ] [ 'd' ]\n// 1 [ 'd', '0' ]\n// 2 [ 'd', '1' ]\n",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"koa2框架",frontmatter:{title:"koa2框架",readingShow:"top"},regularPath:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/koa2%E6%A1%86%E6%9E%B6.html",relativePath:"服务端开发/koa2框架.md",key:"v-d0433916",path:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/koa2%E6%A1%86%E6%9E%B6.html",headers:[{level:2,title:"koa2 环境搭建-创建项目",slug:"koa2-环境搭建-创建项目",normalizedTitle:"koa2 环境搭建-创建项目",charIndex:49},{level:2,title:"koa2 环境搭建-目录和文件介绍",slug:"koa2-环境搭建-目录和文件介绍",normalizedTitle:"koa2 环境搭建-目录和文件介绍",charIndex:140},{level:2,title:"koa2 环境搭建-新建路由",slug:"koa2-环境搭建-新建路由",normalizedTitle:"koa2 环境搭建-新建路由",charIndex:324},{level:2,title:"koa2 处理 http 请求",slug:"koa2-处理-http-请求",normalizedTitle:"koa2 处理 http 请求",charIndex:998},{level:2,title:"koa2 中间件",slug:"koa2-中间件",normalizedTitle:"koa2 中间件",charIndex:2932},{level:2,title:"koa2 洋葱圈模型",slug:"koa2-洋葱圈模型",normalizedTitle:"koa2 洋葱圈模型",charIndex:4691},{level:2,title:"koa2 登录实现方案与实践",slug:"koa2-登录实现方案与实践",normalizedTitle:"koa2 登录实现方案与实践",charIndex:5418},{level:3,title:"cookie-介绍",slug:"cookie-介绍",normalizedTitle:"cookie-介绍",charIndex:5437},{level:3,title:"cookie-服务端操作 cookie",slug:"cookie-服务端操作-cookie",normalizedTitle:"cookie-服务端操作 cookie",charIndex:5602},{level:3,title:"cookie 登录校验",slug:"cookie-登录校验",normalizedTitle:"cookie 登录校验",charIndex:6491},{level:3,title:"session-介绍",slug:"session-介绍",normalizedTitle:"session-介绍",charIndex:6607},{level:3,title:"koa2 实现登录-session",slug:"koa2-实现登录-session",normalizedTitle:"koa2 实现登录-session",charIndex:6783},{level:3,title:"koa2 实现登录-模拟登录",slug:"koa2-实现登录-模拟登录",normalizedTitle:"koa2 实现登录-模拟登录",charIndex:7189},{level:3,title:"完善登录功能-对接数据库",slug:"完善登录功能-对接数据库",normalizedTitle:"完善登录功能-对接数据库",charIndex:7714},{level:3,title:"完善登录功能-重写登录中间件",slug:"完善登录功能-重写登录中间件",normalizedTitle:"完善登录功能-重写登录中间件",charIndex:8340}],headersStr:"koa2 环境搭建-创建项目 koa2 环境搭建-目录和文件介绍 koa2 环境搭建-新建路由 koa2 处理 http 请求 koa2 中间件 koa2 洋葱圈模型 koa2 登录实现方案与实践 cookie-介绍 cookie-服务端操作 cookie cookie 登录校验 session-介绍 koa2 实现登录-session koa2 实现登录-模拟登录 完善登录功能-对接数据库 完善登录功能-重写登录中间件",content:"注意\n\n由于本人才疏学浅，所以本文档有的地方表述可能存在错误，后期会重新学习，进行修改！\n\n\n# koa2 环境搭建-创建项目\n\n安装脚手架：npm i koa-generator -g\n\n使用脚手架 koa-generator 创建 koa2 项目 ：koa2 xxx\n\n\n# koa2 环境搭建-目录和文件介绍\n\napp.js 是项目入口文件，其中 app.use()都是中间件\n\nbin/www 获取 app 导出的 Koa 实例，并且监听 3000 端口；其他先不要管知道这个就行了\n\nviews 下的 pug 是服务端模板引擎，暂时先不用去管,因为前后端分离，不需要服务端返回页面，只关注定义路由，接口返回 JSON 数据就可以\n\n\n# koa2 环境搭建-新建路由\n\n注意\n\n在 ctx.body 为对象时，直接返回 JSON 格式，不需要设置 Content-type;koa将 request 和 response 对象封装在了一个对象中，该对象就是 ctx\n\n 1. 在 routers 下定义路由文件，可能会有前缀，不要忘了写router.prefix('/api')\n\nconst router = require('koa-router')()\nrouter.prefix('/api') // 前缀\n// 定义路由\nrouter.get('/list', async ctx => {\n    ctx.body = {\n        errno: 0,\n        data: [\n            { content: 'text1', user: 'frank' },\n            { content: 'text2', user: 'zhang' },\n            { content: 'text3', user: 'sun' },\n        ],\n    }\n})\nmodule.exports = router // 输出\n\n\n 2. 在 app.js 引用路由\n\nconst comments = require('./routes/comments')\n\n\n 3. app.js 下注册路由\n\napp.use(comments.routes(), comments.allowedMethods())\n\n\n\n# koa2 处理 http 请求\n\nquerystring Request body Response body Content-type\n\nconst router = require('koa-router')()\n\nrouter.prefix('/api') // 前缀\n// 定义路由\nrouter.get('/list', async ctx => {\n    const query = ctx.query // querystring\n    // console.log('query',query)\n    ctx.body = {\n        errno: 0,\n        data: [\n            { content: 'text1', user: 'frank' },\n            { content: 'text2', user: 'zhang' },\n            { content: 'text3', user: 'sun' },\n        ],\n    } //Response body\n})\n\nrouter.post('/create', async ctx => {\n    const body = ctx.request.body //Request body\n    // console.log('req-body',body)\n    ctx.body = {\n        errno: 0,\n        message: '留言创建成功！',\n    } // res-body\n})\n\nmodule.exports = router // 输出\n\n\nKoa 和 node.js 相比，封装了原生代码的 API,规范了流程和格式\n\n// node.js\n// 相同功能node实现\nconst http = require('http')\n\nconst server = http.createServer((req, res) => {\n    const url = req.url\n    const path = url.split('?')[0]\n    const method = req.method\n\n    // 定义一个get路由 获取留言板列表\n    if (path === '/api/list' && method === 'GET') {\n        const result = {\n            errno: 0,\n            data: [\n                { user: 'frank', content: 'messsage-1' },\n                { user: 'dell', content: 'messsage-2' },\n            ],\n        }\n        res.writeHead(200, { 'Content-type': 'application/json' })\n        res.end(\n            // 把对象转化为JSON字符串\n            JSON.stringify(result)\n        )\n    }\n    // 定义一个POST路由 创建留言板\n    else if (path === '/api/create' && method === 'POST') {\n        const result = {\n            errno: 0,\n            message: '留言创建成功！',\n        }\n        res.writeHead(200, { 'Content-type': 'application/json' })\n        res.end(\n            // 把对象转化为JSON字符串\n            JSON.stringify(result)\n        )\n    } else {\n        res.writeHead(404, { 'Content-type': 'text/plain' })\n        res.end('404 not found')\n    }\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# koa2 中间件\n\n中间件：一个流程上，独立的业务模块\n\n可扩展，可插拔\n\n类似于工厂的流水线\n\n\n\n为什么使用中间件？\n\n * 拆分业务模块，使代码清晰\n\n * 统一使用中间件，使得各业务代码都规范标准\n\n * 扩展性好，易添加，易删除\n\nkoa2 业务代码都是中间件所有的 app.use(...)都是中间件\n\n路由也是中间件（只不过限制了 url 规则），所有的请求都会经过 app.use，路由规则匹配后才会进入对应路由中间件\n\n\n\nconst Koa = require('koa')\nconst app = new Koa()\nconst views = require('koa-views')\nconst json = require('koa-json')\nconst onerror = require('koa-onerror')\nconst bodyparser = require('koa-bodyparser')\nconst logger = require('koa-logger')\n\nconst index = require('./routes/index')\nconst users = require('./routes/users')\nconst comments = require('./routes/comments')\n// error handler 错误处理器\nonerror(app)\n\n// middlewares 中间件（ app.use(...) ）\napp.use(\n    bodyparser({\n        // request body 转换\n        enableTypes: ['json', 'form', 'text'],\n    })\n)\n// 处理ctx.body（responce body）\napp.use(json())\napp.use(logger()) // 日志格式\napp.use(require('koa-static')(__dirname + '/public')) // 静态文件服务\n\napp.use(\n    views(__dirname + '/views', {\n        // 服务端模板引擎\n        extension: 'pug',\n    })\n)\n\n// logger 打印当前请求所花费的时间\napp.use(async (ctx, next) => {\n    const start = new Date()\n    await next()\n    const ms = new Date() - start\n    console.log(`${ctx.method} ${ctx.url} - ${ms}ms`)\n})\n\n// routes 注册路由\napp.use(index.routes(), index.allowedMethods())\napp.use(users.routes(), users.allowedMethods())\napp.use(comments.routes(), comments.allowedMethods())\n// allowedMethods() 对于 404 或者返回是空的情况的一种补充\n\n// error-handling\napp.on('error', (err, ctx) => {\n    console.error('server error', err, ctx)\n})\n\nmodule.exports = app\n\n\n模拟登录功能,仅仅是为了使用中间件\n\napp.js 中使用中间件，next()执行下一个中间件\n\n......\napp.use(async(ctx,next)=>{\n  const query=ctx.query\n  if(query.user='frank'){\n    await next()\n  }else{\n      ctx.body='登录失败！'\n  }\n})\n\n......\n\napp.use(index.routes(),......)\n\n\n\n\n\n\n# koa2 洋葱圈模型\n\n注意\n\n中间件机制，业务模块的划分;洋葱圈模型，中间件的执行机制;两者要分开，不要混为一谈\n\n中间件机制，是 koa 的精髓，每个中间件都是 async 函数，中间件的运行机制，就像洋葱圈\n\n\n\n代码演示：\n\nconst Koa = require('koa')\nconst app = new Koa()\n\n// logger\n\napp.use(async (ctx, next) => {\n    await next()\n    const rt = ctx.response.get('X-Response-Time')\n    console.log(`${ctx.method} ${ctx.url} - ${rt}`)\n})\n\n// x-response-time\n\napp.use(async (ctx, next) => {\n    const start = Date.now()\n    await next()\n    const ms = Date.now() - start\n    ctx.set('X-Response-Time', `${ms}ms`)\n})\n\n// response\n\napp.use(async ctx => {\n    ctx.body = 'Hello World'\n})\n\napp.listen(3000)\n\n\n个人理解\n\n遇到了 async 异步函数中的 await，先返回，阻塞了函数中后面代码的执行。去执行下一个中间件，在下一个中间件中又遇到了 await 继续执行下一个中间件....这样到最后一个中间件，逐层向上执行每个 async 函数的后续代码。\n\n\n# koa2 登录实现方案与实践\n\n\n# cookie-介绍\n\n * 存储在浏览器的一段字符串，最大 5kb\n * 每个域都可有一个 cookie，跨域不共享\n * 格式如 k1=V1；k2=V2；k3=v3（可结构化）\n * cookie 会随 http 请求传递给服务端\n * 服务端可修改 cookie 再返回给前端\n * 默认，跨域不可传递 cookie\n\n\n# cookie-服务端操作 cookie\n\n * nodejs\n\nconst http = require('http')\n\nconst server = http.createServer((req, res) => {\n    // 设置cookie\n    res.setHeader('Set-Cookie', 'a=100')\n    // 追加不覆盖\n    res.setHeader('Set-Cookie', 'b=200')\n    // 获取cookie\n    console.log('cookie is', req.headers.cookie)\n    const cookieStr = req.headers.cookie\n    res.end('cookie test')\n    // 结构化cookie 'a=100;b=200'->{a:100,b:200}\n    const cookieObj = {}\n    cookieStr.split(';').forEach(cookieItem => {\n        const arr = cookieItem.trim().split('=')\n        const key = arr[0]\n        const val = arr[1]\n        cookieObj[key] = val\n    })\n    console.log('cookieObj is', cookieObj)\n})\nserver.listen(3000, () => {\n    console.log('server listen on 3000 port')\n})\n\n\n * koa2\n\napp.use(async ctx => {\n    // 设置cookie\n    ctx.cookies.set('a', '100')\n    // 获取cookie\n    ctx.cookies.get('a')\n    // 结构化 koa2已经做好了\n})\n\n\n\n# cookie 登录校验\n\n请求登录接口，成功则设置 cookie，如 user=zhangsan\n\n前端再请求其他接口，就会带着上述 cookie\n\n服务端判断 cookie 有无 user=zhangsan，即可验证\n\n\n\n\n# session-介绍\n\ncookie 不能暴露用户名\n\ncookie 存放用户信息明文，非常危险;解决方案：cookie 存一个用户标识，如 userId=123,而不是 username=zhangfan\n\ncookie 存储用户标识,用户信息则存储到 session 中,session 即用户信息的存储，和 cookie 有对应关系\n\n\n\n\n# koa2 实现登录-session\n\n 1. 安装koa-generic-session(2.0.4)\n\nnpm i koa-generic-session --save\n\n\n 2. app.js 使用中间件\n\n// 自动配置了 cookie 和 session\napp.keys = ['wertwe^&&*UUI123123'] // 秘钥\napp.use(\n    session({\n        // 配置 cookie\n        cookie: {\n            path: '/', // cookie 在根目录下有效\n            httpOnly: true, // cookie 只允许服务端来操作\n            maxAge: 24 * 60 * 60 * 1000, // cookie 的过期时间\n        },\n    })\n)\n\n\n\n# koa2 实现登录-模拟登录\n\nrouter/users.js\n\n// 模拟登录\nrouter.get('/login-mock', async (ctx, next) => {\n    let str = ''\n    const query = ctx.query // url 参数，querystring\n    if (query.username) {\n        // 模拟登录成功\n        ctx.session.userInfo = {\n            username: query.username,\n        }\n        str = 'login ok'\n    } else {\n        // 模拟登录失败，不用处理 session\n        str = 'login failed'\n    }\n\n    ctx.body = str\n})\n\n// 模拟登录验证\nrouter.get('/login-check-mock', async (ctx, next) => {\n    ctx.body = ctx.session.userInfo || {}\n})\n\n\n\n# 完善登录功能-对接数据库\n\n// 登录（对接数据库的）\n// 为了方便同域的测试，暂用 get 请求\nrouter.get('/login', async (ctx, next) => {\n    const { username, password } = ctx.query // get 请求\n    // const { username, password } = ctx.request.body // post 请求\n\n    // 查询数据库\n    const user = await User.findOne({\n        username,\n        password,\n    })\n\n    if (user != null) {\n        // 登录成功，设置 session\n        ctx.session.userInfo = user // 所有的用户信息\n        // 返回\n        ctx.body = {\n            errno: 0,\n            data: user,\n        }\n        return\n    }\n    // 登录失败，不用操作 session\n    ctx.body = {\n        errno: -1,\n        message: '用户名或密码错误',\n    }\n})\n\n\n\n# 完善登录功能-重写登录中间件\n\nmiddlewares/loginCheck.js\n\n// 登录验证的中间件\n\nasync function loginCheck(ctx, next) {\n    const userInfo = ctx.session.userInfo\n    if (userInfo && userInfo.username) {\n        // 登录验证成功\n        await next()\n        return\n    }\n    // 登录失败\n    ctx.body = {\n        errno: -1,\n        message: '请登录',\n    }\n}\n\nmodule.exports = loginCheck\n\n\n将登录中间件单独用于某个路由(比如获取留言板内容)\n\nconst loginCheck = require('../middlewares/loginCheck')\n// 定义路由：模拟获取留言板列表\n\n......\n\nrouter.get('/list',loginCheck,async (ctx, next) => {\n    const query = ctx.query // req 功能\n    console.log('query', query)\n    // ctx.body = 'api list' // res 功能\n\n    // 获取数据库的列表\n    const commentList = await Comment.find().sort({ _id: -1 })\n    ctx.body = {\n        errno: 0,\n        data: commentList\n    }\n})\n",normalizedContent:"注意\n\n由于本人才疏学浅，所以本文档有的地方表述可能存在错误，后期会重新学习，进行修改！\n\n\n# koa2 环境搭建-创建项目\n\n安装脚手架：npm i koa-generator -g\n\n使用脚手架 koa-generator 创建 koa2 项目 ：koa2 xxx\n\n\n# koa2 环境搭建-目录和文件介绍\n\napp.js 是项目入口文件，其中 app.use()都是中间件\n\nbin/www 获取 app 导出的 koa 实例，并且监听 3000 端口；其他先不要管知道这个就行了\n\nviews 下的 pug 是服务端模板引擎，暂时先不用去管,因为前后端分离，不需要服务端返回页面，只关注定义路由，接口返回 json 数据就可以\n\n\n# koa2 环境搭建-新建路由\n\n注意\n\n在 ctx.body 为对象时，直接返回 json 格式，不需要设置 content-type;koa将 request 和 response 对象封装在了一个对象中，该对象就是 ctx\n\n 1. 在 routers 下定义路由文件，可能会有前缀，不要忘了写router.prefix('/api')\n\nconst router = require('koa-router')()\nrouter.prefix('/api') // 前缀\n// 定义路由\nrouter.get('/list', async ctx => {\n    ctx.body = {\n        errno: 0,\n        data: [\n            { content: 'text1', user: 'frank' },\n            { content: 'text2', user: 'zhang' },\n            { content: 'text3', user: 'sun' },\n        ],\n    }\n})\nmodule.exports = router // 输出\n\n\n 2. 在 app.js 引用路由\n\nconst comments = require('./routes/comments')\n\n\n 3. app.js 下注册路由\n\napp.use(comments.routes(), comments.allowedmethods())\n\n\n\n# koa2 处理 http 请求\n\nquerystring request body response body content-type\n\nconst router = require('koa-router')()\n\nrouter.prefix('/api') // 前缀\n// 定义路由\nrouter.get('/list', async ctx => {\n    const query = ctx.query // querystring\n    // console.log('query',query)\n    ctx.body = {\n        errno: 0,\n        data: [\n            { content: 'text1', user: 'frank' },\n            { content: 'text2', user: 'zhang' },\n            { content: 'text3', user: 'sun' },\n        ],\n    } //response body\n})\n\nrouter.post('/create', async ctx => {\n    const body = ctx.request.body //request body\n    // console.log('req-body',body)\n    ctx.body = {\n        errno: 0,\n        message: '留言创建成功！',\n    } // res-body\n})\n\nmodule.exports = router // 输出\n\n\nkoa 和 node.js 相比，封装了原生代码的 api,规范了流程和格式\n\n// node.js\n// 相同功能node实现\nconst http = require('http')\n\nconst server = http.createserver((req, res) => {\n    const url = req.url\n    const path = url.split('?')[0]\n    const method = req.method\n\n    // 定义一个get路由 获取留言板列表\n    if (path === '/api/list' && method === 'get') {\n        const result = {\n            errno: 0,\n            data: [\n                { user: 'frank', content: 'messsage-1' },\n                { user: 'dell', content: 'messsage-2' },\n            ],\n        }\n        res.writehead(200, { 'content-type': 'application/json' })\n        res.end(\n            // 把对象转化为json字符串\n            json.stringify(result)\n        )\n    }\n    // 定义一个post路由 创建留言板\n    else if (path === '/api/create' && method === 'post') {\n        const result = {\n            errno: 0,\n            message: '留言创建成功！',\n        }\n        res.writehead(200, { 'content-type': 'application/json' })\n        res.end(\n            // 把对象转化为json字符串\n            json.stringify(result)\n        )\n    } else {\n        res.writehead(404, { 'content-type': 'text/plain' })\n        res.end('404 not found')\n    }\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# koa2 中间件\n\n中间件：一个流程上，独立的业务模块\n\n可扩展，可插拔\n\n类似于工厂的流水线\n\n\n\n为什么使用中间件？\n\n * 拆分业务模块，使代码清晰\n\n * 统一使用中间件，使得各业务代码都规范标准\n\n * 扩展性好，易添加，易删除\n\nkoa2 业务代码都是中间件所有的 app.use(...)都是中间件\n\n路由也是中间件（只不过限制了 url 规则），所有的请求都会经过 app.use，路由规则匹配后才会进入对应路由中间件\n\n\n\nconst koa = require('koa')\nconst app = new koa()\nconst views = require('koa-views')\nconst json = require('koa-json')\nconst onerror = require('koa-onerror')\nconst bodyparser = require('koa-bodyparser')\nconst logger = require('koa-logger')\n\nconst index = require('./routes/index')\nconst users = require('./routes/users')\nconst comments = require('./routes/comments')\n// error handler 错误处理器\nonerror(app)\n\n// middlewares 中间件（ app.use(...) ）\napp.use(\n    bodyparser({\n        // request body 转换\n        enabletypes: ['json', 'form', 'text'],\n    })\n)\n// 处理ctx.body（responce body）\napp.use(json())\napp.use(logger()) // 日志格式\napp.use(require('koa-static')(__dirname + '/public')) // 静态文件服务\n\napp.use(\n    views(__dirname + '/views', {\n        // 服务端模板引擎\n        extension: 'pug',\n    })\n)\n\n// logger 打印当前请求所花费的时间\napp.use(async (ctx, next) => {\n    const start = new date()\n    await next()\n    const ms = new date() - start\n    console.log(`${ctx.method} ${ctx.url} - ${ms}ms`)\n})\n\n// routes 注册路由\napp.use(index.routes(), index.allowedmethods())\napp.use(users.routes(), users.allowedmethods())\napp.use(comments.routes(), comments.allowedmethods())\n// allowedmethods() 对于 404 或者返回是空的情况的一种补充\n\n// error-handling\napp.on('error', (err, ctx) => {\n    console.error('server error', err, ctx)\n})\n\nmodule.exports = app\n\n\n模拟登录功能,仅仅是为了使用中间件\n\napp.js 中使用中间件，next()执行下一个中间件\n\n......\napp.use(async(ctx,next)=>{\n  const query=ctx.query\n  if(query.user='frank'){\n    await next()\n  }else{\n      ctx.body='登录失败！'\n  }\n})\n\n......\n\napp.use(index.routes(),......)\n\n\n\n\n\n\n# koa2 洋葱圈模型\n\n注意\n\n中间件机制，业务模块的划分;洋葱圈模型，中间件的执行机制;两者要分开，不要混为一谈\n\n中间件机制，是 koa 的精髓，每个中间件都是 async 函数，中间件的运行机制，就像洋葱圈\n\n\n\n代码演示：\n\nconst koa = require('koa')\nconst app = new koa()\n\n// logger\n\napp.use(async (ctx, next) => {\n    await next()\n    const rt = ctx.response.get('x-response-time')\n    console.log(`${ctx.method} ${ctx.url} - ${rt}`)\n})\n\n// x-response-time\n\napp.use(async (ctx, next) => {\n    const start = date.now()\n    await next()\n    const ms = date.now() - start\n    ctx.set('x-response-time', `${ms}ms`)\n})\n\n// response\n\napp.use(async ctx => {\n    ctx.body = 'hello world'\n})\n\napp.listen(3000)\n\n\n个人理解\n\n遇到了 async 异步函数中的 await，先返回，阻塞了函数中后面代码的执行。去执行下一个中间件，在下一个中间件中又遇到了 await 继续执行下一个中间件....这样到最后一个中间件，逐层向上执行每个 async 函数的后续代码。\n\n\n# koa2 登录实现方案与实践\n\n\n# cookie-介绍\n\n * 存储在浏览器的一段字符串，最大 5kb\n * 每个域都可有一个 cookie，跨域不共享\n * 格式如 k1=v1；k2=v2；k3=v3（可结构化）\n * cookie 会随 http 请求传递给服务端\n * 服务端可修改 cookie 再返回给前端\n * 默认，跨域不可传递 cookie\n\n\n# cookie-服务端操作 cookie\n\n * nodejs\n\nconst http = require('http')\n\nconst server = http.createserver((req, res) => {\n    // 设置cookie\n    res.setheader('set-cookie', 'a=100')\n    // 追加不覆盖\n    res.setheader('set-cookie', 'b=200')\n    // 获取cookie\n    console.log('cookie is', req.headers.cookie)\n    const cookiestr = req.headers.cookie\n    res.end('cookie test')\n    // 结构化cookie 'a=100;b=200'->{a:100,b:200}\n    const cookieobj = {}\n    cookiestr.split(';').foreach(cookieitem => {\n        const arr = cookieitem.trim().split('=')\n        const key = arr[0]\n        const val = arr[1]\n        cookieobj[key] = val\n    })\n    console.log('cookieobj is', cookieobj)\n})\nserver.listen(3000, () => {\n    console.log('server listen on 3000 port')\n})\n\n\n * koa2\n\napp.use(async ctx => {\n    // 设置cookie\n    ctx.cookies.set('a', '100')\n    // 获取cookie\n    ctx.cookies.get('a')\n    // 结构化 koa2已经做好了\n})\n\n\n\n# cookie 登录校验\n\n请求登录接口，成功则设置 cookie，如 user=zhangsan\n\n前端再请求其他接口，就会带着上述 cookie\n\n服务端判断 cookie 有无 user=zhangsan，即可验证\n\n\n\n\n# session-介绍\n\ncookie 不能暴露用户名\n\ncookie 存放用户信息明文，非常危险;解决方案：cookie 存一个用户标识，如 userid=123,而不是 username=zhangfan\n\ncookie 存储用户标识,用户信息则存储到 session 中,session 即用户信息的存储，和 cookie 有对应关系\n\n\n\n\n# koa2 实现登录-session\n\n 1. 安装koa-generic-session(2.0.4)\n\nnpm i koa-generic-session --save\n\n\n 2. app.js 使用中间件\n\n// 自动配置了 cookie 和 session\napp.keys = ['wertwe^&&*uui123123'] // 秘钥\napp.use(\n    session({\n        // 配置 cookie\n        cookie: {\n            path: '/', // cookie 在根目录下有效\n            httponly: true, // cookie 只允许服务端来操作\n            maxage: 24 * 60 * 60 * 1000, // cookie 的过期时间\n        },\n    })\n)\n\n\n\n# koa2 实现登录-模拟登录\n\nrouter/users.js\n\n// 模拟登录\nrouter.get('/login-mock', async (ctx, next) => {\n    let str = ''\n    const query = ctx.query // url 参数，querystring\n    if (query.username) {\n        // 模拟登录成功\n        ctx.session.userinfo = {\n            username: query.username,\n        }\n        str = 'login ok'\n    } else {\n        // 模拟登录失败，不用处理 session\n        str = 'login failed'\n    }\n\n    ctx.body = str\n})\n\n// 模拟登录验证\nrouter.get('/login-check-mock', async (ctx, next) => {\n    ctx.body = ctx.session.userinfo || {}\n})\n\n\n\n# 完善登录功能-对接数据库\n\n// 登录（对接数据库的）\n// 为了方便同域的测试，暂用 get 请求\nrouter.get('/login', async (ctx, next) => {\n    const { username, password } = ctx.query // get 请求\n    // const { username, password } = ctx.request.body // post 请求\n\n    // 查询数据库\n    const user = await user.findone({\n        username,\n        password,\n    })\n\n    if (user != null) {\n        // 登录成功，设置 session\n        ctx.session.userinfo = user // 所有的用户信息\n        // 返回\n        ctx.body = {\n            errno: 0,\n            data: user,\n        }\n        return\n    }\n    // 登录失败，不用操作 session\n    ctx.body = {\n        errno: -1,\n        message: '用户名或密码错误',\n    }\n})\n\n\n\n# 完善登录功能-重写登录中间件\n\nmiddlewares/logincheck.js\n\n// 登录验证的中间件\n\nasync function logincheck(ctx, next) {\n    const userinfo = ctx.session.userinfo\n    if (userinfo && userinfo.username) {\n        // 登录验证成功\n        await next()\n        return\n    }\n    // 登录失败\n    ctx.body = {\n        errno: -1,\n        message: '请登录',\n    }\n}\n\nmodule.exports = logincheck\n\n\n将登录中间件单独用于某个路由(比如获取留言板内容)\n\nconst logincheck = require('../middlewares/logincheck')\n// 定义路由：模拟获取留言板列表\n\n......\n\nrouter.get('/list',logincheck,async (ctx, next) => {\n    const query = ctx.query // req 功能\n    console.log('query', query)\n    // ctx.body = 'api list' // res 功能\n\n    // 获取数据库的列表\n    const commentlist = await comment.find().sort({ _id: -1 })\n    ctx.body = {\n        errno: 0,\n        data: commentlist\n    }\n})\n",charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"队列",frontmatter:{title:"队列",sidebarDepth:2,readingShow:"top"},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97.html",relativePath:"数据结构算法/队列.md",key:"v-2c160162",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:171},{level:3,title:"最近的请求次数",slug:"最近的请求次数",normalizedTitle:"最近的请求次数",charIndex:223},{level:3,title:"前端与队列：js 异步中的任务队列",slug:"前端与队列-js-异步中的任务队列",normalizedTitle:"前端与队列：js 异步中的任务队列",charIndex:917}],headersStr:"简介 应用场景 最近的请求次数 前端与队列：js 异步中的任务队列",content:"# 简介\n\n * 一个先进先出的数据结构\n\n * JavaScript 中没有队列，但可以用 Array 实现队列的所有功能。\n\nconst queue = []\nqueue.push(1)\nqueue.push(2)\nconst item1 = queue.shift()\nconst item2 = queue.shift()\n\n\n\n# 应用场景\n\n需要先进先出的场景，比如：食堂排队打饭、JS 异步中的任务队列、计算最近请求次数。\n\n\n# 最近的请求次数\n\nLeetCode：933. 最近的请求次数\n\n * 解题思路\n\n越早发出的请求越早不在最近 3000ms 内的请求里\n\n满足先进先出，考虑用队列\n\n * 解题步骤\n\n 1. 有新请求就入队，3000ms 前发出的请求出队。\n 2. 队列的长度就是最近请求次数。\n\n/*\n * @lc app=leetcode.cn id=933 lang=javascript\n *\n * [933] 最近的请求次数\n */\n\n// @lc code=start\n\nvar RecentCounter = function () {\n    this.q = []\n}\n\n/**\n * @param {number} t\n * @return {number}\n */\nRecentCounter.prototype.ping = function (t) {\n    // 先进先出 用队列！\n    this.q.push(t)\n    //    3000ms前的请求出队\n    while (this.q[0] < t - 3000) {\n        this.q.shift()\n    }\n    return this.q.length\n}\n\n/**\n * Your RecentCounter object will be instantiated and called as such:\n * var obj = new RecentCounter()\n * var param_1 = obj.ping(t)\n */\n// @lc code=end\n\n\n\n# 前端与队列：js 异步中的任务队列\n\n事件循环与任务队列\n\n!",normalizedContent:"# 简介\n\n * 一个先进先出的数据结构\n\n * javascript 中没有队列，但可以用 array 实现队列的所有功能。\n\nconst queue = []\nqueue.push(1)\nqueue.push(2)\nconst item1 = queue.shift()\nconst item2 = queue.shift()\n\n\n\n# 应用场景\n\n需要先进先出的场景，比如：食堂排队打饭、js 异步中的任务队列、计算最近请求次数。\n\n\n# 最近的请求次数\n\nleetcode：933. 最近的请求次数\n\n * 解题思路\n\n越早发出的请求越早不在最近 3000ms 内的请求里\n\n满足先进先出，考虑用队列\n\n * 解题步骤\n\n 1. 有新请求就入队，3000ms 前发出的请求出队。\n 2. 队列的长度就是最近请求次数。\n\n/*\n * @lc app=leetcode.cn id=933 lang=javascript\n *\n * [933] 最近的请求次数\n */\n\n// @lc code=start\n\nvar recentcounter = function () {\n    this.q = []\n}\n\n/**\n * @param {number} t\n * @return {number}\n */\nrecentcounter.prototype.ping = function (t) {\n    // 先进先出 用队列！\n    this.q.push(t)\n    //    3000ms前的请求出队\n    while (this.q[0] < t - 3000) {\n        this.q.shift()\n    }\n    return this.q.length\n}\n\n/**\n * your recentcounter object will be instantiated and called as such:\n * var obj = new recentcounter()\n * var param_1 = obj.ping(t)\n */\n// @lc code=end\n\n\n\n# 前端与队列：js 异步中的任务队列\n\n事件循环与任务队列\n\n!",charsets:{cjk:!0},lastUpdated:"2022年05月11日",lastUpdatedTimestamp:1652248975e3},{title:"Node.js处理HTTP",frontmatter:{title:"Node.js处理HTTP",readingShow:"top"},regularPath:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/node%E5%85%A5%E9%97%A8/Node.js%E5%A4%84%E7%90%86HTTP.html",relativePath:"服务端开发/node入门/Node.js处理HTTP.md",key:"v-7fa1a73e",path:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/node%E5%85%A5%E9%97%A8/Node.js%E5%A4%84%E7%90%86HTTP.html",headers:[{level:2,title:"监听 http 请求",slug:"监听-http-请求",normalizedTitle:"监听 http 请求",charIndex:2},{level:3,title:"node.js 启动 web 服务",slug:"node-js-启动-web-服务",normalizedTitle:"node.js 启动 web 服务",charIndex:17},{level:2,title:"req 和 res",slug:"req-和-res",normalizedTitle:"req 和 res",charIndex:231},{level:2,title:"路由",slug:"路由",normalizedTitle:"路由",charIndex:552},{level:3,title:"路由-定义 get 路由和 post 路由",slug:"路由-定义-get-路由和-post-路由",normalizedTitle:"路由-定义 get 路由和 post 路由",charIndex:559},{level:3,title:"测试路由",slug:"测试路由",normalizedTitle:"测试路由",charIndex:1095},{level:2,title:"querystring",slug:"querystring",normalizedTitle:"querystring",charIndex:1151},{level:3,title:"介绍和使用",slug:"介绍和使用",normalizedTitle:"介绍和使用",charIndex:1167},{level:3,title:"hash 不能传到服务端",slug:"hash-不能传到服务端",normalizedTitle:"hash 不能传到服务端",charIndex:2411},{level:3,title:"结构化与非结构化",slug:"结构化与非结构化",normalizedTitle:"结构化与非结构化",charIndex:2471},{level:2,title:"res 返回数据",slug:"res-返回数据",normalizedTitle:"res 返回数据",charIndex:2556},{level:3,title:"返回 JSON 数据",slug:"返回-json-数据",normalizedTitle:"返回 json 数据",charIndex:2569},{level:3,title:"返回 html",slug:"返回-html",normalizedTitle:"返回 html",charIndex:3755},{level:2,title:"接收 request body",slug:"接收-request-body",normalizedTitle:"接收 request body",charIndex:5309},{level:3,title:"流",slug:"流",normalizedTitle:"流",charIndex:5329}],headersStr:"监听 http 请求 node.js 启动 web 服务 req 和 res 路由 路由-定义 get 路由和 post 路由 测试路由 querystring 介绍和使用 hash 不能传到服务端 结构化与非结构化 res 返回数据 返回 JSON 数据 返回 html 接收 request body 流",content:"# 监听 http 请求\n\n\n# node.js 启动 web 服务\n\n使用 http 模块，启动服务\n\nconst http = require('http')\n\nconst server = http.createServer(() => {\n    console.log('已经收到http请求')\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# req 和 res\n\nconst http = require('http')\n\nconst server = http.createServer((req, res) => {\n    const url = req.url\n    console.log('url is' + url) // http://localhost:3000/index.html url='/index.html'\n    res.end('hello node.js!') // res返回信息给前端\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# 路由\n\n\n# 路由-定义 get 路由和 post 路由\n\nconst http = require('http')\n\nconst server = http.createServer((req, res) => {\n    const url = req.url\n    const path = url.split('?')[0]\n    const method = req.method\n    // 定义一个get路由 获取留言板列表\n    if (path === '/api/list' && method === 'GET') {\n        res.end('this is list ')\n    }\n    // 定义一个POST路由 创建留言板\n    else if (path === '/api/create' && method === 'POST') {\n        res.end('create')\n    } else {\n        res.end('404')\n    }\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# 测试路由\n\n * GET 请求，直接拿浏览器访问\n * POST 请求，需要借助工具——postman\n\n\n# querystring\n\n\n# 介绍和使用\n\nhttp://xxx.com/index.html?keyword=123&lang=en\n\n * url 问号 后面的都是 querystring 也叫 url 参数\n * & 分割 key=value 样式 可继续扩展\n * 如何利用 querystring 实现动态网页\n\n 1. 服务端拿到 querystring\n 2. 根据不同的 querystring 返回不同的内容\n 3. 即变化 querystring 就是变换内容（只要服务端支持）\n\nconst http = require('http')\nconst querystring = require('querystring')\nconst server = http.createServer((req, res) => {\n    const url = req.url\n    const path = url.split('?')[0]\n    const method = req.method\n    const queryStr = url.split('?')[1]\n    // const query ={}\n    // queryStr && queryStr.split('&').forEach(item => {\n    //     const key =item.split('=')[0]\n    //     const val =item.split('=')[1]\n    //     query[key]=val\n    // });\n    const query = querystring.parse(queryStr)\n    console.log(query)\n    // 定义一个get路由 获取留言板列表\n    if (path === '/api/list' && method === 'GET') {\n        if (query.type === '1') {\n            res.end('this is list,all')\n        }\n        if (query.type === '2') {\n            res.end('this is list,only me')\n        }\n    }\n    // 定义一个POST路由 创建留言板\n    else if (path === '/api/create' && method === 'POST') {\n        res.end('create' + path)\n    } else {\n        res.end('404')\n    }\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# hash 不能传到服务端\n\nhttp://xxx.com/index.html/#/user/zhangsan\n\n\n# 结构化与非结构化\n\n * 结构化的数据，易于通过程序访问和分析，如对象和数组\n * 非结构化的数据，不易通过程序分析，如字符串\n * 编程中的数据，都尽量结构化\n\n\n# res 返回数据\n\n\n# 返回 JSON 数据\n\n使用 res 设置返回的状态码， Content-type,Body\n\nconst http = require('http')\n\nconst server = http.createServer((req, res) => {\n    const url = req.url\n    const path = url.split('?')[0]\n    const method = req.method\n\n    // 定义一个get路由 获取留言板列表\n    if (path === '/api/list' && method === 'GET') {\n        const result = {\n            errno: 0,\n            data: [\n                { user: 'frank', content: 'messsage-1' },\n                { user: 'dell', content: 'messsage-2' },\n            ],\n        }\n        res.writeHead(200, { 'Content-type': 'application/json' })\n        res.end(\n            // 把对象转化为JSON字符串\n            JSON.stringify(result)\n        )\n    }\n    // 定义一个POST路由 创建留言板\n    else if (path === '/api/create' && method === 'POST') {\n        const result = {\n            errno: 0,\n            message: '留言创建成功！',\n        }\n        res.writeHead(200, { 'Content-type': 'application/json' })\n        res.end(\n            // 把对象转化为JSON字符串\n            JSON.stringify(result)\n        )\n    } else {\n        res.writeHead(404, { 'Content-type': 'text/plain' })\n        res.end('404 not found')\n    }\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# 返回 html\n\n浏览器会根据Content-type识别出html格式\n\nconst http = require('http')\n\nconst server = http.createServer((req, res) => {\n    const url = req.url\n    const path = url.split('?')[0]\n    const method = req.method\n\n    // 定义一个get路由 获取留言板列表\n    if (path === '/api/list' && method === 'GET') {\n        const result = {\n            errno: 0,\n            data: [\n                { user: 'frank', content: 'messsage-1' },\n                { user: 'dell', content: 'messsage-2' },\n            ],\n        }\n        res.writeHead(200, { 'Content-type': 'application/json' })\n        res.end(\n            // 把对象转化为JSON字符串\n            JSON.stringify(result)\n        )\n    }\n    // 定义一个POST路由 创建留言板\n    else if (path === '/api/create' && method === 'POST') {\n        const result = {\n            errno: 0,\n            message: '留言创建成功！',\n        }\n        res.writeHead(200, { 'Content-type': 'application/json' })\n        res.end(JSON.stringify(result))\n    } else {\n        res.writeHead(404, { 'Content-type': 'text/html' })\n        res.end(\n            `\n             <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <h1>404 not found!!!!!!!!!</h1>\n    <ul>\n    <li>node.js</li>\n    <li>vue.js</li>\n    <li>koa2</li>\n    <li>mongoDB</li>\n    </ul>\n</body>\n</html>\n             `\n        )\n    }\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# 接收 request body\n\n\n# 流\n\n# 流的表现\n\n * 观看视频时，一边加载一边观看\n * 上传文件时，有进度条\n * 网速较慢时，打开网页会先显示-部分，然后继续加载\n\n# 浏览器能接收流（stream）数据\n\n * 服务端 res end（…），会自动以流的形式返回\n * 浏览器会识别到流，并持续接收信息（会有进度条）\n * 待全部接收完，再做显示或处理（视频是一段一段的播放）\n\n# 服务端如何接收流（ stream）数据\n\n * 前端使用 Ajax（或 Postman）提交数据 Request Body\n * 服务端需要识别流，并接收数据\n * 还要知道何时才能接收完成\n\nconst http = require('http')\n\nconst server = http.createServer((req, res) => {\n    const url = req.url\n    const path = url.split('?')[0]\n    const method = req.method\n    //  定义路由 模拟创建留言\n    if (path === '/api/create' && method === 'POST') {\n        let bodyStr = ''\n        req.on('data', chuck => {\n            //服务端怎么去识别‘流’，并接收数据\n            //    chuck,即流的每一段数据\n            bodyStr += bodyStr + chuck.toString()\n        })\n        req.on('end', () => {\n            //服务端怎么知道流完了\n            const body = JSON.parse(bodyStr)\n            console.log(body)\n            res.end('接收完成')\n        })\n    } else {\n        res.writeHead(404, { 'Content-type': 'text/html' })\n        res.end(\n            `\n             <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <h1>404 not found!!!!!!!!!</h1>\n</body>\n</html>\n             `\n        )\n    }\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n * 在 postman 中发送 json 数据\n\n",normalizedContent:"# 监听 http 请求\n\n\n# node.js 启动 web 服务\n\n使用 http 模块，启动服务\n\nconst http = require('http')\n\nconst server = http.createserver(() => {\n    console.log('已经收到http请求')\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# req 和 res\n\nconst http = require('http')\n\nconst server = http.createserver((req, res) => {\n    const url = req.url\n    console.log('url is' + url) // http://localhost:3000/index.html url='/index.html'\n    res.end('hello node.js!') // res返回信息给前端\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# 路由\n\n\n# 路由-定义 get 路由和 post 路由\n\nconst http = require('http')\n\nconst server = http.createserver((req, res) => {\n    const url = req.url\n    const path = url.split('?')[0]\n    const method = req.method\n    // 定义一个get路由 获取留言板列表\n    if (path === '/api/list' && method === 'get') {\n        res.end('this is list ')\n    }\n    // 定义一个post路由 创建留言板\n    else if (path === '/api/create' && method === 'post') {\n        res.end('create')\n    } else {\n        res.end('404')\n    }\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# 测试路由\n\n * get 请求，直接拿浏览器访问\n * post 请求，需要借助工具——postman\n\n\n# querystring\n\n\n# 介绍和使用\n\nhttp://xxx.com/index.html?keyword=123&lang=en\n\n * url 问号 后面的都是 querystring 也叫 url 参数\n * & 分割 key=value 样式 可继续扩展\n * 如何利用 querystring 实现动态网页\n\n 1. 服务端拿到 querystring\n 2. 根据不同的 querystring 返回不同的内容\n 3. 即变化 querystring 就是变换内容（只要服务端支持）\n\nconst http = require('http')\nconst querystring = require('querystring')\nconst server = http.createserver((req, res) => {\n    const url = req.url\n    const path = url.split('?')[0]\n    const method = req.method\n    const querystr = url.split('?')[1]\n    // const query ={}\n    // querystr && querystr.split('&').foreach(item => {\n    //     const key =item.split('=')[0]\n    //     const val =item.split('=')[1]\n    //     query[key]=val\n    // });\n    const query = querystring.parse(querystr)\n    console.log(query)\n    // 定义一个get路由 获取留言板列表\n    if (path === '/api/list' && method === 'get') {\n        if (query.type === '1') {\n            res.end('this is list,all')\n        }\n        if (query.type === '2') {\n            res.end('this is list,only me')\n        }\n    }\n    // 定义一个post路由 创建留言板\n    else if (path === '/api/create' && method === 'post') {\n        res.end('create' + path)\n    } else {\n        res.end('404')\n    }\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# hash 不能传到服务端\n\nhttp://xxx.com/index.html/#/user/zhangsan\n\n\n# 结构化与非结构化\n\n * 结构化的数据，易于通过程序访问和分析，如对象和数组\n * 非结构化的数据，不易通过程序分析，如字符串\n * 编程中的数据，都尽量结构化\n\n\n# res 返回数据\n\n\n# 返回 json 数据\n\n使用 res 设置返回的状态码， content-type,body\n\nconst http = require('http')\n\nconst server = http.createserver((req, res) => {\n    const url = req.url\n    const path = url.split('?')[0]\n    const method = req.method\n\n    // 定义一个get路由 获取留言板列表\n    if (path === '/api/list' && method === 'get') {\n        const result = {\n            errno: 0,\n            data: [\n                { user: 'frank', content: 'messsage-1' },\n                { user: 'dell', content: 'messsage-2' },\n            ],\n        }\n        res.writehead(200, { 'content-type': 'application/json' })\n        res.end(\n            // 把对象转化为json字符串\n            json.stringify(result)\n        )\n    }\n    // 定义一个post路由 创建留言板\n    else if (path === '/api/create' && method === 'post') {\n        const result = {\n            errno: 0,\n            message: '留言创建成功！',\n        }\n        res.writehead(200, { 'content-type': 'application/json' })\n        res.end(\n            // 把对象转化为json字符串\n            json.stringify(result)\n        )\n    } else {\n        res.writehead(404, { 'content-type': 'text/plain' })\n        res.end('404 not found')\n    }\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# 返回 html\n\n浏览器会根据content-type识别出html格式\n\nconst http = require('http')\n\nconst server = http.createserver((req, res) => {\n    const url = req.url\n    const path = url.split('?')[0]\n    const method = req.method\n\n    // 定义一个get路由 获取留言板列表\n    if (path === '/api/list' && method === 'get') {\n        const result = {\n            errno: 0,\n            data: [\n                { user: 'frank', content: 'messsage-1' },\n                { user: 'dell', content: 'messsage-2' },\n            ],\n        }\n        res.writehead(200, { 'content-type': 'application/json' })\n        res.end(\n            // 把对象转化为json字符串\n            json.stringify(result)\n        )\n    }\n    // 定义一个post路由 创建留言板\n    else if (path === '/api/create' && method === 'post') {\n        const result = {\n            errno: 0,\n            message: '留言创建成功！',\n        }\n        res.writehead(200, { 'content-type': 'application/json' })\n        res.end(json.stringify(result))\n    } else {\n        res.writehead(404, { 'content-type': 'text/html' })\n        res.end(\n            `\n             <!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>document</title>\n</head>\n<body>\n    <h1>404 not found!!!!!!!!!</h1>\n    <ul>\n    <li>node.js</li>\n    <li>vue.js</li>\n    <li>koa2</li>\n    <li>mongodb</li>\n    </ul>\n</body>\n</html>\n             `\n        )\n    }\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n\n# 接收 request body\n\n\n# 流\n\n# 流的表现\n\n * 观看视频时，一边加载一边观看\n * 上传文件时，有进度条\n * 网速较慢时，打开网页会先显示-部分，然后继续加载\n\n# 浏览器能接收流（stream）数据\n\n * 服务端 res end（…），会自动以流的形式返回\n * 浏览器会识别到流，并持续接收信息（会有进度条）\n * 待全部接收完，再做显示或处理（视频是一段一段的播放）\n\n# 服务端如何接收流（ stream）数据\n\n * 前端使用 ajax（或 postman）提交数据 request body\n * 服务端需要识别流，并接收数据\n * 还要知道何时才能接收完成\n\nconst http = require('http')\n\nconst server = http.createserver((req, res) => {\n    const url = req.url\n    const path = url.split('?')[0]\n    const method = req.method\n    //  定义路由 模拟创建留言\n    if (path === '/api/create' && method === 'post') {\n        let bodystr = ''\n        req.on('data', chuck => {\n            //服务端怎么去识别‘流’，并接收数据\n            //    chuck,即流的每一段数据\n            bodystr += bodystr + chuck.tostring()\n        })\n        req.on('end', () => {\n            //服务端怎么知道流完了\n            const body = json.parse(bodystr)\n            console.log(body)\n            res.end('接收完成')\n        })\n    } else {\n        res.writehead(404, { 'content-type': 'text/html' })\n        res.end(\n            `\n             <!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>document</title>\n</head>\n<body>\n    <h1>404 not found!!!!!!!!!</h1>\n</body>\n</html>\n             `\n        )\n    }\n})\nserver.listen(3000, () => {\n    console.log('http请求已经被监听，3000端口')\n})\n\n\n * 在 postman 中发送 json 数据\n\n",charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"全局对象和模块化开发",frontmatter:{title:"全局对象和模块化开发",readingShow:"top"},regularPath:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5node/%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91.html",relativePath:"服务端开发/深入node/全局对象和模块化开发.md",key:"v-7306dc59",path:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5node/%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91.html",headers:[{level:2,title:"Node 程序传递参数",slug:"node-程序传递参数",normalizedTitle:"node 程序传递参数",charIndex:2},{level:2,title:"特殊的全局对象",slug:"特殊的全局对象",normalizedTitle:"特殊的全局对象",charIndex:368},{level:2,title:"常见的全局对象",slug:"常见的全局对象",normalizedTitle:"常见的全局对象",charIndex:693},{level:3,title:"process 对象",slug:"process-对象",normalizedTitle:"process 对象",charIndex:705},{level:3,title:"console 对象",slug:"console-对象",normalizedTitle:"console 对象",charIndex:767},{level:3,title:"定时器函数",slug:"定时器函数",normalizedTitle:"定时器函数",charIndex:795},{level:2,title:"global 对象",slug:"global-对象",normalizedTitle:"global 对象",charIndex:1069},{level:2,title:"模块化",slug:"模块化",normalizedTitle:"模块化",charIndex:1381},{level:3,title:"没有模块化带来很多的问题",slug:"没有模块化带来很多的问题",normalizedTitle:"没有模块化带来很多的问题",charIndex:1671},{level:3,title:"CommonJS 和 Node",slug:"commonjs-和-node",normalizedTitle:"commonjs 和 node",charIndex:2180}],headersStr:"Node 程序传递参数 特殊的全局对象 常见的全局对象 process 对象 console 对象 定时器函数 global 对象 模块化 没有模块化带来很多的问题 CommonJS 和 Node",content:"# Node 程序传递参数\n\n在某些情况下执行node 程序的过程中，我们可能希望给 node传递一些参数：node index.js env=development\n\n如果我们这样来使用程序，就意味着我们需要在程序中获取到传递的参数：\n\n * 获取参数其实是在 process 的内置对象中的；\n * process.argv（argument vector的缩写，传入的具体参数）是一个数组，里面包含了我们需要的参数；\n\n// 终端输入：`node index.js env=development`运行\nconsole.log('hello node')\nconsole.log(process.argv)\nprocess.argv.forEach(item => {\n    console.log(item)\n})\n\n\n\n# 特殊的全局对象\n\n这些全局对象可以在模块中任意使用，但是在命令行交互中是不可以使用的\n\n包括：__dirname、__filename、exports、module、require()\n\n__dirname：获取当前文件所在的路径;注意：不包括后面的文件名\n\n__filename：获取当前文件所在的路径和文件名称;注意：包括后面的文件名称\n\nconsole.log(__dirname)\nconsole.log(__filename)\n// D:\\myProject\\gitProject\\node_study\\特殊的全局对象\n// D:\\myProject\\gitProject\\node_study\\特殊的全局对象\\index.js\n\n\n\n# 常见的全局对象\n\n\n# process 对象\n\nprocess 提供了Node 进程中相关的信息;比如 Node 的运行环境、参数信息等；\n\n\n# console 对象\n\n提供了简单的调试控制台\n\n\n# 定时器函数\n\n * setTimeout(callback, delay[, ...args])：callback 在 delay 毫秒后执行一次；\n * setInterval(callback, delay[, ...args])：callback 每 delay 毫秒重复执行一次；\n * setImmediate(callback[, ...args])：callback I / O 事件后的回调的“立即”执行；\n * process.nextTick(callback[, ...args])：添加到下一次 tick 队列中；\n\n\n# global 对象\n\nglobal 是一个全局对象，事实上 process、console、setTimeout 等都有被放到global 中\n\n在浏览器中，全局变量都是在window 上的，比如有document、setInterval、setTimeout、alert、console等等\n\n在 Node 中，我们也有一个 global 属性，并且看起来它里面有很多其他对象。\n\n但是在浏览器中执行的 JavaScript 代码，如果我们在顶级范围内通过 var 定义的一个属性，默认会被添加到 window对象上\n\n但是在node中，我们通过 var定义一个变量，它只是在当前模块中有一个变量，不会放到全局中\n\n\n# 模块化\n\n * 事实上模块化开发最终的目的是将程序划分成一个个小的结构；\n * 这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构；\n * 这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用；\n * 也可以通过某种方式，导入另外结构中的变量、函数、对象等；\n\n上面说提到的结构，就是模块；按照这种结构划分开发程序的过程，就是模块化开发的过程；\n\nJavaScript 本身，直到 ES6（2015）才推出了自己的模块化方案；\n\n为了让 JavaScript 支持模块化，涌现出了很多不同的模块化规范：AMD、CMD、CommonJS 等；\n\n\n# 没有模块化带来很多的问题\n\n早期没有模块化带来了很多的问题：比如命名冲突的问题\n\n当然，我们有办法可以解决上面的问题：立即函数调用表达式 IIFE\n\nvar module1 = (function() {\n    var name = 'frank'\n\n    return {\n        name,\n    }\n})()\n\n\n但是，我们其实带来了新的问题：\n\n * 第一，我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用；\n * 第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写；\n * 第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况；\n\n所以，我们会发现，虽然实现了模块化，但是我们的实现过于简单，并且是没有规范的。\n\n * 我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码；\n * 这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性；\n * JavaScript 社区为了解决上面的问题，涌现出一系列好用的规范，接下来我们就学习具有代表性的一些规范。\n\n\n# CommonJS 和 Node\n\n我们需要知道 CommonJS 是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为 ServerJS，后来为了 体现它的广泛性，修改为CommonJS，平时我们也会简称为 CJS。\n\n * Node 是CommonJS 在服务器端一个具有代表性的实现；\n * Browserify 是 CommonJS 在浏览器中的一种实现；\n * webpack打包工具具备对 CommonJS 的支持和转换；\n\n所以，Node中对 CommonJS进行了支持和实现，让我们在开发 node 的过程中可以方便的进行模块化开发：\n\n * 在 Node 中每一个 js 文件都是一个单独的模块；\n * 这个模块中包括 CommonJS规范的核心变量：exports、module.exports、require；\n * 我们可以使用这些变量来方便的进行模块化开发；\n\n模块化的核心是导出和导入，Node中对其进行了实现：\n\n * exports 和 module.exports 可以负责对模块中的内容进行导出\n * require 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；",normalizedContent:"# node 程序传递参数\n\n在某些情况下执行node 程序的过程中，我们可能希望给 node传递一些参数：node index.js env=development\n\n如果我们这样来使用程序，就意味着我们需要在程序中获取到传递的参数：\n\n * 获取参数其实是在 process 的内置对象中的；\n * process.argv（argument vector的缩写，传入的具体参数）是一个数组，里面包含了我们需要的参数；\n\n// 终端输入：`node index.js env=development`运行\nconsole.log('hello node')\nconsole.log(process.argv)\nprocess.argv.foreach(item => {\n    console.log(item)\n})\n\n\n\n# 特殊的全局对象\n\n这些全局对象可以在模块中任意使用，但是在命令行交互中是不可以使用的\n\n包括：__dirname、__filename、exports、module、require()\n\n__dirname：获取当前文件所在的路径;注意：不包括后面的文件名\n\n__filename：获取当前文件所在的路径和文件名称;注意：包括后面的文件名称\n\nconsole.log(__dirname)\nconsole.log(__filename)\n// d:\\myproject\\gitproject\\node_study\\特殊的全局对象\n// d:\\myproject\\gitproject\\node_study\\特殊的全局对象\\index.js\n\n\n\n# 常见的全局对象\n\n\n# process 对象\n\nprocess 提供了node 进程中相关的信息;比如 node 的运行环境、参数信息等；\n\n\n# console 对象\n\n提供了简单的调试控制台\n\n\n# 定时器函数\n\n * settimeout(callback, delay[, ...args])：callback 在 delay 毫秒后执行一次；\n * setinterval(callback, delay[, ...args])：callback 每 delay 毫秒重复执行一次；\n * setimmediate(callback[, ...args])：callback i / o 事件后的回调的“立即”执行；\n * process.nexttick(callback[, ...args])：添加到下一次 tick 队列中；\n\n\n# global 对象\n\nglobal 是一个全局对象，事实上 process、console、settimeout 等都有被放到global 中\n\n在浏览器中，全局变量都是在window 上的，比如有document、setinterval、settimeout、alert、console等等\n\n在 node 中，我们也有一个 global 属性，并且看起来它里面有很多其他对象。\n\n但是在浏览器中执行的 javascript 代码，如果我们在顶级范围内通过 var 定义的一个属性，默认会被添加到 window对象上\n\n但是在node中，我们通过 var定义一个变量，它只是在当前模块中有一个变量，不会放到全局中\n\n\n# 模块化\n\n * 事实上模块化开发最终的目的是将程序划分成一个个小的结构；\n * 这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构；\n * 这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用；\n * 也可以通过某种方式，导入另外结构中的变量、函数、对象等；\n\n上面说提到的结构，就是模块；按照这种结构划分开发程序的过程，就是模块化开发的过程；\n\njavascript 本身，直到 es6（2015）才推出了自己的模块化方案；\n\n为了让 javascript 支持模块化，涌现出了很多不同的模块化规范：amd、cmd、commonjs 等；\n\n\n# 没有模块化带来很多的问题\n\n早期没有模块化带来了很多的问题：比如命名冲突的问题\n\n当然，我们有办法可以解决上面的问题：立即函数调用表达式 iife\n\nvar module1 = (function() {\n    var name = 'frank'\n\n    return {\n        name,\n    }\n})()\n\n\n但是，我们其实带来了新的问题：\n\n * 第一，我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用；\n * 第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写；\n * 第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况；\n\n所以，我们会发现，虽然实现了模块化，但是我们的实现过于简单，并且是没有规范的。\n\n * 我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码；\n * 这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性；\n * javascript 社区为了解决上面的问题，涌现出一系列好用的规范，接下来我们就学习具有代表性的一些规范。\n\n\n# commonjs 和 node\n\n我们需要知道 commonjs 是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为 serverjs，后来为了 体现它的广泛性，修改为commonjs，平时我们也会简称为 cjs。\n\n * node 是commonjs 在服务器端一个具有代表性的实现；\n * browserify 是 commonjs 在浏览器中的一种实现；\n * webpack打包工具具备对 commonjs 的支持和转换；\n\n所以，node中对 commonjs进行了支持和实现，让我们在开发 node 的过程中可以方便的进行模块化开发：\n\n * 在 node 中每一个 js 文件都是一个单独的模块；\n * 这个模块中包括 commonjs规范的核心变量：exports、module.exports、require；\n * 我们可以使用这些变量来方便的进行模块化开发；\n\n模块化的核心是导出和导入，node中对其进行了实现：\n\n * exports 和 module.exports 可以负责对模块中的内容进行导出\n * require 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；",charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"邂逅Node",frontmatter:{title:"邂逅Node",readingShow:"top"},regularPath:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5node/%E9%82%82%E9%80%85Node.html",relativePath:"服务端开发/深入node/邂逅Node.md",key:"v-f174bee6",path:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5node/%E9%82%82%E9%80%85Node.html",headers:[{level:2,title:"Node.js 架构",slug:"node-js-架构",normalizedTitle:"node.js 架构",charIndex:19}],headersStr:"Node.js 架构",content:"努力学习中\n\n敬请期待...\n\n\n# Node.js 架构\n\n我们编写的 JavaScript 代码会经过 V8 引擎，再通过 Node.js 的 Bindings，将任务放到 Libuv 的事件循环中；\n\nlibuv（Unicorn Velociraptor—独角伶盗龙）是使用 C 语言编写的库；\n\nlibuv 提供了事件循环、文件系统读写、网络 IO、线程池等等内容；\n\n",normalizedContent:"努力学习中\n\n敬请期待...\n\n\n# node.js 架构\n\n我们编写的 javascript 代码会经过 v8 引擎，再通过 node.js 的 bindings，将任务放到 libuv 的事件循环中；\n\nlibuv（unicorn velociraptor—独角伶盗龙）是使用 c 语言编写的库；\n\nlibuv 提供了事件循环、文件系统读写、网络 io、线程池等等内容；\n\n",charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3},{title:"片段",frontmatter:{title:"片段",date:"2022/06/03 18:23:01",sidebar:"auto",readingShow:"top"},regularPath:"/%E6%9D%82%E8%AE%B0.html",relativePath:"杂记.md",key:"v-d326b974",path:"/%E6%9D%82%E8%AE%B0.html",headers:[{level:2,title:"终端命令别名",slug:"终端命令别名",normalizedTitle:"终端命令别名",charIndex:2},{level:2,title:"jetbrains 软件破解（macOS）",slug:"jetbrains-软件破解-macos",normalizedTitle:"jetbrains 软件破解（macos）",charIndex:165},{level:2,title:"vuepress 内置组件 Badge",slug:"vuepress-内置组件-badge",normalizedTitle:"vuepress 内置组件 badge",charIndex:3656},{level:3,title:"Badge beta 默认主题",slug:"badge-beta-默认主题",normalizedTitle:"badge beta 默认主题",charIndex:3680},{level:3,title:"Badge",slug:"badge",normalizedTitle:"badge",charIndex:3670},{level:2,title:"MAC 电脑壁纸和锁屏壁纸怎么不一样?",slug:"mac-电脑壁纸和锁屏壁纸怎么不一样",normalizedTitle:"mac 电脑壁纸和锁屏壁纸怎么不一样?",charIndex:3968},{level:2,title:"网站字库",slug:"网站字库",normalizedTitle:"网站字库",charIndex:4464},{level:2,title:"mac 系统 Log",slug:"mac-系统-log",normalizedTitle:"mac 系统 log",charIndex:4992},{level:2,title:"mac 系统 Cache（缓存）",slug:"mac-系统-cache-缓存",normalizedTitle:"mac 系统 cache（缓存）",charIndex:5406},{level:2,title:"mac 系统绕过公证（提示 app 已损坏）",slug:"mac-系统绕过公证-提示-app-已损坏",normalizedTitle:"mac 系统绕过公证（提示 app 已损坏）",charIndex:5493},{level:2,title:"How to give a Mac OS X machine a new Kerberos identity",slug:"how-to-give-a-mac-os-x-machine-a-new-kerberos-identity",normalizedTitle:"how to give a mac os x machine a new kerberos identity",charIndex:5700},{level:2,title:"Mac 系统默认 hosts",slug:"mac-系统默认-hosts",normalizedTitle:"mac 系统默认 hosts",charIndex:6032},{level:2,title:"Vscode 配置",slug:"vscode-配置",normalizedTitle:"vscode 配置",charIndex:6266},{level:2,title:"Mac OS 名称问题及修改方法",slug:"mac-os-名称问题及修改方法",normalizedTitle:"mac os 名称问题及修改方法",charIndex:7514},{level:3,title:"HostName",slug:"hostname",normalizedTitle:"hostname",charIndex:7535},{level:3,title:"管理员名称",slug:"管理员名称",normalizedTitle:"管理员名称",charIndex:7889},{level:3,title:"ComputerName",slug:"computername",normalizedTitle:"computername",charIndex:8055},{level:3,title:"LocalHostName",slug:"localhostname",normalizedTitle:"localhostname",charIndex:8156},{level:2,title:"macOS下蓝牙键盘(Keychron K2)连接失败的解决办法",slug:"macos下蓝牙键盘-keychron-k2-连接失败的解决办法",normalizedTitle:"macos下蓝牙键盘(keychron k2)连接失败的解决办法",charIndex:8362}],headersStr:"终端命令别名 jetbrains 软件破解（macOS） vuepress 内置组件 Badge Badge beta 默认主题 Badge MAC 电脑壁纸和锁屏壁纸怎么不一样? 网站字库 mac 系统 Log mac 系统 Cache（缓存） mac 系统绕过公证（提示 app 已损坏） How to give a Mac OS X machine a new Kerberos identity Mac 系统默认 hosts Vscode 配置 Mac OS 名称问题及修改方法 HostName 管理员名称 ComputerName LocalHostName macOS下蓝牙键盘(Keychron K2)连接失败的解决办法",content:'# 终端命令别名\n\n用户文件夹下.zshrc写入：\n\nalias nd="npm run dev"\nalias ns="npm run serve"\nalias y="yarn"\nalias ni="npm install"\nalias nb="npm run build"\nalias ys="yarn start"\n\n\n\n# jetbrains 软件破解（macOS）\n\n⚠️\n\n最高支持破解版本为 2021.3\n\n先打开一遍软件，退出\n\n打开访达->软件右键显示包内容->在/Applications/WebStorm.app/Contents/bin/webstorm.vmoptions 写入\n\n-javaagent:/Users/frank/JetBrains Crack file/fineagent.jar\n\n打开软件输入激活码,适用版本 2021.3\n\n破解 🐎\n\n5AYV1D1RE5-eyJsaWNlbnNlSWQiOiI1QVlWMUQxUkU1IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly93d3cuaml3ZWljaGVuZ3podS5jb20iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiIiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsImZhbGxiYWNrRGF0ZSI6IjIwOTktMTItMzEiLCJwYWlkVXBUbyI6IjIwOTktMTItMzEifSx7ImNvZGUiOiJBQyIsImZhbGxiYWNrRGF0ZSI6IjIwOTktMTItMzEiLCJwYWlkVXBUbyI6IjIwOTktMTItMzEifSx7ImNvZGUiOiJEUE4iLCJmYWxsYmFja0RhdGUiOiIyMDk5LTEyLTMxIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIn0seyJjb2RlIjoiUFMiLCJmYWxsYmFja0RhdGUiOiIyMDk5LTEyLTMxIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIn0seyJjb2RlIjoiR08iLCJmYWxsYmFja0RhdGUiOiIyMDk5LTEyLTMxIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIn0seyJjb2RlIjoiRE0iLCJmYWxsYmFja0RhdGUiOiIyMDk5LTEyLTMxIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIn0seyJjb2RlIjoiQ0wiLCJmYWxsYmFja0RhdGUiOiIyMDk5LTEyLTMxIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIn0seyJjb2RlIjoiUlMwIiwiZmFsbGJhY2tEYXRlIjoiMjA5OS0xMi0zMSIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSJ9LHsiY29kZSI6IlJDIiwiZmFsbGJhY2tEYXRlIjoiMjA5OS0xMi0zMSIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSJ9LHsiY29kZSI6IlJEIiwiZmFsbGJhY2tEYXRlIjoiMjA5OS0xMi0zMSIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSJ9LHsiY29kZSI6IlBDIiwiZmFsbGJhY2tEYXRlIjoiMjA5OS0xMi0zMSIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSJ9LHsiY29kZSI6IlJNIiwiZmFsbGJhY2tEYXRlIjoiMjA5OS0xMi0zMSIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSJ9LHsiY29kZSI6IldTIiwiZmFsbGJhY2tEYXRlIjoiMjA5OS0xMi0zMSIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSJ9LHsiY29kZSI6IkRCIiwiZmFsbGJhY2tEYXRlIjoiMjA5OS0xMi0zMSIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSJ9LHsiY29kZSI6IkRDIiwiZmFsbGJhY2tEYXRlIjoiMjA5OS0xMi0zMSIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSJ9LHsiY29kZSI6IlJTVSIsImZhbGxiYWNrRGF0ZSI6IjIwOTktMTItMzEiLCJwYWlkVXBUbyI6IjIwOTktMTItMzEifV0sImhhc2giOiIxMjc5Njg3Ny8wIiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-HNPogO0kWkHCVMnsjmBXUqQt87UPHqdkYqZGveSJtu8hb2V2Yq7gHsHenp4UuEd3jwEwC+YrUIf7U5yDA/56F5Sdn0RLUHZX5DHeQbJPbmYCBsDRT7m8rnmMFOSZn3vwNatvv1cooZbcGOk3Wwxx6bF7XcgaIrmXRcmZMZgv2PZehr0WS1HxNKe3X4nbGP3MwiSbg4ypmxNDrljmgv+Si9QDDwNLDffqeO0Lce0FqEJuMWmvBS42S0aeIYF8IS5bp4+LFKLJ8T7tF40OxKYDurBb9+9c43GZBscM/eLB8Jos66jNGFwgebFUlvhzJKVHZtuc/N8zGeEnTq6K0T/B8w==-MIIDTjCCAjagAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMCAXDTE4MTEwMTEyMjk0NloYDzIwOTkwODA5MDIyNjA3WjAfMR0wGwYDVQQDDBRwcm9kMnktZnJvbS0yMDIwMTAxOTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMK3eyr0+Oys/TwcQO+qYaXWGBmXcEP4fR0bHHzZd/4WNGltXhecM80OWthA38BQRYAJBCKz/dSkO2Kj1H2y+7KB5cIaOiJEyTESfTSgzQdot6laRBU8oxy9mmagI46M8zEEmplPybY4YJj4HOwZiBsMQEMxoTgMDLpuHX6uASoVhSj6koB55lOj4wEgsQBeAMWTAXmTl88ixE179J8aBUkBGpL8w/tZzl9BJXZNF15gPfkS58rw8cdPzXLS0Yym37A2/KKFhfHzJc5KhbaxqYzmkAfTMqPsIqCQ1lQUAqfiPn2gN2I1Z3/cQuEW27M55fXVr2DduQe5DWzYJs85L50CAwEAAaOBmTCBljAJBgNVHRMEAjAAMB0GA1UdDgQWBBQk2hEilvWFQcCTR+gxI0z0wIQC/zBIBgNVHSMEQTA/gBSjnrZIZ0ISNkG9beC5tKBSi5fxs6EcpBowGDEWMBQGA1UEAwwNSmV0UHJvZmlsZSBDQYIJANJssYOyg3nhMBMGA1UdJQQMMAoGCCsGAQUFBwMBMAsGA1UdDwQEAwIFoDANBgkqhkiG9w0BAQsFAAOCAQEAsCQBjO5wttco/Z5cj/o4GBrku8UtBBBVFq4xsBanshTHm4deVxcTvta4aScV0TPKcaLqGqWx8A9v8XXO8dBbCuyXvWZteZ/C2Covg1xXiM99lz7VxqpjVmLdKanZn5u0gQSiYJdcfF+TdbmEIeSOnN/kLXNq2hXdJQK2zk2J25UZqu5EibRtTbdOzw6ZcfwJ8uOntXfsmAhnNICP3Wf/4wR/mwB0Ka4S+JA3IbF5MUmUZ/fjUaFarnin70us+Vxf/sZUi7u67wilvwVV0NAqDpthHUV0NRc4q+yOr2Dt/uCHdy4XRXLJfAv/z9/xBwNZZALNz3EtQL6IeIWWJByl3g==\n\n\n\n# vuepress 内置组件 Badge\n\n\n# Badge beta 默认主题\n\n * Props:\n   * text - string\n   * type - string, 可选值： "tip"|"warning"|"error"，默认值是： "tip"\n   * vertical - string, 可选值： "top"|"middle"，默认值是： "top"\n * Usage:\n\n你可以在标题中，使用这个组件来为某些 API 添加一些状态：\n\n### Badge <Badge text="beta" type="warning"/> <Badge text="默认主题"/>\n\n\n\n# Badge\n\n\n# MAC 电脑壁纸和锁屏壁纸怎么不一样?\n\n注意\n\n锁屏壁纸如果要和桌面保持一致:\n\n 1. 不要删上面的文件夹\n 2. 关闭文件保险箱\n\nMac 系统的开机登录界面壁纸缓存在「资源库--Caches--Desktop Pictures--XXX--lockscreen.png」（其中的 XXX 为你的 UUID，进入系统偏好设置--用户与群组，先把下面的锁解开，然后右键你的用户，点击高级选项，弹出的页面中即有 UUID）部分用户由于使用 Clean my Mac 清理文件，导致这个文件夹从 Desktop Pictures 开始被删掉，而系统又不会自动生成这个文件夹，只能读取 Mojave.heic，只需要把这个文件夹和图片补上即可。图片可以自己用 PS 什么的转一下格式。补上文件夹和图片之后，更换系统壁纸，这个缓存文件夹的文件会随着系统壁纸改变。\n\n作者：Aman 链接：https://www.zhihu.com/question/366941376/answer/1154284728 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n# 网站字库\n\n一个互联网民工的开发笔记库关于作者网站内容网站愿景个人项目本站总访问量次|本站访客数人 1234567890 首页数据库前端开发后端开发前端面试开发工具基础知识开发记录杂记数据结构算法优质编程资源非关系型数据库 mongoDB 微信云 MySQL 进阶-框架 HtmlCsJavaScriptVueReactOtherType 移动重学小程序 Node.BabelMockWebpack 计算机网络浏览器工作原理与实践本地存储前后端数据交互与 HTTP 协议 Ajax&Fetch 与跨域请求其他 VueCopyright © 2020-2022 FANHANG ZHANG | Powered by VuePress, Vercel, Alibaba Cloud, Tencent Cloud and Algolia 菜鸟前端,互联网搬砖民工关于我接触、学习到的开发技术的笔记以及平时开发记录下来的问题笔记千锤百炼,让自己形成完备的前端知识体系,成为一名合格的前端开发工程师<FFE/>博客链我的不止 zf 深入 K 入门通相 Although this site is built by Vue, I like React 片段\n\n\n\n# mac 系统 Log\n\n要查找这些日志文件，请查看以下位置：\n\n * 系统日志文件夹：/var/log\n * 系统日志：/var/log/system.log\n * Mac Analytics 数据：/var/log/DiagnosticMessages\n * 系统应用程序日志：/Library/Logs\n * 系统报告：/Library/Logs/DiagnosticReports\n * 用户应用程序日志：～/Library/Logs（换句话说，/Users/NAME/Library/Logs）\n * 用户报告：～/Library/Logs/DiagnosticReports（换句话说，/Users/NAME/Library/Logs/DiagnosticReports）\n\n主要文件夹\n\n * /var/log\n * /var/logs\n * /Library/Logs\n * ~/Library/Logs\n\n\n# mac 系统 Cache（缓存）\n\n * /Library/Caches\n * /System/Library/Caches\n * ～/Library/Caches\n\n\n# mac 系统绕过公证（提示 app 已损坏）\n\n打开终端，输入以下命令：\n\nsudo xattr -rd com.apple.quarantine /Applications/xxxxxx.app\n\n将上面的 xxxxxx.app 换成你的 App 名称，比如 Sketch.app sudo xattr -rd com.apple.quarantine /Applications/Sketch.app\n\n\n# How to give a Mac OS X machine a new Kerberos identity\n\n 1. In Terminal, run ‘sudo rm -fr /var/db/krb5kdc’ – this will destroy the local KDC database.\n 2. In Terminal, run ‘sudo /usr/libexec/configureLocalKDC’ – this will regenerate the local KDC database, including a new certificate and SHA1 hash.\n 3. Bind the machine to OD.\n\n\n# Mac 系统默认 hosts\n\n##\n# Host Database\n#\n# localhost is used to configure the loopback interface\n# when the system is booting.  Do not change this entry.\n##\n127.0.0.1\tlocalhost\n255.255.255.255\tbroadcasthost\n::1             localhost\n\n\n\n# Vscode 配置\n\n{\n    "workbench.startupEditor": "none",\n    "workbench.statusBar.visible": false,\n    "workbench.productIconTheme": "fluent-icons",\n    "editor.fontSize": 21,\n    "editor.formatOnSave": true,\n    "editor.defaultFormatter": "esbenp.prettier-vscode",\n    "leetcode.endpoint": "leetcode-cn",\n    "leetcode.defaultLanguage": "javascript",\n    "leetcode.workspaceFolder": "/Users/frank/myProjects/data-structure-and-algorithm/leetcode",\n    "leetcode.editor.shortcuts": [\n        "submit",\n        "test",\n        "solution",\n        "description",\n        "star"\n    ],\n    "files.autoSave": "onFocusChange",\n    "prettier.semi": false,\n    "prettier.singleQuote": true,\n    "prettier.tabWidth": 4,\n    "prettier.arrowParens": "avoid",\n    "prettier.bracketSpacing": true,\n    "prettier.jsxSingleQuote": false,\n    "search.exclude": {\n        "**/node_modules": true\n    },\n    "terminal.integrated.fontSize": 19,\n    "terminal.integrated.cursorStyle": "line",\n    "terminal.integrated.cursorBlinking": true,\n    "[markdown]": {\n        "editor.quickSuggestions": true\n    },\n    "workbench.iconTheme": "material-icon-theme",\n    "workbench.colorTheme": "One Monokai",\n    "git.confirmSync": false,\n    "git.enableSmartCommit": true\n}\n\n\n\n# Mac OS 名称问题及修改方法\n\n\n# HostName\n\nHostName主机名, 用于在系统上标识一台机器. 他和 IP 地址的区别是, hostname 用于在系统上标识一台机器; IP 地址是在 TCP/IP 网络中唯一标志一台机器. 联系到实际生活, 主机名相当于一个房子的主人名, 而 IP 地址相当于小区内这间房子的门牌号. [hostname 也就是打开终端, 出现在 “@” 符号后面的名字]\n\n查看 HostName scutil --get HostName hostname echo $HOSTNAME, 这三个命令都可以查看 HostName.\n\n修改 HostName sudo scutil --set HostName [HostName]， [HostName]的位置是你想要设置的 HostName.\n\n\n# 管理员名称\n\n管理员名称就是电脑在初始化的时候你设置的管理员的名称, 也是电脑开机的时候头像下面显示的名称, 在系统偏好设置-用户与群组中进行修改. [打开终端, 管理员名称会出现在“@”最前面]\n\n在图形化界面中直接操作: 【系统偏好设置 - 用户与群组】 这个名称一般是不能改的, 可以通过新建/删除用户的方式进行修改\n\n\n# ComputerName\n\n计算机名, 在进行 Airdrop 共享文件, 或者其他一些共享操作的时候, 其他人会以这个名字看到你的电脑\n\n在【系统偏好设置 - 共享 - 电脑名称】中进行修改\n\n\n# LocalHostName\n\n本地主机名, 本地网络上的电脑可以通过这个名字访问您你的电脑, LocalHostName 是带有 .local 的电脑名称, 而且任何空格都会替换为连字符, 例如电脑的名称是 My Computer 则本地主机名就是 My-Computer.local, 本地主机名不区分大小写\n\n在【系统偏好设置 - 共享 - 电脑名称】下面一行, 点击右侧的“编辑”按钮, 进行修改\n\n\n# macOS下蓝牙键盘(Keychron K2)连接失败的解决办法',normalizedContent:'# 终端命令别名\n\n用户文件夹下.zshrc写入：\n\nalias nd="npm run dev"\nalias ns="npm run serve"\nalias y="yarn"\nalias ni="npm install"\nalias nb="npm run build"\nalias ys="yarn start"\n\n\n\n# jetbrains 软件破解（macos）\n\n⚠️\n\n最高支持破解版本为 2021.3\n\n先打开一遍软件，退出\n\n打开访达->软件右键显示包内容->在/applications/webstorm.app/contents/bin/webstorm.vmoptions 写入\n\n-javaagent:/users/frank/jetbrains crack file/fineagent.jar\n\n打开软件输入激活码,适用版本 2021.3\n\n破解 🐎\n\n5ayv1d1re5-eyjsawnlbnnlswqioii1qvlwmuqxuku1iiwibgljzw5zzwvoyw1lijoiahr0chm6ly93d3cuaml3zwljagvuz3pods5jb20ilcjhc3npz25lzu5hbwuioiiilcjhc3npz25lzuvtywlsijoiiiwibgljzw5zzvjlc3ryawn0aw9uijoiiiwiy2hly2tdb25jdxjyzw50vxnlijpmywxzzswichjvzhvjdhmiolt7imnvzguioijjssisimzhbgxiywnrrgf0zsi6ijiwotktmtitmzeilcjwywlkvxbubyi6ijiwotktmtitmzeifsx7imnvzguioijbqyisimzhbgxiywnrrgf0zsi6ijiwotktmtitmzeilcjwywlkvxbubyi6ijiwotktmtitmzeifsx7imnvzguioijeue4ilcjmywxsymfja0rhdguioiiymdk5lteyltmxiiwicgfpzfvwvg8ioiiymdk5lteyltmxin0seyjjb2rlijoiufmilcjmywxsymfja0rhdguioiiymdk5lteyltmxiiwicgfpzfvwvg8ioiiymdk5lteyltmxin0seyjjb2rlijoir08ilcjmywxsymfja0rhdguioiiymdk5lteyltmxiiwicgfpzfvwvg8ioiiymdk5lteyltmxin0seyjjb2rlijoire0ilcjmywxsymfja0rhdguioiiymdk5lteyltmxiiwicgfpzfvwvg8ioiiymdk5lteyltmxin0seyjjb2rlijoiq0wilcjmywxsymfja0rhdguioiiymdk5lteyltmxiiwicgfpzfvwvg8ioiiymdk5lteyltmxin0seyjjb2rlijoiulmwiiwizmfsbgjhy2teyxrlijoimja5os0xmi0zmsisinbhawrvcfrvijoimja5os0xmi0zmsj9lhsiy29kzsi6iljdiiwizmfsbgjhy2teyxrlijoimja5os0xmi0zmsisinbhawrvcfrvijoimja5os0xmi0zmsj9lhsiy29kzsi6iljeiiwizmfsbgjhy2teyxrlijoimja5os0xmi0zmsisinbhawrvcfrvijoimja5os0xmi0zmsj9lhsiy29kzsi6ilbdiiwizmfsbgjhy2teyxrlijoimja5os0xmi0zmsisinbhawrvcfrvijoimja5os0xmi0zmsj9lhsiy29kzsi6iljniiwizmfsbgjhy2teyxrlijoimja5os0xmi0zmsisinbhawrvcfrvijoimja5os0xmi0zmsj9lhsiy29kzsi6ildtiiwizmfsbgjhy2teyxrlijoimja5os0xmi0zmsisinbhawrvcfrvijoimja5os0xmi0zmsj9lhsiy29kzsi6ikrciiwizmfsbgjhy2teyxrlijoimja5os0xmi0zmsisinbhawrvcfrvijoimja5os0xmi0zmsj9lhsiy29kzsi6ikrdiiwizmfsbgjhy2teyxrlijoimja5os0xmi0zmsisinbhawrvcfrvijoimja5os0xmi0zmsj9lhsiy29kzsi6iljtvsisimzhbgxiywnrrgf0zsi6ijiwotktmtitmzeilcjwywlkvxbubyi6ijiwotktmtitmzeifv0simhhc2gioiixmjc5njg3ny8wiiwiz3jhy2vqzxjpb2reyxlzijo3lcjhdxrvuhjvbg9uz2f0zwqiomzhbhnllcjpc0f1dg9qcm9sb25nyxrlzci6zmfsc2v9-hnpogo0kwkhcvmnsjmbxuqqt87uphqdkyqzgvesjtu8hb2v2yq7ghshenp4uued3jwewc+yruif7u5yda/56f5sdn0rluhzx5dheqbjpbmycbsdrt7m8rnmmfoszn3vwnatvv1coozbcgok3wwxx6bf7xcgairmxrcmzmzgv2pzehr0ws1hxnke3x4nbgp3mwisbg4ypmxndrljmgv+si9qddwnldffqeo0lce0fqejumwmvbs42s0aeiyf8is5bp4+lfklj8t7tf40oxkydurbb9+9c43gzbscm/elb8jos66jngfwgebfulvhzjkvhztuc/n8zgeentq6k0t/b8w==-miidtjccajagawibagibdtanbgkqhkig9w0baqsfadaymrywfaydvqqdda1kzxrqcm9mawxlienbmcaxdte4mtewmteymjk0nloydziwotkwoda5mdiynja3wjafmr0wgwydvqqddbrwcm9kmnktznjvbs0ymdiwmtaxotccasiwdqyjkozihvcnaqebbqadggepadccaqocggebamk3eyr0+oys/twcqo+qyaxwgbmxcep4fr0bhhzzd/4wngltxhecm80owtha38bqryajbckz/dsko2kj1h2y+7kb5ciaoijeytesftsgzqdot6larbu8oxy9mmagi46m8zeemplpyby4yjj4howzibsmqemxotgmdlpuhx6uasovhsj6kob55loj4wegsqbeamwtaxmtl88ixe179j8abukbgpl8w/tzzl9bjxznf15gpfks58rw8cdpzxls0yym37a2/kkfhfhzjc5khbaxqyzmkaftmqpsiqcq1lquaqfipn2gn2i1z3/cquew27m55fxvr2dduqe5dwzyjs85l50caweaaaobmtcbljajbgnvhrmeajaamb0ga1uddgqwbbqk2heilvwfqcctr+gxi0z0wiqc/zbibgnvhsmeqta/gbsjnrziz0isnkg9bec5tkbsi5fxs6ecpbowgdewmbqga1ueawwnsmv0uhjvzmlszsbdqyijanjssyoyg3nhmbmga1udjqqmmaogccsgaqufbwmbmasga1uddwqeawifodanbgkqhkig9w0baqsfaaocaqeascqbjo5wttco/z5cj/o4gbrku8utbbbvfq4xsbanshthm4devxctvta4ascv0tpkcalqgqwx8a9v8xxo8dbbcuyxvwztez/c2covg1xxim99lz7vxqpjvmldkanzn5u0gqsiyjdcff+tdbmeiesonn/klxnq2hxdjqk2zk2j25uzqu5eibrttbdozw6zcfwj8uontxfsmahnnicp3wf/4wr/mwb0ka4s+ja3ibf5mumuz/fjuafarnin70us+vxf/szui7u67wilvwvv0naqdpthhuv0nrc4q+yor2dt/uchdy4xrxljfav/z9/xbwnzzalnz3etql6ieiwwjbyl3g==\n\n\n\n# vuepress 内置组件 badge\n\n\n# badge beta 默认主题\n\n * props:\n   * text - string\n   * type - string, 可选值： "tip"|"warning"|"error"，默认值是： "tip"\n   * vertical - string, 可选值： "top"|"middle"，默认值是： "top"\n * usage:\n\n你可以在标题中，使用这个组件来为某些 api 添加一些状态：\n\n### badge <badge text="beta" type="warning"/> <badge text="默认主题"/>\n\n\n\n# badge\n\n\n# mac 电脑壁纸和锁屏壁纸怎么不一样?\n\n注意\n\n锁屏壁纸如果要和桌面保持一致:\n\n 1. 不要删上面的文件夹\n 2. 关闭文件保险箱\n\nmac 系统的开机登录界面壁纸缓存在「资源库--caches--desktop pictures--xxx--lockscreen.png」（其中的 xxx 为你的 uuid，进入系统偏好设置--用户与群组，先把下面的锁解开，然后右键你的用户，点击高级选项，弹出的页面中即有 uuid）部分用户由于使用 clean my mac 清理文件，导致这个文件夹从 desktop pictures 开始被删掉，而系统又不会自动生成这个文件夹，只能读取 mojave.heic，只需要把这个文件夹和图片补上即可。图片可以自己用 ps 什么的转一下格式。补上文件夹和图片之后，更换系统壁纸，这个缓存文件夹的文件会随着系统壁纸改变。\n\n作者：aman 链接：https://www.zhihu.com/question/366941376/answer/1154284728 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n# 网站字库\n\n一个互联网民工的开发笔记库关于作者网站内容网站愿景个人项目本站总访问量次|本站访客数人 1234567890 首页数据库前端开发后端开发前端面试开发工具基础知识开发记录杂记数据结构算法优质编程资源非关系型数据库 mongodb 微信云 mysql 进阶-框架 htmlcsjavascriptvuereactothertype 移动重学小程序 node.babelmockwebpack 计算机网络浏览器工作原理与实践本地存储前后端数据交互与 http 协议 ajax&fetch 与跨域请求其他 vuecopyright © 2020-2022 fanhang zhang | powered by vuepress, vercel, alibaba cloud, tencent cloud and algolia 菜鸟前端,互联网搬砖民工关于我接触、学习到的开发技术的笔记以及平时开发记录下来的问题笔记千锤百炼,让自己形成完备的前端知识体系,成为一名合格的前端开发工程师<ffe/>博客链我的不止 zf 深入 k 入门通相 although this site is built by vue, i like react 片段\n\n\n\n# mac 系统 log\n\n要查找这些日志文件，请查看以下位置：\n\n * 系统日志文件夹：/var/log\n * 系统日志：/var/log/system.log\n * mac analytics 数据：/var/log/diagnosticmessages\n * 系统应用程序日志：/library/logs\n * 系统报告：/library/logs/diagnosticreports\n * 用户应用程序日志：～/library/logs（换句话说，/users/name/library/logs）\n * 用户报告：～/library/logs/diagnosticreports（换句话说，/users/name/library/logs/diagnosticreports）\n\n主要文件夹\n\n * /var/log\n * /var/logs\n * /library/logs\n * ~/library/logs\n\n\n# mac 系统 cache（缓存）\n\n * /library/caches\n * /system/library/caches\n * ～/library/caches\n\n\n# mac 系统绕过公证（提示 app 已损坏）\n\n打开终端，输入以下命令：\n\nsudo xattr -rd com.apple.quarantine /applications/xxxxxx.app\n\n将上面的 xxxxxx.app 换成你的 app 名称，比如 sketch.app sudo xattr -rd com.apple.quarantine /applications/sketch.app\n\n\n# how to give a mac os x machine a new kerberos identity\n\n 1. in terminal, run ‘sudo rm -fr /var/db/krb5kdc’ – this will destroy the local kdc database.\n 2. in terminal, run ‘sudo /usr/libexec/configurelocalkdc’ – this will regenerate the local kdc database, including a new certificate and sha1 hash.\n 3. bind the machine to od.\n\n\n# mac 系统默认 hosts\n\n##\n# host database\n#\n# localhost is used to configure the loopback interface\n# when the system is booting.  do not change this entry.\n##\n127.0.0.1\tlocalhost\n255.255.255.255\tbroadcasthost\n::1             localhost\n\n\n\n# vscode 配置\n\n{\n    "workbench.startupeditor": "none",\n    "workbench.statusbar.visible": false,\n    "workbench.producticontheme": "fluent-icons",\n    "editor.fontsize": 21,\n    "editor.formatonsave": true,\n    "editor.defaultformatter": "esbenp.prettier-vscode",\n    "leetcode.endpoint": "leetcode-cn",\n    "leetcode.defaultlanguage": "javascript",\n    "leetcode.workspacefolder": "/users/frank/myprojects/data-structure-and-algorithm/leetcode",\n    "leetcode.editor.shortcuts": [\n        "submit",\n        "test",\n        "solution",\n        "description",\n        "star"\n    ],\n    "files.autosave": "onfocuschange",\n    "prettier.semi": false,\n    "prettier.singlequote": true,\n    "prettier.tabwidth": 4,\n    "prettier.arrowparens": "avoid",\n    "prettier.bracketspacing": true,\n    "prettier.jsxsinglequote": false,\n    "search.exclude": {\n        "**/node_modules": true\n    },\n    "terminal.integrated.fontsize": 19,\n    "terminal.integrated.cursorstyle": "line",\n    "terminal.integrated.cursorblinking": true,\n    "[markdown]": {\n        "editor.quicksuggestions": true\n    },\n    "workbench.icontheme": "material-icon-theme",\n    "workbench.colortheme": "one monokai",\n    "git.confirmsync": false,\n    "git.enablesmartcommit": true\n}\n\n\n\n# mac os 名称问题及修改方法\n\n\n# hostname\n\nhostname主机名, 用于在系统上标识一台机器. 他和 ip 地址的区别是, hostname 用于在系统上标识一台机器; ip 地址是在 tcp/ip 网络中唯一标志一台机器. 联系到实际生活, 主机名相当于一个房子的主人名, 而 ip 地址相当于小区内这间房子的门牌号. [hostname 也就是打开终端, 出现在 “@” 符号后面的名字]\n\n查看 hostname scutil --get hostname hostname echo $hostname, 这三个命令都可以查看 hostname.\n\n修改 hostname sudo scutil --set hostname [hostname]， [hostname]的位置是你想要设置的 hostname.\n\n\n# 管理员名称\n\n管理员名称就是电脑在初始化的时候你设置的管理员的名称, 也是电脑开机的时候头像下面显示的名称, 在系统偏好设置-用户与群组中进行修改. [打开终端, 管理员名称会出现在“@”最前面]\n\n在图形化界面中直接操作: 【系统偏好设置 - 用户与群组】 这个名称一般是不能改的, 可以通过新建/删除用户的方式进行修改\n\n\n# computername\n\n计算机名, 在进行 airdrop 共享文件, 或者其他一些共享操作的时候, 其他人会以这个名字看到你的电脑\n\n在【系统偏好设置 - 共享 - 电脑名称】中进行修改\n\n\n# localhostname\n\n本地主机名, 本地网络上的电脑可以通过这个名字访问您你的电脑, localhostname 是带有 .local 的电脑名称, 而且任何空格都会替换为连字符, 例如电脑的名称是 my computer 则本地主机名就是 my-computer.local, 本地主机名不区分大小写\n\n在【系统偏好设置 - 共享 - 电脑名称】下面一行, 点击右侧的“编辑”按钮, 进行修改\n\n\n# macos下蓝牙键盘(keychron k2)连接失败的解决办法',charsets:{cjk:!0},lastUpdated:"2022年07月31日",lastUpdatedTimestamp:1659277691e3},{title:"集合",frontmatter:{title:"集合",readingShow:"top"},regularPath:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%88.html",relativePath:"数据结构算法/集合.md",key:"v-565c38b5",path:"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%88.html",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"LeetCode：349. 两个数组的交集",slug:"leetcode-349-两个数组的交集",normalizedTitle:"leetcode：349. 两个数组的交集",charIndex:368},{level:2,title:"前端与集合：使用 ES6 中 Set",slug:"前端与集合-使用-es6-中-set",normalizedTitle:"前端与集合：使用 es6 中 set",charIndex:1138},{level:3,title:"Set,Array互转",slug:"set-array互转",normalizedTitle:"set,array互转",charIndex:1237},{level:3,title:"交集/差集",slug:"交集-差集",normalizedTitle:"交集/差集",charIndex:1227}],headersStr:"简介 LeetCode：349. 两个数组的交集 前端与集合：使用 ES6 中 Set Set,Array互转 交集/差集",content:"# 简介\n\n一种无序且唯一的数据结构\n\nES6中有集合，名为Set\n\n集合的常用操作：去重、判断某元素是否在集合中、求交集\n\n// 去重\nconst arr =[1,1,1]\nconst arr1=[...new Set(arr)]\nconsole.log(arr1) // [1]\n\n// 判断某元素是否在集合中\nconst set =new Set([1,2])\nconst has =set.has(1) \nconsole.log(has) // true\n// 求交集\nconst set2 = new Set([3,4,1])\nconst set3 = new Set( [...set].filter(item=> set2.has(item)))\nconsole.log(set3) // Set { 1 }\n\n\n\n\n# LeetCode：349. 两个数组的交集\n\n[349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)\n\n * 解题思路\n\n求交集且无序唯一,使用集合\n\n * 解题步骤\n\n用集合对nums1去重,然后遍历nums1,筛选出nums2也包含的值\n\n/*\n * @lc app=leetcode.cn id=349 lang=javascript\n *\n * [349] 两个数组的交集\n */\n\n// @lc code=start\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersection = function (nums1, nums2) {\n    // 集合\n    // return [...new Set(nums1)].filter((item) => {\n    //     return nums2.includes(item)\n    // })\n    // 字典\n    let m = new Map()\n    nums1.forEach(item=>{\n        m.set(item,true)\n    })\n    let res=[]\n    nums2.forEach(item=>{\n        if(m.get(item)){\n            res.push(item)\n            m.delete(item)\n        }\n    })\n    return res\n};\n// @lc code=end\n\n\n\n# 前端与集合：使用 ES6 中 Set\n\n使用Set对象：new、add、delete、has、size\n\n迭代Set：多种迭代方法(for...of)、Set与Array互转、求交集/差集\n\n\n# Set,Array互转\n\n * Set=>Array\n\nconst arr1 = [...new Set([1,2,3,4,1])]  \nconst arr2 = Array.form(new Set[1,2,3,4,1])\n\n\n * Array=>Set\n\nconst set = new Set([1,23,1,3])\n\n\n\n# 交集/差集\n\nconst set1 = new Set([1, 23, 1])\nconst set2 = new Set([23])\n// 交集\nconst newSet = new Set([...set1].filter(item => {\n    return set2.has(item)\n}))\n// 差集\n const newSet2 = new Set([...set1].filter(item => {\n    return !set2.has(item)\n}))\n",normalizedContent:"# 简介\n\n一种无序且唯一的数据结构\n\nes6中有集合，名为set\n\n集合的常用操作：去重、判断某元素是否在集合中、求交集\n\n// 去重\nconst arr =[1,1,1]\nconst arr1=[...new set(arr)]\nconsole.log(arr1) // [1]\n\n// 判断某元素是否在集合中\nconst set =new set([1,2])\nconst has =set.has(1) \nconsole.log(has) // true\n// 求交集\nconst set2 = new set([3,4,1])\nconst set3 = new set( [...set].filter(item=> set2.has(item)))\nconsole.log(set3) // set { 1 }\n\n\n\n\n# leetcode：349. 两个数组的交集\n\n[349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)\n\n * 解题思路\n\n求交集且无序唯一,使用集合\n\n * 解题步骤\n\n用集合对nums1去重,然后遍历nums1,筛选出nums2也包含的值\n\n/*\n * @lc app=leetcode.cn id=349 lang=javascript\n *\n * [349] 两个数组的交集\n */\n\n// @lc code=start\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersection = function (nums1, nums2) {\n    // 集合\n    // return [...new set(nums1)].filter((item) => {\n    //     return nums2.includes(item)\n    // })\n    // 字典\n    let m = new map()\n    nums1.foreach(item=>{\n        m.set(item,true)\n    })\n    let res=[]\n    nums2.foreach(item=>{\n        if(m.get(item)){\n            res.push(item)\n            m.delete(item)\n        }\n    })\n    return res\n};\n// @lc code=end\n\n\n\n# 前端与集合：使用 es6 中 set\n\n使用set对象：new、add、delete、has、size\n\n迭代set：多种迭代方法(for...of)、set与array互转、求交集/差集\n\n\n# set,array互转\n\n * set=>array\n\nconst arr1 = [...new set([1,2,3,4,1])]  \nconst arr2 = array.form(new set[1,2,3,4,1])\n\n\n * array=>set\n\nconst set = new set([1,23,1,3])\n\n\n\n# 交集/差集\n\nconst set1 = new set([1, 23, 1])\nconst set2 = new set([23])\n// 交集\nconst newset = new set([...set1].filter(item => {\n    return set2.has(item)\n}))\n// 差集\n const newset2 = new set([...set1].filter(item => {\n    return !set2.has(item)\n}))\n",charsets:{cjk:!0},lastUpdated:"2022年04月13日",lastUpdatedTimestamp:1649838404e3},{title:"node.js基础",frontmatter:{title:"node.js基础",readingShow:"top"},regularPath:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/node%E5%85%A5%E9%97%A8/Node.js%E5%9F%BA%E7%A1%80.html",relativePath:"服务端开发/node入门/Node.js基础.md",key:"v-3f1e209c",path:"/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/node%E5%85%A5%E9%97%A8/Node.js%E5%9F%BA%E7%A1%80.html",headers:[{level:2,title:"node.js 介绍",slug:"node-js-介绍",normalizedTitle:"node.js 介绍",charIndex:2},{level:3,title:"chrome v8 引擎",slug:"chrome-v8-引擎",normalizedTitle:"chrome v8 引擎",charIndex:63},{level:2,title:"nvm",slug:"nvm",normalizedTitle:"nvm",charIndex:174},{level:3,title:"windows 下安装",slug:"windows-下安装",normalizedTitle:"windows 下安装",charIndex:205},{level:3,title:"macOS 下安装",slug:"macos-下安装",normalizedTitle:"macos 下安装",charIndex:656},{level:2,title:"npm",slug:"npm",normalizedTitle:"npm",charIndex:445},{level:3,title:"npm 的常用命令",slug:"npm-的常用命令",normalizedTitle:"npm 的常用命令",charIndex:1671},{level:2,title:"nrm",slug:"nrm",normalizedTitle:"nrm",charIndex:1996},{level:3,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:1224},{level:2,title:"Yarn",slug:"yarn",normalizedTitle:"yarn",charIndex:2183},{level:3,title:"Yarn 的一些常用命令",slug:"yarn-的一些常用命令",normalizedTitle:"yarn 的一些常用命令",charIndex:2299},{level:2,title:"common.js 模块化",slug:"common-js-模块化",normalizedTitle:"common.js 模块化",charIndex:2656},{level:3,title:"commonjs 语法介绍",slug:"commonjs-语法介绍",normalizedTitle:"commonjs 语法介绍",charIndex:2686},{level:3,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:2761},{level:3,title:"commonjs 和 ES6 Module 的区别",slug:"commonjs-和-es6-module-的区别",normalizedTitle:"commonjs 和 es6 module 的区别",charIndex:3019}],headersStr:"node.js 介绍 chrome v8 引擎 nvm windows 下安装 macOS 下安装 npm npm 的常用命令 nrm 常用命令 Yarn Yarn 的一些常用命令 common.js 模块化 commonjs 语法介绍 实例 commonjs 和 ES6 Module 的区别",content:'# node.js 介绍\n\n一个基于 Chrome v8 引擎的 Javascript 运行时(代码的运行环境)环境\n\n\n# chrome v8 引擎\n\n * chrome是一个浏览器，它可以执行 js 代码\n * V8 就是 chrome 的 js引擎，以速度著称\n * nodejs 也是基于 js 语法的，因此也可以借用 ∨8 引擎\n\n\n# nvm\n\nnvm 是 node.js 的版本管理工具\n\n\n# windows 下安装\n\n下载地址：https://github.com/coreybutler/nvm-windows/releases\n\n安装完成后，找到 nvm 的安装目录，有一个 settings.txt 文件，打开之后把下面的代码复制进去：\n\nroot: C:\\Users\\Frank\\AppData\\Roaming\\nvm\npath: C:\\Program Files\\nodejs\narch: 64\nproxy: none\nnode_mirror: https://npmmirror.com/mirrors/node/\nnpm_mirror: https://npmmirror.com/mirrors/npm/\n\n\nnvm 基本命令有：\n\n * 安装 node:nvm install <version>\n\n * 切换版本:nvm use [version]\n\n * 列出已安装的版本:nvm list\n\n * 卸载 node：nvm uninstall <version>\n\n\n# macOS 下安装\n\n注意\n\n当在 arm架构下的 macos 上，通过 nvm 安装 v16 以下版本 node 时,必须在 Rosetta 2的模式下打开终端，执行安装命令\n\n建议使用 homebrew，安装nvm:\n\n国内可以使用Homebrew 国内安装脚本安装homebrew\n\n第一步：brew install nvm\n\n第二步：touch .zshrc,写入：\n\nexport NVM_DIR="$HOME/.nvm"\n  [ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && . "/opt/homebrew/opt/nvm/nvm.sh"  # This loads nvm\n  [ -s "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" ] && . "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm"  # This loads nvm bash_completion\nexport NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node/\n\n\n第三步：source .zshrc\n\n接下来就可以使用 nvm指令安装 node\n\n常用命令:\n\nnvm install xxx\nnvm uninstall xxx\nnvm alias default xxx //设置新终端的默认node版本\nnvm ls\n\n\n\n# npm\n\n注意\n\npackage.json 中的版本和 package-lock.json 的作用\n\n"dependencies": {\n    "react": "^16.8.0"\n    "react": "~16.8.0",\n    "react": "16.8.0",\n  },\n\n\n三种方式的区分在于，项目通过 npm install 重新下载依赖包时，对于所下载的版本号的区别：\n\n * ^16.8.0’ 表示安装 16.x.x 的最新版本，安装时不改变大版本号。\n * ‘~16.8.0’ 表示安装 16.8.x 的最新版本，安装时不改变大版本号和次要版本号。\n * ‘16.8.0’ 表示安装指定的版本号，也就是安装 16.8.0 版本。\n\nnpm 是 node.js 的软件包管理器\n\n\n# npm 的常用命令\n\n * 安装所有依赖：npm install\n * 查看全局的包：npm list -g --depth 0\n * 查看全局包的安装位置：npm root -g\n * 查看 bin 目录位置:npm bin -g\n * 安装全局的包：npm installl -g\n * 安装生产依赖：npm intall module_name\n * 安装开发依赖： npm install module_name -D\n * 移除依赖：npm uninstall module_name,全局加上-g\n * 设置淘宝镜像源：npm config set registry=https://registry.npmmirror.com\n\n\n# nrm\n\nnrm是npm的源管理工具\n\n安装：npm install -g @adams549659584/nrm\n\nMac M1芯片电脑可能无法正确获取当前正在使用的源使用此包可解决问题,解决方法来自抖音前端博主：后盾人，感谢！\n\n\n# 常用命令\n\n * nrm ls:显示源列表\n * nrm test：测试延迟\n * nrm use xxxx:使用xxxx源\n\n\n# Yarn\n\nYarn 也是 node 包管理工具\n\nReact 脚手架默认使用 yarn\n\n使用 homebrew安装：brew install yarn\n\nyarn 的镜像设置默认使用.npmrc 中的设置，无需单独配置\n\n\n# Yarn 的一些常用命令\n\nmacOS:yarn 安装全局包后找不到命令的问题\n\n将\n\nexport PATH="$PATH:`yarn global bin`"\n\n\n添加到.zshrc 中\n\n * 安装所有依赖：yarn\n * 查看全局的包：yarn global list\n * 查看全局包的安装位置：yarn global dir\n * 查看 bin 目录位置:yarn global bin\n * 安装全局的包:yarn global add <packageName>\n * 安装生产依赖：yarn add <packageName>\n * 安装开发依赖： yarn add <packageName> -D\n * 移除依赖：yarn <global> remove <packageName>\n\n\n# common.js 模块化\n\n回顾 ES6 模块化\n\n\n# commonjs 语法介绍\n\n * module.exports 导出\n * require(…)导入\n * 主要用于 node.js 开发\n\n\n# 实例\n\n# index.js\n\nconst { add, message } = require(\'./tool\')\n\nadd(1, 2)\nmessage()\n\n// node index.js\n\n\n# tool.js\n\nfunction add(a, b) {\n    console.log(a + b)\n}\nfunction message() {\n    console.log(\'common.js\')\n}\n\nmodule.exports = {\n    add,\n    message,\n}\n\n\n\n# commonjs 和 ES6 Module 的区别\n\n * commonJs 是执行时引入 ，动态的,程序执行到 require才会引入\n * ES6 Module是打包时引入，静态的,代码执行之前就要把所有东西引入进来',normalizedContent:'# node.js 介绍\n\n一个基于 chrome v8 引擎的 javascript 运行时(代码的运行环境)环境\n\n\n# chrome v8 引擎\n\n * chrome是一个浏览器，它可以执行 js 代码\n * v8 就是 chrome 的 js引擎，以速度著称\n * nodejs 也是基于 js 语法的，因此也可以借用 ∨8 引擎\n\n\n# nvm\n\nnvm 是 node.js 的版本管理工具\n\n\n# windows 下安装\n\n下载地址：https://github.com/coreybutler/nvm-windows/releases\n\n安装完成后，找到 nvm 的安装目录，有一个 settings.txt 文件，打开之后把下面的代码复制进去：\n\nroot: c:\\users\\frank\\appdata\\roaming\\nvm\npath: c:\\program files\\nodejs\narch: 64\nproxy: none\nnode_mirror: https://npmmirror.com/mirrors/node/\nnpm_mirror: https://npmmirror.com/mirrors/npm/\n\n\nnvm 基本命令有：\n\n * 安装 node:nvm install <version>\n\n * 切换版本:nvm use [version]\n\n * 列出已安装的版本:nvm list\n\n * 卸载 node：nvm uninstall <version>\n\n\n# macos 下安装\n\n注意\n\n当在 arm架构下的 macos 上，通过 nvm 安装 v16 以下版本 node 时,必须在 rosetta 2的模式下打开终端，执行安装命令\n\n建议使用 homebrew，安装nvm:\n\n国内可以使用homebrew 国内安装脚本安装homebrew\n\n第一步：brew install nvm\n\n第二步：touch .zshrc,写入：\n\nexport nvm_dir="$home/.nvm"\n  [ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && . "/opt/homebrew/opt/nvm/nvm.sh"  # this loads nvm\n  [ -s "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" ] && . "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm"  # this loads nvm bash_completion\nexport nvm_nodejs_org_mirror=https://npmmirror.com/mirrors/node/\n\n\n第三步：source .zshrc\n\n接下来就可以使用 nvm指令安装 node\n\n常用命令:\n\nnvm install xxx\nnvm uninstall xxx\nnvm alias default xxx //设置新终端的默认node版本\nnvm ls\n\n\n\n# npm\n\n注意\n\npackage.json 中的版本和 package-lock.json 的作用\n\n"dependencies": {\n    "react": "^16.8.0"\n    "react": "~16.8.0",\n    "react": "16.8.0",\n  },\n\n\n三种方式的区分在于，项目通过 npm install 重新下载依赖包时，对于所下载的版本号的区别：\n\n * ^16.8.0’ 表示安装 16.x.x 的最新版本，安装时不改变大版本号。\n * ‘~16.8.0’ 表示安装 16.8.x 的最新版本，安装时不改变大版本号和次要版本号。\n * ‘16.8.0’ 表示安装指定的版本号，也就是安装 16.8.0 版本。\n\nnpm 是 node.js 的软件包管理器\n\n\n# npm 的常用命令\n\n * 安装所有依赖：npm install\n * 查看全局的包：npm list -g --depth 0\n * 查看全局包的安装位置：npm root -g\n * 查看 bin 目录位置:npm bin -g\n * 安装全局的包：npm installl -g\n * 安装生产依赖：npm intall module_name\n * 安装开发依赖： npm install module_name -d\n * 移除依赖：npm uninstall module_name,全局加上-g\n * 设置淘宝镜像源：npm config set registry=https://registry.npmmirror.com\n\n\n# nrm\n\nnrm是npm的源管理工具\n\n安装：npm install -g @adams549659584/nrm\n\nmac m1芯片电脑可能无法正确获取当前正在使用的源使用此包可解决问题,解决方法来自抖音前端博主：后盾人，感谢！\n\n\n# 常用命令\n\n * nrm ls:显示源列表\n * nrm test：测试延迟\n * nrm use xxxx:使用xxxx源\n\n\n# yarn\n\nyarn 也是 node 包管理工具\n\nreact 脚手架默认使用 yarn\n\n使用 homebrew安装：brew install yarn\n\nyarn 的镜像设置默认使用.npmrc 中的设置，无需单独配置\n\n\n# yarn 的一些常用命令\n\nmacos:yarn 安装全局包后找不到命令的问题\n\n将\n\nexport path="$path:`yarn global bin`"\n\n\n添加到.zshrc 中\n\n * 安装所有依赖：yarn\n * 查看全局的包：yarn global list\n * 查看全局包的安装位置：yarn global dir\n * 查看 bin 目录位置:yarn global bin\n * 安装全局的包:yarn global add <packagename>\n * 安装生产依赖：yarn add <packagename>\n * 安装开发依赖： yarn add <packagename> -d\n * 移除依赖：yarn <global> remove <packagename>\n\n\n# common.js 模块化\n\n回顾 es6 模块化\n\n\n# commonjs 语法介绍\n\n * module.exports 导出\n * require(…)导入\n * 主要用于 node.js 开发\n\n\n# 实例\n\n# index.js\n\nconst { add, message } = require(\'./tool\')\n\nadd(1, 2)\nmessage()\n\n// node index.js\n\n\n# tool.js\n\nfunction add(a, b) {\n    console.log(a + b)\n}\nfunction message() {\n    console.log(\'common.js\')\n}\n\nmodule.exports = {\n    add,\n    message,\n}\n\n\n\n# commonjs 和 es6 module 的区别\n\n * commonjs 是执行时引入 ，动态的,程序执行到 require才会引入\n * es6 module是打包时引入，静态的,代码执行之前就要把所有东西引入进来',charsets:{cjk:!0},lastUpdated:"2022年07月16日",lastUpdatedTimestamp:1657989072e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"数据库",items:[{text:"MySQL",link:"/数据库/MySQL"},{text:"mongoDB",link:"/数据库/mongoDB"}]},{text:"前端开发",items:[{text:"前端基础",items:[{text:"Html",link:"/前端开发/Html"},{text:"Css",link:"/前端开发/Css/Css3/基础与盒模型"},{text:"JavaScript",link:"/前端开发/JavaScript/JS基础/变量与数据类型"}]},{text:"前端进阶-框架",items:[{text:"Vue",link:"/前端开发/前端框架/Vue/Vue核心"},{text:"React",link:"/前端开发/前端框架/React/JSX核心语法"}]},{text:"前端进阶-其他",items:[{text:"TypeScript",link:"/前端开发/TypeScript/TS基础"},{text:"移动开发",link:"/前端开发/移动开发/移动Web开发入门"},{text:"重学前端",link:"/前端开发/重学前端/JavaScript"},{text:"微信小程序",link:"/前端开发/微信小程序"}]}]},{text:"服务端开发",items:[{text:"Node入门",link:"/服务端开发/node入门/Node.js基础"},{text:"深入Node",link:"/服务端开发/深入node/邂逅Node"},{text:"Koa2",link:"/服务端开发/Koa2框架"}]},{text:"前端面试",link:"/前端面试/Html面试题"},{text:"开发工具",items:[{text:"前端工具",items:[{text:"Babel",link:"/开发工具/前端工具/Babel"},{text:"Mock.js",link:"/开发工具/前端工具/Mock.js"},{text:"Webpack",link:"/开发工具/前端工具/Webpack"}]},{text:"其他工具",items:[{text:"git",link:"/开发工具/git"},{text:"homebrew",link:"/开发工具/homebrew"},{text:"Docker",link:"/开发工具/Docker"}]}]},{text:"基础知识",items:[{text:"计算机通识",items:[{text:"计算机网络",link:"/基础知识/计算机通识/计算机网络/概述篇"}]},{text:"前端相关",items:[{text:"浏览器工作原理与实践",link:"/基础知识/前端相关/浏览器工作原理与实践/01-chrome架构:仅仅打开了一个页面,为什么会有4个进程"},{text:"本地存储",link:"/基础知识/前端相关/本地存储"},{text:"前后端数据交互与HTTP协议",link:"/基础知识/前端相关/前后端数据交互与HTTP协议"},{text:"Ajax&Fetch与跨域请求",link:"/基础知识/前端相关/Ajax&Fetch与跨域请求"}]}]},{text:"开发记录",items:[{text:"CSS",link:"/开发记录/CSS/CSS文本溢出处理方式"},{text:"JS",link:"/开发记录/JS/关于async和await"},{text:"Node",link:"/开发记录/Node/在Vuekoa项目中如何解决跨域和cookie问题"},{text:"Vue",link:"/开发记录/Vue/vue如何实现界面刷新"},{text:"React",link:"/开发记录/React/开发流程管理平台学习心得"}]},{text:"数据结构算法",link:"/数据结构算法/栈"},{text:"杂记",link:"/杂记"},{text:"优质链接",link:"/优质链接"}],sidebar:{"/开发记录/":[{title:"CSS",sidebarDepth:2,children:["CSS/calc函数","CSS/CSS关于deep的用法","CSS/CSS文本溢出处理方式"]},{title:"JS",sidebarDepth:2,children:["JS/关于async和await","JS/理解js事件循环","JS/数组对象根据对象中指定的属性去重","JS/数组对象根据数据项状态属性如何筛选数据","JS/重新理解闭包","JS/Array.prototype.slice.call()&Array.from()的应用和理解","JS/js的严格模式"]},{title:"Node",sidebarDepth:2,children:["Node/在Vuekoa项目中如何解决跨域和cookie问题","Node/记一次koa2项目部署过程"]},{title:"Vue",sidebarDepth:2,children:["Vue/vue如何实现界面刷新","Vue/vueecharts数据报表项目学习心得","Vue/Vue3ElementPlusKoa2全栈开发后台系统学习记录"]},{title:"React",sidebarDepth:2,children:["React/开发流程管理平台学习心得"]}],"/开发工具/前端工具/":["Babel","Webpack","Mock.js"],"/基础知识/前端相关/":["前后端数据交互与HTTP协议","本地存储","Ajax&Fetch与跨域请求",{title:"浏览器工作原理与实践",sidebarDepth:2,children:["浏览器工作原理与实践/思维导图","浏览器工作原理与实践/01"]}],"/数据结构算法/":["栈","队列","链表","集合","字典","树","图"],"/基础知识/计算机通识/":[{title:"计算机网络",sidebarDepth:2,children:["计算机网络/概述篇"]}],"/前端开发/Css/":[{title:"Css3",sidebarDepth:2,children:["Css3/基础与盒模型","Css3/浮动与定位","Css3/边框圆角与盒子阴影","Css3/背景与渐变","Css3/2D与3D转换","Css3/过渡与动画"]},{title:"玩转CSS艺术之美",sidebarDepth:2,children:["玩转CSS艺术之美/浏览器","玩转CSS艺术之美/回流重绘"]},"Flex布局","Sass"],"/前端开发/JavaScript/":[{title:"JS基础",sidebarDepth:2,children:["JS基础/变量与数据类型","JS基础/操作符","JS基础/流程控制语句","JS基础/数组","JS基础/函数","JS基础/DOM","JS基础/BOM","JS基础/面向对象","JS基础/正则表达式"]},{title:"ES6",sidebarDepth:2,children:["ES6/let和const","ES6/模板字符串与箭头函数","ES6/解构赋值","ES6/对象字面量的增强与函数参数的默认值","ES6/剩余参数与展开运算符","ES6/Set和Map数据结构","ES6/遍历器与for...of循环","ES6/ES6的新增方法","ES6/Promise","ES6/Class类","ES6/Module模块","ES6/Generator"]},"深入理解javascript原型和闭包"],"/前端开发/前端框架/":[{title:"Vue",sidebarDepth:2,children:["Vue/Vue核心","Vue/Vue组件化编程","Vue/VueX","Vue/VueRouter","Vue/Vue3","Vue/Vue2源码全方位深入解析"]},{title:"React",sidebarDepth:2,children:["React/JSX核心语法","React/React脚手架","React/React组件化开发","React/React中的CSS","React/AntDesgin组件库","React/React中axios","React/React的过渡动画","React/Redux","React/React-router","React/ReactHook","React/React与TypeScript","React/React的SSR","React/React好用的库"]}],"/前端开发/TypeScript/":["TS基础","TS面向对象","TS进阶"],"/前端开发/移动开发/":["移动Web开发入门"],"/前端开发/重学前端/":["JavaScript"],"/服务端开发/":[{title:"node入门",sidebarDepth:2,children:["node入门/Node.js基础","node入门/Node.js处理HTTP"]},{title:"深入node",sidebarDepth:2,children:["深入node/邂逅Node","深入node/全局对象和模块化开发"]},"koa2框架"],"/前端面试/":["Html面试题","Css面试题","JS面试题","Vue面试题","计网&浏览器面试题","手撕代码",{title:"菜鸟的前端面试复盘",sidebarDepth:2,children:["面试复盘/21.9.14一面复盘","面试复盘/21.10.12技术面","面试复盘/21.10.20技术面复盘","面试复盘/21.10.21技术面复盘"]}]},lastUpdated:"上次更新",logo:"https://zfh-oss.oss-cn-shanghai.aliyuncs.com/docs-assets/assets/LOGO_52x52.png"}};t(531);a.a.component("busuanzi",(function(){return t.e(3).then(t.bind(null,624))})),a.a.component("Badge",(function(){return Promise.all([t.e(0),t.e(5)]).then(t.bind(null,743))})),a.a.component("CodeBlock",(function(){return Promise.all([t.e(0),t.e(6)]).then(t.bind(null,625))})),a.a.component("CodeGroup",(function(){return Promise.all([t.e(0),t.e(7)]).then(t.bind(null,626))}));t(532);var Ce={name:"DynamicTitle",data:function(){return{originTitle:"",recoverTimeout:null,config:{showIcon:"/favicon.ico",showText:"好孩子真听话~",hideIcon:"/favicon.ico",hideText:"不要摸鱼快来学习~",recoverTime:2e3}}},mounted:function(){var n=this;this.originTitle=document.title,""!==this.config.showIcon&&this.getIconElm().setAttribute("href",this.config.showIcon),document.addEventListener("visibilitychange",(function(){document.hidden?n.hidden():n.visible()}))},methods:{hidden:function(){""!==this.config.hideIcon&&this.getIconElm().setAttribute("href",this.config.hideIcon),document.title=this.config.hideText,clearTimeout(this.recoverTimeout)},visible:function(){var n=this;""!==this.config.showIcon&&this.getIconElm().setAttribute("href",this.config.showIcon),document.title=this.config.showText+this.originTitle,this.recoverTimeout=setTimeout((function(){document.title=n.originTitle}),this.config.recoverTime)},getIconElm:function(){var n=document.querySelector("link[rel=icon]");return null===n&&((n=document.createElement("link")).setAttribute("rel","icon"),document.head.appendChild(n)),n}},watch:{$route:function(n,e){n.path!==e.path&&(this.originTitle=document.title,clearTimeout(this.recoverTimeout))}}},Te=Object(ye.a)(Ce,(function(){var n=this.$createElement;return(this._self._c||n)("div")}),[],!1,null,null,null).exports;var Ie=function(n){var e=n.Vue;n.router.options.scrollBehavior=function(n,t,o){if(o)return window.scrollTo({top:o.y,behavior:"smooth"});if(!n.hash)return window.scrollTo({top:0,behavior:"smooth"});if(!e.$vuepress.$get("disableScrollBehavior")){var r,a,i,s=n.hash.slice(1),l=document.getElementById(s)||document.querySelector("[name='".concat(s,"']"));return l?window.scrollTo({top:(r=l,a=document.documentElement.getBoundingClientRect(),i=r.getBoundingClientRect(),{x:i.left-a.left,y:i.top-a.top}).y,behavior:"smooth"}):void 0}}},ze=(t(292),{name:"BackToTop",props:{threshold:{type:Number,default:300}},data:function(){return{scrollTop:null}},computed:{show:function(){return this.scrollTop>this.threshold}},mounted:function(){var n=this;this.scrollTop=this.getScrollTop(),window.addEventListener("scroll",pe()((function(){n.scrollTop=n.getScrollTop()}),100))},methods:{getScrollTop:function(){return window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0},scrollToTop:function(){window.scrollTo({top:0,behavior:"smooth"}),this.scrollTop=0}}}),Fe=(t(533),Object(ye.a)(ze,(function(){var n=this.$createElement,e=this._self._c||n;return e("transition",{attrs:{name:"fade"}},[this.show?e("svg",{staticClass:"go-to-top",attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 49.484 28.284"},on:{click:this.scrollToTop}},[e("g",{attrs:{transform:"translate(-229 -126.358)"}},[e("rect",{attrs:{fill:"currentColor",width:"35",height:"5",rx:"2",transform:"translate(229 151.107) rotate(-45)"}}),this._v(" "),e("rect",{attrs:{fill:"currentColor",width:"35",height:"5",rx:"2",transform:"translate(274.949 154.642) rotate(-135)"}})])]):this._e()])}),[],!1,null,"5fd4ef0c",null).exports),De=(t(327),{name:"ReadingProgress",data:function(){return{readingTop:0,readingHeight:1,progressStyle:null,transform:void 0,running:!1}},watch:{$readingShow:function(){this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)}},mounted:function(){this.transform=this.getTransform(),this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)},beforeDestroy:function(){this.$readingShow&&window.removeEventListener("scroll",this.base)},methods:{base:function(){this.running||(this.running=!0,requestAnimationFrame(this.getReadingBase))},getReadingBase:function(){this.readingHeight=this.getReadingHeight()-this.getScreenHeight(),this.readingTop=this.getReadingTop(),this.progressStyle=this.getProgressStyle(),this.running=!1},getReadingHeight:function(){return Math.max(document.body.scrollHeight,document.body.offsetHeight,0)},getScreenHeight:function(){return Math.max(window.innerHeight,document.documentElement.clientHeight,0)},getReadingTop:function(){return Math.max(window.pageYOffset,document.documentElement.scrollTop,0)},getTransform:function(){var n=document.createElement("div");return["transform","-webkit-transform","-moz-transform","-o-transform","-ms-transform"].find((function(e){return e in n.style}))||void 0},getProgressStyle:function(){var n=this.readingTop/this.readingHeight;switch(this.$readingShow){case"top":case"bottom":return this.transform?"".concat(this.transform,": scaleX(").concat(n,")"):"width: ".concat(100*n,"%");case"left":case"right":return this.transform?"".concat(this.transform,": scaleY(").concat(n,")"):"height: ".concat(100*n,"%");default:return null}}}}),Pe=(t(534),Object(ye.a)(De,(function(){var n=this.$createElement,e=this._self._c||n;return e("ClientOnly",[this.$readingShow?e("div",{staticClass:"reading-progress",class:this.$readingShow},[e("div",{staticClass:"progress",style:this.progressStyle})]):this._e()])}),[],!1,null,"3640397f",null).exports);function Oe(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function Re(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}function _e(n,e,t){return e&&Re(n.prototype,e),t&&Re(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}var Me=function(){function n(e){Oe(this,n),Object.defineProperty(this,"registration",{value:e,configurable:!0,writable:!0})}return _e(n,[{key:"update",value:function(){return this.registration.update()}},{key:"skipWaiting",value:function(){var n=this.registration.waiting;return n?(console.log("[vuepress:sw] Doing worker.skipWaiting()."),new Promise((function(e,t){var o=new MessageChannel;o.port1.onmessage=function(n){console.log("[vuepress:sw] Done worker.skipWaiting()."),n.data.error?t(n.data.error):e(n.data)},n.postMessage({type:"skip-waiting"},[o.port2])}))):Promise.resolve()}}]),n}(),Ne=t(92);a.a.component("SWUpdatePopup",(function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,622))}));var Le=[{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(n){n.Vue.component("DynamicTitle",Te)},Ie,function(n){n.Vue.component("CodeCopy",we)},function(n){n.Vue.component("BackToTop",Fe)},function(n){var e=n.Vue;e.component(Pe.name,Pe),e.mixin({computed:{$readingShow:function(){return this.$page.frontmatter.readingShow}}})},function(){var n=Object(r.a)(Object(o.a)().mark((function n(e){var r,a,i;return Object(o.a)().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(r=e.router,e.isServer){n.next=7;break}return n.next=4,t.e(125).then(t.bind(null,620));case 4:a=n.sent,i=a.register,r.onReady((function(){i("".concat("/","service-worker.js"),{registrationOptions:{},ready:function(){console.log("[vuepress:sw] Service worker is active."),Ne.a.$emit("sw-ready")},cached:function(n){console.log("[vuepress:sw] Content has been cached for offline use."),Ne.a.$emit("sw-cached",new Me(n))},updated:function(n){console.log("[vuepress:sw] Content updated."),Ne.a.$emit("sw-updated",new Me(n))},offline:function(){console.log("[vuepress:sw] No internet connection found. App is running in offline mode."),Ne.a.$emit("sw-offline")},error:function(n){console.error("[vuepress:sw] Error during service worker registration:",n),Ne.a.$emit("sw-error",n),GA_ID&&ga("send","exception",{exDescription:n.message,exFatal:!1})}})}));case 7:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()],qe=["DynamicTitle","BackToTop","ReadingProgress","SWUpdatePopup"];t(193);function Je(n,e){return(Je=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(321),t(200);function $e(n){return($e=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function Ve(n,e){if(e&&("object"===Object(i.a)(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function Ue(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,o=$e(n);if(e){var r=$e(this).constructor;t=Reflect.construct(o,arguments,r)}else t=o.apply(this,arguments);return Ve(this,t)}}var He=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&Je(n,e)}(t,n);var e=Ue(t);function t(){return Oe(this,t),e.apply(this,arguments)}return _e(t)}(function(){function n(){Oe(this,n),this.store=new a.a({data:{state:{}}})}return _e(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){a.a.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(He.prototype,{getPageAsyncComponent:Qn.d,getLayoutAsyncComponent:Qn.c,getAsyncComponent:Qn.b,getVueComponent:Qn.e});var We={install:function(n){var e=new He;n.$vuepress=e,n.prototype.$vuepress=e}};function Ge(n){n.beforeEach((function(e,t,o){if(Xe(n,e.path))o();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var r=e.path.replace(/\/$/,"")+".html";Xe(n,r)?o(r):o()}else o();else{var a=e.path+"/",i=e.path+".html";Xe(n,i)?o(i):Xe(n,a)?o(a):o()}}))}function Xe(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var Ye={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return Object(Qn.h)("pageKey",e),a.a.component(e)||a.a.component(e,Object(Qn.d)(e)),a.a.component(e)?n(e):n("")}},Ze={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,o=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},o()[t.slotKey])}},Ke={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Qe=(t(535),t(536),Object(ye.a)(Ke,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function nt(){return(nt=Object(r.a)(Object(o.a)().mark((function n(e){var t,r,i,s;return Object(o.a)().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Se.routerBase||Se.base,Ge(r=new Zn({base:t,mode:"history",fallback:!1,routes:Be,scrollBehavior:function(n,e,t){return t||(n.hash?!a.a.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),i={},n.prev=4,n.next=7,Promise.all(Le.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:a.a,options:i,router:r,siteData:Se,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return s=new a.a(Object.assign(i,{router:r,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},qe.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:s,router:r});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}a.a.config.productionTip=!1,a.a.use(Zn),a.a.use(We),a.a.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:a.a;Kn(e),t.$vuepress.$set("siteData",e);var o=n(t.$vuepress.$get("siteData")),r=new o,i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),s={};return Object.keys(i).reduce((function(n,e){return e.startsWith("$")&&(n[e]=i[e].get),n}),s),{computed:s}}((function(n){return function(){function e(){Oe(this,e)}return _e(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,o=void 0===t?{}:t;for(var r in o)"/"===r?e=o[r]:0===this.$page.path.indexOf(r)&&(n=o[r]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,o=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?o?o+" | "+t:t:o||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var o=n[t];if(o.path.toLowerCase()===e.toLowerCase())return o}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),Se)),a.a.component("Content",Ye),a.a.component("ContentSlotsDistributor",Ze),a.a.component("OutboundLink",Qe),a.a.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,o=e.children;if(t._isMounted)return o;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),a.a.component("Layout",Object(Qn.c)("Layout")),a.a.component("NotFound",Object(Qn.c)("NotFound")),a.a.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.7",hash:"84cbc42"},function(n){return nt.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);